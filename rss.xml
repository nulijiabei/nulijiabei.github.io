<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>NLJB - 别问我为啥叫加贝(哥名里有贺)</title>
    <link>http://www.nljb.net</link>
    <pubDate>25 Jun 21 20:46 CST</pubDate>
    <item>
      <title>Vue.js之async的使用方法</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8Basync%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2021-03-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue.js之async与Promise的使用方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;axios 使用 async 实现同步顺序执行&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// axios 初始化  ...&#xA;import http from &amp;quot;@/axios&amp;quot;;&#xA;Vue.prototype.$http = http;&#xA;&#xA;// 常用 axios 接口方式&#xA;this.$http.post(&amp;quot;/api/data&amp;quot;,{data: &amp;quot;我的数据&amp;quot;})&#xA;.then(res =&amp;gt; {&#xA;    this.$message(res.data)&#xA;})&#xA;.catch(error =&amp;gt; {&#xA;    this.$message(error.toString());&#xA;});&#xA;&#xA;// 分析一下 axios 接口返回的都是 Promise ...&#xA;request&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt; (config: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;get&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt;(url: string, config?: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;delete&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt;(url: string, config?: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;head&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt;(url: string, config?: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;options&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt;(url: string, config?: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;post&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;put&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;patch&amp;lt;T = any, R = AxiosResponse&amp;lt;T&amp;gt;&amp;gt;(url: string, data?: any, config?: AxiosRequestConfig): Promise&amp;lt;R&amp;gt;;&#xA;&#xA;// async 用于申明一个 function 是异步的 ...&#xA;// await 用于等待一个异步方法执行完成 ...&#xA;&#xA;async getData() {&#xA;  try {&#xA;    let res = await this.$http.get(&amp;quot;/api/data&amp;quot;, {}).then();&#xA;    return Promise.resolve(res.data);&#xA;  } catch (error) {&#xA;    return Promise.reject(error.toString());&#xA;  }&#xA;}&#xA;&#xA;showData() {&#xA;    this.getData().then(data =&amp;gt; {&#xA;        console.log(&amp;quot;111&amp;quot;);&#xA;    }).catch(error =&amp;gt; {&#xA;      this.$message(error);&#xA;    });&#xA;    console.log(&amp;quot;222&amp;quot;);&#xA;}&#xA;&#xA;// 分析一下 ...&#xA;// await 等待 this.$http.get 的 Promise 结果 ...&#xA;// getData 返回了 Promise 包装的结果或错误 ...&#xA;// getData 是异步方法，所以先输出 222 后 111 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如何等待两个异步方法 ...&#xA;async showData() {&#xA;    const v1 = await getData1();&#xA;    const v2 = await getData2();&#xA;}&#xA;&#xA;// axios 如何等待两个异步方法 ...&#xA;all&amp;lt;T&amp;gt;(values: (T | Promise&amp;lt;T&amp;gt;)[]): Promise&amp;lt;T[]&amp;gt;;&#xA;&#xA;// 全部执行完毕后返回结果 ...&#xA;axios.all([this.getData1(), this.getData1()]).then(&#xA;  axios.spread((data1, data2) =&amp;gt; {&#xA;    // 获取 data1、data2&#xA;  })&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;JavaScript Promise 对象&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ECMAscript 6 原生提供了 Promise 对象&#xA;&#xA;Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息&#xA;Promise 对象代表一个异步操作，有三种状态:&#xA;1. pending   初始状态&#xA;2. fulfilled 成功完成&#xA;3. rejected  操作失败&#xA;Promise 一旦状态改变，就不会再变，任何时候都可以得到这个结果&#xA;Promise 一旦新建它就会立即执行，无法中途取消。&#xA;Promise 如果不设置回调函数，则内部抛出的错误，不会反映到外部&#xA;Promise .then 的回调函数是异步执行的 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以使用 new 来调用 Promise 的构造器来进行实例化对象    &#xA;var promise = new Promise(function(resolve, reject) {&#xA;    // 异步处理&#xA;    // 处理结束后、调用resolve 或 reject&#xA;});&#xA;&#xA;// 例子 ...&#xA;var myPromise = new Promise(function(resolve, reject){&#xA;    // 当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)&#xA;    // 在本例中，我们使用setTimeout(...)来模拟异步代码 ... 也可以是 axios 的异步请求 ...&#xA;    setTimeout(function(){&#xA;    resolve(&amp;quot;成功!&amp;quot;); // 代码正常执行！&#xA;    }, 250);&#xA;});&#xA;myPromise.then(function(successMessage){&#xA;    // successMessage的值是上面调用resolve(...)方法传入的值.&#xA;    // successMessage参数不一定非要是字符串类型，这里只是举个例子&#xA;    document.write(&amp;quot;Yay! &amp;quot; + successMessage);&#xA;});&#xA;&#xA;&#xA;// promise.then() 是 promise 最为常用的方法。&#xA;promise.then(onFulfilled, onRejected)&#xA;promise.then(onFulfilled).catch(onRejected)&#xA;&#xA;// 例子&#xA;function ajax(URL) {&#xA;    return new Promise(function (resolve, reject) {&#xA;    var req = new XMLHttpRequest(); &#xA;    req.open(&#39;GET&#39;, URL, true);&#xA;    req.onload = function () {&#xA;    if (req.status === 200) { &#xA;        resolve(req.responseText);&#xA;        } else {&#xA;        reject(new Error(req.statusText));&#xA;        } &#xA;    };&#xA;    req.onerror = function () {&#xA;        reject(new Error(req.statusText));&#xA;    };&#xA;    req.send(); &#xA;    });&#xA;}&#xA;var URL = &amp;quot;/try/ajax/testpromise.php&amp;quot;; &#xA;ajax(URL).then(function onFulfilled(value){&#xA;    document.write(&#39;内容是：&#39; + value); &#xA;}).catch(function onRejected(error){&#xA;    document.write(&#39;错误：&#39; + error); &#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Promise.prototype.then 方法：链式操作&#xA;Promise.prototype.catch 方法：捕捉错误&#xA;Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例&#xA;Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Promise.resolve 方法，Promise.reject 方法&#xA;&#xA;// 例如:&#xA;var p = Promise.resolve(&#39;Hello&#39;);&#xA;p.then(function (s){&#xA;  console.log(s)&#xA;});&#xA;&#xA;上面代码生成一个新的Promise对象的实例p，它的状态为fulfilled&#xA;所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。&#xA;&#xA;var p = Promise.reject(&#39;出错了&#39;);&#xA;p.catch(error =&amp;gt; {&#xA;  console.log(error);&#xA;});&#xA;&#xA;上面代码生成一个Promise对象的实例，状态为rejected，回调函数会立即执行。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;async 的使用&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;async 是“异步”的简写，而 await 可以认为是 async wait 的简写。&#xA;async 用于申明一个异步的 function 而 await 用于等待一个异步方法执行完成。 &#xA;async 函数如果没有返回值，它会返回 Promise.resolve(undefined)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;async 函数是怎么处理它的返回值?&#xA;&#xA;async 起什么作用?&#xA;&#xA;    // 写段代码来试试，看它到底会返回什么 ...&#xA;&#xA;    async function testAsync() {&#xA;        return &amp;quot;hello async&amp;quot;;&#xA;    }&#xA;&#xA;    const result = testAsync();&#xA;    console.log(result);&#xA;&#xA;    // 执行结果&#xA;    Promise { &#39;hello async&#39; }&#xA;&#xA;    // 所以 async 函数返回的是一个 Promise 对象&#xA;    // 如果 async 关键字函数返回的不是 Promise 会自动用 Promise.resolve() 封装&#xA;    // 如果 async 关键字函数显式的返回 Promise 以你返回的 Promise 为准 ....&#xA;&#xA;await 到底在等什么？&#xA;&#xA;    // await 只能出现在 async 函数中&#xA;&#xA;    // 一般来说，都认为 await 是在等待一个 async 函数完成。&#xA;    // 不过语法说明 await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值&#xA;    // 因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值&#xA;&#xA;    // 写段代码来试试 ...&#xA;&#xA;    getSomething() {&#xA;      return &amp;quot;something&amp;quot;;&#xA;    }&#xA;&#xA;    async testAsync() {&#xA;      return Promise.resolve(&amp;quot;hello async&amp;quot;);&#xA;    }&#xA;&#xA;    async test() {&#xA;      const v1 = await this.getSomething();&#xA;      const v2 = await this.testAsync();&#xA;      console.log(v1, v2);&#xA;    }&#xA;&#xA;    // 执行结果&#xA;    // 注意：await 得到的是返回值 ...&#xA;    something hello async&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;async / await 帮我们干了什么?&#xA;&#xA;    // 写段代码来试试 ...&#xA;&#xA;    takeLongTime() {&#xA;      return new Promise(resolve =&amp;gt; {&#xA;        setTimeout(() =&amp;gt; resolve(&amp;quot;long_time_value&amp;quot;), 1000);&#xA;      });&#xA;    }&#xA;&#xA;    test1() {&#xA;      this.takeLongTime().then(v =&amp;gt; {&#xA;        console.log(&amp;quot;test1&amp;quot;, v);&#xA;      });&#xA;      console.log(&amp;quot;test1&amp;quot;);&#xA;    }&#xA;&#xA;    async test2() {&#xA;      const v = await this.takeLongTime();&#xA;      console.log(&amp;quot;test2&amp;quot;, v);&#xA;      console.log(&amp;quot;test2&amp;quot;);&#xA;    }&#xA;&#xA;    this.test1();&#xA;    this.test2();&#xA;&#xA;    // 执行结果&#xA;    test1&#xA;    test1 long_time_value&#xA;    test2 long_time_value&#xA;    test2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数&#xA;&#xA;当函数执行的时候，一旦遇到 await 就会先返回 ...&#xA;等到触发的异步操作完成, 再接着执行函数体内后面的语句 ...&#xA;&#xA;// 函数前面的 async 关键字，表明该函数内部有异步操作&#xA;// 调用该函数，会立即返回一个 Promise 对象 ...&#xA;async function getStockPriceByName(name) {&#xA;  var symbol = await getStockSymbol(name);&#xA;  var stockPrice = await getStockPrice(symbol);&#xA;  return stockPrice;&#xA;}&#xA;getStockPriceByName(&#39;goog&#39;).then(function (result){&#xA;  console.log(result);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 指定多少毫秒后输出一个值&#xA;&#xA;function timeout(ms) {&#xA;  return new Promise((resolve) =&amp;gt; {&#xA;    setTimeout(resolve, ms);&#xA;  });&#xA;}&#xA;&#xA;async function asyncPrint(value, ms) {&#xA;  await timeout(ms);&#xA;  console.log(value)&#xA;}&#xA;&#xA;asyncPrint(&#39;hello world&#39;, 50);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。&#xA;await 命令后面的 Promise 对象，运行结果可能是 rejected&#xA;所以最好把 await 命令放在 try...catch 代码块中 ...&#xA;&#xA;// 例&#xA;async function myFunction() {&#xA;  try {&#xA;    await somethingThatReturnsAPromise();&#xA;  } catch (err) {&#xA;    console.log(err);&#xA;  }&#xA;}&#xA;&#xA;// 另一种写法&#xA;async function myFunction() {&#xA;  await somethingThatReturnsAPromise().catch(function (err){&#xA;    console.log(err);&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 指定多少毫秒后输出一个值&#xA;function timeout(value, ms) {&#xA;  // 使用 Promise 封装一个异步操作&#xA;  return new Promise((resolve, reject) =&amp;gt; {&#xA;    // 异步操作 ...&#xA;    setTimeout(() =&amp;gt; {&#xA;      // 成功 ...&#xA;      // resolve(value);&#xA;      // 失败 ...&#xA;      reject(value);&#xA;    }, ms);&#xA;  });&#xA;}&#xA;&#xA;// 函数前面的async关键字，表明该函数内部有异步操作&#xA;// 调用该函数时，会立即返回一个Promise对象 ...&#xA;async function asyncPrint(value, ms) {&#xA;  try {&#xA;    // 等待执行完成, 并返回结果 ...&#xA;    return await timeout(value, ms);&#xA;  } catch (error) {&#xA;    // 失败返回 ...&#xA;    return Promise.reject(error);&#xA;  }&#xA;}&#xA;&#xA;// 执行 ...&#xA;asyncPrint(&amp;quot;hello world&amp;quot;, 3000)&#xA;  .then(res =&amp;gt; {&#xA;    console.log(&amp;quot;成功&amp;quot;, res);&#xA;  })&#xA;  .catch(error =&amp;gt; {&#xA;    console.log(&amp;quot;失败&amp;quot;, error);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 举例&#xA;&#xA;getFileSize(file) {&#xA;    return new Promise((resolve, reject) =&amp;gt; {&#xA;        switch (file.type) {&#xA;          case &amp;quot;image/jpeg&amp;quot;:&#xA;          case &amp;quot;image/png&amp;quot;:&#xA;            var imageReader = new FileReader();&#xA;            imageReader.readAsDataURL(file);&#xA;            imageReader.onload = function(event) {&#xA;              var replaceSrc = event.target.result;&#xA;              var imageObj = new Image();&#xA;              imageObj.src = replaceSrc;&#xA;              imageObj.onload = function() {&#xA;            resolve(imageObj);&#xA;              };&#xA;            };&#xA;            break;&#xA;          case &amp;quot;video/mp4&amp;quot;:&#xA;            var videoUrl = URL.createObjectURL(file);&#xA;            var videoObj = document.createElement(&amp;quot;video&amp;quot;);&#xA;            videoObj.onloadedmetadata = function() {&#xA;              URL.revokeObjectURL(videoUrl);&#xA;              videoObj.width = videoObj.videoWidth;&#xA;              videoObj.height = videoObj.videoHeight;&#xA;              resolve(videoObj);&#xA;            };&#xA;            videoObj.src = videoUrl;&#xA;            videoObj.load();&#xA;            break;&#xA;          default:&#xA;            reject(&amp;quot;未知类型&amp;quot;);&#xA;        }&#xA;    });&#xA;}&#xA;&#xA;async handleBefore(file) {&#xA;    await this.getFileSize(file)&#xA;    .then(res =&amp;gt; {&#xA;      this.data = {&#xA;        pid: this.currentPath.id,&#xA;        rid: this.currentPath.rid,&#xA;        race: &amp;quot;file&amp;quot;,&#xA;        type: &amp;quot;material&amp;quot;,&#xA;        width: res.width,&#xA;        height: res.height&#xA;      };&#xA;    })&#xA;    .catch(error =&amp;gt; {&#xA;      this.$message(error);&#xA;      return false;&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Vue.js之使用基于Gin的JwtBearer认证</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8EGin%E7%9A%84JwtBearer%E8%AE%A4%E8%AF%81/</link>
      <pubDate>2021-01-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue之使用基于Gin的JwtBearer认证&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Jin 与 Jwt&#xA;github.com/gin-gonic/gin&#xA;github.com/dgrijalva/jwt-go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Jwt 官方案例 - 创建 Token &#xA;&#xA;// Create a new token object, specifying signing method and the claims&#xA;// you would like it to contain.&#xA;token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{&#xA;    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,&#xA;    &amp;quot;nbf&amp;quot;: time.Date(2015, 10, 10, 12, 0, 0, 0, time.UTC).Unix(),&#xA;})&#xA;&#xA;// Sign and get the complete encoded token as a string using the secret&#xA;tokenString, err := token.SignedString(hmacSampleSecret)&#xA;&#xA;fmt.Println(tokenString, err)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Jwt 官方案例 - 解析 Token&#xA;&#xA;// sample token string taken from the New example&#xA;tokenString := &amp;quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJuYmYiOjE0NDQ0Nzg0MDB9.u1riaD1rW97opCoAuRCTy4w58Br-Zk-bh7vLiRIsrpU&amp;quot;&#xA;&#xA;// Parse takes the token string and a function for looking up the key. The latter is especially&#xA;// useful if you use multiple keys for your application.  The standard is to use &#39;kid&#39; in the&#xA;// head of the token to identify which key to use, but the parsed token (head and claims) is provided&#xA;// to the callback, providing flexibility.&#xA;token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {&#xA;    // Don&#39;t forget to validate the alg is what you expect:&#xA;    if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {&#xA;        return nil, fmt.Errorf(&amp;quot;Unexpected signing method: %v&amp;quot;, token.Header[&amp;quot;alg&amp;quot;])&#xA;    }&#xA;&#xA;    // hmacSampleSecret is a []byte containing your secret, e.g. []byte(&amp;quot;my_secret_key&amp;quot;)&#xA;    return hmacSampleSecret, nil&#xA;})&#xA;&#xA;if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;amp;&amp;amp; token.Valid {&#xA;    fmt.Println(claims[&amp;quot;foo&amp;quot;], claims[&amp;quot;nbf&amp;quot;])&#xA;} else {&#xA;    fmt.Println(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 增加自定义属性&#xA;&#xA;// 可以使用官方的 jwt.MapClaims 来全部重新定义内置属性&#xA;// 也可以通过嵌套 jwt.StandardClaims 来增加自定义属性&#xA;&#xA;// Claims 接口&#xA;type Claims interface {&#xA;    // 包含 Valid() 都可以是 Claims 接口&#xA;    Valid() error&#xA;}&#xA;&#xA;// 创建 Token &#xA;func NewWithClaims(method SigningMethod, claims Claims) *Token {...}&#xA;&#xA;// 所以可以自定义 MyClaims ...&#xA;type MyClaims struct {&#xA;    Username string&#xA;    jwt.StandardClaims // 嵌套&#xA;}   &#xA;&#xA;// 标准 StandardClaims&#xA;type StandardClaims struct {&#xA;    Audience  string `json:&amp;quot;aud,omitempty&amp;quot;`&#xA;    ExpiresAt int64  `json:&amp;quot;exp,omitempty&amp;quot;`&#xA;    Id        string `json:&amp;quot;jti,omitempty&amp;quot;`&#xA;    IssuedAt  int64  `json:&amp;quot;iat,omitempty&amp;quot;`&#xA;    Issuer    string `json:&amp;quot;iss,omitempty&amp;quot;`&#xA;    NotBefore int64  `json:&amp;quot;nbf,omitempty&amp;quot;`&#xA;    Subject   string `json:&amp;quot;sub,omitempty&amp;quot;`&#xA;}&#xA;&#xA;// StandardClaims 成员 ...&#xA;func (c StandardClaims) Valid() error {...}&#xA;&#xA;// 这样就可以在标准的 StandardClaims 中增加自定义属性 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第一步：创建与解码 Token&#xA;&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;github.com/dgrijalva/jwt-go&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;// 密钥&#xA;var secret = []byte(&amp;quot;abcdefg&amp;quot;)&#xA;&#xA;// 自定义结构&#xA;type MyClaims struct {&#xA;    Username string&#xA;    jwt.StandardClaims&#xA;}&#xA;&#xA;// 获取 Token&#xA;func GenToken(username string) (string, error) {&#xA;    // 创建结构&#xA;    claims := MyClaims{&#xA;        Username: username,&#xA;        StandardClaims: jwt.StandardClaims{&#xA;            // 过期时间&#xA;            ExpiresAt: time.Now().Add(time.Hour * 3).Unix(),&#xA;            // 指定token发行人&#xA;            Issuer: &amp;quot;nulijiabei&amp;quot;,&#xA;        },&#xA;    }&#xA;    // 创建一个新的令牌对象, 指定签名方法和, 您要包含的声明&#xA;    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)&#xA;    // 使用指定的 secret 签名并获得完整的编码后的字符串 token&#xA;    return token.SignedString(secret)&#xA;}&#xA;&#xA;// 解码 Token&#xA;func ParseToken(tokenString string) (*MyClaims, error) {&#xA;    token, err := jwt.ParseWithClaims(tokenString, &amp;amp;MyClaims{}, func(token *jwt.Token) (interface{}, error) {&#xA;        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {&#xA;            return nil, fmt.Errorf(&amp;quot;Unexpected signing method: %v&amp;quot;, token.Header[&amp;quot;alg&amp;quot;])&#xA;        }&#xA;        return secret, nil&#xA;    })&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    if claims, ok := token.Claims.(*MyClaims); ok &amp;amp;&amp;amp; token.Valid {&#xA;        return claims, nil&#xA;    }&#xA;    return nil, fmt.Errorf(&amp;quot;Invalid Token&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第二步：在 Gin 中通过中间件来进行 Token 验证&#xA;&#xA;// 主&#xA;func main() {&#xA;    router := gin.Default()&#xA;    router.POST(&amp;quot;/api/login&amp;quot;, loginHandler)&#xA;    router.POST(&amp;quot;/api/home&amp;quot;, JWTAuthMiddleware(), homeHandler)&#xA;    router.Run()&#xA;}&#xA;&#xA;// 返回数据结构 ...&#xA;type QueryResult struct {&#xA;    Code int         `json:&amp;quot;code&amp;quot;`&#xA;    Data interface{} `json:&amp;quot;data&amp;quot;`&#xA;}&#xA;&#xA;// 登录&#xA;func loginHandler(c *gin.Context) {&#xA;    username := c.PostForm(&amp;quot;username&amp;quot;)&#xA;    password := c.PostForm(&amp;quot;password&amp;quot;)&#xA;    result := new(QueryResult)&#xA;    if username == &amp;quot;admin&amp;quot; &amp;amp;&amp;amp; password == &amp;quot;admin&amp;quot; {&#xA;        tokenString, _ := GenToken(username)&#xA;        result.Code = 200&#xA;        result.Data = map[string]interface{}{&#xA;            &amp;quot;username&amp;quot;: username,&#xA;            &amp;quot;token&amp;quot;:    tokenString,&#xA;        }&#xA;    } else {&#xA;        result.Code = 404&#xA;        result.Data = &amp;quot;验证失败&amp;quot;&#xA;    }&#xA;    c.JSON(200, result)&#xA;}&#xA;&#xA;// Home&#xA;func homeHandler(c *gin.Context) {&#xA;    result := new(QueryResult)&#xA;    result.Code = 200&#xA;    result.Data = &amp;quot;欢迎访问&amp;quot;&#xA;    c.JSON(200, result)     &#xA;}&#xA;&#xA;// JWTAuthMiddleware 基于JWT的认证中间件&#xA;func JWTAuthMiddleware() func(c *gin.Context) {&#xA;    return func(c *gin.Context) {&#xA;        // 这里Token放在Header的Authorization中，并使用Bearer开头&#xA;        authHeader := c.Request.Header.Get(&amp;quot;Authorization&amp;quot;)&#xA;        if authHeader == &amp;quot;&amp;quot; {&#xA;            result := new(QueryResult)&#xA;            result.Code = 498&#xA;            result.Data = &amp;quot;Header Auth Error&amp;quot;&#xA;            c.JSON(http.StatusOK, result)&#xA;            c.Abort()&#xA;            return&#xA;        }&#xA;        // 按空格分割&#xA;        parts := strings.SplitN(authHeader, &amp;quot; &amp;quot;, 2)&#xA;        if !(len(parts) == 2 &amp;amp;&amp;amp; parts[0] == &amp;quot;Bearer&amp;quot;) {&#xA;            result := new(QueryResult)&#xA;            result.Code = 498&#xA;            result.Data = &amp;quot;Header Auth Error&amp;quot;&#xA;            c.JSON(http.StatusOK, result)&#xA;            c.Abort()&#xA;            return&#xA;        }&#xA;        // parts[1] 是获取到的 tokenString&#xA;        // 我们使用之前定义好的解析JWT的函数来解析它&#xA;        mc, err := ParseToken(parts[1])&#xA;        if err != nil {&#xA;            result := new(QueryResult)&#xA;            result.Code = 498&#xA;            result.Data = &amp;quot;Invalid Token&amp;quot;&#xA;            c.JSON(http.StatusOK, result)&#xA;            c.Abort()&#xA;            return&#xA;        }&#xA;        // 将当前请求的 username 信息保存到请求的上下文&#xA;        c.Set(&amp;quot;username&amp;quot;, mc.Username)&#xA;        c.Next() // 后续的处理 ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第三步：在 Vue 中如何使用 Token &#xA;&#xA;// 1. 在 Vuex 中保存 token &#xA;this.$http.post(&amp;quot;/api/login&amp;quot;, this.form).then(res =&amp;gt; {&#xA;    res = res.data;&#xA;    if (res.code === 200) {&#xA;      // 注意：保存 Token 及前面加 &amp;quot;Bearer &amp;quot;&#xA;      this.setToken(&amp;quot;Bearer &amp;quot; + res.data.token);&#xA;    } else {&#xA;      this.$message(res.data);&#xA;    }&#xA;});&#xA;&#xA;// 2. 在 Vue-Router 中检查 Token&#xA;&#xA;// 在路由守卫中检查 token ...&#xA;router.beforeEach((to, from, next) =&amp;gt; {&#xA;  // 只有授权后才可以继续访问 ...&#xA;  let token = store.state.user.token;&#xA;  if (!token &amp;amp;&amp;amp; to.name !== &amp;quot;login&amp;quot;) {&#xA;    next({ name: &amp;quot;login&amp;quot; });&#xA;  } else {&#xA;    next();&#xA;  }&#xA;});&#xA;&#xA;// 3. 在 axios 中 ...&#xA;// 请求拦截器中获取并且写到 Token 进行请求 ...&#xA;// 响应拦截器中检查 Token 类型错误, 并移除本地 Token &#xA;&#xA;// 添加请求拦截器&#xA;instance.interceptors.request.use(&#xA;  config =&amp;gt; {&#xA;    if (config.method === &amp;quot;post&amp;quot;) config.data = qs.stringify(config.data);&#xA;    config.headers.Authorization = store.state.user.token;&#xA;    return config;&#xA;  },&#xA;  error =&amp;gt; {&#xA;    return Promise.reject(error);&#xA;  }&#xA;);&#xA;&#xA;// 添加响应拦截器&#xA;instance.interceptors.response.use(&#xA;  response =&amp;gt; {&#xA;    // 指定 Token 错误 code 为 498&#xA;    if (response.data.code === 498) store.commit(&amp;quot;user/clear&amp;quot;);&#xA;    return response;&#xA;  },&#xA;  error =&amp;gt; {&#xA;    return Promise.reject(error);&#xA;  }&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>CSS之SCSS的使用介绍</title>
      <link>http://www.nljb.net/default/CSS%E4%B9%8BSCSS%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2021-01-22 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;CSS 常用&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;全局样式 &#xA;&#xA;// main.js&#xA;import &amp;quot;@/assets/scss/_global.scss&amp;quot;;&#xA;&#xA;// _global.scss&#xA;html,&#xA;body,&#xA;#app {&#xA;  height: 100%;&#xA;  margin: 0;&#xA;  padding: 0;&#xA;}&#xA;&#xA;* {&#xA;  box-sizing:border-box;&#xA;  -moz-box-sizing:border-box; /* Firefox */&#xA;  -webkit-box-sizing:border-box; /* Safari */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。&#xA;// 也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding&#xA;// 内容区的实际宽度是width减去(border + padding)的值&#xA;// 大多数情况下，这使得我们更容易地设定一个元素的宽高。&#xA;&#xA;特别说明：border-box 不包含 margin &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如何查看元素是块级元素还是内联(行内)元素&#xA;let element = document.getElementById(&amp;quot;myName&amp;quot;);&#xA;console.log(window.getComputedStyle(element).display);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;块级元素：display: block;&#xA;// 1. 每个块级元素都从新的一行开始, 并且其后的元素也另起一行, 一个块级元素独占一行&#xA;// 2. 元素的高度、宽度、行高以及顶和底边距都可设置&#xA;// 3. 元素宽度在不设置的情况下, 是它本身父容器的100%(和父元素的宽度一致)，除非设定一个宽度。&#xA;&#xA;内联(行内)元素：display: inline;&#xA;// 1. 和其他元素都在一行上；&#xA;// 2. 元素的高度、宽度及顶部和底部边距不可设置；&#xA;// 3. 元素的宽度就是它包含的文字或图片的宽度，不可改变。&#xA;&#xA;内联(行内)块级元素：display: inline-block; (同时具备内联元素、块状元素的特点)&#xA;// 1. 和其他元素都在一行上；&#xA;// 2. 元素的高度、宽度、行高以及顶和底边距都可设置。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt; 元素允许你将一组元素集中到一个块级元素内 (display: block;)&#xA;&amp;lt;span&amp;gt; 元素用来包含一段文本或包含若干个内联(行内)元素 (display: inline;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. text-align 属性对块级元素起作用，对行内元素不起作用&#xA;// 因为：行内元素的宽完全是靠内容撑开, 行内元素的宽就是内容宽，没有可居中的空间&#xA;&#xA;2. 块级元素即使设置宽度也还是独占一行&#xA;// 块级元素当没有明确指定 width 和 height 值时，块级元素尺寸由内容确定&#xA;// 当指定了 width 和 height 的值时，内容超出块级元素的尺寸就会溢出&#xA;// 这时块级元素要呈现什么行为要看其 overflow 的值&#xA;&#xA;3. 块级元素可以设置 margin 和 padding 属性&#xA;// 行内元素 margin-left、padding-right 可以产生边距效果&#xA;// 行内元素 margin-top、margin-bottom 不起作用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;什么是文档流&#xA;&#xA;1. 窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素&#xA;2. 每个非浮动块级元素都独占一行；非浮动的内联元素则从左到右连续排列，直到改行容纳不下再另起一行&#xA;3. 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动&#xA;4. 几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素&#xA;5. 有三种情况将使得元素脱离文档流而存在，分别是 float、absolute、fixed&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Position 定位元素, 指出一个元素的定位方法&#xA;&#xA;position 有4种可能值 ...&#xA;&#xA;1. static (不脱离文档流)&#xA;    // 默认值，元素按照在文档流中出现的顺序渲染&#xA;    // (忽略 top, bottom, left, right 或者 z-index 声明)&#xA;2. absolute (脱离文档流)&#xA;    // 绝对定位，元素相对于它的第一个被定位的祖先元素(非static)来进行定位&#xA;3. fixed (脱离文档流)&#xA;    // 元素相对于浏览器window进行定位&#xA;4. relative (不脱离文档流)&#xA;    // 元素相对与它的正常位置进行定位&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;FlexBox 弹性布局&#xA;&#xA;// 任何一个容器都可以指定为 Flex 布局。&#xA;.box{&#xA;  display: flex;&#xA;}&#xA;&#xA;// 行内元素也可以使用 Flex 布局。&#xA;.box{&#xA;  display: inline-flex;&#xA;}&#xA;&#xA;// 例&#xA;.box {&#xA;    display:flex;  /*盒子模型*/&#xA;    flex-direction: row;  /*横向*/&#xA;    justify-content: space-around; /*主轴居中*/&#xA;    align-items: center; /*纵轴居中*/&#xA;}&#xA;&#xA;// 注意: 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。&#xA;&#xA;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&amp;quot;容器&amp;quot;。&#xA;// 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&amp;quot;项目&amp;quot;。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;容器属性：以下6个属性设置在容器上 ...&#xA;&#xA;1. flex-direction &#xA;    // 属性决定主轴的方向（即项目的排列方向）&#xA;    * row（默认值）：主轴为水平方向，起点在左端。&#xA;    * row-reverse：主轴为水平方向，起点在右端。&#xA;    * column：主轴为垂直方向，起点在上沿。&#xA;    * column-reverse：主轴为垂直方向，起点在下沿。&#xA;2. flex-wrap &#xA;    // 默认项目都排在一条线（又称&amp;quot;轴线&amp;quot;）上。&#xA;    // flex-wrap 属性定义，如果一条轴线排不下，如何换行。&#xA;    * nowrap（默认）：不换行。&#xA;    * wrap：换行，第一行在上方。&#xA;    * wrap-reverse：换行，第一行在下方。&#xA;3. flex-flow&#xA;    // 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap&#xA;4. justify-content&#xA;    // 属性定义了项目在主轴上的对齐方式 (主轴)&#xA;    * flex-start（默认值）：左对齐&#xA;    * flex-end：右对齐&#xA;    * center： 居中&#xA;    * space-between：两端对齐，项目之间的间隔都相等。&#xA;    * space-around：每个项目两侧的间隔相等。&#xA;5. align-items&#xA;    // 属性定义项目在交叉轴上如何对齐 (纵轴)&#xA;    * flex-start：交叉轴的起点对齐。&#xA;    * flex-end：交叉轴的终点对齐。&#xA;    * center：交叉轴的中点对齐。&#xA;    * baseline: 项目的第一行文字的基线对齐。&#xA;    * stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。&#xA;6. align-content&#xA;    // 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用&#xA;    * flex-start：与交叉轴的起点对齐。&#xA;    * flex-end：与交叉轴的终点对齐。&#xA;    * center：与交叉轴的中点对齐。&#xA;    * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。&#xA;    * space-around：每根轴线两侧的间隔都相等。&#xA;    * stretch（默认值）：轴线占满整个交叉轴。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;项目的属性：以下6个属性设置在项目上 ...&#xA;&#xA;1. order&#xA;    // 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。&#xA;    // order: &amp;lt;integer&amp;gt;;&#xA;2. flex-grow&#xA;    // 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。&#xA;    // flex-grow: &amp;lt;number&amp;gt;; /* default 0 */&#xA;3. flex-shrink&#xA;    // 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&#xA;    // flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */&#xA;4. flex-basis&#xA;    // 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。&#xA;    // 浏览器根据这个属性，计算主轴是否有多余空间。&#xA;    // 它的默认值为 auto，即项目的本来大小。&#xA;    // 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。&#xA;    // flex-basis: &amp;lt;length&amp;gt; | auto; /* default auto */&#xA;5. flex&#xA;    // 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。&#xA;    // flex: none | [ &amp;lt;&#39;flex-grow&#39;&amp;gt; &amp;lt;&#39;flex-shrink&#39;&amp;gt;? || &amp;lt;&#39;flex-basis&#39;&amp;gt; ]&#xA;6. align-self&#xA;    // 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。&#xA;    // 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。&#xA;    // align-self: auto | flex-start | flex-end | center | baseline | stretch;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;CSS之SCSS的使用介绍&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;SCSS (Sassy CSS)，一款css预处理语言&#xA;SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。&#xA;也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件。&#xA;SCSS 需要使用分号和花括号而不是换行和缩进。&#xA;SCSS 对空白符号不敏感，其实就和css3语法一样，其后缀名是分别为 .scss。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;变量&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ 符号来标识变量；把反复使用的css属性值定义成变量；&#xA;&#xA;$highlight-color: #F90;&#xA;$highlight-border: 1px solid $highlight-color; // 变量中可存在变量&#xA;&#xA;$link-color: blue;&#xA;a {&#xA;  color: $link_color; // 中划线和下划线等价，包括对混合器和Sass函数的命名&#xA;}&#xA;&#xA;$side : left;&#xA;.rounded {&#xA;  border-#{$side}-radius: 5px; // 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。&#xA;}&#xA;&#xA;$nav-color: #F90;// 当前样式表都可以使用&#xA;nav {&#xA;  $width: 100px; // 只有nav{}里面才可以使用，当前样式表其他地方可以重复定义和使用&#xA;  width: $width;&#xA;  color: $nav-color;&#xA;}&#xA;&#xA;// 编译后&#xA;nav {&#xA;  width: 100px;&#xA;  color: #F90;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;嵌套&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 选择器嵌套&#xA;#content {&#xA;  article {&#xA;    h1 { color: #333 }&#xA;    p { margin-bottom: 1.4em }&#xA;  }&#xA;  aside { background-color: #EEE }&#xA;}&#xA;&#xA;/* 编译后 */&#xA;#content article h1 { color: #333 }&#xA;#content article p { margin-bottom: 1.4em }&#xA;#content aside { background-color: #EEE }&#xA;&#xA;// 属性也可以嵌套，比如border-color属性，可以写成：&#xA;p {&#xA;    border: {   // 注意，border后面必须加上冒号。&#xA;        color: red;&#xA;    }&#xA;}&#xA;&#xA;// 在嵌套的代码块内，可以使用&amp;amp;引用父元素。比如a:hover伪类，可以写成&#xA;a {&#xA;    &amp;amp;:hover { color: #ffb3ff; } &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;计算功能&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。&#xA;&#xA;// 数字运算: 支持数字的加减乘除、取整等运算 (+, -, *, /, %)&#xA;$var: 20px;&#xA;body {&#xA;  margin: (14px/2);&#xA;  top: 50px + 100px;&#xA;  right: $var * 10%;}&#xA;&#xA;// 字符串运算： + 可用于连接字符串&#xA;// 注意，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，&#xA;// 相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号&#xA;p {cursor: e + -resize;} // 编译后 p {cursor: e-resize; }&#xA;&#xA;// 例如&#xA;p:before { &#xA;    content: &amp;quot;Foo &amp;quot; + Bar;  &#xA;    font-family: sans- + &amp;quot;serif&amp;quot;;&#xA;}&#xA;&#xA;// 编译为&#xA;p:before {&#xA;  content: &amp;quot;Foo Bar&amp;quot;;&#xA;  font-family: sans-serif; &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;继承&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 继承是基于类class的（有时是基于其他类型的选择器）&#xA;// 允许一个选择器，继承另一个选择器。&#xA;// 比如，现有class1：&#xA;.class1 {&#xA;    border: 1px solid #ddd;&#xA;}&#xA;&#xA;// class2 要继承 class1，就要使用 @extend 命令：&#xA;.class2 {&#xA;     @extend .class1;&#xA;     font-size:120%;&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;混合器 Mixin&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 避免不停地重复一段样式&#xA;&#xA;// 使用@mixin命令，定义一个代码块。&#xA;@mixin left {&#xA;　　float: left;&#xA;　　margin-left: 10px;&#xA;}&#xA;&#xA;// 使用@include命令，调用这个mixin。&#xA;div {&#xA;　　@include left;&#xA;}&#xA;　　&#xA;// mixin 的强大之处，在于可以指定参数和缺省值。&#xA;@mixin left($value: 10px) {&#xA;    float: left;&#xA;    margin-right: $value;&#xA;}&#xA;&#xA;// 使用的时候，根据需要加入参数：&#xA;div {&#xA;　　@include left(20px);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;插入文件&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Sass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。&#xA;// 被导入的文件将合并编译到同一个 CSS 文件中&#xA;// 另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。&#xA;&#xA;@import &amp;quot;foo.scss&amp;quot;;             // 都会导入文件 foo.scss&#xA;@import &amp;quot;foo&amp;quot;;                  // 都会导入文件 foo.scss&#xA;@import &amp;quot;http://foo.com/bar&amp;quot;;   // 插入外部文件&#xA;@import &amp;quot;foo.css&amp;quot;;              // 等同于css的import命令。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之使用Module创建gin项目</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E4%BD%BF%E7%94%A8Module%E5%88%9B%E5%BB%BAgin%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>2021-01-06 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Golang之使用Module创建gin项目&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开启 Go Module &#xA;go env -w GO111MODULE=on&#xA;&#xA;// 设置代理服务器（任选其一）&#xA;go env -w GOPROXY=https://goproxy.cn,direct&#xA;go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# 启用 Go Modules 功能&#xA;export GO111MODULE=on&#xA;# 配置 GOPROXY 环境变量&#xA;export GOPROXY=https://goproxy.io&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建项目(文件夹)&#xA;MyProject&#xA;&#xA;// 进入 MyProject 目录&#xA;// 创建 go.mod 文件&#xA;module MyProject&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 进入 MyProject 目录&#xA;// 创建 main.go 文件&#xA;package main&#xA;&#xA;import &amp;quot;github.com/gin-gonic/gin&amp;quot;&#xA;&#xA;func main() {&#xA;    r := gin.Default()&#xA;    r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) {&#xA;        c.JSON(200, gin.H{&#xA;            &amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;,&#xA;        })&#xA;    })&#xA;    r.Run() &#xA;    // listen and serve on 0.0.0.0:8080 &#xA;    // (for windows &amp;quot;localhost:8080&amp;quot;)&#xA;}&#xA;&#xA;// 编译, 此时 Go 会自动安装 gin module 及相关&#xA;go build main.go&#xA;&#xA;// 运行&#xA;go run main.go &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在项目中导入内部模块&#xA;&#xA;// 目录结构 。。。&#xA;MyProject/&#xA;MyProject/go.mod&#xA;MyProject/main.go&#xA;MyProject/NewModule&#xA;MyProject/NewModule/go.mod&#xA;MyProject/NewModule/module.go&#xA;&#xA;// 编辑 MyProject/go.mod&#xA;&#xA;module MyProject&#xA;&#xA;require (&#xA;    // 其它包 ...&#xA;    github.com/gin-gonic/gin v1.6.3&#xA;    // 导入的包名称及版本号&#xA;    NewModule v0.0.1&#xA;)&#xA;&#xA;// 导入本地项目 ...&#xA;replace NewModule =&amp;gt; ./NewModule&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Vue.js之实战项目搭建及相关问题</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8B%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>2021-01-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue之实战项目搭建及相关问题&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Visual Studio Code&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Visual Studio Code 安装    &#xA;https://code.visualstudio.com/&#xA;&#xA;// 扩展插件&#xA;EsLint —— 支持 JavaScript 语法规则和代码风格检查工具&#xA;Vetur —— 支持 .vue 文件的语法高亮&#xA;Prettier Code formatter —— 代码格式化&#xA;Auto Close Tag —— 自动添加HTML/XML结束标签&#xA;Auto Rename Tag —— 重命名HTML/XML标签时，开始标签和结束标签同步修改&#xA;Path Intellisense —— 自动路劲补全&#xA;HTML Snippets —— HTML5 代码提示 &#xA;HTML CSS Support —— HTML CSS 代码提示&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 配置插件 &#xA;// 文件 &amp;gt; 首选项 &amp;gt; 设置 &amp;gt; 扩展 &amp;gt; ESLint &amp;gt; settings.json &#xA;{&#xA;  ...&#xA;  // Prettier —— 无尾随逗号&#xA;  &amp;quot;prettier.trailingComma&amp;quot;: &amp;quot;none&amp;quot;,&#xA;  // ESLint —— 增加支持&#xA;  &amp;quot;eslint.validate&amp;quot;: [&amp;quot;javascript&amp;quot;, &amp;quot;javascriptreact&amp;quot;, &amp;quot;html&amp;quot;, &amp;quot;vue&amp;quot;],&#xA;  // Editor —— 保存格式化&#xA;  &amp;quot;editor.codeActionsOnSave&amp;quot;: {&#xA;    &amp;quot;source.fixAll.eslint&amp;quot;: true&#xA;  }&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue Cli&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;npm install -g vue        # 安装 Vue&#xA;npm install -g @vue/cli   # 安装 Vue Cli&#xA;npm install -g yarn   # 安装 Yarn&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// .npmrc&#xA;phantomjs_cdnurl=http://cnpmjs.org/downloads&#xA;sass_binary_site=https://npm.taobao.org/mirrors/node-sass/&#xA;registry=https://registry.npm.taobao.org&#xA;&#xA;// .yarnrc&#xA;yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建项目&#xA;vue create 项目名称&#xA;&#xA;Vue CLI v4.5.9&#xA;? Please pick a preset: Manually select features&#xA;? Check the features needed for your project: Choose Vue version, Babel, Router, Vuex, CSS Pre-processors, Linter&#xA;? Choose a version of Vue.js that you want to start the project with 2.x&#xA;? Use history mode for router? (Requires proper server setup for index fallback in production) No&#xA;? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS (with node-sass)&#xA;? Pick a linter / formatter config: Prettier&#xA;? Pick additional lint features: Lint on save&#xA;? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files&#xA;? Save this as a preset for future projects? No&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建 vue.config.js 文件&#xA;&#xA;module.exports = {&#xA;  devServer: {&#xA;    port: 3333,&#xA;    open: true&#xA;  }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue 常用库&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Element UI &#xA;npm i element-ui -S&#xA;https://element.eleme.cn/#/zh-CN/&#xA;&#xA;axios &#xA;npm install axios&#xA;https://github.com/axios/axios&#xA;&#xA;qs&#xA;npm install qs -S&#xA;&#xA;js-cookie &#xA;npm install js-cookie -S&#xA;https://github.com/js-cookie/js-cookie&#xA;&#xA;mockjs &#xA;npm install mockjs&#xA;http://mockjs.com&#xA;&#xA;vuedraggable&#xA;npm i -S vuedraggable&#xA;https://github.com/SortableJS/Vue.Draggable&#xA;https://sortablejs.github.io/Vue.Draggable/#/simple&#xA;&#xA;element-resize-detector 元素调整大小检测器&#xA;npm install element-resize-detector&#xA;https://github.com/wnr/element-resize-detector&#xA;&#xA;Font Awesome 图标库&#xA;npm install font-awesome -S&#xA;http://www.fontawesome.com&#xA;http://www.fontawesome.com.cn&#xA;&#xA;Base64 and Md5&#xA;npm install --save js-base64&#xA;npm install --save js-md5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;JavaScript 数据类型&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;JS 有6种数据类型：String 字符串、Number 数值、 Boolean 布尔值、Null 空值、Undefined 未定义、Object 对象&#xA;&#xA;一、String&#xA;&#xA;    // 用引号括起来，单引号和双引号都可以，但是不能混搭。&#xA;    var a = &#39;hello&#39;;&#xA;    var b = &amp;quot;world&amp;quot;;&#xA;&#xA;    // 错误示例&#xA;    var c = &#39;hello&amp;quot;；&#xA;&#xA;二、Number&#xA;&#xA;&#xA;    // 所有数值都是Number类型，包括整数和浮点数&#xA;    var a = 123;&#xA;    var b = 123.456;&#xA;    // 可以使用typeof来检查一个变量的类型&#xA;    console.log(typeof a); // number&#xA;&#xA;    var c = &amp;quot;123&amp;quot;;&#xA;    console.log(typeof c); // string&#xA;&#xA;三、Boolean&#xA;&#xA;    // Boolean的布尔值只有两个，一个是true，一个是false&#xA;    var bool = true;&#xA;    console.log(bool); // true&#xA;    console.log(typeof bool); // boolean&#xA;&#xA;四、Null&#xA;&#xA;    // Null类型的值只有一个,就是 null,专门用来表示为一个空的对象&#xA;    var a = null ;&#xA;    console.log(a); // null&#xA;    console.log(typeof a); // object&#xA;&#xA;五、Undefined&#xA;&#xA;    // Undefined 类型的值只有一个，就是 undefined&#xA;    var b;&#xA;    console.log(b); //undefined 表示未定义，声明了未赋值&#xA;    console.log(typeof b); // undefined     &#xA;&#xA;强制类型转换&#xA;&#xA;    var a = 123;&#xA;    a = a.toString(); // &amp;quot;123&amp;quot;&#xA;&#xA;    var b = false&#xA;    b = b.toString(); // &amp;quot;false&amp;quot;&#xA;&#xA;    var a = 123;&#xA;    a = String(a); // &amp;quot;123&amp;quot;&#xA;&#xA;    var b = false&#xA;    b = String(b); // &amp;quot;false&amp;quot;&#xA;&#xA;    a = Number(a); // number 123&#xA;&#xA;    var str = &#39;hello&#39;;&#xA;    str = Number(str); // number NaN&#xA;&#xA;    a = &amp;quot;123px&amp;quot;;&#xA;    a = parseInt(a); // 123&#xA;&#xA;    a = &#39;b1234ddd&#39;;&#xA;    a = parseInt(a); // NaN&#xA;&#xA;    a = &#39;123.456px&#39;;&#xA;    a = parseFloat(a); // 123.456 &#xA;&#xA;    a = &#39;123px&#39;;&#xA;    a = parseFloat(a); // 123&#xA;&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;使用 Web Storage 存储键值&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用 Web Storage 存储键值对比存储 Cookie 方式更直观，而且容量更大&#xA;它包含两种：localStorage 和 sessionStorage&#xA;&#xA;sessionStorage(临时存储)：为每一个数据源维持一个存储区域&#xA;在浏览器打开期间存在，包括页面重新加载&#xA;&#xA;localStorage(长期存储)：与 sessionStorage 一样&#xA;但是浏览器关闭后，数据依然会一直存在&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 保存&#xA;localStorage.setItem(&#39;hou&#39;, JSON.stringify(info));&#xA;localStorage.setItem(&#39;zheng&#39;, str);&#xA;&#xA;// 获取&#xA;var data1 = JSON.parse(localStorage.getItem(&#39;hou&#39;));&#xA;var data2 = localStorage.getItem(&#39;zheng&#39;);&#xA;&#xA;// 删除&#xA;localStorage.removeItem(&#39;hou&#39;);&#xA;localStorage.clear();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;关于跨域解决方案&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;关于跨域的解决方法，大部分可以分为 2 种 ...&#xA;&#xA;1. nginx 反向代理解决跨域&#xA;2. 服务端设置 Response Header(响应头部)的 Access-Control-Allow-Origin&#xA;&#xA;// 服务端设置响应头部 ...&#xA;func Cors() gin.HandlerFunc {&#xA;    return func(c *gin.Context) {&#xA;        method := c.Request.Method&#xA;        if origin := c.Request.Header.Get(&amp;quot;Origin&amp;quot;); origin != &amp;quot;&amp;quot; {&#xA;            c.Header(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;) // 可将将 * 替换为指定的域名&#xA;            c.Header(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;POST, GET, OPTIONS, PUT, DELETE, UPDATE&amp;quot;)&#xA;            c.Header(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;Origin, X-Requested-With, Content-Type, Accept, Authorization&amp;quot;)&#xA;            c.Header(&amp;quot;Access-Control-Expose-Headers&amp;quot;, &amp;quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Cache-Control, Content-Language, Content-Type&amp;quot;)&#xA;            c.Header(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, &amp;quot;true&amp;quot;)&#xA;        }&#xA;        if method == &amp;quot;OPTIONS&amp;quot; {&#xA;            c.AbortWithStatus(http.StatusNoContent)&#xA;        }&#xA;        c.Next()&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    router := gin.Default()&#xA;    router.Use(Cors())&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;axios 与 vuex&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在 axios .then 中修改 vuex 数据是使用 mutations 还是 actions 呢 ...&#xA;要知道 axios .then 中的回调执行是在线程中完成的 ...&#xA;&#xA;注：mutation 里不应该异步操作数据, 所以有了 actions 选项&#xA;&#xA;mutations、actions 看起来很相似，可能会觉得不知道该用哪个&#xA;    但是 Vuex 很像是一种与开发者的约定 ...&#xA;    涉及改变数据的，就是用 mutations, 存在业务逻辑的，就用 actions &#xA;    至于将业务逻辑放在 action 里还是 Vue 组件里完成，需要根据场景&#xA;&#xA;简单说就是，如果占用线程时间的用 actions 不占用的 mutations &#xA;    也就是说，对于 vuex 赋值不管是不是在线程里面完成的&#xA;    只要是不占用时间都是 mutations ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;vuex 严格模式&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开启严格模式，仅需在创建 store 的时候传入 strict: true：&#xA;const store = new Vuex.Store({&#xA;  // ...&#xA;  strict: true&#xA;})&#xA;&#xA;// 为什么要开启严格模式&#xA;在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的&#xA;将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到 ...&#xA;&#xA;// 不要在发布环境下启用严格模式！&#xA;严格模式会深度监测状态树来检测不合规的状态变更&#xA;请确保在发布环境下关闭严格模式，以避免性能损失&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;vuex state 被 v-model 双向绑定怎么办&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果开启了严格模式，这样的修改会抛出一个错误 ...&#xA;&#xA;// 这里的 obj 是计算属性中返回的一个属于 Vuex store 的对象&#xA;// 在用户输入时 v-model 会试图直接修改 obj.message ...&#xA;&amp;lt;input v-model=&amp;quot;obj.message&amp;quot;&amp;gt;&#xA;&#xA;// 如何解决呢 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 方法一：给 &amp;lt;input&amp;gt; 中绑定 value 然后侦听 input 或者 change 事件&#xA;&#xA;// template&#xA;&amp;lt;input :value=&amp;quot;message&amp;quot; @input=&amp;quot;updateMessage&amp;quot;&amp;gt;&#xA;&#xA;// script&#xA;computed: {&#xA;  ...mapState({&#xA;    message: state =&amp;gt; state.obj.message&#xA;  })&#xA;},&#xA;methods: {&#xA;  updateMessage(e) {&#xA;    this.$store.commit(&#39;updateMessage&#39;, e.target.value)&#xA;  }&#xA;}&#xA;&#xA;// vuex&#xA;mutations: {&#xA;  updateMessage(state, message) {&#xA;    state.obj.message = message&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 方法二：双向绑定计算属性&#xA;&#xA;&amp;lt;input v-model=&amp;quot;message&amp;quot;&amp;gt;&#xA;&#xA;computed: {&#xA;  message: {&#xA;    get () {&#xA;      return this.$store.state.obj.message&#xA;    },&#xA;    set (value) {&#xA;      this.$store.commit(&#39;updateMessage&#39;, value)&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;@click.stop 与 @click.prevent&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@click.stop 阻止事件冒泡&#xA;&#xA;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div v-on:click=&amp;quot;dodo&amp;quot;&amp;gt;&#xA;        &amp;lt;button v-on:click=&amp;quot;doThis&amp;quot;&amp;gt;阻止单击事件继续传播&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;var app = new Vue({&#xA;    el: &amp;quot;#app&amp;quot;,&#xA;    data: {&#xA;    name: &amp;quot;Vue.js&amp;quot;&#xA;    },&#xA;    methods: {&#xA;    doThis: function () {&#xA;        alert(&amp;quot;noclick&amp;quot;);&#xA;    },&#xA;    dodo: function () {&#xA;        alert(&amp;quot;dodo&amp;quot;);&#xA;    }&#xA;    }&#xA;});&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 会先弹出 “noclick” 再弹出 “dodo”&#xA;&#xA;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div v-on:click=&amp;quot;dodo&amp;quot;&amp;gt;&#xA;    &amp;lt;button v-on:click.stop=&amp;quot;doThis&amp;quot;&amp;gt;阻止单击事件继续传播&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;var app = new Vue({&#xA;    el: &amp;quot;#app&amp;quot;,&#xA;    data: {&#xA;    name: &amp;quot;Vue.js&amp;quot;&#xA;    },&#xA;    methods: {&#xA;    doThis: function () {&#xA;        alert(&amp;quot;noclick&amp;quot;);&#xA;    },&#xA;    dodo: function () {&#xA;        alert(&amp;quot;dodo&amp;quot;);&#xA;    }&#xA;    }&#xA;});&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 只弹出 “noclick” 因为 @click.stop 阻止事件冒泡 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 阻止a标签跳转，仅执行函数test4&#xA;&amp;lt;a href=&amp;quot;http://www.baidu.com&amp;quot; @click.prevent=&amp;quot;test4&amp;quot;&amp;gt;百度一下&amp;lt;/a&amp;gt;   &#xA;// 阻止表单提交，仅执行函数test5&#xA;&amp;lt;form  action=&amp;quot;/xxx&amp;quot;   @submit.prevent=&amp;quot;test5&amp;quot;&amp;gt; &#xA;     &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;注册&amp;quot;&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;自动获得焦点 v-focus&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;el-input v-focus @blur=&amp;quot;失去焦点时...&amp;quot; /&amp;gt; &#xA;&#xA;export default {&#xA;  directives: {&#xA;    // 注册一个局部的自定义指令 v-focus&#xA;    focus: {&#xA;      // 指令的定义&#xA;      inserted: function(el) {&#xA;    // 聚焦元素&#xA;    el.querySelector(&amp;quot;input&amp;quot;).focus();&#xA;      }&#xA;    }&#xA;  },&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Vue 常见问题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  // axios 传输数据中包含数组时 gin 或 beego 等无法接收问题&#xA;&#xA;  // 解决办法就是 JSON.stringify 转换成字符串 ...&#xA;&#xA;  this.$utils&#xA;.requestData(&amp;quot;/api/ph/save&amp;quot;, {&#xA;  id: this.data.id,&#xA;  type: this.data.type,&#xA;  width: this.screenWidth,&#xA;  height: this.screenHeight,&#xA;  layers: JSON.stringify(this.screenLayers)&#xA;})&#xA;.then(data =&amp;gt; {&#xA;  console.log(data);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 多行换行 ...&#xA;&#xA;.m-wrapper {&#xA;  width: 90px;&#xA;  height: 48px;&#xA;  word-break: break-all;&#xA;  span {&#xA;    overflow: hidden;&#xA;    text-overflow: ellipsis;&#xA;    display: -webkit-box;&#xA;    -webkit-line-clamp: 3;&#xA;    -webkit-box-orient: vertical;&#xA;    color: #fff;&#xA;    text-align: center;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 删除 scoped 是定义局部使用，无法覆盖掉插件的样式&#xA;&amp;lt;script scoped&amp;gt;&#xA;&#xA;// companyinfo 是自己定义的，后面的是原组件的样式&#xA;// 自己定义 class 可以帮助寻找到 DOM&#xA;companyinfo .el-breadcrumb__inner {&#xA;    // 用！important 增加优先&#xA;    color: blue !important;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Element UI 内置自定义指令 v-clickoutside 使用方法&#xA;&#xA;// 引入指令 &#xA;import Clickoutside from &#39;element-ui/src/utils/clickoutside&#39;&#xA;&#xA;// 声明指令&#xA;export default {&#xA;  directives: { Clickoutside },&#xA;  data: function() {&#xA;    return {&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;// 使用指令&#xA;&amp;lt;div v-clickoutside=&amp;quot;handleClickOutside&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&#xA;// 绑定函数&#xA;methods: {&#xA;    // 点击区域外&#xA;    handleClickOutside() {}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Vue 跳转页面传值&#xA;&#xA;// params 传参 &#xA;// 相当于post请求, 页面跳转时参数不会在地址栏中显示&#xA;    this.$router.push({&#xA;           name:&#39;&#39;,&#xA;           params: { id:idParams }&#xA;    })&#xA;    接收参数：this.$route.params.id&#xA;&#xA;// query 传参 &#xA;// 相当于get请求, 页面跳转时参数会在地址栏中显示&#xA;    this.$router.push({&#xA;           name:&#39;&#39;,&#xA;           query: { id:idParams }&#xA;    })&#xA;    接收参数：this.$route.query.id&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Vue 之 vue-router 同一个页面地址参数改变, 页面不刷新的问题&#xA;&#xA;解决办法有两种：&#xA;&#xA;1. 监听地址栏变化(watch)这是vue-router官方给出的解决办法&#xA;&#xA;watch: {&#xA;    &#39;$route&#39; (to, from) {&#xA;    this.getData(this.$route.query.id)&#xA;    }&#xA;}&#xA;&#xA;methods: {&#xA;    async getData (id) {&#xA;      // 按照id获取数据&#xA;      const { data: { result } } = await this.$http.get(&#39;getShowList&#39;, {&#xA;    params: { id }&#xA;      })&#xA;      this.dataList = result&#xA;    }&#xA;}&#xA;&#xA;2. 给router-view加个唯一的key，来保证路由切换时都会重新渲染触发钩子了&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;main&amp;quot; class=&amp;quot;app-main&amp;quot;&amp;gt;&#xA;    &amp;lt;transition :name=&amp;quot;transitionName&amp;quot;&amp;gt;&#xA;        &amp;lt;router-view class=&amp;quot;router-box&amp;quot; :key=&amp;quot;key&amp;quot;&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;    &amp;lt;/transition&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    export default {&#xA;    computed:{&#xA;        key(){&#xA;        return this.$route.name ? &#xA;            this.$route.name+ +new Date() : &#xA;            this.$route+ +new Date()&#xA;        }&#xA;    }&#xA;    };&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Vue.js之使用transition实现过渡与动画</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8B%E4%BD%BF%E7%94%A8transition%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</link>
      <pubDate>2020-12-21 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue之使用transition实现过渡与动画&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 文档 ...&#xA;https://cn.vuejs.org/v2/guide/transitions.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Vue 提供了 transition 的封装组件&#xA;&#xA;// 在下列情形中，可以给任何元素和组件添加进入/离开过渡&#xA;1. 条件渲染 (使用 v-if)&#xA;2. 条件展示 (使用 v-show)&#xA;3. 动态组件&#xA;4. 组件根节点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;例:&#xA;&#xA;&amp;lt;div id=&amp;quot;demo&amp;quot;&amp;gt;&#xA;  &amp;lt;button v-on:click=&amp;quot;show = !show&amp;quot;&amp;gt;&#xA;    Toggle&#xA;  &amp;lt;/button&amp;gt;&#xA;  &amp;lt;transition name=&amp;quot;fade&amp;quot;&amp;gt;&#xA;    &amp;lt;p v-if=&amp;quot;show&amp;quot;&amp;gt;hello&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/transition&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;new Vue({&#xA;  el: &#39;#demo&#39;,&#xA;  data: {&#xA;    show: true&#xA;  }&#xA;})&#xA;&#xA;.fade-enter-active, .fade-leave-active {&#xA;  transition: opacity .5s;&#xA;}&#xA;.fade-enter, .fade-leave-to &#xA;/* .fade-leave-active below version 2.1.8 */ {&#xA;  opacity: 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-enter: 定义进入过渡的开始状态。&#xA;    在元素被插入之前生效，在元素被插入之后的下一帧移除。&#xA;v-enter-active: 定义进入过渡生效时的状态&#xA;    在整个进入过渡的阶段中应用，在元素被插入之前生效，&#xA;    在过渡/动画完成之后移除。&#xA;    这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。&#xA;v-enter-to: 定义进入过渡的结束状态。&#xA;    在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，&#xA;    在过渡/动画完成之后移除。&#xA;v-leave: 定义离开过渡的开始状态。&#xA;    在离开过渡被触发时立刻生效，下一帧被移除。&#xA;v-leave-active: 定义离开过渡生效时的状态。&#xA;    在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，&#xA;    在过渡/动画完成之后移除。&#xA;    这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。&#xA;v-leave-to: 上定义离开过渡的结束状态。&#xA;    在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，&#xA;    在过渡/动画完成之后移除。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;对于这些在过渡中切换的类名来说&#xA;&#xA;如果你使用一个没有名字的 &amp;lt;transition&amp;gt; 则 v- 是这些类名的默认前缀。&#xA;如果你使用了 &amp;lt;transition name=&amp;quot;myname&amp;quot;&amp;gt;, 那么 v-enter 会替换为 myname-enter。&#xA;&#xA;v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;CSS 过渡, 常用的过渡都是使用 CSS 过渡。&#xA;&#xA;&amp;lt;div id=&amp;quot;example-1&amp;quot;&amp;gt;&#xA;  &amp;lt;button @click=&amp;quot;show = !show&amp;quot;&amp;gt;&#xA;    Toggle render&#xA;  &amp;lt;/button&amp;gt;&#xA;  &amp;lt;transition name=&amp;quot;slide-fade&amp;quot;&amp;gt;&#xA;    &amp;lt;p v-if=&amp;quot;show&amp;quot;&amp;gt;hello&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/transition&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;new Vue({&#xA;  el: &#39;#example-1&#39;,&#xA;  data: {&#xA;    show: true&#xA;  }&#xA;})&#xA;&#xA;/* 可以设置不同的进入和离开动画 */&#xA;/* 设置持续时间和动画函数 */&#xA;.slide-fade-enter-active {&#xA;  transition: all .3s ease;&#xA;}&#xA;.slide-fade-leave-active {&#xA;  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#xA;}&#xA;.slide-fade-enter, .slide-fade-leave-to&#xA;/* .slide-fade-leave-active for below version 2.1.8 */ {&#xA;  transform: translateX(10px);&#xA;  opacity: 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* 定义进入过渡的开始状态 */&#xA;.logo-enter {&#xA;  /* 允许你将元素旋转，缩放，移动，倾斜等。*/&#xA;  /* https://www.runoob.com/cssref/css3-pr-transform.html */&#xA;  transform: translateX(15px);&#xA;  /* 设置元素的不透明级别 */&#xA;  /* 从 0.0 （完全透明）到 1.0（完全不透明）。 */&#xA;  opacity: 0;&#xA;}&#xA;&#xA;/* 定义进入过渡生效时的状态 */&#xA;.logo-enter-active {&#xA;  /* &#xA;    transition: property duration timing-function delay; &#xA;    transition-property 规定设置过渡效果的 CSS 属性的名称。&#xA;    transition-duration 规定完成过渡效果需要多少秒或毫秒。&#xA;    transition-timing-function 规定速度效果的速度曲线。&#xA;    transition-delay 定义过渡效果何时开始。 &#xA;  */&#xA;  transition: all 0.5s cubic-bezier(1, 0.5, 0.8, 1) 0.5s;&#xA;  /*&#xA;    cubic-bezier() 函数定义了一个贝塞尔曲线(Cubic Bezier)。 &#xA;    https://www.runoob.com/cssref/func-cubic-bezier.html &#xA;  */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;CSS 动画 &#xA;&#xA;animation 动画与元素绑定&#xA;animation: name duration timing-function delay iteration-count direction;&#xA;animation-name  规定需要绑定到选择器的 keyframe 名称&#xA;animation-duration  规定完成动画所花费的时间，以秒或毫秒计。&#xA;animation-timing-function   规定动画的速度曲线。&#xA;animation-delay 规定在动画开始之前的延迟。&#xA;animation-iteration-count   规定动画应该播放的次数。&#xA;animation-direction 规定是否应该轮流反向播放动画。&#xA;https://www.w3school.com.cn/cssref/pr_animation.asp&#xA;&#xA;// 例&#xA;&#xA;&amp;lt;div id=&amp;quot;example-2&amp;quot;&amp;gt;&#xA;  &amp;lt;button @click=&amp;quot;show = !show&amp;quot;&amp;gt;Toggle show&amp;lt;/button&amp;gt;&#xA;  &amp;lt;transition name=&amp;quot;bounce&amp;quot;&amp;gt;&#xA;    &amp;lt;p v-if=&amp;quot;show&amp;quot;&amp;gt;Lorem ipsum dolor sit amconsectetur&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/transition&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;new Vue({&#xA;  el: &#39;#example-2&#39;,&#xA;  data: {&#xA;    show: true&#xA;  }&#xA;})&#xA;&#xA;.bounce-enter-active {&#xA;  animation: bounce-in .5s;&#xA;}&#xA;.bounce-leave-active {&#xA;  animation: bounce-in .5s reverse;&#xA;}&#xA;@keyframes bounce-in {&#xA;  0% {&#xA;    transform: scale(0);&#xA;  }&#xA;  50% {&#xA;    transform: scale(1.5);&#xA;  }&#xA;  100% {&#xA;    transform: scale(1);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之Qt安装QtWebengine环境</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8BQt%E5%AE%89%E8%A3%85QtWebengine%E7%8E%AF%E5%A2%83/</link>
      <pubDate>2020-12-13 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之Qt安装QtWebengine环境&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// QtWebengine 需要在 Xorg 环境下运行&#xA;// Raspberry Pi 4B 支持 Xorg 硬件加速&#xA;// Raspberry Pi OS with desktop 系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 准备工作&#xA;sed -i &#39;s/raspbian.raspberrypi.org/mirrors4.tuna.tsinghua.edu.cn\/raspbian/&#39; /etc/apt/sources.list&#xA;sed -i &#39;s/archive.raspberrypi.org\/debian/mirrors4.tuna.tsinghua.edu.cn\/raspberrypi/&#39; /etc/apt/sources.list.d/raspi.list&#xA;apt-get update&#xA;&#xA;// 第一步：安装 Qt&#xA;apt-get install qt5-default &#xA;&#xA;// 第二步：查看 qt 版本&#xA;root@raspberrypi:~# qmake -v&#xA;QMake version 3.1&#xA;Using Qt version 5.11.3 in /usr/lib/arm-linux-gnueabihf&#xA;&#xA;// 官方源中并没有 WebEngine 所以无法用 apt 安装&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第四步：查找下载软件包&#xA;https://www.debian.org/distrib/packages&#xA;&#xA;// 下面四个软件包&#xA;1. libqt5webenginecore5_5.11.3+dfsg-2+deb10u1_armhf.deb &#xA;2. libqt5webengine5_5.11.3+dfsg-2+deb10u1_armhf.deb     &#xA;3. libqt5webenginewidgets5_5.11.3+dfsg-2+deb10u1_armhf.deb&#xA;4. qtwebengine5-dev_5.11.3+dfsg-2+deb10u1_armhf.deb&#xA;&#xA;// 下载对应的 armhf 版本&#xA;https://packages.debian.org/buster/libqt5webenginecore5&#xA;https://packages.debian.org/buster/libqt5webengine5&#xA;https://packages.debian.org/buster/libqt5webenginewidgets5&#xA;https://packages.debian.org/buster/qtwebengine5-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第五步：安装软件包&#xA;dpkg -i libqt5webenginecore5_5.11.3+dfsg-2+deb10u1_armhf.deb&#xA;dpkg -i libqt5webengine5_5.11.3+dfsg-2+deb10u1_armhf.deb&#xA;dpkg -i libqt5webenginewidgets5_5.11.3+dfsg-2+deb10u1_armhf.deb&#xA;dpkg -i qtwebengine5-dev_5.11.3+dfsg-2+deb10u1_armhf.deb&#xA;&#xA;// 在提示 dependency problems - leaving unconfigured 错误时&#xA;sudo apt-get -f install // 一键安装依赖包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第六步：使用 WebEngine&#xA;QT += core gui network webengine webenginewidgets &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;硬件加速的一些相关配置&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装库&#xA;sudo apt-get install libgles2-mesa libgles2-mesa-dev xorg-dev&#xA;&#xA;// 设置&#xA;1. sudo raspi-config&#xA;2. Advanced Options&amp;gt;GL Driver&#xA;2. GL (Fake KMS) OpenGL desktop driver with fake KMS&#xA;3. Advanced Options&amp;gt;Memory Split&#xA;4. 键入128并单击确定&#xA;5. 选择完成并重新启动系统。&#xA;&#xA;// 查看 3D 驱动是否正常工作&#xA;cat /proc/device-tree/soc/firmwarekms@7e600000/status&#xA;cat /proc/device-tree/v3dbus/v3d@7ec04000/status&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;减少屏幕撕裂&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 设置&#xA;1. sudo raspi-config&#xA;2. Advanced Options&amp;gt; Compositor&amp;gt;xcompmgr composition manager&#xA;3. 选择 No&#xA;4. 重新启动 Raspberry Pi&#xA;&#xA;// 或者直接删除&#xA;rm -rf /etc/xdg/autostart/xcompmgr.desktop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;WebEngine 配置&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看 GPU 状态&#xA;chrome://gpu&#xA;&#xA;// 状态&#xA;Graphics Feature Status&#xA;1. Canvas: Hardware accelerated&#xA;2. CheckerImaging: Disable&#xA;3. Flash: Hardware accelerated&#xA;4. Flash Stage3D: Hardware accelerated&#xA;5. Flash Stage3D Baseline profile: Hardware accelerated&#xA;6. Compositing: Hardware accelerated&#xA;7. Multiple Raster Threads: Enabled&#xA;8. Native GpuMemoryBuffers: Software only. Hardware acceleration disabled&#xA;9. Rasterization: Software only. Hardware acceleration disabled&#xA;10. Video Decode: Unavailable&#xA;11. WebGL: Hardware accelerated&#xA;12. WebGL2: Hardware accelerated&#xA;&#xA;// 开启光栅化&#xA;--enable-gpu-rasterization&#xA;Rasterization: Hardware accelerated&#xA;&#xA;// 忽略黑名单后 Video Decode 显示开启&#xA;--ignore-gpu-blacklist&#xA;Video Decode: Hardware accelerated&#xA;&#xA;// 开启 Native GpuMemoryBuffers &#xA;--enable-native-gpu-memory-buffers &#xA;&#xA;// 开启 CheckerImaging &#xA;--enable-checker-imaging&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 参数解释&#xA;https://www.cnblogs.com/TimFang/articles/13540314.html&#xA;&#xA;// 互联网案例&#xA;&#xA;--ignore-gpu-blacklist &#xA;--enable-one-copy-rasterizer &#xA;--enable-gpu-rasterization &#xA;--enable-native-gpu-memory-buffers &#xA;--enable-checker-imaging --enable-quic &#xA;--site-per-process --enable-tcp-fastopen &#xA;--disable-features=MaterialDesignBookmarks &#xA;--disable-gpu-compositing &#xA;--enable-fast-unload &#xA;--enable-experimental-canvas-features &#xA;--enable-scroll-prediction &#xA;--answers-in-suggest &#xA;--ppapi-flash-path=/usr/lib/chromium-browser/libpepflashplayer.so &#xA;--ppapi-flash-args=enable_stagevideo_auto=0 &#xA;--ppapi-flash-version= &#xA;--max-tiles-for-interest-area=512 &#xA;--num-raster-threads=4 &#xA;--default-tile-height=512&#xA;&#xA;// 相关讨论&#xA;https://www.raspberrypi.org/forums/viewtopic.php?t=199543&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;QtWebEngine / VideoAcceleration 视频加速&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// QtWebEngine / VideoAcceleration 官方文档&#xA;https://wiki.qt.io/QtWebEngine/VideoAcceleration&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之QWebEngine与JavaScript交互</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8BQWebEngine%E4%B8%8EJavaScript%E4%BA%A4%E4%BA%92/</link>
      <pubDate>2020-11-27 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qt之QWebEngine与JavaScript交互&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Webenginewidgets （web显示类，用于显示web界面)&#xA;Webchannel（web数据通道类，用于数据通信）&#xA;&#xA;// 在工程文件.pro添加：&#xA;QT += core gui webengine webenginewidgets webchannel&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建通道对象类 ...&#xA;&#xA;#ifndef PLAYOBJECT_H&#xA;#define PLAYOBJECT_H&#xA;&#xA;#include &amp;lt;QObject&amp;gt;&#xA;&#xA;// 创建通道对象类（Qt与Web通信是通过对象的方式交换数据）&#xA;class PlayObject : public QObject&#xA;{&#xA;    Q_OBJECT&#xA;public:&#xA;    PlayObject(QObject *parent);&#xA;    // 使用 Q_INVOKABLE 来修饰成员函数，目的在于被修饰的成员函数能够被元对象系统所唤起&#xA;    // 注：在 JS 中可以使用 JSSendMessage 向 Qt 发送数据 ...&#xA;    Q_INVOKABLE void JSSendMessage(QString strParameter, QString str) {&#xA;        // 当接收到 JS 发来的数据时，向外部发送消息 ...&#xA;        emit SigReceivedMessFromJS(strParameter,str);&#xA;    }&#xA;signals:&#xA;    // 当接收到 JS 发来的数据时，向 Qt 其它类发送消息 ...&#xA;    void SigReceivedMessFromJS(QString strParameter,QString str);&#xA;    // 通过该信号向 JS 发送数据 ...&#xA;    void SigSendMessageToJS(QString strParameter);&#xA;};&#xA;&#xA;#endif // PLAYOBJECT_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 QWebEngineView 中注册通道对象类&#xA;&#xA;#include &amp;lt;QWebEngineView&amp;gt;&#xA;#include &amp;lt;QWebChannel&amp;gt;&#xA;#include &amp;quot;playobject.h&amp;quot;&#xA;&#xA;class Web : public QWebEngineView&#xA;{&#xA;    Q_OBJECT&#xA;public:&#xA;    Web(QWidget *parent = 0);&#xA;    // 注册&#xA;    void regObject();&#xA;public slots:&#xA;    // 接收&#xA;    void OnReceiveMessageFromJS(QString usr,QString passwd);&#xA;signals:&#xA;    // 发送&#xA;    void SigSendMessageToJS(QString strParameter);&#xA;};&#xA;&#xA;---&#xA;&#xA;#include &amp;quot;web.h&amp;quot;&#xA;&#xA;Web::Web(QWidget *parent, Content *content) : QWebEngineView(parent)&#xA;{&#xA;}&#xA;&#xA;// 注册通道对象类 ...&#xA;void Web::regObject() {&#xA;    // 创建 QWebChannel&#xA;    QWebChannel *m_wc = new QWebChannel(this-&amp;gt;page());&#xA;    // 创建 PlayObject&#xA;    PlayObject *m_po = new PlayObject(this);&#xA;    // 注册 PlayObject 到 QWebChannel 指定 ID 为 context&#xA;    m_wc-&amp;gt;registerObject(QStringLiteral(&amp;quot;context&amp;quot;), m_po);&#xA;    // 设置 QWebChannel 到 QWebEngineView&#xA;    this-&amp;gt;page()-&amp;gt;setWebChannel(m_wc);&#xA;    // 当 JS 调用 JSSendMessage 时，PlayObject 发送 SigReceivedMessFromJS 信号到 Web&#xA;    connect(m_po, &amp;amp;PlayObject::SigReceivedMessFromJS, this, &amp;amp;Web::OnReceiveMessageFromJS);&#xA;    // 当 Web 调用 SigSendMessageToJS 时 PlayObject 发送 SigSendMessageToJS 信号到 JS&#xA;    connect(this, &amp;amp;Web::SigSendMessageToJS, m_po, &amp;amp;PlayObject::SigSendMessageToJS);&#xA;}&#xA;&#xA;// 接收 JS 发来的数据 ... 通过 PlayObject 中 JSSendMessage 中转 ...&#xA;void Web::OnReceiveMessageFromJS(QString usr,QString passwd)&#xA;{&#xA;    LOGD(&amp;quot;&amp;gt;&amp;gt;&amp;gt; %s&amp;quot;, QString(&amp;quot;%1 %2&amp;quot;).arg(usr).arg(passwd).toStdString().c_str());&#xA;    // 发送数据到 JS ... 通过 PlayObject 中 SigSendMessageToJS 中转 ...&#xA;    emit SigSendMessageToJS(&amp;quot;ok&amp;quot;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 HTML 中使用 JS 向 Qt 发送与接收数据 ...&#xA;// 需要导入 qwebchannel.js 文件 (在Qt安装目录中)&#xA;&#xA;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;http://192.168.31.160:8711/qwebchannel.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;http://192.168.31.160:8711/jquery-3.5.1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&#xA;    window.onload = function () {&#xA;&#xA;      // 浏览器内核自带&#xA;      new QWebChannel(qt.webChannelTransport, function (channel) {&#xA;&#xA;        // 获取 Qt 通道类 ...&#xA;        var context = channel.objects.context; // 注册对象名&#xA;&#xA;        // 通过 Qt 通道类 JSSendMessage 函数向 Qt 发送消息&#xA;        $(&amp;quot;#_login_&amp;quot;).click(function () {&#xA;          var name = document.getElementById(&amp;quot;_username_&amp;quot;).value;&#xA;          var passwd = document.getElementById(&amp;quot;_password_&amp;quot;).value;&#xA;          context.JSSendMessage(name, passwd); // 发送消息&#xA;        });&#xA;&#xA;        // 接收 Qt 发来的数据 ...&#xA;        context.SigSendMessageToJS.connect(function (str) {&#xA;          if (str == &amp;quot;ok&amp;quot;) alert(&amp;quot;success&amp;quot;);&#xA;        });&#xA;&#xA;      });&#xA;&#xA;    };&#xA;&amp;lt;/script&amp;gt;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;在 Vue.js 中使用 QWebChannel&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在 Vue Cli 项目中, 拷贝 qwebchannel.js 到 public 目录中&#xA;&#xA;// 在 qwebchannel.js 中需要修改 ...&#xA;Object.prototype.hasOwnProperty.call(data, &amp;quot;id&amp;quot;)&#xA;Object.prototype.hasOwnProperty.call(message, &amp;quot;id&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;ok&amp;quot;&amp;gt;发送&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { QWebChannel } from &amp;quot;../public/qwebchannel&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      sendMessageToQt: &amp;quot;&amp;quot;,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    ok() {&#xA;      // 发送消息到 Qt&#xA;      this.sendMessageToQt(&amp;quot;123&amp;quot;, &amp;quot;321&amp;quot;);&#xA;    },&#xA;    // 接收 Qt 发来的消息 &#xA;    receiveMessageFromQt(key, value) {&#xA;      alert(key + &amp;quot;-&amp;quot; + value);&#xA;      console.log(key + &amp;quot;-&amp;quot; + value);&#xA;    },&#xA;  },&#xA;  mounted() {&#xA;    // 初始化 QWebChannel ...&#xA;    new QWebChannel(window.qt.webChannelTransport, (channel) =&amp;gt; {&#xA;      var pobj = channel.objects.pobj;&#xA;      this.sendMessageToQt = (key, value) =&amp;gt; {&#xA;        pobj.SendMessageToQt(key, value);&#xA;      };&#xA;      pobj.SigSendMessageToJS.connect((key, value) =&amp;gt; {&#xA;        this.receiveMessageFromQt(key, value);&#xA;      });&#xA;    });&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Vue.js之使用Vuex管理状态</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8B%E4%BD%BF%E7%94%A8Vuex%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81/</link>
      <pubDate>2020-11-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue.js之使用Vuex管理状态&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 之前介绍，父组件通过 prop 向子组件传递数据&#xA;// 子组件通过自定义事件向父组件传递数据 ...&#xA;&#xA;// 然而，在实际项目中，经常会遇到多个组件需要访问同一数据的情况&#xA;// 且都需要根据数据的变化做出响应，而这些组件之间可能并不是父子关系&#xA;// 在这种情况下，就需要一个全局的状态管理方案 ... Vuex&#xA;&#xA;Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式&#xA;// 它采用集中式存储来管理应用程序中所有组件的状态&#xA;// 并以相应的规则保证状态以一种可预测的方式发生变化&#xA;&#xA;Vuex 也集成到了 Vue 的官方调试工具 vue-devtools 中&#xA;// 提供了诸如零配置的 time-travel 调试、状态快照等高级功能&#xA;&#xA;// 安装&#xA;npm install vuex&#xA;&#xA;// 在 Vue Cli 中使用 &#xA;import Vue from &#39;vue&#39;&#xA;import Vuex from &#39;vuex&#39;&#xA;// 安装插件&#xA;Vue.use(Vuex)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Vuex 使用单一状态树，也就是说，用一个对象包含了所有应用层级的状态&#xA;// 作为唯一数据源 (single surce of truth) 而存在 ...&#xA;&#xA;1. Vuex 的状态存储是响应式的，当 Vue 组件从 store 中检索状态的时候，&#xA;    如果 store 中的状态发生变化，那么组件也会相应地得到高效的更新&#xA;2. 不能直接改变 store 中的状态，改变 store 中的状态的唯一途径就是&#xA;    显示地提交 mutation 这可以确保每个状态更改都留下可跟踪的记录&#xA;    从而能够启动一些工具来帮助我们更好地理解应用 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在 Vue Cli 创建项目的时候可以选择创建时安装 Vuex &#xA;&#xA;// 此时系统会生成 /src/store/index.js 来创建 store&#xA;&#xA;import Vue from &#39;vue&#39;&#xA;import Vuex from &#39;vuex&#39;&#xA;&#xA;Vue.use(Vuex)&#xA;&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;  },&#xA;  mutations: {&#xA;  },&#xA;  actions: {&#xA;  },&#xA;  modules: {&#xA;  }&#xA;})&#xA;&#xA;// 并且在/src/main.js入口函数中安装&#xA;&#xA;import Vue from &#39;vue&#39;&#xA;import App from &#39;./App.vue&#39;&#xA;import router from &#39;./router&#39;&#xA;import store from &#39;./store&#39;&#xA;&#xA;Vue.config.productionTip = false&#xA;&#xA;new Vue({&#xA;  router,&#xA;  store,&#xA;  render: h =&amp;gt; h(App)&#xA;}).$mount(&#39;#app&#39;)&#xA;&#xA;// 这样就可以在子组件中通过 this.$store 来访问 store 了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：如果要在组件中展示 store 中的状态，应该使用计算属性来返回 store 的状态&#xA;computed: {&#xA;    count() {&#xA;        return this.$store.state.count;&#xA;    }&#xA;}&#xA;&#xA;注意：通过提交 mutation 来更改 store 中的状态。&#xA;// 在严格模式下，如果 store 中的状态改变不是由 mutation 函数引起的，则会抛出错误&#xA;&#xA;// 在创建 store 的时候，传入 strict: true 启动严格模式&#xA;const store = new Vuex.Store({&#xA;    strice: true,&#xA;    // ....&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型和一个处理函数&#xA;// 这个处理函数就是实际进行状态更改的地方，它接收 state 作为第一参数 ...&#xA;&#xA;// 我们不能直接调用一个 mutation 处理函数，mutations 选项更像是事件注册&#xA;// 当触发一个类型为 increment 的 mutation 时，调用此函数 ...&#xA;&#xA;// 要调用一个 mutation 处理函数，需要用它的类型去调用 store.commit 方法&#xA;store.commit(&#39;increment&#39;)&#xA;&#xA;// 例如：&#xA;&#xA;// store/index.js&#xA;import Vue from &#39;vue&#39;&#xA;import Vuex from &#39;vuex&#39;&#xA;&#xA;Vue.use(Vuex)&#xA;&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    count: 0&#xA;  },&#xA;  mutations: {&#xA;    aaa(state) {&#xA;      state.count += 1;&#xA;    },&#xA;  },&#xA;  actions: {&#xA;  },&#xA;  modules: {&#xA;  }&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;handleClick&amp;quot;&amp;gt;You click me \{{ count }} times.&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  computed: {&#xA;    count() {&#xA;      return this.$store.state.count;&#xA;    },&#xA;  },&#xA;  methods: {&#xA;    handleClick() {&#xA;      this.$store.commit(&amp;quot;aaa&amp;quot;);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 上面已经介绍过更改 store 中的状态的唯一方式是提交 mutation &#xA;// 在使用 store.commit 方法提交 mutation 时，还可以传入额外的参数&#xA;// 既 mutation 的载荷 (payload)&#xA;&#xA;// 代码如下：&#xA;mutation: {&#xA;    increment (state, n) {&#xA;        state.count += n;&#xA;    }&#xA;}&#xA;&#xA;store.commit(&#39;increment&#39;, 10);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 载荷也可以是一个对象&#xA;mutation: {&#xA;    increment (state, payload) {&#xA;        state.count += payload.amount;&#xA;    }&#xA;}&#xA;&#xA;store.commit(&#39;increment&#39;, {&#xA;    amount: 10,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 提交 mutation 时，也可以使用包含 type 属性的对象&#xA;store.commit({&#xA;    type: &#39;increment&#39;,&#xA;    amount: 10,&#xA;});&#xA;&#xA;// 当使用对象风格提交时，整个对象将作为载荷传给 mutation 函数&#xA;// 使用 type 属性包含 type 属性的对象时, 处理器保持不变 ...&#xA;mutations: {&#xA;    increment (state, playload) {&#xA;        state.count += playload.amount;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以使用 mapMutations 辅助函数将组建中的方法映射为 store.commit 调用&#xA;&#xA;import { mapMutations } form &#39;vuex&#39;&#xA;methods: mapMutations([&#xA;    // 将 this.increment() 映射为 this.$store.commit(&#39;increment&#39;)&#xA;    &#39;increment&#39;,&#xA;    // 将 this.incrementBy(amount) 映射为 this.$store.commit(&#39;incrementBy&#39;, amount)&#xA;    &#39;incrementBy&#39;,&#xA;])&#xA;&#xA;// 除了使用字符串数组外，mapMutations 函数的参数也可以是一个对象&#xA;import { mapMutations } form &#39;vuex&#39;&#xA;methods: mapMutations({&#xA;    // 将 this.add() 映射为 this.$store.commit(&#39;increment&#39;)&#xA;    add: &#39;increment&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 大多情况下，组建还有自己的方法，在这种情况下可以使用 ECMAScript 6 的展开运算符&#xA;// 提取 mapMutations 函数返回的对象属性，复制到 methods 选项中 ...&#xA;import { mapMutations } from &#39;vuex&#39;&#xA;export default {&#xA;    methods: {&#xA;        ...MapMutations([&#xA;            // 将 this.increment() 映射为 this.$store.commit(&#39;increment&#39;)&#xA;            &#39;increment&#39;,&#xA;            // mapMutations 也支持载荷&#xA;            // 将 this.incrementBy(amount) 映射为 this.$store.commit(&#39;incrementBy&#39;, amount)&#xA;            &#39;incrementBy&#39;,&#xA;        ]),&#xA;        ...mapMutations({&#xA;            // 将 this.add() 映射为 this.$store.commit(&#39;increment&#39;)&#xA;            add: &#39;increment&#39;,&#xA;        })&#xA;    }&#xA;}&#xA;&#xA;// 例如：&#xA;&#xA;// store/index.js&#xA;import Vue from &#39;vue&#39;&#xA;import Vuex from &#39;vuex&#39;&#xA;&#xA;Vue.use(Vuex)&#xA;&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    count: 0&#xA;  },&#xA;  mutations: {&#xA;    aaa(state) {&#xA;      state.count += 1;&#xA;    },&#xA;  },&#xA;  actions: {&#xA;  },&#xA;  modules: {&#xA;  }&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt;You click me \{{ count }} times.&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;aaa&amp;quot;&amp;gt;You click me \{{ count }} times.&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { mapMutations } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  computed: {&#xA;    count() {&#xA;      return this.$store.state.count;&#xA;    },&#xA;  },&#xA;  methods: {&#xA;    ...mapMutations({&#xA;      // 将 this.aaa() 映射为 this.$store.commit(&#39;aaa&#39;)&#xA;      // 也就是 @click=&#39;aaa&#39; 时执行的是 this.$store.commit(&#39;aaa&#39;)&#xA;      &#39;aaa&#39;,&#xA;    }),&#xA;    ...mapMutations({&#xA;      // 将 this.add() 映射为 this.$store.commit(&#39;aaa&#39;)&#xA;      add: &amp;quot;aaa&amp;quot;,&#xA;    }),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 你可以调用 increment 方法，也可以调用 add 方法，来提交 increment mutation &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 还可以使用常量来代替 mutation 的类型，可以把常量放到一个单独的JS文件中，&#xA;// 有助于项目团队对 store 中所包含的 mutation 一目了然 ...&#xA;&#xA;// mutation-types.js&#xA;export const INCREMENT = &#39;increment&#39;&#xA;&#xA;// state.js&#xA;import Vuex from &#39;vuex&#39;&#xA;import { INCREMENT } from &#39;./mutation-type&#39;&#xA;&#xA;const store = new Vuex.Store({&#xA;    state: {...},&#xA;    mutations: {&#xA;        [INCREMENT] (state) {&#xA;            // mutate 状态&#xA;        }&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当一个组件需要使用多个 store 状态属性时，将这些状态都声明为计算属性就会有些重复和冗余&#xA;// 为了解决这个问题，可以使用 mapState 辅助函数帮助我们生成计算属性 ...&#xA;&#xA;// 例如：&#xA;&#xA;// 在 store/index.js 定义：&#xA;const store = new Vuex.Store({&#xA;    state: {&#xA;        count: 0,&#xA;        message: &#39;Vue.js 从入门到实战&#39;,&#xA;    },&#xA;    ...&#xA;})&#xA;&#xA;// Hello.vue 组件中使用 mapState 辅助函数生成计算属性&#xA;import { mapMutations, mapState } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;    computed: mapState({&#xA;        // 冒号前是计算属性名字，后是 store 中状态属性的名字 &#xA;        count: &#39;count&#39;,&#xA;        msg: &#39;message&#39;,&#xA;    })&#xA;}&#xA;&#xA;// 注意：上面代码等价于下面代码&#xA;import { mapMutations } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;    computed: mapState({&#xA;        count: function(state) {&#xA;            return state.count;&#xA;        },&#xA;        msg: (state) =&amp;gt; state.message;&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意：如果在计算属性中还要访问组件内的数据属性，那么就只能使用普通函数的方式&#xA;&amp;lt;script&amp;gt;&#xA;import { mapMutations, mapState } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      price: 99,&#xA;    };&#xA;  },&#xA;  computed: mapState({&#xA;    count: function (state) { &#xA;      return state.count + this.price;&#xA;    },&#xA;  }),&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 注意：之前介绍的写法是这样的 ...&#xA;&amp;lt;script&amp;gt;&#xA;import { mapMutations, mapState } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      price: 99,&#xA;    };&#xA;  },&#xA;  computed: {&#xA;     count() {&#xA;       return this.$store.state.count + this.price;&#xA;     },&#xA;   },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果计算属性的名字和store中状态属性的名字相同&#xA;// 那么还可以进一步简化，直接给 mapState 函数传递一个字符串数组即可&#xA;&#xA;computed: mapState({&#xA;    // 映射 this.count 为 store.state.count&#xA;    &#39;count&#39;,&#xA;    // 映射 this.message 为 store.state.message&#xA;    &#39;message&#39;,&#xA;})&#xA;&#xA;// 注意：之前介绍的写法是这样 ...&#xA;import { mapMutations, mapState } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;    computed: mapState({&#xA;        // 冒号前是计算属性名字，后是 store 中状态属性的名字 &#xA;        count: &#39;count&#39;,&#xA;        msg: &#39;message&#39;,&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 与 mapMutations 一样，mapState 函数返回的也是一个对象&#xA;// 因此可以使用展开运算符将它和组件内的本地计算属性结合一起使用&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;aaa&amp;quot;&amp;gt;You click me \{{ count }} times.&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { mapMutations, mapState } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      price: 99,&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    ...mapState({&#xA;      count: &amp;quot;count&amp;quot;,&#xA;    }),&#xA;  },&#xA;  methods: {&#xA;    ...mapMutations([&amp;quot;aaa&amp;quot;]),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// getter &#xA;&#xA;// 假如在 store 的状态中定义了一个图书数组&#xA;// 在组件内需要得到正在销售的图书，于是定义了一个计算属性 sellingBooks &#xA;// 对 state 中的 books 进行过滤 ...&#xA;&#xA;// store/index.js&#xA;...&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    books: [&#xA;      { id: 1, title: &#39;Vue.js 从入门到实战&#39;, isSold: false },&#xA;      { id: 2, title: &#39;VC++ 深入详解&#39;, isSold: true },&#xA;      { id: 3, title: &#39;Servlet/JSP 深入详解&#39;, isSold: true }&#xA;    ]&#xA;  },&#xA;  ...&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    sellingBooks() {&#xA;      return this.$store.state.books.filter((book) =&amp;gt; book.isSold === true);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 这没有什么问题，但如果多个组件都需要用到 sellingBooks 属性，那么应该怎么办呢？&#xA;&#xA;Vuex 允许我们在 store 中定义 getters (可以认为是 store 的计算属性) &#xA;// 与计算属性一样，getters 的返回值会根据它的依赖项被缓存起来&#xA;// 且只有在它的依赖项发生改变时才会重新计算 ...&#xA;&#xA;// store/index.js&#xA;... &#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    books: [&#xA;      { id: 1, title: &#39;Vue.js 从入门到实战&#39;, isSold: false },&#xA;      { id: 2, title: &#39;VC++ 深入详解&#39;, isSold: true },&#xA;      { id: 3, title: &#39;Servlet/JSP 深入详解&#39;, isSold: true }&#xA;    ]&#xA;  },&#xA;  getters: {&#xA;    sellingBooks(state) {&#xA;      return state.books.filter(book =&amp;gt; book.isSold === true)&#xA;    }&#xA;  }&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in this.$store.getters.sellingBooks&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        \{{ book.title }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果想简化上述 getter 在计算属性中的访问形式，可以使用 MapGetters 辅助函数&#xA;// 这个辅助函数的用法和 mapMutations、mapState 类似 ...&#xA;&#xA;// 例如:&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in sellingBooks&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        \{{ book.title }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { mapGetters } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  computed: {&#xA;    // 计算属性与 store 类型属性同名时使用数组作为参数&#xA;    ...mapGetters([&amp;quot;sellingBooks&amp;quot;]),&#xA;    // 将 this.sellingBooks() 映射为 this.$store.getters.sellingBooks()&#xA;    ...mapGetters({&#xA;      sellingBooks: &amp;quot;sellingBooks&amp;quot;,&#xA;    }),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// getter 还有更灵活的用法，通过让 getter 返回一个函数，来实现给 getter 传参&#xA;getters: {&#xA;    ...&#xA;    getBookById: function(state) {&#xA;        return function(id) {&#xA;            return state.books.find(book =&amp;gt; book.id === id);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&amp;lt;p&amp;gt;\{{$store.getters.getBookById(2)}}&amp;lt;/p&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在定义 mutation 时，有一条重要的原则就是 mutation 必须是同步函数&#xA;// 换句话说，在 mutation 处理函数中，不能存在异步调用 ...&#xA;&#xA;// 如果确实需要执行异步操作，那么应该使用 action &#xA;// action 类似于 mutation 不同之处在于：&#xA;// 1. action 提交的是 mutation 而不是直接变更状态&#xA;// 2. action 可以包含任意异步操作 ...&#xA;&#xA;const store = new Vuex.Store({&#xA;    state: {&#xA;        count: 0,&#xA;    },&#xA;    mutations: {&#xA;        increment (state) {&#xA;            state.count++;&#xA;        }&#xA;    },&#xA;    actions: {&#xA;        increment (context) {&#xA;            context.commit(&#39;increment&#39;);&#xA;        }&#xA;    }&#xA;})&#xA;&#xA;// action 处理函数接收一个与 store 实例具有相同方法和属性的 context 对象&#xA;// 因此可以利用该对象调用 commit 方法来提交 mutation ... &#xA;// 或者通过 context.state 和 context.getters 来访问 state 和 getter&#xA;// 设置可以用 context.dispatch 调用其他的 action &#xA;// 要注意的是：context 对象不是 store 实例本身 ...&#xA;&#xA;// action 同样支持载荷和对象方式进行分发&#xA;store.dispatch(&#39;incrementAsync&#39;, 10);&#xA;store.dispatch(&#39;incrementAsync&#39;, {&#xA;    amount: 10,&#xA;})&#xA;store.dispatch({&#xA;    type: &#39;incrementAsync&#39;,&#xA;    amount: 10,&#xA;})&#xA;&#xA;// 例子：&#xA;&#xA;// store/index.js&#xA;...&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    books: [&#xA;      { id: 1, title: &#39;Vue.js 从入门到实战&#39;, isSold: false },&#xA;      { id: 2, title: &#39;VC++ 深入详解&#39;, isSold: true },&#xA;      { id: 3, title: &#39;Servlet/JSP 深入详解&#39;, isSold: true }&#xA;    ]&#xA;  },&#xA;  mutations: {&#xA;    add(state, book) {&#xA;      this.state.books.push(book)&#xA;    }&#xA;  },&#xA;  actions: {&#xA;    add(context, book) {&#xA;      let item = context.state.books.find(item =&amp;gt; item.id === book.id)&#xA;      if (!item) {&#xA;        context.commit(&#39;add&#39;, book)&#xA;      }&#xA;    }&#xA;  },&#xA;  getters: {&#xA;    sellingBooks(state) {&#xA;      return state.books.filter(book =&amp;gt; book.isSold === true)&#xA;    }&#xA;  }&#xA;})&#xA;...&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in sellingBooks&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        \{{ book.title }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt;添加&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { mapGetters } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  methods: {&#xA;    add() {&#xA;      // action 通过 store.dispatch 方法触发&#xA;      this.$store.dispatch(&amp;quot;add&amp;quot;, {&#xA;        id: 4,&#xA;        title: &amp;quot;努力加贝学习笔记&amp;quot;,&#xA;        isSold: true,&#xA;      });&#xA;    },&#xA;  },&#xA;  computed: {&#xA;    ...mapGetters([&amp;quot;sellingBooks&amp;quot;]),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// action 支持 mapActions 辅助函数将组建的方法映射为 store.dispatch 调用&#xA;&#xA;// store/index.js&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    books: [&#xA;      { id: 1, title: &#39;Vue.js 从入门到实战&#39;, isSold: false },&#xA;      { id: 2, title: &#39;VC++ 深入详解&#39;, isSold: true },&#xA;      { id: 3, title: &#39;Servlet/JSP 深入详解&#39;, isSold: true }&#xA;    ]&#xA;  },&#xA;  mutations: {&#xA;    add(state, book) {&#xA;      this.state.books.push(book)&#xA;    }&#xA;  },&#xA;  actions: {&#xA;    add(context, book) {&#xA;      let item = context.state.books.find(item =&amp;gt; item.id === book.id)&#xA;      if (!item) {&#xA;        context.commit(&#39;add&#39;, book)&#xA;      }&#xA;    }&#xA;  },&#xA;  modules: {&#xA;  },&#xA;  getters: {&#xA;    sellingBooks(state) {&#xA;      return state.books.filter(book =&amp;gt; book.isSold === true)&#xA;    },&#xA;  }&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in sellingBooks&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        \{{ book.title }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;add(book)&amp;quot;&amp;gt;添加&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { mapGetters, mapActions } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      book: {&#xA;        id: 4,&#xA;        title: &amp;quot;努力加贝学习笔记&amp;quot;,&#xA;        isSold: true,&#xA;      },&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    ...mapActions([&amp;quot;add&amp;quot;]),&#xA;  },&#xA;  computed: {&#xA;    ...mapGetters([&amp;quot;sellingBooks&amp;quot;]),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise&#xA;// 并且 store.dispatch 仍旧返回 Promise ...&#xA;&#xA;// Promise是什么？&#xA;// Promise 意在让异步代码变得干净和直观，让异步代码变得井然有序。&#xA;// Promise在设计上具有原子性，即只有三种状态：&#xA;//      等待（Pending）、成功（Fulfilled）、失败（Rejected）&#xA;// 在调用支持Promise的异步方法时，逻辑变得非常简单，在大规模的软件工程开发中具有良好的健壮性。&#xA;&#xA;// 创建Promise对象：&#xA;// 要想给一个函数赋予Promise能力，就要先创建一个Promise对象，并将其作为函数值返回。&#xA;// Promise对象要求传入一个函数，并带有resolve和reject参数。&#xA;// 这是两个用于结束Promise等待的函数，对应的状态分别是成功和失败。&#xA;&#xA;&#xA;// store/index.js&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    books: [&#xA;      { id: 1, title: &#39;Vue.js 从入门到实战&#39;, isSold: false },&#xA;      { id: 2, title: &#39;VC++ 深入详解&#39;, isSold: true },&#xA;      { id: 3, title: &#39;Servlet/JSP 深入详解&#39;, isSold: true }&#xA;    ]&#xA;  },&#xA;  mutations: {&#xA;    add(state, book) {&#xA;      this.state.books.push(book)&#xA;    }&#xA;  },&#xA;  actions: {&#xA;    add(context, book) {&#xA;      return new Promise((resolve) =&amp;gt; {&#xA;        let item = context.state.books.find(item =&amp;gt; item.id === book.id)&#xA;        if (!item) {&#xA;          context.commit(&#39;add&#39;, book)&#xA;        }&#xA;        resolve();&#xA;      })&#xA;    }&#xA;  },&#xA;  modules: {&#xA;  },&#xA;  getters: {&#xA;    sellingBooks(state) {&#xA;      return state.books.filter(book =&amp;gt; book.isSold === true)&#xA;    },&#xA;  }&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in sellingBooks&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        \{{ book.title }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;add(book)&amp;quot;&amp;gt;添加&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { mapGetters } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      book: {&#xA;        id: 4,&#xA;        title: &amp;quot;努力加贝学习笔记&amp;quot;,&#xA;        isSold: true,&#xA;      },&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    add() {&#xA;      // 在执行完成后输出成功 ...&#xA;      this.$store&#xA;        .dispatch(&amp;quot;add&amp;quot;, {&#xA;          id: 4,&#xA;          title: &amp;quot;努力加贝学习笔记&amp;quot;,&#xA;          isSold: true,&#xA;        })&#xA;        .then(() =&amp;gt; {&#xA;          console.log(&amp;quot;add data success&amp;quot;);&#xA;        });&#xA;    },&#xA;  },&#xA;  computed: {&#xA;    ...mapGetters([&amp;quot;sellingBooks&amp;quot;]),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果使用 async/await 则可以按如下方式组合 action &#xA;&#xA;// 假设 getData() 和 getOtherData() 返回的是 Promise &#xA;actions: {&#xA;    async actionA({ commit }) {&#xA;        commit(&#39;gotData&#39;, await getData())&#xA;    },&#xA;    async actionB({ dispatch, commit }) {&#xA;        await dispatch(&#39;actionA&#39;) // 等待 actionA 完成&#xA;        commit(&#39;gotOtherData&#39;, await getOtherData())&#xA;    }&#xA;}&#xA;&#xA;// 一个 store.dispatch 在不同模块中可以触发多个 action 处理函数&#xA;// 在这种情况下，只有当所有触发的处理函数完成后，返回的 Promise 才会执行&#xA;&#xA;// 提示：async/await 是 ECMAScript 2017 标准引入的用于执行异步任务的简化语法&#xA;// 在函数前面添加关键字 async 表示该函数将以异步模式运行 ...&#xA;// 关键字 await 在 async 函数内部使用，表示紧跟在后面的表达式需要等待结果 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;表单处理&#xA;&#xA;// 在表单控件上使用 v-model 指令来进行绑定数据，需要自定义 get 与 set ...&#xA;&#xA;// store/index.js&#xA;...&#xA;export default new Vuex.Store({&#xA;  state: {&#xA;    message: &#39;&#39;&#xA;  },&#xA;  mutations: {&#xA;    updateMessage(state, msg) {&#xA;      state.message = msg&#xA;    }&#xA;  },&#xA;  ...&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input tyoe=&amp;quot;text&amp;quot; v-model=&amp;quot;message&amp;quot; /&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ message }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  computed: {&#xA;    message: {&#xA;      get() {&#xA;        return this.$store.state.message;&#xA;      },&#xA;      set(value) {&#xA;        this.$store.commit(&amp;quot;updateMessage&amp;quot;, value);&#xA;      },&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Vuex 使用单一状态树，应用程序的所有状态都包含在一个大的对象中&#xA;// 当应用程序变得复杂时 store 对象就会变得非常臃肿 ...&#xA;&#xA;为了解决这个问题，Vuex 允许将 store 划分为多个模块=&#xA;// 每个模块可以包含自己的 state、mutations、actions、getters 以及嵌套的子模块&#xA;&#xA;// store/modules/cart.js&#xA;const cart = &#xA;{&#xA;    state: { ... },&#xA;    mutation: { ... },&#xA;    actions: { ... },&#xA;    getters: { ... }&#xA;}&#xA;&#xA;// store/index.js&#xA;...&#xA;import cart from &#39;./modules/cart&#39;&#xA;export default new Vuex.Store({&#xA;  modules: {&#xA;    cart&#xA;  }&#xA;})&#xA;...&#xA;&#xA;// 项目中对应的映射需要以下方式访问 ...&#xA;store.state.cart // -&amp;gt; cart 的状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;默认情况下，模块内部的 actions、mutations、getters 是注册在全局命名空间下的&#xA;// 这使得多个模块能够对同一个 mutations 或 actions 做出响应 ...&#xA;&#xA;如果希望模块具有更高的封装度和复用性，则可以通过添加 &#xA;// namespaced: true 的方式使其成为带命名空间的模块 ...&#xA;&#xA;注意：当模块被注册后 ...&#xA;// 它的所有 mutations、actions 和 getters 都会根据模块注册的路径自动命名&#xA;&#xA;// store/modules/cart.js&#xA;const state = {&#xA;    count: 0&#xA;};&#xA;const mutations = {&#xA;    add(state) {&#xA;        state.count += 1&#xA;    }&#xA;};&#xA;const actions = {&#xA;&#xA;};&#xA;const getters = {&#xA;&#xA;};&#xA;&#xA;export default {&#xA;    namespaced: true,&#xA;    state,&#xA;    mutations,&#xA;    actions,&#xA;    getters&#xA;}&#xA;&#xA;// store/index.js&#xA;import Vue from &#39;vue&#39;&#xA;import Vuex from &#39;vuex&#39;&#xA;&#xA;Vue.use(Vuex)&#xA;import cart from &#39;./modules/cart&#39;&#xA;export default new Vuex.Store({&#xA;  modules: {&#xA;    cart&#xA;  }&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;aaa&amp;quot;&amp;gt;You click me \{{ count }} times.&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { mapState } from &amp;quot;vuex&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    ...mapState(&#39;cart&#39;, [&#39;count&#39;]),&#xA;  },&#xA;  methods: {&#xA;    ...mapMutations([&amp;quot;add&amp;quot;]),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。&#xA;// 它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数&#xA;&#xA;// store/modules/cart.js&#xA;const state = {&#xA;    count: 0&#xA;};&#xA;const mutations = {&#xA;    add(state) {&#xA;        state.count += 1&#xA;    }&#xA;};&#xA;const actions = {&#xA;&#xA;};&#xA;const getters = {&#xA;&#xA;};&#xA;&#xA;export default {&#xA;    namespaced: true,&#xA;    state,&#xA;    mutations,&#xA;    actions,&#xA;    getters&#xA;}&#xA;&#xA;// store/index.js&#xA;import Vue from &#39;vue&#39;&#xA;import Vuex from &#39;vuex&#39;&#xA;&#xA;Vue.use(Vuex)&#xA;import cart from &#39;./modules/cart&#39;&#xA;export default new Vuex.Store({&#xA;  modules: {&#xA;    cart&#xA;  }&#xA;})&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt;You click me \{{ count }} times.&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import { createNamespacedHelpers } from &amp;quot;vuex&amp;quot;;&#xA;const { mapMutations, mapState } = createNamespacedHelpers(&amp;quot;cart&amp;quot;);&#xA;export default {&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  computed: {&#xA;    ...mapState([&amp;quot;count&amp;quot;]),&#xA;  },&#xA;  methods: {&#xA;    ...mapMutations([&amp;quot;add&amp;quot;]),&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Vue.js之使用axios与服务器通信</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8B%E4%BD%BF%E7%94%A8axios%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1/</link>
      <pubDate>2020-11-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue.js之使用axios与服务器通信&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用 NPM 安装 axios&#xA;// npm install axios&#xA;&#xA;在 Vue Cli 项目中使用，可以在 main.js 文件中导入 axios &#xA;// import Vue from &#39;vue&#39;&#xA;// import axios from &#39;axios&#39;&#xA;// Vue.prototype.$axios = axios;&#xA;// 之后在组件内就可以通过this.$axios来调用axios的方法发送请求&#xA;&#xA;此外，还可以将 axios 结合 vue-axios 插件一起使用&#xA;// npm install axios vue-axios&#xA;&#xA;安装了 vue-axios 插件之后，就不需要将 axios 绑定到 Vue 的原型链上了&#xA;// import Vue from &#39;vue&#39;&#xA;// import axios from &#39;axios&#39;&#xA;// import VueAxios from &#39;vue-axios&#39;&#xA;// Vue.use(VueAxios, axios) // 安装插件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// HTTP 最基本的请求就是 Get 和 Post 请求&#xA;&#xA;Get 和 Post 方法的原型如下：&#xA;get(url[, config])&#xA;post(url[, data[, config]])&#xA;&#xA;// 使用 axios 发送 Get 请求调用形式如下：&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;this.axios&#xA;  .get(&amp;quot;/book?id=1&amp;quot;)&#xA;  .then(function (response) {&#xA;    console.log(response);&#xA;  })&#xA;  .catch(function (error) {&#xA;    console.log(error);&#xA;  });&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 可以给 Get 方法传递一个配置对象作为参数&#xA;this.axios&#xA;  .get(&amp;quot;/book&amp;quot;, {&#xA;    params: {&#xA;      id: 1,&#xA;    },&#xA;  })&#xA;  .then(function (response) {&#xA;    console.log(response);&#xA;  })&#xA;  .catch(function (error) {&#xA;    console.log(error);&#xA;  });&#xA;&#xA;// 使用 axios 发送 Post 请求调用形式如下：&#xA;this.axios&#xA;  .post(&amp;quot;/login&amp;quot;, {&#xA;    username: &amp;quot;nulijiabei&amp;quot;,&#xA;    password: &amp;quot;1234&amp;quot;,&#xA;  })&#xA;  .then(function (response) {&#xA;    console.log(response);&#xA;  })&#xA;  .catch(function (error) {&#xA;    console.log(error);&#xA;  });   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 接收到服务器的响应信息后，需要对响应信息进行处理&#xA;// 回到函数 response 是一个对象，该对象常用的属性是 &#xA;// 1. data 用于获取服务器端发回的响应数据&#xA;// 2. status 是服务器端发送的 HTTP 状态代码&#xA;&#xA;// response 对象的完整属性如下：&#xA;&#xA;1. data: {} // 是服务器发回的响应数据&#xA;2. status 200 // 是服务器响应的 HTTP 状态代码&#xA;3. statusText: &#39;OK&#39; // 是服务器响应的HTTP状态描述&#xA;4. headers:{} // 是服务器响应的消息报头&#xA;5. config: {} // 是为请求提供的配置信息&#xA;6. request: {} // 是生成此响应的请求&#xA;&#xA;// 成功响应后，获取数据的一般处理形式如下：&#xA;this.axios&#xA;  .get(&amp;quot;/book?id=1&amp;quot;)&#xA;  .then(function (response) {&#xA;    if (response.status === 200) {&#xA;      console.log(response);&#xA;      this.book = response.data;&#xA;    }&#xA;  })&#xA;  .catch(function (error) {&#xA;    console.log(error);&#xA;  });&#xA;&#xA;// 如果出现错误，则会调用 catch 方法回调，并向该回调传递一个错误对象&#xA;.catch(function (error) {&#xA;    if (error.response) {&#xA;      // 请求已经发送并接收服务器响应，但状态码不是 2XX&#xA;      console.log(error.response.data);&#xA;      console.log(error.response.status);&#xA;      console.log(error.response.headers);&#xA;    } else if (error.request) {&#xA;      // 请求已经发送，但是未收到相应&#xA;      console.log(error.request);&#xA;    } else {&#xA;      // 在设置请求时出现问题而引发错误&#xA;      console.log(&amp;quot;Error&amp;quot;, error.message);&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;axios API&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;可以通过 axios 传递相关配置来创建请求，axios 原型如下：&#xA;// axios(config)&#xA;// axios(url[, config])&#xA;&#xA;Get 和 Post 请求的调用形式如下：&#xA;&#xA;// 发送 Get 请求&#xA;axios(&#39;/book?id=1&#39;)&#xA;&#xA;// Get 请求，获取远端图片&#xA;this.axios({&#xA;  method: &amp;quot;get&amp;quot;,&#xA;  url: &amp;quot;/images/logo.png&amp;quot;,&#xA;  responseType: &amp;quot;stream&amp;quot;,&#xA;}).then(function (response) {&#xA;  response.data.pipe(fs.createWriteStream(&amp;quot;logo.png&amp;quot;));&#xA;});&#xA;&#xA;// 发送 Post 请求&#xA;axios({&#xA;    method: &#39;post&#39;,&#xA;    url: &#39;login&#39;,&#xA;    data: {&#xA;        username: &#39;nulijiabei&#39;,&#xA;        password: &#39;1234,&#xA;    }&#xA;});&#xA;&#xA;为了方便使用，axios 库为所有支持的请求方法提供了别名：&#xA;&#xA;// axios.request(config)&#xA;// axios.get(url[, config])&#xA;// axios.delete(url[, config])&#xA;// axios.head(url[, config])&#xA;// axios.options(url[, config])&#xA;// axios.post(url[, config])&#xA;// axios.put(url[, config])&#xA;// axios.patch(url[, config])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;axios 库为请求提供了配置对象，该对象中可以设置很多选项&#xA;&#xA;{&#xA;    // 是用于请求的服务器地址&#xA;    url: &#39;/book&#39;, &#xA;&#xA;    // 是发起请求时使用的请求方法&#xA;    method: &#39;get&#39;, &#xA;&#xA;    // baseURL 将自动加载 url 前面，除非 url 是一个绝对 URL&#xA;    // 为 axios 实例设置一个 baseURL，就可以将相对 URL 传递给该示例的方法&#xA;    baseURL: &#39;https://some-domain.com/api/&#39;,&#xA;&#xA;    // 允许将请求数据发送到服务器前对其进行修改&#xA;    // 只能用于 PUT、POST、PATCH 这几个请求方法&#xA;    // 数组中的函数必须返回一个字符串、Buffer的实例、ArrayBuffer、FormData、Stream&#xA;    transformRequest: [function (data) {&#xA;        // 对 data 进行任意转换处理&#xA;        return data;&#xA;    }],&#xA;&#xA;    // 允许在将相应数据传递给 then/catch 之前对其进行更改&#xA;    transformResponse: [function (data) {&#xA;        // 对 data 进行任意转换处理&#xA;        return data;&#xA;    }],&#xA;&#xA;    // 是要发送的自定义请求头&#xA;    header: { &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39; },&#xA;&#xA;    // 是与请求一起发送的 URL 参数&#xA;    // 必须是一个普通对象(plain object)或URLSearchParams对象&#xA;    params: { ID: 1 },&#xA;&#xA;    // 是一个负责 params 序列化的可选函数&#xA;    paramsSerializer: function(params) {&#xA;        return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;})&#xA;    },&#xA;&#xA;    // 是作为请求体被发送的数据&#xA;    // 只适用于请求放松 PUT、POST、PATCH&#xA;    // 在没有设置 transformRequest 时，必须是以下类型之一：&#xA;    // - string、plain object、ArrayBuffer、ArrayBufferView、URLSearchParams&#xA;    // - 浏览器专属：FromData、File、Blob&#xA;    // - Node 专属：Stream&#xA;    data: { firstName: &#39;Fred&#39; },&#xA;&#xA;    // 指定请求超时的毫秒数，默认是0，标识无超时时间&#xA;    // 如果请求耗费的时间超时了，则请求被终止&#xA;    timeout: 1000,&#xA;&#xA;    // 标识跨域请求时是否需要使用凭证&#xA;    withCredentials: false,&#xA;&#xA;    // 允许自定义处理请求，以使测试更加容易&#xA;    // 返回一个 promise 并提供一个有效的响应&#xA;    adapter: function (config) {&#xA;    },&#xA;&#xA;    // 标识用该使用HTTPS基础验证，并提供凭据&#xA;    // 这将设置一个 Authorization 报头，覆盖使用 headers 设置的现有的 Authorization 自定义报头&#xA;    // auth: {&#xA;        username: &#39;janedoe&#39;,&#xA;        password: &#39;s00pers3cret&#39;,&#xA;    },&#xA;&#xA;    // 标识服务器响应的数据类型&#xA;    // 可以是 arraybuffer、blob、document、json、text、stream&#xA;    responseType: &#39;json&#39;, &#xA;&#xA;    // 表示用于解码响应数据的编码&#xA;    // 注意：对于 stream 相应类型，将忽略&#xA;    responseEncoding: &#39;utf8&#39;,&#xA;&#xA;    // 是用作 xsrf token 值的 cookie 的名称&#xA;    xsrfCookieName: &#39;XSRF-TOKEN&#39;, &#xA;&#xA;    // 是携带 xsrf token 值的 http 报头的名字&#xA;    xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, &#xA;&#xA;    // 允许为上传处理进度事件&#xA;    onUploadProgress: function (progressEvent) {&#xA;        // 对原生进度事件的处理&#xA;    },&#xA;&#xA;    // 允许为下载处理进度事件&#xA;    onDownloadProgress: function (progressEvent) {&#xA;        // 对原生进度事件的处理&#xA;    },&#xA;&#xA;    // 定义允许的响应内容的最大大小(以字节为单位)&#xA;    maxContentLength: 2000,&#xA;&#xA;    // 定义对于给定的HTTP响应状态码是解析(resolve)还是决绝(reject)这个promise&#xA;    // 如果 validateStatus 返回 true (或者设置为null或undefined)&#xA;    // promise 将被解析(resolve), 否则, promise 将被拒绝(reject)&#xA;    // validateStatus: function(status) {&#xA;        return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300;&#xA;    },&#xA;&#xA;    // 定义在 node.js 中 follow 的最大重定向数目&#xA;    // 如果设置为0，将不会follow任何重定向&#xA;    maxRedirects: 5,&#xA;&#xA;    // 定义要在 node.js 中使用的 UNIX 套接字&#xA;    // 例如：&#39;/var/run/docker.sock&#39; 向 docker 守护进程发送请求&#xA;    // 只能指定 socketPath 或 proxy, 如果两者都指定，则使用 socketPath&#xA;    socketPath: null,&#xA;&#xA;    // 用于定义在 node.js 执行 http 和 https 时要使用的自定义代理&#xA;    // 用于配置类似 keepAlive 的选项，keepAlive 默认没有启用&#xA;    httpAgent: new http.Agent({ keepAlive: true }),&#xA;    httpsAgent: new https.Agent({ keepAlive: true }),&#xA;&#xA;    // proxy 定义代理服务器的主机名和端口&#xA;    // auth 标识 HTTP 基础验证应当于连接代理，并提供凭证&#xA;    // 这将会设置一个 Proxy-Authorization 报头&#xA;    // 覆盖使用 headers 设置的任何现有的自定义 Proxy-Authorization 报头&#xA;    proxy: {&#xA;        host: &#39;127.0.0.1&#39;,&#xA;        port: 9000,&#xA;        auth: {&#xA;            username: &#39;mikeymike&#39;,&#xA;            password: &#39;rapunz31&#39;,&#xA;        },&#xA;    },&#xA;&#xA;    // 指定用于取消请求的 cancel token&#xA;    cancelToken: new CancelToken(function (cancel) {&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;并发请求&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;有时需要同时向服务端发起多个请求，这可以利用 axios 库提供的并发请求助手函数来实现&#xA;&#xA;axios.all(iterable)&#xA;axios.spread(callback)&#xA;&#xA;例如:&#xA;&#xA;function getUserAccount() {&#xA;    return axios.get(&#39;/user/12345&#39;);&#xA;}&#xA;&#xA;function getUserPermissions() {&#xA;    return axios.get(&#39;/user/12345/permissions&#39;);&#xA;}&#xA;&#xA;axios.all([getUserAccount(), getUserPermissions()])&#xA;.then(axios.spread(function (acct, perms) {&#xA;    // 两个请求现在都执行完成&#xA;    // acct 是 getUserAccount() 方法请求的响应结果&#xA;    // perms 是 getUserPermissions() 方法请求的响应结果&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;创建实例&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以使用自定义配置调用 axios.create([config]) 方法来创建一个 axios 实例&#xA;// 之后使用该实例向服务端发起请求，就不用每次请求时重复设置配置选项了&#xA;&#xA;const instance = axios.create({&#xA;    baseUrl: &#39;https://some-domain.com/api/&#39;,&#xA;    timeout: 1000,&#xA;    headers: { &#39;X-Custom-Header&#39;: &#39;foobar&#39; }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;配置默认值&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 对于每次请求相同的配置选项，可以通过为配置选项设置默认值来简化代码的编写。&#xA;// 项目中用到的全局axios默认值可以在项目入口文件main.js中按照如下形式进行设置&#xA;&#xA;axios.defaults.baseUrl = &amp;quot;Https://api.example.com&#39;;&#xA;axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;&#xA;axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;&#xA;axios.defaults.withCredentials = true&#xA;&#xA;// 也可以在定义实例中设置配置默认值，这些配置选项只有在使用该实例发起请求时才生效&#xA;&#xA;// 创建实例时设置配置默认值&#xA;const instance = axios.create({&#xA;    baseUrl: &#39;https://api.example.com&#39;&#xA;});&#xA;&#xA;// 实例创建后设置配置默认值&#xA;instance.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;&#xA;&#xA;// 配置将按优先顺序进行合并&#xA;// 1. 优先 lib/defaults.js 中设置库的默认值&#xA;// 2. 然后是实例的 defaults 属性&#xA;// 3. 最后是请求的 config 参数&#xA;&#xA;// 此时配置中，超时配置的默认值是：0&#xA;var instance = axios.create(); &#xA;&#xA;// 覆写库的超时默认值&#xA;// 现在，在超时前，使用该实例发起的所有请求都会等待 2.5s&#xA;instance.defaults.timeout = 2500;&#xA;&#xA;// 在发起请求时，覆写超时值&#xA;instance.get(&#39;/longRequest&#39;, {&#xA;    timeout: 5000,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;拦截器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 有时需要统一处理 HTTP 的请求和响应，例如登录验证，这时就可以使用 axios 的拦截器&#xA;// 分为请求拦截器和响应拦截器，他们会在请求或响应被then或catch处理前拦截它们 ...&#xA;&#xA;// axios 拦截器的使用形式如下：&#xA;&#xA;// 添加请求拦截器&#xA;axios.interceptors.request.use(function (config) {&#xA;    // 在发送请求之前做些什么&#xA;    return config;&#xA;}, function (error) {&#xA;    // 对请求错误做些什么&#xA;    return Promise.reject(error);&#xA;});&#xA;&#xA;// 添加响应拦截器&#xA;axios.interceptors.response.use(function (response) {&#xA;    // 对响应数据做点什么&#xA;    return response;&#xA;}, function (error) {&#xA;    // 对响应错误做点什么&#xA;    return Promise.reject(error);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 之前有例子使用全局守卫实现了一个用户登录验证的例子。&#xA;// 不过这种方式只是简单的前端路由控制，用户一旦登录成功&#xA;// 前端就保存了登录状态，允许用户访问受保护的资源 ...&#xA;&#xA;// 如果在这期间，该用户在服务端失效了&#xA;// 例如：用户长时间未操作，服务端强制下线了，又或者管理员将用户来如黑名单&#xA;// 那么，前端就应该及时更新用户的状态，对用户的后续访问做出控制。&#xA;&#xA;// 这种情况下，就应该使用axios的拦截器结合HTTP状态码进行用户是否已登录的判断&#xA;&#xA;// 示例代码：&#xA;&#xA;// 请求拦截器&#xA;axios.interceptors.request.use(&#xA;    config =&amp;gt; {&#xA;        if (token) {&#xA;            // 判断是否存在 token, 如果存在，则每个 http header 都加上 token&#xA;            config.headers.Authorization = `token ${store.state.token}`;&#xA;        }&#xA;        return config;&#xA;    },&#xA;    err =&amp;gt; {&#xA;        return Promise.reject(err);&#xA;});&#xA;&#xA;// 相应拦截器&#xA;axios.interceptors.response.use(&#xA;    response =&amp;gt; {&#xA;        return response;&#xA;    },&#xA;    error =&amp;gt; {&#xA;        if (error.response) {&#xA;            switch (error.response.status) {&#xA;                case 401:&#xA;                    // 返回 401 清除 token 信息并跳转到登录页面&#xA;                    router.replact({&#xA;                        path: &#39;login&#39;,&#xA;                        query: { redirect: router.currentRoute.fullPath }&#xA;                    })&#xA;            }&#xA;        }&#xA;        return Promise.reject(error.response.data);&#xA;});&#xA;&#xA;// 如果之后想移除拦截器，则可以按如下方法来调用&#xA;const myInterceptor = axios.interceptors.request.use(function () { });&#xA;axios.interceptors.request.eject(myInterceptor);&#xA;&#xA;// 也可以为自定义的 axios 实例添加拦截器&#xA;const instance = axios.create();&#xA;instance.interceptors.request.use(function () { });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Vue.js之使用Vue-Router开发单页应用</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8B%E4%BD%BF%E7%94%A8Vue-Router%E5%BC%80%E5%8F%91%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8/</link>
      <pubDate>2020-11-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Vue.js之使用Vue-Router开发单页应用&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;传统的Web应用程序中&#xA;    不同页面间的跳转都是向服务器发起请求，服务器处理请求后向浏览器推送页面&#xA;在单页应用程序中&#xA;    不同视图（组件的模版）的内容都是在同一个页面中渲染，页面间跳转都是在浏览器端完成&#xA;    这就需要用到前端路由，在Vue.js中，可以使用官方的路由管理器Vue Router。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// CDN 方式来引用 Vue Router·&#xA;&amp;lt;script src=&amp;quot;https://unpkg.com/vue-router/dist/vue-router.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&#xA;// 使用模块化开发，则使用NPM安装方式&#xA;npm install vue-router&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;单页应用全屏化&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 Vue 中为 id 属性值为 app 的 div 元素设置样式&#xA;&#xA;// public/index.html&#xA;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;&#xA;&#xA;&amp;lt;head&amp;gt;&#xA;  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&#xA;  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;&#xA;  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0&amp;quot;&amp;gt;&#xA;  &amp;lt;link rel=&amp;quot;icon&amp;quot; href=&amp;quot;&amp;lt;%= BASE_URL %&amp;gt;favicon.ico&amp;quot;&amp;gt;&#xA;  &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&#xA;&amp;lt;body&amp;gt;&#xA;  &amp;lt;noscript&amp;gt;&#xA;    &amp;lt;strong&amp;gt;We&#39;re sorry but &amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt; doesn&#39;t work properly without JavaScript enabled.&#xA;      Please enable it to continue.&amp;lt;/strong&amp;gt;&#xA;  &amp;lt;/noscript&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;  &amp;lt;!-- built files will be auto injected --&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&#xA;&amp;lt;/html&amp;gt;&#xA;&#xA;// App.vue&#xA;&amp;lt;style&amp;gt;&#xA;html,&#xA;body,&#xA;#app {&#xA;  height: 100%;&#xA;  margin: 0;&#xA;  padding: 0;&#xA;}&#xA;&amp;lt;/style&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;HTML 页面使用路由&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 使用 router-link 组件设置导航链接&#xA;// 默认会被渲染为一个&amp;lt;a&amp;gt;标签&#xA;&#xA;&amp;lt;router-link to=&amp;quot;/news&amp;quot;&amp;gt;新闻&amp;lt;/router-link&amp;gt;&#xA;&amp;lt;router-link to=&amp;quot;/books&amp;quot;&amp;gt;图书&amp;lt;/router-link&amp;gt;   &#xA;&amp;lt;router-link to=&amp;quot;/videos&amp;quot;&amp;gt;视频&amp;lt;/router-link&amp;gt;&#xA;&#xA;2. 指定组件在何处渲染，这是通过&amp;lt;router-view&amp;gt;指定的&#xA;&amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;模块化开发使用路由&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 App.vue 中设置导航链接和渲染的位置&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;&#xA;      &amp;lt;router-link to=&amp;quot;/news&amp;quot;&amp;gt;新闻&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link to=&amp;quot;/books&amp;quot;&amp;gt;图书&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link to=&amp;quot;/videos&amp;quot;&amp;gt;视频&amp;lt;/router-link&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;router-view /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 在 components(全局组件) 目录下新建 XXX.vue 文件&#xA;// 在 views(页面级组件) 目录下新建 XXX.vue 文件&#xA;&#xA;// components/News.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;新闻页面&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// components/Books.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;图书页面&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// components/Videos.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;视频页面&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// 在 router/index.js 文件中配置路由信息&#xA;&#xA;import Vue from &#39;vue&#39;&#xA;import VueRouter from &#39;vue-router&#39;&#xA;import News from &#39;@/components/News.vue&#39;&#xA;import Books from &#39;@/components/Books.vue&#39;&#xA;import Videos from &#39;@/components/Videos.vue&#39;&#xA;&#xA;Vue.use(VueRouter)&#xA;&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    component: News&#xA;  },&#xA;  {&#xA;    path: &#39;/books&#39;,&#xA;    component: Books&#xA;  },&#xA;  {&#xA;    path: &#39;/videos&#39;,&#xA;    component: Videos&#xA;  },&#xA;]&#xA;&#xA;const router = new VueRouter({&#xA;  mode: &#39;history&#39;,&#xA;  base: process.env.BASE_URL,&#xA;  routes&#xA;})&#xA;&#xA;export default router&#xA;&#xA;// 在程序入口 main.js 文件中，向 Vue 根实例注入 VueRouter 实例&#xA;&#xA;import Vue from &#39;vue&#39;&#xA;import App from &#39;./App.vue&#39;&#xA;import router from &#39;./router&#39;&#xA;&#xA;Vue.config.productionTip = false&#xA;&#xA;new Vue({&#xA;  router,&#xA;  render: h =&amp;gt; h(App),&#xA;}).$mount(&#39;#app&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;动态路由匹配&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在实际项目开发时，经常需要把匹配某种模式的路由映射到同一个组件&#xA;// 例如有一个Book组件，对于所有ID各不同的图书，都使用这个组件来渲染&#xA;// 这可以使用路段中的动态段来实现&#xA;// 动态段使用冒号(:)标记，如/book/:id，既/book/1、/book/2、/book/foo&#xA;// 都将映射到相同的路由&#xA;// 当匹配到一个路由时，动态的值将被保存到this.$route.params中，可以在组件内使用&#xA;&#xA;// Book.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;图书ID：\{{ $route.params.id }}&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// router/index.js&#xA;...&#xA;import Book from &#39;@/components/Book.vue&#39;&#xA;{&#xA;    path: &#39;/book/:id&#39;,&#xA;    component: BOOK&#xA;}&#xA;...&#xA;&#xA;// App.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;&#xA;      &amp;lt;router-link to=&amp;quot;/book/1&amp;quot;&amp;gt;图书一&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link to=&amp;quot;/book/2&amp;quot;&amp;gt;图书二&amp;lt;/router-link&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;router-view /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;查询参数&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// URL中带有查询参数的形式为/book?id=1，这在传统的Web应用程序中很常见&#xA;// 根据查询参数向服务端请求数据，在单页应用程序开发中，也支持路径中的查询参数&#xA;&#xA;// Book.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;图书ID：\{{ $route.query.id }}&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// router/index.js&#xA;...&#xA;import Book from &#39;@/components/Book.vue&#39;&#xA;{&#xA;    path: &#39;/book&#39;,&#xA;    component: BOOK&#xA;}&#xA;...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;&#xA;      &amp;lt;router-link to=&amp;quot;/book/?id=1&amp;quot;&amp;gt;图书一&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link to=&amp;quot;/book/?id=2&amp;quot;&amp;gt;图书二&amp;lt;/router-link&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;router-view /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;嵌套路由&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在实际的应用场景中，一个界面UI通常由多层嵌套的组件组合而成&#xA;// URL中的各段也按某种结构对应嵌套的各层组件 ...&#xA;&#xA;// 说明：在books组件中嵌套book组件，并使用动态段传递book.id&#xA;&#xA;// 在 assets 目录下新建一个 books.js 文件，里面是图书数据&#xA;&#xA;// assets/books.js&#xA;export default [&#xA;    { id: 1, title: &#39;Vue.js 无难事&#39;, desc: &#39;前端框架经典图书&#39; },&#xA;    { id: 2, title: &#39;VC++ 深入详解&#39;, desc: &#39;畅销10多年的图书&#39; },&#xA;    { id: 3, title: &#39;Servlet/JSP 深入详解&#39;, desc: &#39;经典JSP图书&#39; }&#xA;]&#xA;&#xA;// Books.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;图书列表&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in books&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        &amp;lt;router-link :to=&amp;quot;&#39;/book/&#39; + book.id&amp;quot;&amp;gt;\{{ book.title }}&amp;lt;/router-link&amp;gt;&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;!-- Book 组件在这里渲染 --&amp;gt;&#xA;    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      books: Books,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// router/index.js&#xA;{&#xA;    path: &#39;/books&#39;,&#xA;    component: Books,&#xA;    children: [&#xA;      { path: &#39;/book/:id&#39;, component: Book }&#xA;    ]&#xA;},&#xA;&#xA;// Book.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p&amp;gt;图书ID：\{{ book.id }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;书名：\{{ book.title }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;说明：\{{ book.desc }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      book: {},&#xA;    };&#xA;  },&#xA;  created() {&#xA;    this.book = Books.find((item) =&amp;gt; item.id == this.$route.params.id);&#xA;  },&#xA;  watch: {&#xA;    $route(to) {&#xA;      this.book = Books.find((item) =&amp;gt; item.id == to.params.id);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意：可以使用immediate选项，将监听器函数在开始后立即执行，这样就不需要created钩子了&#xA;watch: {&#xA;    $route: {&#xA;      handler: function (to) {&#xA;        this.book = Books.find((item) =&amp;gt; item.id == to.params.id);&#xA;      },&#xA;      immediate: true,&#xA;    },&#xA;},&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;命名路由&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 有时通过一个名称来标识路由会更方便，特别是在链路到路由，或者是执行导航时。&#xA;// 可以在创建Router实例的时候，在routes选项中为路由设置名称 ...&#xA;&#xA;// router/index.js&#xA;...&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/&#39;,&#xA;    // 重定向，指向目标路径&#xA;    redirect: {&#xA;      name: &#39;news&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    name: &#39;news&#39;,&#xA;    component: News&#xA;  },&#xA;  {&#xA;    path: &#39;/books&#39;,&#xA;    name: &#39;books&#39;,&#xA;    component: Books,&#xA;    children: [&#xA;      { path: &#39;/book/:id&#39;, name: &#39;book&#39;, component: Book }&#xA;    ]&#xA;  },&#xA;]&#xA;...&#xA;&#xA;// App.vue 在设置导航链接时使用命名路由&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;news&#39; }&amp;quot;&amp;gt;新闻&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;books&#39; }&amp;quot;&amp;gt;图书&amp;lt;/router-link&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;router-view /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;// Books.vue 修改 Books.vue 也使用命名路由&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;图书列表&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in books&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        &amp;lt;router-link :to=&amp;quot;{ name: &#39;book&#39;, params: { id: book.id } }&amp;quot;&amp;gt;\{{ book.title }}&amp;lt;/router-link&amp;gt;&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;!-- Book 组件在这里渲染 --&amp;gt;&#xA;    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      books: Books,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;命名视图&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意：有时需要同时(同级)显示多个视图，而不是嵌套展示&#xA;&#xA;// 运行项目，可以看到当单机一个图书链接时，图书的详情在Books同级显示了&#xA;&#xA;// /router/index.js&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/&#39;,&#xA;    redirect: {&#xA;      name: &#39;news&#39;,&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    name: &#39;news&#39;,&#xA;    component: News,&#xA;  },&#xA;  {&#xA;    path: &#39;/books&#39;,&#xA;    name: &#39;books&#39;,&#xA;    component: Books,&#xA;  },&#xA;  {&#xA;    path: &#39;/book/:id&#39;,&#xA;    name: &#39;book&#39;,&#xA;    components: {&#xA;      bookDetail: Book,&#xA;    }&#xA;  },&#xA;]&#xA;&#xA;// App.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;news&#39; }&amp;quot;&amp;gt;新闻&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;books&#39; }&amp;quot;&amp;gt;图书&amp;lt;/router-link&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;router-view /&amp;gt;&#xA;    &amp;lt;router-view name=&amp;quot;bookDetail&amp;quot;&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;// Books.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;图书列表&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in books&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        &amp;lt;router-link :to=&amp;quot;{ name: &#39;book&#39;, params: { id: book.id } }&amp;quot;&amp;gt;\{{&#xA;          book.title&#xA;        }}&amp;lt;/router-link&amp;gt;&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;!-- Book 组件在这里渲染 --&amp;gt;&#xA;    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      books: Books,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// Book.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p&amp;gt;图书ID：\{{ book.id }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;书名：\{{ book.title }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;说明：\{{ book.desc }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      book: {},&#xA;    };&#xA;  },&#xA;  created() {&#xA;    this.book = Books.find((item) =&amp;gt; item.id == this.$route.params.id);&#xA;  },&#xA;  watch: {&#xA;    $route(to) {&#xA;      this.book = Books.find((item) =&amp;gt; item.id == to.params.id);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;编程式导航&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 除了使用&amp;lt;router-link&amp;gt;创建&amp;lt;a&amp;gt;标签来定义导航链接外&#xA;// 还可以使用router的实例方法，通过编写代码来导航&#xA;&#xA;// 要导航到不同的URL，可以使用Router实例的push方法&#xA;router.push(location, onComplete?, onAbort?)&#xA;&#xA;// 字符串&#xA;router.push(&#39;home&#39;)&#xA;// 对象&#xA;router.push({ path: &#39;home&#39; })&#xA;// 命名路由&#xA;router.push({ name: &#39;user&#39;, params: { userId: &#39;123&#39; })&#xA;// 带查询参数，结果是 /register?plan=private&#xA;router.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }})&#xA;&#xA;// App.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;news&#39; }&amp;quot;&amp;gt;新闻&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;books&#39; }&amp;quot;&amp;gt;图书&amp;lt;/router-link&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;router-view /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;// router/index.js&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/&#39;,&#xA;    redirect: {&#xA;      name: &#39;news&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    name: &#39;news&#39;,&#xA;    component: News,&#xA;  },&#xA;  {&#xA;    path: &#39;/books&#39;,&#xA;    name: &#39;books&#39;,&#xA;    component: Books,&#xA;  },&#xA;  {&#xA;    path: &#39;/book/:id&#39;,&#xA;    name: &#39;book&#39;,&#xA;    component: Book,&#xA;  },&#xA;]&#xA;&#xA;// Books.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;图书列表&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in books&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        &amp;lt;a&#xA;          href=&amp;quot;#&amp;quot;&#xA;          @click.prevent=&amp;quot;goRoute({ name: &#39;book&#39;, params: { id: book.id } })&amp;quot;&#xA;          &amp;gt;\{{ book.title }}&#xA;        &amp;lt;/a&amp;gt;&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      books: Books,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    goRoute(location) {&#xA;      if (location.params.id != this.$route.params.id)&#xA;        this.$router.push(location);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// Book.vue&#xA;&amp;lt;template&amp;gt;&#xA;    &amp;lt;div&amp;gt;&#xA;        &amp;lt;p&amp;gt;\{{ this.$route.params.id }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;&#xA;}&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;导航守卫&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 已经介绍过一个组件内的导航守卫：beforeRouteUpdate &#xA;// vue-router 提供的导航守卫主要用于在导航的过程中&#xA;// 重定向或者取消路由，或者添加权限验证、数据获取等业务逻辑&#xA;&#xA;// 导航守卫分为三类：全局守卫、路由独享守卫、组件内守卫&#xA;// 可以用于路由导航过程中的不同阶段 ...&#xA;&#xA;// 每一个导航守卫都有三个参数：to、from、next(除 router.afterEach 外)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;全局守卫&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 全局守卫分为：全局前置守卫、全局解析守卫、全局后置钩子&#xA;&#xA;// 当一个导航触发时，全局前置守卫按照创建的顺序调用。&#xA;// 守卫可以是异步解析执行，此时导航在所有守卫解析完之前一直处于挂起状态&#xA;&#xA;// 1. 全局前置守卫使用 router.beforeEach 注册&#xA;// 2. 全局解析守卫使用 router.beforeResolve 注册&#xA;// 3. 全局后置钩子使用 router.afterEach 注册&#xA;// 3.1 与守卫不同的是，全局后置钩子不接受next函数，也不会改变导航&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;登录验证&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// $router 是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造的对象&#xA;// 这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。&#xA;&#xA;// $route 是一个跳转的路由对象，每一个路由都会有一个route对象&#xA;// 是一个局部的对象，可以获取对应的 name,path,params,query 等&#xA;&#xA;// App.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;div id=&amp;quot;nav&amp;quot;&amp;gt;&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;news&#39; }&amp;quot;&amp;gt;新闻&amp;lt;/router-link&amp;gt; |&#xA;      &amp;lt;router-link :to=&amp;quot;{ name: &#39;login&#39; }&amp;quot;&amp;gt;登录&amp;lt;/router-link&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;router-view /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;// News.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;新闻页面&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// Login.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;\{{ info }}&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;table&amp;gt;&#xA;      &amp;lt;caption&amp;gt;&#xA;        用户登录&#xA;      &amp;lt;/caption&amp;gt;&#xA;      &amp;lt;tbody&amp;gt;&#xA;        &amp;lt;tr&amp;gt;&#xA;          &amp;lt;td&amp;gt;&amp;lt;label&amp;gt;用户名：&amp;lt;/label&amp;gt;&amp;lt;/td&amp;gt;&#xA;          &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model.trim=&amp;quot;username&amp;quot; /&amp;gt;&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tr&amp;gt;&#xA;          &amp;lt;td&amp;gt;&amp;lt;label&amp;gt;密码：&amp;lt;/label&amp;gt;&amp;lt;/td&amp;gt;&#xA;          &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; v-model.trim=&amp;quot;password&amp;quot; /&amp;gt;&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tr&amp;gt;&#xA;          &amp;lt;td cols=&amp;quot;2&amp;quot;&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;登录&amp;quot; @click.prevent=&amp;quot;login&amp;quot; /&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;注销&amp;quot; @click.prevent=&amp;quot;logout&amp;quot; /&amp;gt;&#xA;          &amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;      &amp;lt;/tbody&amp;gt;&#xA;    &amp;lt;/table&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      username: &amp;quot;nulijiabei&amp;quot;,&#xA;      password: &amp;quot;1234&amp;quot;,&#xA;      info: &amp;quot;&amp;quot;,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    logout() {&#xA;      sessionStorage.setItem(&amp;quot;isAuth&amp;quot;, false);&#xA;      this.username = &amp;quot;&amp;quot;;&#xA;      this.password = &amp;quot;&amp;quot;;&#xA;      this.info = &amp;quot;用户名或密码错误&amp;quot;;&#xA;    },&#xA;    login() {&#xA;      if (&amp;quot;nulijiabei&amp;quot; == this.username &amp;amp;&amp;amp; &amp;quot;1234&amp;quot; == this.password) {&#xA;        sessionStorage.setItem(&amp;quot;isAuth&amp;quot;, true);&#xA;        this.info = &amp;quot;&amp;quot;;&#xA;        let queryParam = this.$route.query.redirect;&#xA;        if (queryParam) {&#xA;          this.$router.replace(queryParam);&#xA;        } else {&#xA;          this.$router.replace(&amp;quot;/&amp;quot;);&#xA;        }&#xA;      } else {&#xA;        sessionStorage.setItem(&amp;quot;isAuth&amp;quot;, false);&#xA;        this.username = &amp;quot;&amp;quot;;&#xA;        this.password = &amp;quot;&amp;quot;;&#xA;        this.info = &amp;quot;用户名或密码错误&amp;quot;;&#xA;      }&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// router/index.js&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/&#39;,&#xA;    redirect: {&#xA;      name: &#39;news&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    name: &#39;news&#39;,&#xA;    component: News,&#xA;  },&#xA;  {&#xA;    path: &#39;/books&#39;,&#xA;    name: &#39;books&#39;,&#xA;    component: Books,&#xA;  },&#xA;  {&#xA;    path: &#39;/book/:id&#39;,&#xA;    name: &#39;book&#39;,&#xA;    component: Book,&#xA;  },&#xA;  {&#xA;    path: &#39;/login&#39;,&#xA;    name: &#39;login&#39;,&#xA;    component: Login,&#xA;  },&#xA;]&#xA;&#xA;const router = new VueRouter({&#xA;  mode: &#39;history&#39;,&#xA;  base: process.env.BASE_URL,&#xA;  routes&#xA;})&#xA;&#xA;router.beforeEach((to, from, next) =&amp;gt; {&#xA;  if (to.path == &#39;/login&#39;) {&#xA;    next();&#xA;  } else if (sessionStorage.isAuth === &amp;quot;true&amp;quot;) {&#xA;    next();&#xA;  } else {&#xA;    router.push({&#xA;      name: &#39;login&#39;,&#xA;      query: { redirect: to.fullPath }&#xA;    })&#xA;  }&#xA;})&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;页面标题&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 因为在单页应用程序中，实际只有一个页面，因此在页面切换时，标题不会发生改变&#xA;// 在定义路由时，在routes配置中的每个路由对象都可以使用一个meta字段，在该字段中设置标题&#xA;&#xA;// router/index.js&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/&#39;,&#xA;    redirect: {&#xA;      name: &#39;news&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    name: &#39;news&#39;,&#xA;    component: News,&#xA;    meta: {&#xA;      title: &#39;新闻&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/books&#39;,&#xA;    name: &#39;books&#39;,&#xA;    component: Books,&#xA;    meta: {&#xA;      title: &#39;图书&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/login&#39;,&#xA;    name: &#39;login&#39;,&#xA;    component: Login,&#xA;    meta: {&#xA;      title: &#39;登录&#39;&#xA;    }&#xA;  },&#xA;]&#xA;&#xA;...&#xA;&#xA;router.afterEach((to) =&amp;gt; {&#xA;  document.title = to.meta.title&#xA;})&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;路由独享守卫&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 路由独立的守卫是在routes配置的路由对象中直接定义的beforeEnter守卫&#xA;// 独享守卫只在该组件上生效，在全局前置守卫调用之后，在进入路由组件之间调用&#xA;&#xA;// router/index.js&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    name: &#39;news&#39;,&#xA;    component: News,&#xA;    beforeEach:(to,from,next) =&amp;gt; {&#xA;      // ...&#xA;    }&#xA;    meta: {&#xA;      title: &#39;新闻&#39;&#xA;    }&#xA;  }&#xA;]&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;组件内守卫&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 组件内守卫有三个：beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave&#xA;&#xA;// 注意：beforeRouteEnter 守卫不能访问 this 因为该守卫是在导航确认之前被调用&#xA;// 不过：beforeRouteEnter 有一个特权，就是它的 next 函数支持回调，而其它则不行&#xA;&#xA;// beforeRouteLeave 守卫通常用来防止用户在还未保存修改前突然离开&#xA;// 可以通过next(false)取消导航 ...&#xA;&#xA;// assets/books.js&#xA;export default [&#xA;    { id: 1, title: &#39;Vue.js 无难事&#39;, desc: &#39;前端框架经典图书&#39; },&#xA;    { id: 2, title: &#39;VC++ 深入详解&#39;, desc: &#39;畅销10多年的图书&#39; },&#xA;    { id: 3, title: &#39;Servlet/JSP 深入详解&#39;, desc: &#39;经典JSP图书&#39; }&#xA;]&#xA;&#xA;// Books.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;图书列表&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;book in books&amp;quot; :key=&amp;quot;book.id&amp;quot;&amp;gt;&#xA;        &amp;lt;router-link :to=&amp;quot;&#39;/book/&#39; + book.id&amp;quot;&amp;gt;\{{ book.title }}&amp;lt;/router-link&amp;gt;&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;!-- Book 组件在这里渲染 --&amp;gt;&#xA;    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      books: Books,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// router/index.js&#xA;{&#xA;    path: &#39;/books&#39;,&#xA;    component: Books,&#xA;    children: [&#xA;      { path: &#39;/book/:id&#39;, component: Book }&#xA;    ]&#xA;},&#xA;&#xA;// Book.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p&amp;gt;图书ID：\{{ book.id }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;书名：\{{ book.title }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;说明：\{{ book.desc }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Books from &amp;quot;@/assets/books&amp;quot;;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      book: {},&#xA;    };&#xA;  },&#xA;  beforeRouteEnter(to, form, next) {&#xA;    next((vm) =&amp;gt; {&#xA;      vm.book = Books.find((item) =&amp;gt; item.id == to.params.id);&#xA;    });&#xA;  },&#xA;  beforeRouteUpdate(to, from, next) {&#xA;    this.book = Books.find((item) =&amp;gt; item.id == to.params.id);&#xA;    next();&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;延迟加载路由&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当应用变得复杂后，路由组建也会增多&#xA;// 而Webpack的打包机制会将应用程序中所有 JS 打包成一个文件&#xA;// 这个文件可能相当大，影响页面的加载效率 ...&#xA;// 为此，可以结合Vue的异步组建和Webpack的代码分割功能，实现路由的延迟加载&#xA;&#xA;const routes = [&#xA;  {&#xA;    path: &#39;/&#39;,&#xA;    redirect: {&#xA;      name: &#39;news&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/news&#39;,&#xA;    name: &#39;news&#39;,&#xA;    component: () =&amp;gt; import(&#39;@/components/News.vue&#39;),&#xA;    meta: {&#xA;      title: &#39;新闻&#39;&#xA;    }&#xA;  },&#xA;  {&#xA;    path: &#39;/books&#39;,&#xA;    name: &#39;books&#39;,&#xA;    component: () =&amp;gt; import(&#39;@/components/Books.vue&#39;),&#xA;    meta: {&#xA;      title: &#39;图书&#39;&#xA;    }&#xA;  }&#xA;]&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Vue.js之从入门到实战</title>
      <link>http://www.nljb.net/default/Vue.js%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</link>
      <pubDate>2020-11-15 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Vue.js之从入门到实战&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;准备工作&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Node.js https:#nodejs.org/en # 安装&#xA;.\node_modules\npm\npmrc  # 编辑配置&#xA;prefix=E:\NodeModules\npm_global # 自定义路径&#xA;cache=E:\NodeModules\npm_cache # 自定义路径&#xA;PATH=E:\NodeModules\npm_global # 环境变量&#xA;NODE_PATH=E:\NodeModules\npm_global # 环境变量&#xA;&#xA;Visual Studio Code https:#code.visualstudio.com # 安装&#xA;Configure Display Language # 中文简体&#xA;Vetur # 该插件支持 .vue 文件的语法高亮&#xA;ESLint # 该插件支持 JavaScript 语法规则和代码风格检查工具&#xA;&#xA;npm config set registry https://registry.npm.taobao.org&#xA;npm install -g cnpm --registry=https://registry.npm.taobao.org&#xA;&#xA;npm install vue       # 本地安装 Vue&#xA;npm install -g vue        # 全局安装 Vue&#xA;npm install -g @vue/cli   # 扩展安装 Vue Cli&#xA;npm uninstall vue         # 卸载 Vue&#xA;npm list -g --depth 0     # 查看已安装 ...&#xA;npm install element-ui --save # 安装 Element-UI&#xA;npm install vue-router        # 安装 Vue Router 也可在 vue create 时选择&#xA;说明：--save 安装后会在 dependencies 中写入依赖项，项目打包发布时会一并打包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;开始工作&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vue ui # 图形界面&#xA;vue create bookstroe # 创建脚手架&#xA;npm run serve # 运行&#xA;&#xA;1. Babel：转码器，用于将 ES6 转为 ES5，从而在现有环境下执行&#xA;2. TypeScript：是 JavaScript 的一个超集，主要提供类型系统和对ES6的支持.&#xA;3. Progressive Web App(PWA) Support：支持渐进式 Web 应用程序&#xA;4. Router：路由管理器（vue-router）&#xA;5. Vuex：Vue 的状态管理&#xA;6. CSS Pre-processors：CSS 预处理器（如 Less、Sass）&#xA;7. Linter / Formatter：代码风格检查和格式检验（如 ESLint）&#xA;8. Unit Testing：单元测试&#xA;9. E2E Testing：End to End 测试&#xA;&#xA;// 创建项目选项 ...&#xA;? Please pick a preset: Manually select features # 手动选择&#xA;? Check the features needed for your project: Choose Vue version, Babel, Router, Vuex, Linter&#xA;? Choose a version of Vue.js that you want to start the project with 2.x&#xA;? Use history mode for router? (Requires proper server setup for index fallback in production) Yes&#xA;? Pick a linter / formatter config: Basic&#xA;? Pick additional lint features: Lint on save&#xA;? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files&#xA;? Save this as a preset for future projects? No&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装依赖&#xA;cd bookstroe&#xA;npm install&#xA;&#xA;// 打包项目&#xA;npm run build&#xA;&#xA;// 路径问题&#xA;vue.config.js&#xA;&#xA;module.exports = {&#xA;    publicPath: process.env.NODE_ENV === &#39;production&#39;&#xA;    ? &#39;./&#39;&#xA;    : &#39;/&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;目录结构&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; node_module # 项目依赖的模块&#xA;&amp;gt; public # 该目录下的文件不会被Webpack编译压缩处理，引用的第三方库的JS文件可以放在这里&#xA;  &amp;gt;&amp;gt; favicon.ico # 图标文件&#xA;  &amp;gt;&amp;gt; index.html # 项目的主页面&#xA;&amp;gt; src # 项目代码的主目录&#xA;  &amp;gt;&amp;gt; assets # 存放项目中的静态资源，如 CSS、图片等&#xA;    &amp;gt;&amp;gt;&amp;gt; logo.png # logo 图片&#xA;  &amp;gt;&amp;gt; components # 编写的组件放在这个目录下（全局）&#xA;    &amp;gt;&amp;gt;&amp;gt; mixin # 混入对象目录&#xA;      &amp;gt;&amp;gt;&amp;gt;&amp;gt; mixin.js # 混入对象&#xA;    &amp;gt;&amp;gt;&amp;gt; HelloWorld.vue # Vue Cli 创建的 Hello World 组件&#xA;  &amp;gt;&amp;gt; views # 页面级组件放在这个目录&#xA;    &amp;gt;&amp;gt;&amp;gt; Home.vue # 创建的 Home 组件&#xA;  &amp;gt;&amp;gt; router # 前端路由&#xA;  &amp;gt;&amp;gt; store # 应用级数据（state）&#xA;  &amp;gt;&amp;gt; App.vue # 项目的根组件（入口）&#xA;  &amp;gt;&amp;gt; main.js # 程序入口 js 文件，加载各种公共组件和所需要用到的插件&#xA;&amp;gt; .browserslistrc # 配置项目目标浏览器的范围&#xA;&amp;gt; .gitignore # 配置在 git 提交项目代码时忽略哪些文件&#xA;&amp;gt; .eslintrc.js # ESLint 使用的配置文件&#xA;&amp;gt; babel.config.js # Babel 使用的配置文件&#xA;&amp;gt; postcss.config.js # PostCSS 使用的配置文件&#xA;&amp;gt; package.json # npm 的配置文件，其中设定了脚本和项目依赖的库&#xA;&amp;gt; package-lock.json # 用于锁定项目实际安装的各个 npm 包的具体来源和版本号&#xA;&amp;gt; README.md # 项目说明文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package.json 文件介绍&#xA;&#xA;{&#xA;  &amp;quot;name&amp;quot;: &amp;quot;bookstroe&amp;quot;, // 项目名称&#xA;  &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;, // 项目版本&#xA;  &amp;quot;private&amp;quot;: true, // 是否私有项目&#xA;  &amp;quot;scripts&amp;quot;: { // 值是一个对象，其中指定了项目生命周期各个环节需要执行的命令&#xA;    &amp;quot;serve&amp;quot;: &amp;quot;vue-cli-service serve&amp;quot;, // 执行 npm run serve 运行项目&#xA;    &amp;quot;build&amp;quot;: &amp;quot;vue-cli-service build&amp;quot;, // 执行 npm run build 构建项目&#xA;    &amp;quot;lint&amp;quot;: &amp;quot;vue-cli-service lint&amp;quot; // 执行 npm run list 运行 ESLint 验证并格式化代码&#xA;  },&#xA;  &amp;quot;dependencies&amp;quot;: { // 配置项目依赖的模块列表&#xA;    &amp;quot;core-js&amp;quot;: &amp;quot;^3.6.5&amp;quot;,&#xA;    &amp;quot;element-ui&amp;quot;: &amp;quot;^2.14.1&amp;quot;,&#xA;    &amp;quot;vue&amp;quot;: &amp;quot;^2.6.11&amp;quot;,&#xA;    &amp;quot;vue-router&amp;quot;: &amp;quot;^3.2.0&amp;quot;,&#xA;    &amp;quot;vuex&amp;quot;: &amp;quot;^3.4.0&amp;quot;&#xA;  },&#xA;  &amp;quot;devDependencies&amp;quot;: { // 这里的依赖是用于开发环境的，不发布到生产&#xA;    &amp;quot;@vue/cli-plugin-babel&amp;quot;: &amp;quot;~4.5.0&amp;quot;,&#xA;    &amp;quot;@vue/cli-plugin-eslint&amp;quot;: &amp;quot;~4.5.0&amp;quot;,&#xA;    &amp;quot;@vue/cli-plugin-router&amp;quot;: &amp;quot;~4.5.0&amp;quot;,&#xA;    &amp;quot;@vue/cli-plugin-vuex&amp;quot;: &amp;quot;~4.5.0&amp;quot;,&#xA;    &amp;quot;@vue/cli-service&amp;quot;: &amp;quot;~4.5.0&amp;quot;,&#xA;    &amp;quot;babel-eslint&amp;quot;: &amp;quot;^10.1.0&amp;quot;,&#xA;    &amp;quot;eslint&amp;quot;: &amp;quot;^6.7.2&amp;quot;,&#xA;    &amp;quot;eslint-plugin-vue&amp;quot;: &amp;quot;^6.2.2&amp;quot;,&#xA;    &amp;quot;vue-template-compiler&amp;quot;: &amp;quot;^2.6.11&amp;quot;&#xA;  }&#xA;}&#xA;&#xA;// 在使用 NPM 安装依赖的模块，可以根据模块是否需要在生成环境下使用而选择&#xA;// 附加 --save(-S) 或者 --save-dev(-D) 参数 ...&#xA;// npm install element-ui -S 安装后会在 dependencies 中写入依赖项&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一个典型的单文件组件包含了组件代码、模版代码和CSS样式规则&#xA;&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt; 、&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;、&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;内置指令&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-show 指令根据表达式的值的真假，来显示或隐藏HTML元素&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- v-show 为 true 则 h1 元素显示，false 则元素不显示 --&amp;gt;&#xA;    &amp;lt;h4 v-show=&amp;quot;ok&amp;quot;&amp;gt;SHOW IS Ture&amp;lt;/h4&amp;gt;&#xA;    &amp;lt;!-- 在 v-show 中使用 JavaScript 表达式 --&amp;gt;&#xA;    &amp;lt;h4 v-show=&amp;quot;age &amp;gt; 25&amp;quot;&amp;gt;Age: \{{ age }}&amp;lt;/h4&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      ok: true,&#xA;      age: 28,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-if/v-else-if/v-else 这三个指令用于实现条件判断&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- v-if 为 ture 则 h1 元素创建(显示)，false 则元素不创建 --&amp;gt;&#xA;    &amp;lt;h4 v-if=&amp;quot;ok&amp;quot;&amp;gt;IF IS True&amp;lt;/h4&amp;gt;&#xA;    &amp;lt;!-- v-if/v-else-if/v-else --&amp;gt;&#xA;    &amp;lt;span v-if=&amp;quot;score &amp;gt;= 85&amp;quot;&amp;gt;优秀&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span v-else-if=&amp;quot;score &amp;gt;= 75&amp;quot;&amp;gt;合格&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span v-else-if=&amp;quot;score &amp;gt;= 60&amp;quot;&amp;gt;及格&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span v-else&amp;gt;不及格&amp;lt;/span&amp;gt;&#xA;    &amp;lt;!-- v-if-key 管理可复用的元素 --&amp;gt;&#xA;    &amp;lt;!-- 在 input 中增加一个具有唯一值的 key 属性 --&amp;gt;&#xA;    &amp;lt;div v-if=&amp;quot;loginType == &#39;username&#39;&amp;quot;&amp;gt;&#xA;      &amp;lt;label&amp;gt;用户名&amp;lt;/label&amp;gt;&#xA;      &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;请输入您的用户名&amp;quot; key=&amp;quot;username-input&amp;quot; /&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div v-else&amp;gt;&#xA;      &amp;lt;label&amp;gt;邮箱&amp;lt;/label&amp;gt;&#xA;      &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;请输入您的Email&amp;quot; key=&amp;quot;email-input&amp;quot; /&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;button @click=&amp;quot;changeLoginType&amp;quot;&amp;gt;切换登录方式&amp;lt;/button&amp;gt;&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Hello&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      ok: true,&#xA;      score: 60,&#xA;      loginType: &amp;quot;username&amp;quot;,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    changeLoginType() {&#xA;      if (this.loginType === &amp;quot;username&amp;quot;) {&#xA;        this.loginType = &amp;quot;email&amp;quot;;&#xA;      } else {&#xA;        this.loginType = &amp;quot;username&amp;quot;;&#xA;      }&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-for 指令就是通过循环的方式来渲染一个列表，循环的对象可以是数组或JS对象&#xA;&#xA;// Vue和核心是数据与视图的双向绑定&#xA;// 为了监测数组中元素的变化，以便能及时将变化反映到视图中&#xA;// Vue对数组的下列编译方法进行了包裹 ...&#xA;// push()、pop()、shitf()、unshift()、splice()、sort()、reverse()&#xA;// 数组中海油一些非变异方法，如：filter()、concat()、slice() &#xA;// 他们不会改变原始数组，而总是返回一个新数组 ...&#xA;// 对于这些方法，想让视图自动更新，可以使用新数据替换原来数组即可&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- v-for-array 通过循环方式来渲染一个列表 --&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;(book, index) in books&amp;quot; v-bind:key=&amp;quot;book.title&amp;quot;&amp;gt;&#xA;        \{{ index }} - \{{ book.title }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;!-- v-for-object 通过循环方式来渲染一个对象 --&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;(value, key) in objs&amp;quot; v-bind:key=&amp;quot;key&amp;quot;&amp;gt;&#xA;        \{{ key }} - \{{ value }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      // 数组数据&#xA;      books: [ &#xA;        { title: &amp;quot;Vue 无难事&amp;quot;, complete: true },&#xA;        { title: &amp;quot;VC++ 深入详解&amp;quot;, complete: true },&#xA;        { title: &amp;quot;Servlet/JSP 深入详解&amp;quot;, complete: false },&#xA;      ],&#xA;      // 对象数据&#xA;      objs: {&#xA;        one: &amp;quot;这是第一条&amp;quot;,&#xA;        tow: &amp;quot;这是第二条&amp;quot;,&#xA;        three: &amp;quot;这是第三条&amp;quot;,&#xA;      },&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-for 对象更新检测&#xA;&#xA;// 由于JS的限制，Vue不能检测对象属性的添加和删除&#xA;// 要解决这个问题，可以使用Vue全局的set()和delete()方法来添加和删除属性&#xA;// 或者Vue实例$set()和$delete()方法来添加和删除属性，并触发更新&#xA;&#xA;this.$set(book, &#39;publishDate&#39;, &#39;2019-07-01)&#xA;this.$delete(book, &#39;isbn&#39;)&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;(value, key) in objs&amp;quot; v-bind:key=&amp;quot;key&amp;quot;&amp;gt;&#xA;        \{{ key }} - \{{ value }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;ddd&amp;quot;&amp;gt;删除&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      objs: {&#xA;        one: &amp;quot;这是第一条&amp;quot;,&#xA;        tow: &amp;quot;这是第二条&amp;quot;,&#xA;        three: &amp;quot;这是第三条&amp;quot;,&#xA;      },&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    ddd() {&#xA;      this.$delete(this.objs, &amp;quot;one&amp;quot;);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-for-key&#xA;&#xA;// 这段代码预先定义了一个books数组对象，通过v-for指令遍历数组，同时提供输入框&#xA;// 在用户输入图片的ID和书名后，向数组添加一个新的图书对象&#xA;// 使用unshift()方法想数组的开头添加一个或多个元素 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- v-for-key 增加一个具有唯一值的 key 属性 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;      ID: &amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;bookId&amp;quot; /&amp;gt; 书名:&#xA;      &amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;titleNm&amp;quot; /&amp;gt;&#xA;      &amp;lt;button v-on:click=&amp;quot;add()&amp;quot;&amp;gt;添加&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;p v-for=&amp;quot;book1 in books&amp;quot; v-bind:key=&amp;quot;book1.id&amp;quot;&amp;gt;&#xA;      &amp;lt;input type=&amp;quot;checkbox&amp;quot; /&amp;gt;&#xA;      &amp;lt;span&amp;gt;ID: \{{ book1.id }}, 书名: \{{ book1.title }}&amp;lt;/span&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      bookId: &amp;quot;&amp;quot;,&#xA;      titleNm: &amp;quot;&amp;quot;,&#xA;      books: [&#xA;        { id: 1, title: &amp;quot;Vue 无难事&amp;quot; },&#xA;        { id: 2, title: &amp;quot;VC++ 深入详解&amp;quot; },&#xA;        { id: 3, title: &amp;quot;Servlet/JSP 深入详解&amp;quot; },&#xA;      ],&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    add() {&#xA;      this.books.unshift({&#xA;        id: this.bookId,&#xA;        title: this.titleNm,&#xA;      });&#xA;      this.bookId = &amp;quot;&amp;quot;;&#xA;      this.titleNm = &amp;quot;&amp;quot;;&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果考虑 v-for 与 v-if 一同使用，需要使用计算属性来代替&#xA;&#xA;// 通过计算属性过滤对应条件的数据 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- 计算属性代替 v-for 和 v-if --&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;li v-for=&amp;quot;plan in completePlans&amp;quot; v-bind:key=&amp;quot;plan.content&amp;quot;&amp;gt;&#xA;        \{{ plan.content }}&#xA;      &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      plans: [&#xA;        { content: &amp;quot;吃饭&amp;quot;, completed: true },&#xA;        { content: &amp;quot;睡觉&amp;quot;, completed: false },&#xA;        { content: &amp;quot;打豆豆&amp;quot;, completed: false },&#xA;        { content: &amp;quot;写书&amp;quot;, completed: false },&#xA;        { content: &amp;quot;买菜&amp;quot;, completed: true },&#xA;      ],&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    reversedMessage: function () {&#xA;      return this.message.split(&amp;quot;&amp;quot;).reverse().join(&amp;quot;&amp;quot;);&#xA;    },&#xA;    completePlans() {&#xA;      return this.plans.filter((plan) =&amp;gt; plan.completed);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-bind &#xA;&#xA;// 用于响应更新HTML元素属性，将一个或多个属性或者一个组件的prop动态绑定到表达式&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- v-bind(可缩写) 主要用于响应更新HTML元素的属性 --&amp;gt;&#xA;    &amp;lt;!-- 将一个或多个属性或者一个组件的prop动态绑定到表达式 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;a v-bind:[attrname]=&amp;quot;url&amp;quot;&amp;gt;链接&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;a :[attrname]=&amp;quot;url&amp;quot;&amp;gt;链接&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;form v-bind=&amp;quot;formObj&amp;quot;&amp;gt;&#xA;      &amp;lt;input type=&amp;quot;text&amp;quot; /&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      attrname: &amp;quot;href&amp;quot;,&#xA;      url: &amp;quot;http://www.baidu.com&amp;quot;,&#xA;      formObj: {&#xA;        method: &amp;quot;get&amp;quot;,&#xA;        action: &amp;quot;#&amp;quot;,&#xA;      },&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-model 指令用来在表单&amp;lt;input&amp;gt;、&amp;lt;textarea&amp;gt;、&amp;lt;select&amp;gt;元素上创建双向绑定&#xA;// 它会更具控件类型自动选取正确的方法来更新元素 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- v-model 在表单&amp;lt;input&amp;gt;、&amp;lt;textarea&amp;gt;及&amp;lt;select&amp;gt;元素上创建双向数据绑定 --&amp;gt;&#xA;    &amp;lt;!-- 它会根据控件类型自动选取正确的方法来更新元素 ... --&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;message&amp;quot; /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;测试&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-on 指令用于监听DOM事件，并在触发时运行一些JS代码&#xA;// v-on 指令表达式可以是一段JS代码，也可以是一个方法名字或方法调用语句&#xA;&#xA;// 注意：在使用 v-on 指令绑定事件处理器时，就可以使用$event传入原始DOM事件对象&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- click 事件直接使用 JS 语句 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;      &amp;lt;button v-on:click=&amp;quot;count += 1&amp;quot;&amp;gt;+1 = \{{ count }}&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- click 事件直接绑定一个方法 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;button v-on:click=&amp;quot;greet&amp;quot;&amp;gt;Greet&amp;lt;/button&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;button @click=&amp;quot;greet&amp;quot;&amp;gt;Greet&amp;lt;/button&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- click 事件使用内联语句调用方法 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;button @click=&amp;quot;say(&#39;Hi&#39;)&amp;quot;&amp;gt;Hi&amp;lt;/button&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- v-on 事件修饰符 --&amp;gt;&#xA;    &amp;lt;!-- .stop 调用 event.stopPropagation() --&amp;gt;&#xA;    &amp;lt;!-- .prevent 调用 event.preventDefault() --&amp;gt;&#xA;    &amp;lt;!-- .capture 添加事件监听器时使用 capture 模式 --&amp;gt;&#xA;    &amp;lt;!-- .self 只当事件是从侦听器绑定的元素本身触发时才触发回调 --&amp;gt;&#xA;    &amp;lt;!-- .{keyCode | keyAlias} 只当事件是从特定按键触发时才触发回调 --&amp;gt;&#xA;    &amp;lt;!-- .native 监听组件根元素的原生事件 --&amp;gt;&#xA;    &amp;lt;!-- .once 只触发一次回调 --&amp;gt;&#xA;    &amp;lt;!-- .left 只当按鼠标左键时触发 --&amp;gt;&#xA;    &amp;lt;!-- .right 只当按鼠标右键时触发 --&amp;gt;&#xA;    &amp;lt;!-- .middle 只当按鼠标中键时触发 --&amp;gt;&#xA;    &amp;lt;!-- .passive 以{passive: true} 模式添加侦听器 --&amp;gt;&#xA;    &amp;lt;a href=&amp;quot;/login&amp;quot; v-on:click.prevent=&amp;quot;greet&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&#xA;    &amp;lt;!-- v-on 按键修饰符 --&amp;gt;&#xA;    &amp;lt;!-- .enter 只有在按键是回车键时调用方法 --&amp;gt;&#xA;    &amp;lt;!-- .tab、.delete、.esc、.space、.up、.down、.left、.right --&amp;gt;&#xA;    &amp;lt;!-- .ctrl、.alt、.shitf、.meta --&amp;gt;&#xA;    &amp;lt;!-- .left、.right、.middle --&amp;gt;&#xA;    &amp;lt;input @keyup.enter=&amp;quot;greet&amp;quot; /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      count: 0,&#xA;      message: &amp;quot;测试&amp;quot;,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    greet() {&#xA;      alert(this.message);&#xA;    },&#xA;    say(msg) {&#xA;      alert(msg);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-text 元素用于更新元素的文本内容&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- v-text 元素用于更新元素的文本内容 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;span v-text=&amp;quot;message&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;      &amp;lt;span&amp;gt;更新元素内容：\{{ message }}&amp;lt;/span&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;测试&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-html 指令用于更新元素的innerHTML，该部分内容作为普通HTML代码插入&#xA;// 不会作为Vue模版进行编译 ...&#xA;&#xA;&amp;lt;!-- v-html 指令用于更新元素的 innerHTML --&amp;gt;&#xA;&amp;lt;p v-html=&amp;quot;hElt&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-once 指令可以让元素或组件只渲染一次，该指令不需要表达式&#xA;&#xA;&amp;lt;!-- v-once 指令可以让元素或组件只渲染一次 --&amp;gt;&#xA;&amp;lt;!-- 例如：导航菜单等，仅需要渲染一次，不会需要修改重新渲染的 --&amp;gt;&#xA;&amp;lt;h1 v-once&amp;gt;V-ONCE：\{{ message }}&amp;lt;/h1&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-pre 指令用于跳过这个元素和它的子元素的编译过程&#xA;// 可以用来显示原始Mustache标签&#xA;// 指令不需要表达式&#xA;&#xA;&amp;lt;!-- v-pre 用于跳过这个元素和它的子元素的编译过程 --&amp;gt;&#xA;&amp;lt;h1 v-pre&amp;gt;V-PRE：\{{ message }}&amp;lt;/h1&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-cloak 指令保持在元素上直到关联实例编译结束&#xA;// 指令不需要表达式&#xA;&#xA;// 说明：浏览器在加载页面时，如果网速较慢或者页面较大，&#xA;// 那么浏览器在构造完DOM树后会在页面中直接显示\{{message}}字样&#xA;// 直到Vue的JS文件加载完毕，Vue实例创建、模版编译后才会被替换为数据&#xA;// 如果使用CSS规则[v-cloak]{display:none}配合v-cloak指令使用，就可以解决这问问题&#xA;&#xA;&amp;lt;!-- v-cloak 这个指令保持在元素上直到关联实例编译结束，编译结束后盖指令被移除 --&amp;gt;&#xA;&amp;lt;!-- 当和CSS规则如[v-cloak]{display:none}一起使用时，可以隐藏未编译的Mustache标签 --&amp;gt;&#xA;&amp;lt;!-- 直到实例准备完毕 --&amp;gt;&#xA;&amp;lt;h1 v-cloak&amp;gt;V-CLOAK：\{{ message }}&amp;lt;/h1&amp;gt;&#xA;&#xA;&amp;lt;style&amp;gt;&#xA;[v-cloak] {&#xA;  display: none;&#xA;}&#xA;&amp;lt;/style&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;自定义指令&#xA;&#xA;自定义指令的注册&#xA;&#xA;// 自定义指令需要注册后才能使用，Vue提供了两种注册方式：全局注册和局部注册&#xA;// 全局注册使用Vue.directive()方法来注册，使用Vue Cli时在main.js中注册&#xA;&#xA;钩子函数&#xA;&#xA;// 自定义指令的功能是在定义对象中实现的，而定义对象则是由钩子函数组成的&#xA;// Vue提供了下面几个钩子函数，这些钩子函数都是可选的：&#xA;// 1. bind 只调用一次，指令第一次绑定到元素时调用&#xA;// 2. inserted 被绑定元素插入父节点时调用&#xA;// 3. update 所在组件的VNode更新时调用&#xA;// 4. componentUpdated 指令所在组件VNode及子VNode全部更新后调用&#xA;// 5. unbind 只调用一次，指令与元素解绑时调用&#xA;&#xA;指令的钩子函数可以带有一些参数：&#xA;// el：指令所绑定的元素，可以用来直接操作DOM&#xA;// binding 一个对象，包含一组属性 ...&#xA;// 1. name 指令名称，不包括 v-前缀&#xA;// 2. value 指令的绑定值，例如：v-mydirective=&amp;quot;1+1&amp;quot; 中 value 值为 2&#xA;// 3. oldValue 指令绑定的前一个值，仅在update和componentUpdated钩子中可用&#xA;// 4. expression 字符串形式的指令表达式, 值为 &amp;quot;1+1&amp;quot;&#xA;// 5. arg 传给指令的参数，可选，例如：v-mydirective:foo 中的 foo&#xA;// 6. modifiers 一个包含修饰符的对象，例如：v-mydirective.foo.bar 中 { foo:true, bar: true }&#xA;// vnode Vue编译生成的虚拟节点&#xA;// oldVnode 上一个虚拟节点，仅在update和componentUpdated钩子中可用&#xA;&#xA;// 全局注册&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input v-focus /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;   &#xA;&#xA;// main.js&#xA;Vue.directive(&#39;focus&#39;, {&#xA;  bind: function (el) {&#xA;    el.focus();&#xA;    alert(&amp;quot;Hello ...&amp;quot;);&#xA;  }&#xA;})&#xA;&#xA;new Vue({ ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 局部注册&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input v-focus /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  directives: {&#xA;    focus: {&#xA;      bind: function (el) {&#xA;        el.focus();&#xA;        alert(&amp;quot;Hello ...&amp;quot;);&#xA;      },&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;动态指令参数&#xA;&#xA;// 已经介绍过指令的参数可以是动态参数，同样地&#xA;// 自定义的指令也可以使用动态参数 ...&#xA;// 例如：v-mydirective:[argument]=&amp;quot;value&amp;quot;&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- 直接给出指令的参数 --&amp;gt;&#xA;    &amp;lt;p v-pin:top=&amp;quot;100&amp;quot;&amp;gt;Vue.js 无难事&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 使用动态参数 --&amp;gt;&#xA;    &amp;lt;p v-pin:[direction]=&#39;100&#39;&amp;gt;Vue.js 无难事&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      direction: &amp;quot;left&amp;quot;,&#xA;    };&#xA;  },&#xA;  directives: {&#xA;    pin: {&#xA;      bind: function (el, binding) {&#xA;        el.style.position = &amp;quot;fixed&amp;quot;;&#xA;        let s = binding.arg || &amp;quot;left&amp;quot;;&#xA;        el.style[s] = binding.value + &amp;quot;px&amp;quot;;&#xA;      },&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;函数简写&#xA;&#xA;// 如果自定义指令在bind和update钩子函数中的行为一致，&#xA;// 且只需要用到这两个钩子，那么可以在注册时传递一个函数对象作为参数&#xA;&#xA;Vue.directive(&#39;color-swatch&#39;, function (el, binding) {&#xA;    el.style.backgroundColor = binding.value&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;对象字面量&#xA;&#xA;// 如果指令需要多个值，可以传入一个 JS 对象字面量&#xA;&amp;lt;div v-demo=&amp;quot;{ color: &#39;white&#39;, text: &#39;hello&#39; }&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&#xA;Vue.directive(&#39;demo&#39;, funciton (el, binding) {&#xA;    console.log(binding.value.color)&#xA;    console.log(binding.value.hello)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;计算属性&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;定义计算属性&#xA;&#xA;// 表达式的逻辑过于复杂的时候，都应当考虑使用计算属性。&#xA;// 计算属性是以函数形式，在Vue实例的选项对象computed中定义&#xA;&#xA;// 当message属性的值改变时，reversedMessage的值也会自动更新&#xA;// 并且会自动同步更新DOM部分 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- 表达式的逻辑过于复杂的时候，都应当考虑使用计算属性 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;计算后的反转字符串: \{{ reversedMessage }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ fullName }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;Hello, Vue.js 从入门到实战&amp;quot;,&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    reversedMessage: function () {&#xA;      return this.message.split(&amp;quot;&amp;quot;).reverse().join(&amp;quot;&amp;quot;);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 计算属性默认只有getter，因此是不能直接修改计算属性的&#xA;// 如果需要也可以提供一个setter ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p&amp;gt;First name: &amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;firstName&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;Last name: &amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;lastName&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ fullName }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      firstName: &amp;quot;Smith&amp;quot;,&#xA;      lastName: &amp;quot;Will&amp;quot;,&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    fullName: {&#xA;      // getter&#xA;      get: function () {&#xA;        return this.firstName + &amp;quot; &amp;quot; + this.lastName;&#xA;      },&#xA;      // setter&#xA;      set: function (newValue) {&#xA;        var names = newValue.split(&amp;quot; &amp;quot;);&#xA;        this.firstName = names[0];&#xA;        this.lastName = names[names.length - 1];&#xA;      },&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;计算属性缓存&#xA;&#xA;// 既然使用方法能实现与计算属性相同的结果，那么还有必要使用计算属性吗？&#xA;// 答案是有必要，因为计算属性是基于它的响应式依赖进行缓存的 ...&#xA;// 只有在计算属性的相关响应式依赖发生改变时才会重新求值 ...&#xA;&#xA;// 这就意味着只要message还没有发生改变，多次访问reversedMessage会立即返回之前结果&#xA;// 而不会再次执行；而如果采用方法，那么不管什么时候访问reversedMessage()都会被调用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;监听器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Vue 提供了一种更通用的方式来观察和响应Vue实例上的数据变动：监听属性&#xA;// 当你有一些数据需要随着其他数据变化而变动时，就可以使用监听器&#xA;&#xA;// 听起来好像和计算属性的作用差不多，从功能描述来看，确实是&#xA;// 不过在实际应用中二者有很大差别 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p&amp;gt;千米：&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;kilometers&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;米：&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;meters&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      kilometers: 0,&#xA;      meters: 0,&#xA;    };&#xA;  },&#xA;  watch: {&#xA;    kilometers: function (val) {&#xA;      this.meters = val * 1000;&#xA;    },&#xA;    meters: function (val) {&#xA;      this.kilometers = val / 1000;&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;监听器的更多形式&#xA;&#xA;// 监听器在定义时，除了直接写一个函数外，还可以接一个方法名&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p&amp;gt;年龄：&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;age&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p v-if=&amp;quot;info&amp;quot;&amp;gt;\{{info}}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      age: 0,&#xA;      info: &amp;quot;&amp;quot;,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    checkAge() {&#xA;      if (this.age &amp;gt;= 18) this.info = &amp;quot;已成年&amp;quot;;&#xA;      else this.info = &amp;quot;未成年&amp;quot;;&#xA;    },&#xA;  },&#xA;  watch: {&#xA;    age: &amp;quot;checkAge&amp;quot;,&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 监听器还可以监听一个对象的属性变化 ...&#xA;&#xA;// handler 用于定义数据变化时调用的监听器函数&#xA;// deep 只要该属性的值发生变化，都会被检测到&#xA;// immediate 监听器函数在监听开始后立即执行&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;person.age&amp;quot; /&amp;gt;&#xA;    &amp;lt;p v-if=&amp;quot;info&amp;quot;&amp;gt;\{{ info }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      person: {&#xA;        name: &amp;quot;nulijiabei&amp;quot;,&#xA;        age: 0,&#xA;      },&#xA;      info: &amp;quot;&amp;quot;,&#xA;    };&#xA;  },&#xA;  watch: {&#xA;    person: {&#xA;      handler: function (val) {&#xA;        if (val.age &amp;gt;= 18) this.info = &amp;quot;已成年&amp;quot;;&#xA;        else this.info = &amp;quot;未成年&amp;quot;;&#xA;      },&#xA;      deep: true,&#xA;      immediate: true,&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;class 与 style 绑定&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;HTML元素有两个设置样式的属性：class 和 style &#xA;// 前者用于指定样式表中class，后者用于设置内联样式&#xA;// 在 Vue.js 中可以用 v-bind 指令来处理它们 ...&#xA;&#xA;绑定 HTML class&#xA;&#xA;// active 这个 class 存在与否将取决于数据属性 isActive 的值&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div v-bind:class=&amp;quot;{ active: isActive }&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;style&amp;gt;&#xA;.active {&#xA;  width: 100px;&#xA;  height: 100px;&#xA;  background: green;&#xA;}&#xA;&amp;lt;/style&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      isActive: true,&#xA;    };&#xA;  },&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;/script&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 也可以在对象中传入更多属性来动态切换多个 class&#xA;// 此外，v-bind:class 指令也可以和普通的class属性一起使用&#xA;&#xA;// 最终渲染结果：&amp;lt;div class=&amp;quot;static active&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&#xA;// 当数据属性isActive或hasError改变时，class 列表将相应地更新&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&#xA;    class=&amp;quot;static&amp;quot;&#xA;    v-bind:class=&amp;quot;{ active: isActive, &#39;text-danger&#39;: hasError }&amp;quot;&#xA;  &amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;style&amp;gt;&#xA;.static {&#xA;  border: solid 2px black;&#xA;}&#xA;.active {&#xA;  width: 100px;&#xA;  height: 100px;&#xA;  background: green;&#xA;}&#xA;&amp;lt;/style&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      isActive: true,&#xA;      hasError: false,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 绑定的数据对象如果较为复杂，可以在数据属性中单独定义一个对象，然后绑定它&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div class=&amp;quot;static&amp;quot; v-bind:class=&amp;quot;classObject&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;style&amp;gt;&#xA;.static {&#xA;  border: solid 2px black;&#xA;}&#xA;.active {&#xA;  width: 100px;&#xA;  height: 100px;&#xA;  background: green;&#xA;}&#xA;&amp;lt;/style&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      classObject: {&#xA;        active: true,&#xA;        &amp;quot;text-danger&amp;quot;: false,&#xA;      },&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当然也可以考虑绑定一个返回对象的计算属性，这是一个常用且强大的模式&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div class=&amp;quot;static&amp;quot; v-bind:class=&amp;quot;classObject&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;style&amp;gt;&#xA;.static {&#xA;  border: solid 2px black;&#xA;}&#xA;.active {&#xA;  width: 100px;&#xA;  height: 100px;&#xA;  background: green;&#xA;}&#xA;&amp;lt;/style&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      isActive: true,&#xA;      error: null,&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    classObject: function () {&#xA;      return {&#xA;        active: this.isActive &amp;amp;&amp;amp; !this.error,&#xA;        &amp;quot;text-danger&amp;quot;: this.error &amp;amp;&amp;amp; this.error.type === &amp;quot;fatal&amp;quot;,&#xA;      };&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;数组语法 &#xA;&#xA;// 除了给 v-bind:class 传递对象外，也可以传递一个数组, 应用一个 class 列表&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div class=&amp;quot;static&amp;quot; v-bind:class=&amp;quot;[activeClass, errorClass]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;style&amp;gt;&#xA;.static {&#xA;  border: solid 2px black;&#xA;}&#xA;.active {&#xA;  width: 100px;&#xA;  height: 100px;&#xA;  background: red;&#xA;}&#xA;&amp;lt;/style&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      activeClass: &amp;quot;active&amp;quot;,&#xA;      errorClass: &amp;quot;text-danger&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 也可以使用三元表达式来根据条件切换 class &#xA;&#xA;&amp;lt;div v-bind:class=&amp;quot;[isActive ? activeClass : &#39;&#39;, errorClass]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&#xA;data: {&#xA;    activeClass: &#39;active&#39;,&#xA;    errorClass: &#39;text-danger&#39;,&#xA;    isActive: true,&#xA;}&#xA;&#xA;// 当 class 属性的表达式中有多个条件时，可以在数组语法中使用对象语法来简化表达式&#xA;&amp;lt;div v-bind:class=&amp;quot;[{active: isActive }, errorClass]&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在组件上使用 class 属性&#xA;&#xA;// 当在一个自定义组件上使用 class 属性时，这些 class 将被添加到该组件的根元素上面。&#xA;// 这个元素山哥已经存在的 class 不会被覆盖。&#xA;&#xA;// 首先定义一个组件&#xA;Vue.component(&#39;my-component&#39;, {&#xA;    template: &#39;&amp;lt;p class=&amp;quot;foo bar&amp;quot;&amp;gt;Hi&amp;lt;/p&amp;gt;&#39;&#xA;})&#xA;&#xA;// 然后在使用该组件时添加一些 class&#xA;&amp;lt;my-component class=&amp;quot;baz boo&amp;quot;&amp;gt;&amp;lt;/my-component&amp;gt;&#xA;&#xA;// HTML 将会被渲染为&#xA;&amp;lt;p class=&amp;quot;foo bar baz boo&amp;quot;&amp;gt;Hi&amp;lt;/p&amp;gt;&#xA;&#xA;// 对于带数据绑定 class 也同样适用&#xA;&amp;lt;my-component v-binbd:class=&amp;quot;{ active: isActive }&amp;quot;&amp;gt;&amp;lt;/my-component&amp;gt;&#xA;&#xA;// 当 isActive 计算为真时，HTML 将被渲染为&#xA;&amp;lt;p class=&amp;quot;foo bar active&amp;quot;&amp;gt;Hi&amp;lt;/p&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;绑定内联样式&#xA;&#xA;v-bind:style 的对象语法非常像 HTML 的内联 CSS 样式与法，但其实是一个JS对象&#xA;&#xA;// CSS 属性名可以用驼峰式(camelCase)或短横线分割(kebab-case)来命名&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div v-bind:style=&amp;quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&amp;quot;&amp;gt;&#xA;    Vue.js 无难事&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      activeColor: &amp;quot;red&amp;quot;,&#xA;      fontSize: 30,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以在数属性中定义一个样式对象，然后直接绑定该对象&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div v-bind:style=&amp;quot;styleObject&amp;quot;&amp;gt;Vue.js 无难事&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      styleObject: {&#xA;        color: &amp;quot;red&amp;quot;,&#xA;        fontSize: &amp;quot;30px&amp;quot;,&#xA;      },&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;数组语法&#xA;&#xA;v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div v-bind:style=&amp;quot;[baseStyles, moreStyles]&amp;quot;&amp;gt;Vue.js 无难事&amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      baseStyles: {&#xA;        border: &amp;quot;solid 2px black&amp;quot;,&#xA;      },&#xA;      moreStyles: {&#xA;        width: &amp;quot;100px&amp;quot;,&#xA;        height: &amp;quot;100px&amp;quot;,&#xA;        background: &amp;quot;orange&amp;quot;,&#xA;      },&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;表单属于绑定&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 表单控件的数据绑定就是用v-model指令来实现的&#xA;// 它会根据控件类型自动选取正确的方法来更新元素&#xA;&#xA;// 在&amp;lt;input&amp;gt;元素中，使用value属性设置一个初始值&amp;quot;Hello Vue.js&amp;quot;&#xA;// 用v-model指令绑定一个表达式message，对应的数据属性是message&#xA;&#xA;// 注意：&#xA;&#xA;// 在结果中可以看到，文本输入框中显示的是数据属性message的值&#xA;// 而&amp;lt;input&amp;gt;元素的value属性的值并没有看到。&#xA;&#xA;// 这是因为v-model指令会忽略所有表单元素的value、checked、selected属性的初始值&#xA;// 而总是将Vue实例的数据属性作为数据来源 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;message&amp;quot; value=&amp;quot;Hello Vue.js&amp;quot; /&amp;gt;&#xA;    &amp;lt;p&amp;gt;message: \{{ message }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;Vue.js 无难事&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;v-model.trim 提供了一个 trim 修饰符，可以帮我们自动过滤输入数据首尾的空白字符&#xA;&amp;lt;input type=&amp;quot;text&amp;quot; v-model.trim=&amp;quot;message&amp;quot;&amp;gt;&#xA;&#xA;v-model.lazy 转变为使用change时间进行同步&#xA;// 默认输入框每输入一个字符&amp;quot;num&amp;quot;均会触发.lazy则为输入完成后移动焦点触发&#xA;&amp;lt;input type=&amp;quot;text&amp;quot; v-model.lazy=&amp;quot;num&amp;quot;&amp;gt;&#xA;&#xA;v-model.number 如果想自动将用户输入数据转为数值类型，可以使用.number修饰符&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;多行文本输入框&#xA;&#xA;&amp;lt;textarea v-model=&amp;quot;message&amp;quot;&amp;lt;/textarea&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;复选框&#xA;&#xA;复选框在单独使用和多个复选框一起使用时，v-model 绑定的值会有所不同&#xA;// 单独使用时，绑定的是布尔值，选中为true，未选中为false&#xA;// 多个复选框时，绑定的是同一个数组，选中的复选框的值将被保存到数组中&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;单个复选框&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;agreement&amp;quot; type=&amp;quot;checkbox&amp;quot; v-model=&amp;quot;isAgree&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;agreement&amp;quot;&amp;gt;\{{ isAgree }}&amp;lt;/label&amp;gt;&#xA;    &amp;lt;h3&amp;gt;多个复选框&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;basketball&amp;quot; type=&amp;quot;checkbox&amp;quot; value=&amp;quot;篮球&amp;quot; v-model=&amp;quot;interests&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;basketball&amp;quot;&amp;gt;篮球&amp;lt;/label&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;football&amp;quot; type=&amp;quot;checkbox&amp;quot; value=&amp;quot;足球&amp;quot; v-model=&amp;quot;interests&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;football&amp;quot;&amp;gt;足球&amp;lt;/label&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;volleyball&amp;quot; type=&amp;quot;checkbox&amp;quot; value=&amp;quot;排球&amp;quot; v-model=&amp;quot;interests&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;volleyball&amp;quot;&amp;gt;排球&amp;lt;/label&amp;gt;&#xA;    &amp;lt;p&amp;gt;你的兴趣爱好是：\{{ interests }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      isAgree: false,&#xA;      interests: [],&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;单选按钮&#xA;&#xA;// 当单选按钮被选中时，v-model 绑定的数据属性的值会被设置为该单选按钮的value值&#xA;&#xA;// 选择&amp;quot;男&amp;quot;时gender值为&amp;quot;1&amp;quot;, 选择&amp;quot;女&amp;quot;时gender值为&amp;quot;0&amp;quot;&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;单选框&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;male&amp;quot; type=&amp;quot;radio&amp;quot; value=&amp;quot;1&amp;quot; v-model=&amp;quot;gender&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;male&amp;quot;&amp;gt;男&amp;lt;/label&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;female&amp;quot; type=&amp;quot;radio&amp;quot; value=&amp;quot;0&amp;quot; v-model=&amp;quot;gender&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;female&amp;quot;&amp;gt;女&amp;lt;/label&amp;gt;&#xA;    &amp;lt;span&amp;gt;性别：\{{ gender }}&amp;lt;/span&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      gender: &amp;quot;&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;选择框&#xA;&#xA;// 与复选框类型，因为选择框可以是单选，也可以多选，因此v-model在这两种情形下绑定值会有所不同&#xA;// 单选时，绑定的是选项的值(&amp;lt;option&amp;gt;元素value属性的值)&#xA;// 多选时，绑定到一个数组，所有选中的选项的值被保存到数组中&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;h3&amp;gt;选择框&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;select v-model=&amp;quot;education&amp;quot;&amp;gt;&#xA;      &amp;lt;option disabled value=&amp;quot;&amp;quot;&amp;gt;请选择您的学历&amp;lt;/option&amp;gt;&#xA;      &amp;lt;option value=&amp;quot;gz&amp;quot;&amp;gt;高中&amp;lt;/option&amp;gt;&#xA;      &amp;lt;option value=&amp;quot;bk&amp;quot;&amp;gt;本科&amp;lt;/option&amp;gt;&#xA;      &amp;lt;option value=&amp;quot;bs&amp;quot;&amp;gt;博士&amp;lt;/option&amp;gt;&#xA;    &amp;lt;/select&amp;gt;&#xA;    &amp;lt;p&amp;gt;您的学历是：\{{ education }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;h3&amp;gt;多选选择框&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;select v-model=&amp;quot;searches&amp;quot; multiple&amp;gt;&#xA;      &amp;lt;option&#xA;        v-for=&amp;quot;option in options&amp;quot;&#xA;        v-bind:value=&amp;quot;option.value&amp;quot;&#xA;        v-bind:key=&amp;quot;option.text&amp;quot;&#xA;      &amp;gt;&#xA;        \{{ option.text }}&#xA;      &amp;lt;/option&amp;gt;&#xA;    &amp;lt;/select&amp;gt;&#xA;    &amp;lt;p&amp;gt;新选择的搜索引擎是：\{{ searches }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      education: &amp;quot;&amp;quot;,&#xA;      searches: [],&#xA;      options: [&#xA;        { text: &amp;quot;百度&amp;quot;, value: &amp;quot;baidu.com&amp;quot; },&#xA;        { text: &amp;quot;谷歌&amp;quot;, value: &amp;quot;google.com&amp;quot; },&#xA;        { text: &amp;quot;必应&amp;quot;, value: &amp;quot;bing.com&amp;quot; },&#xA;      ],&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;值绑定，v-model 针对不同的表单控件，绑定的值都有默认的约定&#xA;// 单个复选框，绑定的是布尔值&#xA;// 多个复选框，绑定的是一个数组，选中的复选框value属性值被保存到数组中&#xA;// 有时候你课鞥呢想要改变默认的绑定规则，那么可以使用v-bind把值绑定到&#xA;// Vue实例的一个动态属性上，并且这个属性的值可以不是字符串&#xA;&#xA;值绑定 - 复选框&#xA;&#xA;// 在使用单个复选框时, 在&amp;lt;input&amp;gt;元素上可以使用两个特殊的属性&#xA;// true-value和false-value来指定选中状态和未选中状态下v-model绑定的值是什么&#xA;&#xA;// isAgree的初始值为false&#xA;// 当选中复选框时，其值为true-value属性的值&amp;quot;yes&amp;quot;&#xA;// 之后再去掉复选框时，其值为false-value属性的值&amp;quot;no&amp;quot;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input&#xA;      id=&amp;quot;agreement&amp;quot;&#xA;      type=&amp;quot;checkbox&amp;quot;&#xA;      v-model=&amp;quot;isAgree&amp;quot;&#xA;      true-value=&amp;quot;yes&amp;quot;&#xA;      false-value=&amp;quot;no&amp;quot;&#xA;    /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;agreement&amp;quot;&amp;gt;\{{ isAgree }}&amp;lt;/label&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      isAgree: false,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;true-value 属性和 false-value 属性也可以使用 v-bind&#xA;// 将它们绑定到data选项中的某个数据属性上 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input&#xA;      id=&amp;quot;agreement&amp;quot;&#xA;      type=&amp;quot;checkbox&amp;quot;&#xA;      v-model=&amp;quot;isAgree&amp;quot;&#xA;      :true-value=&amp;quot;trueVal&amp;quot;&#xA;      :false-value=&amp;quot;falseVal&amp;quot;&#xA;    /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;agreement&amp;quot;&amp;gt;\{{ isAgree }}&amp;lt;/label&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      isAgree: false,&#xA;      trueVal: &amp;quot;真&amp;quot;,&#xA;      falseVal: &amp;quot;假&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;值绑定 - 单选按钮&#xA;&#xA;// 单选按钮被选中时，v-model 绑定的数据属性的值默认被设置为该单选按钮的value值&#xA;// 可以使用 v-bind 将 &amp;lt;input&amp;gt; 元素的 value 属性再绑定到另一个数据属性上 ...&#xA;// 这样选中后的值就是这个 value 属性绑定的数据属性的值 ...&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;male&amp;quot; type=&amp;quot;radio&amp;quot; v-model=&amp;quot;gender&amp;quot; :value=&amp;quot;genderVal[0]&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;male&amp;quot;&amp;gt;男&amp;lt;/label&amp;gt;&#xA;    &amp;lt;input id=&amp;quot;female&amp;quot; type=&amp;quot;radio&amp;quot; v-model=&amp;quot;gender&amp;quot; :value=&amp;quot;genderVal[1]&amp;quot; /&amp;gt;&#xA;    &amp;lt;label for=&amp;quot;female&amp;quot;&amp;gt;女&amp;lt;/label&amp;gt;&#xA;    &amp;lt;span&amp;gt;性别：\{{ gender }}&amp;lt;/span&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      gender: &amp;quot;&amp;quot;,&#xA;      genderVal: [&amp;quot;帅哥&amp;quot;, &amp;quot;美女&amp;quot;],&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;选择框的选项&#xA;&#xA;// 选择框选择内容后其值是选项的值(&amp;lt;option&amp;gt;元素的value属性的值)&#xA;// 选项的value属性也可以使用v-bind指令绑定到一个数据属性上。&#xA;&#xA;&amp;lt;option v-for=&amp;quot;option in options&amp;quot; v-bind:value=&amp;quot;option.value&amp;quot;&amp;gt;&#xA;&#xA;// 也可以像如下写法，将 value 属性绑定到一个对象字面上&#xA;&amp;lt;select v-model=&amp;quot;selected&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 内联对象字面量 --&amp;gt;&#xA;    &amp;lt;option v-bind:value=&amp;quot;{ number: 123 }&amp;quot;&amp;gt;123&amp;lt;/option&amp;gt;&#xA;&amp;lt;/select&amp;gt;&#xA;&#xA;// 当选中时：&#xA;typeof this.selected // &#39;object&#39;&#xA;this.selected.number // 123&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;过滤器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意：文本格式化、数组数据过滤、排序&#xA;&#xA;在Vue.js中，过滤器主要用于文本的格式化，或者数组数据的过滤与排序等。&#xA;&#xA;全局过滤器与局部过滤器&#xA;&#xA;// 过滤器本质上是一个函数，与自定义指令相似，过滤器也分为全局和局部过滤器&#xA;&#xA;// 当全局过滤器和局部过滤器重名时，会采用局部过滤器.&#xA;&#xA;全局过滤器使用Vue.filter()方法来注册&#xA;&#xA;// 全局在 main.js 注册 ...&#xA;Vue.filter(&#39;capitalize&#39;, funciton (value) {&#xA;    if (!value) reutrn &#39;&#39;;&#xA;    value = value.toString();&#xA;    return value.charAt(0).toUpperCase() + value.slice(1);&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;局部过滤器&#xA;&#xA;// 过滤器可以用在两个地方：双花括号插值和v-bind表达式&#xA;// 使用时通过管道符(|)添加到表达式的尾部使用 ...&#xA;// &amp;lt;p&amp;gt;\{{ message | capitalize }}&amp;lt;/p&amp;gt;&#xA;// &amp;lt;a v-bind:href=&amp;quot;url | lowercase&amp;gt;&amp;lt;/a&amp;gt;&#xA;&#xA;过滤器的参数&#xA;&#xA;// 过滤器函数总是接收表达式的值作为第一个参数&#xA;// 过滤器本质上是一个JS函数，自然也可以接收多个参数&#xA;&#xA;过滤器的串联&#xA;&#xA;// 过滤器总是接收管道符(|)前的表达式作为第一个参数，利用该特性&#xA;// 可以将多个过滤器通过管道串联起来使用，形成类似于法链的条用形式&#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ loginType | capitalize }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;a v-bind:href=&amp;quot;url | capitalize&amp;quot;&amp;gt;过滤器&amp;lt;/a&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ filename | format(&amp;quot;vue&amp;quot;, suffix) }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ filename | format(&amp;quot;vue&amp;quot;, suffix) | capitalize }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloWorld&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      loginType: &amp;quot;username&amp;quot;,&#xA;      url: &amp;quot;http://www.baidu.com&amp;quot;,&#xA;      filename: &amp;quot;filters&amp;quot;,&#xA;      suffix: &amp;quot;js&amp;quot;,&#xA;    };&#xA;  },&#xA;  // 过滤器&#xA;  filters: {&#xA;    // 将字符串首字母转换为大写字母的过滤器&#xA;    capitalize: function (value) {&#xA;      if (!value) return &amp;quot;&amp;quot;;&#xA;      value = value.toString();&#xA;      return value.charAt(0).toUpperCase() + value.slice(1);&#xA;    },&#xA;    format: function (value, prefix, suffix) {&#xA;      if (!value) return &amp;quot;&amp;quot;;&#xA;      value = value.toString();&#xA;      return prefix + &amp;quot;-&amp;quot; + value + &amp;quot;.&amp;quot; + suffix;&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;组件&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;编写一个 Hello 全局组件（components/Hello.vue） &#xA;&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- 传递参数 --&amp;gt;&#xA;    &amp;lt;div&amp;gt;\{{ msg }}&amp;lt;/div&amp;gt;&#xA;    &amp;lt;!-- 插值(针对内容)：使用Mustache语法（双花括号）的文本插值绑定数据 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ message.toUpperCase() }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- v-bind(针对属性)：作用于HTML元素或组件元素的属性上 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;a v-bind:href=&amp;quot;url&amp;quot;&amp;gt;百度&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;a :href=&amp;quot;url&amp;quot;&amp;gt;百度&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 指令：指令是带有 v-前缀的特殊属性 --&amp;gt;&#xA;    &amp;lt;p v-html=&amp;quot;spanHtml&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ spanHtml }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;button v-on:click=&amp;quot;sayHello&amp;quot;&amp;gt;问候&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;sayHello&amp;quot;&amp;gt;问候&amp;lt;/button&amp;gt;&#xA;    &amp;lt;!-- 动态指令: 参数名字不要使用大写 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;a :[attribute]=&amp;quot;url&amp;quot;&amp;gt;百度&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  props: {&#xA;    msg: String,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;Hello, Vue.js&amp;quot;,&#xA;      url: &amp;quot;http://www.baidu.com&amp;quot;,&#xA;      spanHtml: &amp;quot;&amp;lt;span style=&#39;color: red&#39;&amp;gt;HTML 元素，红色字体&amp;lt;/span&amp;gt;&amp;quot;,&#xA;      attribute: &amp;quot;href&amp;quot;&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    sayHello() {&#xA;      alert(&amp;quot;你好&amp;quot;);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;使用 Hello 组件（App.vue）&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 可以使用 v-bind 绑定动态值 --&amp;gt;&#xA;    &amp;lt;Hello msg=&amp;quot;这是传递到组件的参数&amp;quot; /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;# 导入语句中的@符号表示 src 目录，该符号用于简化路径访问&#xA;import Hello from &amp;quot;@/components/Hello.vue&amp;quot;;&#xA;export default {&#xA;  name: &#39;Hello&#39;,&#xA;  components: {&#xA;    Hello&#xA;  }&#xA;}&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;组件传参（类型检查）&#xA;&#xA;什么是 prop：在 props 中定义的组件属性，可以通过 prop 向组件传递数据&#xA;&#xA;// 组件是当作自定义元素来使用的，而元素一般都是有属性的，同样，组件也可以有属性。&#xA;// 在使用组件时，给组件元素设置属性，组件内部如何接受呢？&#xA;// 首先需要在组件内部注册一些自定义的属性，称为 prop &#xA;// 这些 prop 是放在组件的 props 选项中定义的&#xA;// 在使用组件时，就可以把这些 prop 的名字作为元素的属性名来使用&#xA;// 通过属性向组件传递数据，这些数据将作为组件实例属性被使用&#xA;&#xA;// 验证的 type 可以是下列原生构造函数中的一个：&#xA;1. String&#xA;2. Number&#xA;3. Boolean&#xA;4. Array&#xA;5. Object&#xA;6. Date&#xA;7. Function&#xA;8. Symbol&#xA;&#xA;// Hello.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;\{{ msg }}&amp;lt;/div&amp;gt;&#xA;  &amp;lt;!-- 子组件向父组件发起通知或传递参数 --&amp;gt;&#xA;  &amp;lt;button v-on:click=&amp;quot;handleClick&amp;quot;&amp;gt;开始欢迎&amp;lt;/button&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Hello&amp;quot;,&#xA;  props: {&#xA;    // 类型检查&#xA;    msg: String,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      name: &amp;quot;张三&amp;quot;,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    handleClick() {&#xA;      // 子组件使用$emit()方法触发事件&#xA;      this.$emit(&amp;quot;greet&amp;quot;, this.name);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// HelloTwo.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;      &amp;lt;p&amp;gt;\{{ post.title }}&amp;lt;/p&amp;gt;&#xA;      &amp;lt;p&amp;gt;作者：\{{ post.author }}&amp;lt;/p&amp;gt;&#xA;      &amp;lt;p&amp;gt;\{{ post.content }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;HelloTwo&amp;quot;,&#xA;  // props: [&#39;post&#39;], // 不类型检查&#xA;  props: { // 类型检查&#xA;    post: {&#xA;      // 检查类型 ...&#xA;      type: Object,&#xA;      // 默认值 ...&#xA;      default: function () {&#xA;        return {};&#xA;      },&#xA;    },&#xA;  },&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue&#xA;&amp;lt;template&amp;gt;&#xA;    &amp;lt;!-- 组件 --&amp;gt;&#xA;    &amp;lt;!-- 只要组件注册是采用的是PascalCase(首字母大写)命名 --&amp;gt;&#xA;    &amp;lt;!-- 就可以采用kebab-case命名来引用 --&amp;gt;&#xA;    &amp;lt;Hello msg=&amp;quot;这是传递到组件的参数&amp;quot; /&amp;gt;&#xA;    &amp;lt;hello :msg=&amp;quot;message&amp;quot; /&amp;gt;&#xA;    &amp;lt;!-- 父组件通过prop向子组件传递数据 --&amp;gt;&#xA;    &amp;lt;HelloTwo :post=&amp;quot;post&amp;quot;&amp;gt;&amp;lt;/HelloTwo&amp;gt;&#xA;    &amp;lt;hello-two :post=&amp;quot;post&amp;quot;&amp;gt;&amp;lt;/hello-two&amp;gt;&#xA;    &amp;lt;!-- 监听子组件事件 --&amp;gt;&#xA;    &amp;lt;!-- 父组件使用v-on指令监听子组件的自定义事件 --&amp;gt;&#xA;    &amp;lt;hello v-on:greet=&amp;quot;sayHello&amp;quot;&amp;gt;&amp;lt;/hello&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Hello from &amp;quot;@/components/Hello.vue&amp;quot;;&#xA;import HelloTwo from &amp;quot;@/components/HelloTwo.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;Home&amp;quot;,&#xA;  methods: {&#xA;    textButton() {&#xA;      this.post.author = &amp;quot;测试完成&amp;quot;;&#xA;    },&#xA;    // 子组件的附加参数会自动传入方法&#xA;    sayHello(name) {&#xA;      alert(&amp;quot;Hello, &amp;quot; + name);&#xA;    },&#xA;  },&#xA;  components: {&#xA;    Hello,&#xA;    HelloTwo,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;这是传递到组件的参数&amp;quot;,&#xA;      post: {&#xA;        author: &amp;quot;孙鑫&amp;quot;,&#xA;        title: &amp;quot;Vue.js无难事&amp;quot;,&#xA;        content: &amp;quot;这本书不错&amp;quot;,&#xA;      },&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;练习(投票)&#xA;&#xA;// TouPiaoItem.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;li&amp;gt;&#xA;    &amp;lt;h3&amp;gt;\{{ post.title }}&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;      发帖人：\{{ post.author }} 发帖时间：\{{ post.date }} 投票数：\{{&#xA;        post.vote&#xA;      }}&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 子组件向父组件发起通知或传递参数 --&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;handleVote&amp;quot;&amp;gt;投票&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/li&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;TouPiaoItem&amp;quot;,&#xA;  props: [&amp;quot;post&amp;quot;],&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  methods: {&#xA;    handleVote() {&#xA;      // 子组件使用$emit()方法触发事件&#xA;      this.$emit(&amp;quot;vote&amp;quot;);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;    &amp;lt;ul&amp;gt;&#xA;      &amp;lt;tou-piao-item v-for=&amp;quot;post in posts&amp;quot; :key=&amp;quot;post.id&amp;quot; :post=&amp;quot;post&amp;quot; @vote=&amp;quot;handleVote(post.id)&amp;quot;&amp;gt;&amp;lt;/tou-piao-item&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import TouPiaoItem from &amp;quot;@/components/TouPiaoItem.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  methods: {&#xA;    // 父组件接收传出来的值&#xA;    handleVote(id) {&#xA;      this.posts.map((item) =&amp;gt; {&#xA;        item.id === id ? { ...item, voite: ++item.vote } : item;&#xA;      });&#xA;    },&#xA;  },&#xA;  components: {&#xA;    TouPiaoItem,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      // 父组件数据，传入子组件供子组件显示 ...&#xA;      posts: [&#xA;        {&#xA;          id: 1,&#xA;          title: &amp;quot;这是第一本书&amp;quot;,&#xA;          author: &amp;quot;第一位&amp;quot;,&#xA;          date: &amp;quot;2020/11/16&amp;quot;,&#xA;          vote: 0,&#xA;        },&#xA;        {&#xA;          id: 2,&#xA;          title: &amp;quot;这是第二本书&amp;quot;,&#xA;          author: &amp;quot;第二位&amp;quot;,&#xA;          date: &amp;quot;2020/11/17&amp;quot;,&#xA;          vote: 0,&#xA;        },&#xA;        {&#xA;          id: 3,&#xA;          title: &amp;quot;这是第三本书&amp;quot;,&#xA;          author: &amp;quot;第三位&amp;quot;,&#xA;          date: &amp;quot;2020/11/18&amp;quot;,&#xA;          vote: 0,&#xA;        },&#xA;        {&#xA;          id: 4,&#xA;          title: &amp;quot;这是第四本书&amp;quot;,&#xA;          author: &amp;quot;第四位&amp;quot;,&#xA;          date: &amp;quot;2020/11/19&amp;quot;,&#xA;          vote: 0,&#xA;        },&#xA;      ],&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.sync 修饰符&#xA;&#xA;// 在一些情况下，可能需要对一个组件的prop进行双向绑定&#xA;// Vue.js 推荐以 update:myPropName 模式触发事件来实现&#xA;&#xA;// Child.vue    &#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;span&amp;gt;计数：\{{ count }}&amp;lt;/span&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;handleClick&amp;quot;&amp;gt;增加计数&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Child&amp;quot;,&#xA;  props: {&#xA;    // Prop的Name是vla&#xA;    val: {&#xA;      type: Number,&#xA;      default: 0,&#xA;    },&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      // 避免直接改变属性，因为每当父组件重新渲染时，该值都将被覆盖&#xA;      // 所以这里把 val 赋值给 count &#xA;      count: this.val,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    handleClick() {&#xA;      // 子组件使用$emit()方法触发事件&#xA;      this.$emit(&amp;quot;update:val&amp;quot;, ++this.count);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;span&amp;gt;计数器的值：\{{ counter }}&amp;lt;/span&amp;gt;&#xA;    // 使用 v-on 指令监听 update:val 事件，接收子组件传来的数据&#xA;    // 使用 v-bind 指令绑定子组件的 val prop 就可以给子组件传递父组件的数据&#xA;    &amp;lt;child v-bind:val=&amp;quot;counter&amp;quot; v-on:update:val=&amp;quot;counter = $event&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;&#xA;    // .sync 修饰符只是简化了 v-bind 和 v-on 指令的使用 ...&#xA;    &amp;lt;child v-bind:val.sync=&amp;quot;counter&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Child from &amp;quot;./components/Child.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  methods: {},&#xA;  components: {&#xA;    Child,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      counter: 0,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;自定义组件的 v-model&#xA;&#xA;// 当修改父组件message时子组件props.value也随之更改&#xA;// 这是因为，在默认情况下，一个组件上的 ...&#xA;// v-model 会把 value 作为 prop，把 input 事件作为 event&#xA;&#xA;// MyInput.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;label&amp;gt;\{{ value }}&amp;lt;/label&amp;gt;&#xA;    &amp;lt;!-- 绑定value并且在发生input时调用handleInput传递$event --&amp;gt;&#xA;    &amp;lt;input :value=&amp;quot;value&amp;quot; @input=&amp;quot;handleInput($event)&amp;quot; /&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;MyInput&amp;quot;,&#xA;  props: {&#xA;    value: String,&#xA;  },&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  methods: {&#xA;    handleInput(event) {&#xA;      // 使用$emit()方法触发事件，父组件使用v-on监听&#xA;      this.$emit(&amp;quot;input&amp;quot;, event.target.value);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;my-input v-model=&amp;quot;message&amp;quot;&amp;gt;&amp;lt;/my-input&amp;gt;&#xA;    &amp;lt;!-- 等价于 --&amp;gt;&#xA;    &amp;lt;my-input :value=&amp;quot;message&amp;quot; v-on:input=&amp;quot;message = $event&amp;quot;&amp;gt;&amp;lt;/my-input&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import MyInput from &amp;quot;./components/MyInput.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  components: {&#xA;    MyInput,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;Vue.js 无难事&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;model 选项 (相当于声明属性改名)&#xA;&#xA;// CheckBox.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;input&#xA;      type=&amp;quot;checkbox&amp;quot;&#xA;      :checked=&amp;quot;checked&amp;quot;&#xA;      @change=&amp;quot;$emit(&#39;change&#39;, $event.target.checked)&amp;quot;&#xA;    /&amp;gt;&#xA;    &amp;lt;label&amp;gt;\{{ value }}&amp;lt;/label&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;CheckBox&amp;quot;,&#xA;  model: {&#xA;    // 使用 checked 替换 value 作为 prop&#xA;    prop: &#39;checked&#39;,&#xA;    event: &#39;change&#39;,&#xA;  },&#xA;  props: {&#xA;    // 这里的 value prop 可以用于不同的目的&#xA;    value: String,&#xA;    // 使用 checked 替换 value 作为 prop&#xA;    checked: {&#xA;      type: Boolean,&#xA;      default: false,&#xA;    },&#xA;  },&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    // 此时，isAgree的值将会传入名为checked的prop&#xA;    // 同时，当CheckBox触发change事件并附带一个新的值时，isAgree属性将会被更新&#xA;    // 注意，在组件的model选项中声明了prop后，依然需要在props选项里声明这个prop&#xA;    &amp;lt;check-box v-model=&amp;quot;isAgree&amp;quot; value=&amp;quot;同意协议&amp;quot;&amp;gt;&amp;lt;/check-box&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import CheckBox from &amp;quot;./components/CheckBox.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  components: {&#xA;    CheckBox,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      isAgree: false,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;实例 ComboBox&#xA;&#xA;// ComboBox.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;dev&amp;gt;&#xA;    &amp;lt;table&amp;gt;&#xA;      &amp;lt;tr&amp;gt;&#xA;        &amp;lt;td&amp;gt;\{{ label }}&amp;lt;/td&amp;gt;&#xA;      &amp;lt;/tr&amp;gt;&#xA;      &amp;lt;tr&amp;gt;&#xA;        &amp;lt;td&amp;gt;&#xA;          &amp;lt;input :value=&amp;quot;value&amp;quot; @change=&amp;quot;handleChange($event)&amp;quot; /&amp;gt;&#xA;        &amp;lt;/td&amp;gt;&#xA;        &amp;lt;select :value=&amp;quot;value&amp;quot; @change=&amp;quot;handleChange($event)&amp;quot;&amp;gt;&#xA;          &amp;lt;option disabled value=&amp;quot;&amp;quot;&amp;gt;请选择&amp;lt;/option&amp;gt;&#xA;          &amp;lt;option v-for=&amp;quot;item in list&amp;quot; v-bind:key=&amp;quot;item&amp;quot;&amp;gt;&#xA;            \{{ item }}&#xA;          &amp;lt;/option&amp;gt;&#xA;        &amp;lt;/select&amp;gt;&#xA;      &amp;lt;/tr&amp;gt;&#xA;    &amp;lt;/table&amp;gt;&#xA;  &amp;lt;/dev&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;ComboBox&amp;quot;,&#xA;  props: {&#xA;    label: String,&#xA;    value: String,&#xA;    list: {&#xA;      type: Array,&#xA;      default: function () {&#xA;        return [];&#xA;      },&#xA;    },&#xA;  },&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  model: {&#xA;    event: &amp;quot;change&amp;quot;,&#xA;  },&#xA;  methods: {&#xA;    handleChange(event) {&#xA;      this.$emit(&amp;quot;change&amp;quot;, event.target.value);&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;combo-box&#xA;      label=&amp;quot;请选择了解信息的渠道&amp;quot;&#xA;      :list=&amp;quot;[&#39;报纸&#39;, &#39;网络&#39;, &#39;朋友介绍&#39;]&amp;quot;&#xA;      v-model=&amp;quot;selectedVal&amp;quot;&#xA;    &amp;gt;&amp;lt;/combo-box&amp;gt;&#xA;    &amp;lt;span&amp;gt;选中的值是：\{{ selectedVal }}&amp;lt;/span&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import ComboBox from &amp;quot;./components/ComboBox.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  components: {&#xA;    ComboBox,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;      selectedVal: &amp;quot;&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用插槽分发内容&#xA;&#xA;// 组件是当作自定义元素来使用的，元素可以有属性和内容&#xA;// 通过组件定义的prop来接收属性值，可以解决属性问题&#xA;// 那么内容呢？这可以通过&amp;lt;slot&amp;gt;元素来解决 ...&#xA;// 插槽(slot)也可以作为父子组件之间通信的另一种实现方式&#xA;&#xA;// 编译作用域，下列name的作用域是父组件&#xA;// &amp;lt;greeting&amp;gt;Hello, \{{name}}&amp;lt;/greeting&amp;gt;&#xA;&#xA;// 父组件模版中的所有内容都是在父作用域内编译&#xA;// 子组件模版中的所有内容都是在子作用域内编译&#xA;&#xA;// 缺省内容：可以给&amp;lt;slot&amp;gt;元素指定一个缺省内容&#xA;// 以防止组件的使用者没有给该组件传递内容 ...&#xA;&#xA;// 可以通过命名插槽来使用多个插槽 ...&#xA;// 没有使用name属性的&amp;lt;slot&amp;gt;元素具有隐含名称default&#xA;&#xA;// v-slot 指令也有缩写语法，既用#号来替换 v-slot&#xA;// &amp;lt;template #default&amp;gt; ...&#xA;&#xA;// Greeting.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;dev&amp;gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&amp;lt;/dev&amp;gt;&#xA;  &amp;lt;!-- 缺省内容 --&amp;gt;&#xA;  &amp;lt;slot&amp;gt;这里是缺省内容&amp;lt;/slot&amp;gt;&#xA;  &amp;lt;!-- 命名插槽 --&amp;gt;&#xA;  &amp;lt;slot name=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/slot&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Greeting&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 父组件的内容会替换子组件&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;的内容 --&amp;gt;&#xA;    &amp;lt;greeting&amp;gt;Hello Vue.js&amp;lt;/greeting&amp;gt;&#xA;    &amp;lt;!-- 使用命名插槽 --&amp;gt;&#xA;    &amp;lt;greeting&amp;gt;&#xA;      &amp;lt;template v-slot:content&amp;gt;&#xA;        &amp;lt;h1&amp;gt;这里是头部内容&amp;lt;/h1&amp;gt;&#xA;      &amp;lt;/template&amp;gt;&#xA;    &amp;lt;/greeting&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Greeting from &#39;./components/Greeting.vue&#39;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  components: {&#xA;    Greeting,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;作用域插槽(prop)&#xA;&#xA;// 在父级作用域下，在插槽的内容中是无法访问到子组件的数据属性&#xA;// 但有时候需要在父级的插槽内容中访问子组件的数据 ...&#xA;// 为此，可以在子组件的&amp;lt;slot&amp;gt;元素上使用v-bind指定绑定一个prop&#xA;&#xA;// 1. 在子组件插槽中v-bind(绑定)要在父组件插槽中访问的数据(键:值)&#xA;// 2. 在父组件插槽中就可以通过v-slot(键:值)来访问子组件数据&#xA;&#xA;// MyButton.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;    &amp;lt;button&amp;gt;&#xA;        &amp;lt;slot v-bind:values=&amp;quot;titles&amp;quot;&amp;gt;\{{titles.login}}&amp;lt;/slot&amp;gt;&#xA;    &amp;lt;/button&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;MyButton&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      titles: {&#xA;        login: &amp;quot;登录&amp;quot;,&#xA;        register: &amp;quot;注册&amp;quot;,&#xA;      },&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;my-button&amp;gt;&#xA;      &amp;lt;template v-slot:default=&amp;quot;slotProps&amp;quot;&amp;gt;&#xA;        \{{slotProps.values.register}}&#xA;      &amp;lt;/template&amp;gt;&#xA;    &amp;lt;/my-button&amp;gt;&#xA;    &amp;lt;!-- 统一测试 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&amp;lt;button @click=&amp;quot;textButton&amp;quot;&amp;gt;测试按钮&amp;lt;/button&amp;gt;&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import MyButton from &#39;./components/MyButton.vue&#39;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  components: {&#xA;    MyButton&#xA;  },&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;动态组件&#xA;&#xA;// 在页面应用程序中，经常会遇到多标签页面，在Vue.js中，可以通过动态组件来实现&#xA;// 组件的动态切换通过在&amp;lt;component&amp;gt;元素上使用is属性来实现 ...&#xA;&#xA;// 当点击某个按钮时，会触发更改数据属性(currentTab)值&#xA;// 这将导致计算属性currentTabComponent被触发返回新的值&#xA;// &amp;lt;component&amp;gt;元素的is属性使用v-bind指令绑定到一个已注册组件的名字上&#xA;// 随着currentTabComponent值的改变，组件也就自动切换了 ...&#xA;&#xA;// TabComment.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;p&amp;gt;这是一本好书&amp;lt;/p&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;TabComment&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// TabIntroduce.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;p&amp;gt;&amp;lt;input v-model=&amp;quot;content&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;TabIntroduce&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      content: &amp;quot;Vue.js 无难事&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// TabQa.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;p&amp;gt;有人看过吗？怎么样&amp;lt;/p&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;TabQa&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;button&#xA;      v-for=&amp;quot;tab in tabs&amp;quot;&#xA;      :key=&amp;quot;tab.title&amp;quot;&#xA;      :class=&amp;quot;[&#39;tab-button&#39;, { active: currentTab === tab.title }]&amp;quot;&#xA;      @click=&amp;quot;currentTab = tab.title&amp;quot;&#xA;    &amp;gt;&#xA;      \{{ tab.displayName }}&#xA;    &amp;lt;/button&amp;gt;&#xA;    &amp;lt;componentcomponent :is=&amp;quot;currentTabComponent&amp;quot; class=&amp;quot;tab&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import TabComment from &amp;quot;./components/TabComment.vue&amp;quot;;&#xA;import TabIntroduce from &amp;quot;./components/TabIntroduce.vue&amp;quot;;&#xA;import TabQa from &amp;quot;./components/TabQa.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  components: { TabComment, TabIntroduce, TabQa },&#xA;  data() {&#xA;    return {&#xA;      currentTab: &amp;quot;introduce&amp;quot;,&#xA;      tabs: [&#xA;        { title: &amp;quot;introduce&amp;quot;, displayName: &amp;quot;图书介绍&amp;quot; },&#xA;        { title: &amp;quot;comment&amp;quot;, displayName: &amp;quot;图书评价&amp;quot; },&#xA;        { title: &amp;quot;qa&amp;quot;, displayName: &amp;quot;图书问答&amp;quot; },&#xA;      ],&#xA;    };&#xA;  },&#xA;  // 计算属性&#xA;  computed: {&#xA;    currentTabComponent: function () {&#xA;      return &amp;quot;tab-&amp;quot; + this.currentTab;&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;组件的生命周期&#xA;&#xA;1. beforeCreate &#xA;2. created&#xA;3. beforeMount&#xA;4. mounted&#xA;5. beforeUpdate&#xA;6. updated&#xA;7. activated&#xA;8. deactivated&#xA;9. beforeDestroy&#xA;10. destroyed&#xA;11. errorCaptured&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;混入(mixin) 提供了一种非常灵活的方式，来分发Vue组件中的可复用功能&#xA;&#xA;// 混入就是在一个公共的实例中写入公共的数据或者方法&#xA;// 也就是说你在export default {}里边的内容都可以混入&#xA;&#xA;// 一个混入对象可以包含任意组件选项，当组件使用混入对象时&#xA;// 所有混入对象的选项将被&amp;quot;混合&amp;quot;进入该组件本身的选项。&#xA;&#xA;// components/mixin/mixin.js 混入对象&#xA;&#xA;// 默认混入对象&#xA;export default {&#xA;    created() {&#xA;        this.startMixin()&#xA;    },&#xA;    methods: {&#xA;        startMixin: function () {&#xA;            document.write(&#39;欢迎来到混入实例&#39;)&#xA;            console.log(&amp;quot;欢迎来到混入实例&amp;quot;)&#xA;        }&#xA;    },&#xA;    data() {&#xA;        return {&#xA;            isNoData: false,&#xA;            isShowLoding: true,&#xA;            title: &amp;quot;这是混入内的数据&amp;quot;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// 命名混入对象&#xA;export let myMixin = {&#xA;    created() {&#xA;        this.startMixin()&#xA;    },&#xA;    methods: {&#xA;        startMixin: function () {&#xA;            document.write(&#39;欢迎来到混入实例&#39;)&#xA;            console.log(&amp;quot;欢迎来到混入实例&amp;quot;)&#xA;        }&#xA;    },&#xA;    data() {&#xA;        return {&#xA;            isNoData: false,&#xA;            isShowLoding: true,&#xA;            title: &amp;quot;这是混入内的数据&amp;quot;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// App.vue &#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- title 是混入内的数据 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{title}}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- message 是当前组件内的数据 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;\{{ message }}&amp;lt;/p&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;&amp;lt;!-- 在需要混入的组件中把这个mixin引入 --&amp;gt;&#xA;&amp;lt;!-- 引入默认混入对象 --&amp;gt;&#xA;import mixin from &#39;@/components/mixin/mixin.js&#39;&#xA;&amp;lt;!-- 引入命名混入对象 --&amp;gt;&#xA;import {myMixin} from &amp;quot;@/components/mixin/mixin.js&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  mixins: [mixin], // 默认&#xA;  mixins: [myMixin], // 命名&#xA;  data() {&#xA;    return {&#xA;        message: &amp;quot;Vue.js 无难事&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;混入(mixin) 选项合并&#xA;&#xA;// 当混入对象和组件本身包含同名的选项时，这些选项将以下面的策略进行合并&#xA;// 1. 数据对象进行递归合并，在发生冲突时以组件的数据优先&#xA;// 2. 同名的钩子函数被合并到一个数据中，因此这些函数都会被调用&#xA;// 2.1 另外，混入对象的钩子将在组件自身钩子之前调用&#xA;// 3. 值为对象的选项，如 methods、components 和 directives&#xA;// 3.1 将会被合并为同一个对象，当这些对象中存在冲突的键名时，以组件的选项优先&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;混入(mixin) 全局混入&#xA;&#xA;// 混入也可以进行全局注册，这是通过调用Vue.mixin()方法来实现的。&#xA;// 不过全局注册混入对象很危险，因为它会影响随后创建的每个Vue实例&#xA;&#xA;// index.js&#xA;const myMixin = {&#xA;    data() {&#xA;        return {&#xA;            isNoData: false,&#xA;            isShowLoding: true&#xA;        }&#xA;    }&#xA;}&#xA;export default myMixin;&#xA;&#xA;// main.js&#xA;import MinXin from &#39;@/components/MinXins/index.js&#39;&#xA;Vue.mixin(MinXin);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;组件通信的其它方式&#xA;&#xA;// 总结一下前面介绍的组件通信的三种方式：&#xA;// 1. 父组件通过prop向子组件传递数据&#xA;// 2. 子组件通过自定义事件向父组件发起通知或进行数据传递&#xA;// 3. 子组件通过&amp;lt;slot&amp;gt;元素充当占位符，获取父组件分发的内容&#xA;// 3.1 也可以在子组件的&amp;lt;slot&amp;gt;元素上使用v-bind指令绑定一个插槽prop，向父组件提供数据&#xA;&#xA;// 在每一个new Vue实例的子组件中，都可以通过$root属性来访问根实例&#xA;// 对于 Vue Cli 来说 $root 访问的是 main.js 中 new Vue 的根实例&#xA;&#xA;// $root 属性来访问根实例&#xA;// $parent 属性来访问父组件实例&#xA;&#xA;// Child.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;accessRoot&amp;quot;&amp;gt;访问根实例&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Child&amp;quot;,&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  methods: {&#xA;    accessRoot() {&#xA;      console.log(&amp;quot;单价：&amp;quot; + this.$parent.price);&#xA;      console.log(&amp;quot;总价：&amp;quot; + this.$parent.totalPrice);&#xA;      console.log(this.$parent.hello());&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;child&amp;gt;&amp;lt;/child&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Child from &#39;./components/Child.vue&#39;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  methods: {&#xA;    hello() {&#xA;      return &amp;quot;Hello, Vue.js 无难事&amp;quot;;&#xA;    },&#xA;  },&#xA;  components: {Child},&#xA;  data() {&#xA;    return {&#xA;      price: 98,&#xA;    };&#xA;  },&#xA;  computed: {&#xA;    totalPrice() {&#xA;      return this.price * 10;&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;访问子组件实例或者子组件元素&#xA;&#xA;// 如果父组件要访问子组件实例怎么办？&#xA;// 可以给子组件或子元素添加一个特殊的属性ref&#xA;// 为子组件或子元素分配一个引用ID&#xA;// 然后父组件就可以通过$refs属性来访问子组件实例或元素&#xA;&#xA;// Child.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;p&amp;gt;\{{ message }}&amp;lt;/p&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Child&amp;quot;,&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;Vue.js 无难事&amp;quot;,&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// Parent.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;!-- 子元素 --&amp;gt;&#xA;    &amp;lt;input ref=&amp;quot;inputElement&amp;quot; /&amp;gt;&amp;lt;br /&amp;gt;&#xA;    &amp;lt;!-- 子组件 --&amp;gt;&#xA;    &amp;lt;child ref=&amp;quot;childComponent&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Child from &amp;quot;./Child.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;Parent&amp;quot;,&#xA;  components: { Child },&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;  mounted() {&#xA;    &amp;lt;!-- 访问了&amp;lt;input&amp;gt;组件的focus元素 --&amp;gt;&#xA;    this.$refs.inputElement.focus();&#xA;    &amp;lt;!-- 访问了&amp;lt;child&amp;gt;子组件的message数据 --&amp;gt;&#xA;    console.log(this.$refs.childComponent.message);&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;parent&amp;gt;&amp;lt;/parent&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Parent from &#39;./components/Parent.vue&#39;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  methods: {&#xA;  components: {Parent},&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;依赖注入&#xA;&#xA;// $root 属性用于访问根实例&#xA;// $parent 属性用于访问父组件实例&#xA;&#xA;// 如果组件嵌套的层级不确定，某个组件的数据或方法需要被后代组件所访问，又该如何实现呢？&#xA;// 这时需要用到两个新的实例选项：provide 和 inject&#xA;&#xA;// provide 选项允许我们指定要提供给后代组件的数据或方法&#xA;// 在后代组件中使用 inject 选项来接收要添加到该实例中的特定属性&#xA;&#xA;// Child.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;p&amp;gt;\{{ message }}&amp;lt;/p&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Child&amp;quot;,&#xA;  inject: [&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;],&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;child&amp;gt;&amp;lt;/child&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Child from &amp;quot;./components/Child.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  provide() {&#xA;    return {&#xA;      // 数据属性message和sayHello方法可供后代组件访问&#xA;      message: &amp;quot;Vue.js 无难事 ...&amp;quot;,&#xA;      hello: this.sayHello(&amp;quot;nulijiabei&amp;quot;),&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    sayHello(name) {&#xA;      console.log(&amp;quot;Hello, &amp;quot; + name);&#xA;    },&#xA;  },&#xA;  components: { Child },&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;手动监听事件&#xA;&#xA;// 已经介绍过$emit的方法，它用于触发当前实例事件，触发的时间可以被v-on指令监听&#xA;// Vue 还提供了以下三个事件方法，让我们能够以编程的方式手动对自定义事件进行监听&#xA;&#xA;// 1. 监听当前实例上的自定义事件，事件可以由vm.$emit触发&#xA;//    $on(eventName, eventHandler)&#xA;// 2. 监听一个自定义事件，但是触发一次，一旦触发之后，监听器就会被删除&#xA;//    $once(eventName, eventHandler)&#xA;// 3. 删除自定义事件监听器&#xA;//    $off(eventName, eventHandler)&#xA;&#xA;// 也就是，监听当前组件中由$emit触发的事件&#xA;&#xA;// Child.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;button @click=&amp;quot;handleClick&amp;quot;&amp;gt;手动监听事件&amp;lt;/button&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  name: &amp;quot;Child&amp;quot;,&#xA;  created() {&#xA;    // 监听当前实例的greet事件&#xA;    this.$on(&amp;quot;greet&amp;quot;, function () {&#xA;      this.$parent.sayHello();&#xA;    });&#xA;  },&#xA;  beforeDestroy() {&#xA;    // 删除greet事件的所有监听器&#xA;    this.$off(&amp;quot;greet&amp;quot;);&#xA;  },&#xA;  methods: {&#xA;    // 按钮绑定函数&#xA;    handleClick() {&#xA;      // 触发自定义事件greet&#xA;      this.$emit(&amp;quot;greet&amp;quot;);&#xA;    },&#xA;  },&#xA;  data() {&#xA;    return {};&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;child&amp;gt;&amp;lt;/child&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import Child from &amp;quot;./components/Child.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  methods: {&#xA;    sayHello() {&#xA;      alert(&amp;quot;Hello, Vue.js&amp;quot;);&#xA;    },&#xA;  },&#xA;  components: { Child },&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;异步更新队列&#xA;&#xA;// 当单机&amp;quot;修改内容&amp;quot;按钮时，修改组件message数据属性的值&#xA;// 然后使用$refs访问&amp;lt;p&amp;gt;元素内容并在控制台窗口中输出 ...&#xA;&#xA;// 当单机&amp;quot;修改内容&amp;quot;按钮时 ...&#xA;// 希望 this.$refs.msg.textContent 内容为 &amp;quot;VC++ 深入详解&amp;quot;&#xA;// 但实际上 this.$refs.msg.textContent 内容却是 &amp;quot;Vue.js 无难事&amp;quot;&#xA;&#xA;// 这是因为Vue在数据变化需要更新DOM时并不是同步执行，而是异步执行&#xA;// 每当侦听到数据更改时，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更&#xA;// 如果同一个观察者被多次触发，只会将其放入队列中一次，Vue在缓冲时会去除重复数据 ...&#xA;// 然后在下一个时间循环tick中，Vue刷新队列并执行实际的而工作 ...&#xA;&#xA;// 当在change()方法中修改message属性值的时候，该组件不会立即重新渲染&#xA;// 当队列刷新时，组件会在下一个tick中更新，多数情况下不需要更新这个过程&#xA;// 当时如果想在数据更改后立即访问更新后的DOM，这时就需要nextTick(callback)方法&#xA;// 传递给nextTick()方法的回调函数会在DOM更新完成后被调用 ...&#xA;&#xA;// MyComponent.vue 子组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div&amp;gt;&#xA;    &amp;lt;p ref=&amp;quot;msg&amp;quot;&amp;gt;\{{ message }}&amp;lt;/p&amp;gt;&#xA;    &amp;lt;button @click=&amp;quot;change&amp;quot;&amp;gt;修改内容&amp;lt;/button&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;export default {&#xA;  data() {&#xA;    return {&#xA;      message: &amp;quot;Vue.js 无难事&amp;quot;,&#xA;    };&#xA;  },&#xA;  methods: {&#xA;    change() {&#xA;      this.message = &amp;quot;VC++ 深入详解&amp;quot;;&#xA;      console.log(this.$refs.msg.textContent);&#xA;      // 传递给nextTick()方法的回调函数会在DOM更新完成后被调用&#xA;      this.$nextTick(() =&amp;gt; console.log(this.$refs.msg.textContent));&#xA;    },&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&#xA;// App.vue 父组件&#xA;&amp;lt;template&amp;gt;&#xA;  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;    &amp;lt;my-component&amp;gt;&amp;lt;/my-component&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;&amp;lt;/template&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;import MyComponent from &amp;quot;./components/MyComponent.vue&amp;quot;;&#xA;export default {&#xA;  name: &amp;quot;App&amp;quot;,&#xA;  components: {&#xA;    MyComponent,&#xA;  },&#xA;  data() {&#xA;    return {&#xA;    };&#xA;  },&#xA;};&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之DRM截图方案</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8BDRM%E6%88%AA%E5%9B%BE%E6%96%B9%E6%A1%88/</link>
      <pubDate>2020-11-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Linux之DRM截图方案&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 该方案来自 google chromium&#xA;https://chromium-review.googlesource.com/c/chromiumos/platform/factory/+/367611&#xA;&#xA;// 需要安装 ...&#xA;apt-get install python-pip&#xA;pip install pillow&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Copyright 2016 The Chromium OS Authors. All rights reserved.&#xA;# Use of this source code is governed by a BSD-style license that can be&#xA;# found in the LICENSE file.&#xA;&#xA;&amp;quot;&amp;quot;&amp;quot;DRM library wrapper.&#xA;&#xA;Based on:&#xA;  third_party/autotest/files/client/cros/graphics/drm.py&#xA;&#xA;A wrapper around the Direct Rendering Manager (DRM) library, which itself is a&#xA;wrapper around the Direct Rendering Interface (DRI) between the kernel and&#xA;userland.&#xA;&#xA;Since we are masochists, we use ctypes instead of cffi to load libdrm and&#xA;access several symbols within it. We use Python&#39;s file descriptor and mmap&#xA;wrappers.&#xA;&#xA;At some point in the future, cffi could be used, for approximately the same&#xA;cost in lines of code.&#xA;&amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;from ctypes import *&#xA;import mmap&#xA;import os&#xA;import tempfile&#xA;&#xA;from PIL import Image&#xA;&#xA;&#xA;class DrmVersion(Structure):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    The version of a DRM node.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    _fields_ = [&#xA;    (&amp;quot;version_major&amp;quot;, c_int),&#xA;    (&amp;quot;version_minor&amp;quot;, c_int),&#xA;    (&amp;quot;version_patchlevel&amp;quot;, c_int),&#xA;    (&amp;quot;name_len&amp;quot;, c_int),&#xA;    (&amp;quot;name&amp;quot;, c_char_p),&#xA;    (&amp;quot;date_len&amp;quot;, c_int),&#xA;    (&amp;quot;date&amp;quot;, c_char_p),&#xA;    (&amp;quot;desc_len&amp;quot;, c_int),&#xA;    (&amp;quot;desc&amp;quot;, c_char_p),&#xA;    ]&#xA;&#xA;    _l = None&#xA;&#xA;    def __repr__(self):&#xA;    return &amp;quot;%s %d.%d.%d (%s) (%s)&amp;quot; % (&#xA;        self.name,&#xA;        self.version_major,&#xA;        self.version_minor,&#xA;        self.version_patchlevel,&#xA;        self.desc,&#xA;        self.date,&#xA;    )&#xA;&#xA;    def __del__(self):&#xA;    if self._l:&#xA;        self._l.drmFreeVersion(self)&#xA;&#xA;&#xA;class DrmModeResources(Structure):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Resources associated with setting modes on a DRM node.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    _fields_ = [&#xA;    (&amp;quot;count_fbs&amp;quot;, c_int),&#xA;    (&amp;quot;fbs&amp;quot;, POINTER(c_uint)),&#xA;    (&amp;quot;count_crtcs&amp;quot;, c_int),&#xA;    (&amp;quot;crtcs&amp;quot;, POINTER(c_uint)),&#xA;    # XXX incomplete struct!&#xA;    ]&#xA;&#xA;    _fd = None&#xA;    _l = None&#xA;&#xA;    def __repr__(self):&#xA;    return &amp;quot;&amp;lt;DRM mode resources&amp;gt;&amp;quot;&#xA;&#xA;    def __del__(self):&#xA;    if self._l:&#xA;        self._l.drmModeFreeResources(self)&#xA;&#xA;    def getCrtc(self, index):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Obtain the CRTC at a given index.&#xA;&#xA;    @param index: The CRTC to get.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    if not 0 &amp;lt;= index &amp;lt; self.count_crtcs:&#xA;        raise IndexError(&amp;quot;CRTC index out of range&amp;quot;)&#xA;&#xA;    crtc = self._l.drmModeGetCrtc(self._fd, self.crtcs[index]).contents&#xA;    crtc._fd = self._fd&#xA;    crtc._l = self._l&#xA;    return crtc&#xA;&#xA;&#xA;class DrmModeCrtc(Structure):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    A DRM modesetting CRTC.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    _fields_ = [&#xA;    (&amp;quot;crtc_id&amp;quot;, c_uint),&#xA;    (&amp;quot;buffer_id&amp;quot;, c_uint),&#xA;    # XXX incomplete struct!&#xA;    ]&#xA;&#xA;    _fd = None&#xA;    _l = None&#xA;&#xA;    def __repr__(self):&#xA;    return &amp;quot;&amp;lt;CRTC (%d)&amp;gt;&amp;quot; % self.crtc_id&#xA;&#xA;    def __del__(self):&#xA;    if self._l:&#xA;        self._l.drmModeFreeCrtc(self)&#xA;&#xA;    def hasFb(self):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Whether this CRTC has an associated framebuffer.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    return self.buffer_id != 0&#xA;&#xA;    def fb(self):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Obtain the framebuffer, if one is associated.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    if self.hasFb():&#xA;        fb = self._l.drmModeGetFB(self._fd, self.buffer_id).contents&#xA;        fb._fd = self._fd&#xA;        fb._l = self._l&#xA;        return fb&#xA;&#xA;&#xA;class drm_mode_map_dumb(Structure):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Request a mapping of a modesetting buffer.&#xA;&#xA;    The map will be &amp;quot;dumb;&amp;quot; it will be accessible via mmap() but very slow.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    _fields_ = [&#xA;    (&amp;quot;handle&amp;quot;, c_uint),&#xA;    (&amp;quot;pad&amp;quot;, c_uint),&#xA;    (&amp;quot;offset&amp;quot;, c_ulonglong),&#xA;    ]&#xA;&#xA;&#xA;# This constant is not defined in any one header; it is the pieced-together&#xA;# incantation for the ioctl that performs dumb mappings. I would love for this&#xA;# to not have to be here, but it can&#39;t be imported from any header easily.&#xA;DRM_IOCTL_MODE_MAP_DUMB = 0xc01064b3&#xA;&#xA;&#xA;class DrmModeFB(Structure):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    A DRM modesetting framebuffer.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    _fields_ = [&#xA;    (&amp;quot;fb_id&amp;quot;, c_uint),&#xA;    (&amp;quot;width&amp;quot;, c_uint),&#xA;    (&amp;quot;height&amp;quot;, c_uint),&#xA;    (&amp;quot;pitch&amp;quot;, c_uint),&#xA;    (&amp;quot;bpp&amp;quot;, c_uint),&#xA;    (&amp;quot;depth&amp;quot;, c_uint),&#xA;    (&amp;quot;handle&amp;quot;, c_uint),&#xA;    ]&#xA;&#xA;    _l = None&#xA;    _map = None&#xA;&#xA;    def __repr__(self):&#xA;    s = &amp;quot;&amp;lt;Framebuffer (%dx%d (pitch %d bytes), %d bits/pixel, depth %d)&amp;quot;&#xA;    vitals = s % (&#xA;        self.width,&#xA;        self.height,&#xA;        self.pitch,&#xA;        self.bpp,&#xA;        self.depth,&#xA;    )&#xA;    if self._map:&#xA;        tail = &amp;quot; (mapped)&amp;gt;&amp;quot;&#xA;    else:&#xA;        tail = &amp;quot;&amp;gt;&amp;quot;&#xA;    return vitals + tail&#xA;&#xA;    def __del__(self):&#xA;    if self._l:&#xA;        self._l.drmModeFreeFB(self)&#xA;&#xA;    def map(self):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Map the framebuffer.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    if self._map:&#xA;        return&#xA;&#xA;    mapDumb = drm_mode_map_dumb()&#xA;    mapDumb.handle = self.handle&#xA;&#xA;    rv = self._l.drmIoctl(self._fd, DRM_IOCTL_MODE_MAP_DUMB,&#xA;        pointer(mapDumb))&#xA;    if rv:&#xA;        raise IOError(rv, os.strerror(rv))&#xA;&#xA;    size = self.pitch * self.height&#xA;&#xA;    # mmap.mmap() has a totally different order of arguments in Python&#xA;    # compared to C; check the documentation before altering this&#xA;    # incantation.&#xA;    self._map = mmap.mmap(self._fd, size, flags=mmap.MAP_SHARED,&#xA;        prot=mmap.PROT_READ, offset=mapDumb.offset)&#xA;&#xA;    def unmap(self):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Unmap the framebuffer.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    if self._map:&#xA;        self._map.close()&#xA;        self._map = None&#xA;&#xA;&#xA;def loadDRM():&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Load a handle to libdrm.&#xA;&#xA;    In addition to loading, this function also configures the argument and&#xA;    return types of functions.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    l = cdll.LoadLibrary(&amp;quot;libdrm.so&amp;quot;)&#xA;&#xA;    l.drmGetVersion.argtypes = [c_int]&#xA;    l.drmGetVersion.restype = POINTER(DrmVersion)&#xA;&#xA;    l.drmFreeVersion.argtypes = [POINTER(DrmVersion)]&#xA;    l.drmFreeVersion.restype = None&#xA;&#xA;    l.drmModeGetResources.argtypes = [c_int]&#xA;    l.drmModeGetResources.restype = POINTER(DrmModeResources)&#xA;&#xA;    l.drmModeFreeResources.argtypes = [POINTER(DrmModeResources)]&#xA;    l.drmModeFreeResources.restype = None&#xA;&#xA;    l.drmModeGetCrtc.argtypes = [c_int, c_uint]&#xA;    l.drmModeGetCrtc.restype = POINTER(DrmModeCrtc)&#xA;&#xA;    l.drmModeFreeCrtc.argtypes = [POINTER(DrmModeCrtc)]&#xA;    l.drmModeFreeCrtc.restype = None&#xA;&#xA;    l.drmModeGetFB.argtypes = [c_int, c_uint]&#xA;    l.drmModeGetFB.restype = POINTER(DrmModeFB)&#xA;&#xA;    l.drmModeFreeFB.argtypes = [POINTER(DrmModeFB)]&#xA;    l.drmModeFreeFB.restype = None&#xA;&#xA;    l.drmIoctl.argtypes = [c_int, c_ulong, c_voidp]&#xA;    l.drmIoctl.restype = c_int&#xA;&#xA;    return l&#xA;&#xA;&#xA;class DRM(object):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    A DRM node.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    def __init__(self, library, fd):&#xA;    self._l = library&#xA;    self._fd = fd&#xA;&#xA;    def __repr__(self):&#xA;    return &amp;quot;&amp;lt;DRM (FD %d)&amp;gt;&amp;quot; % self._fd&#xA;&#xA;    @classmethod&#xA;    def fromHandle(cls, handle):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Create a node from a file handle.&#xA;&#xA;    @param handle: A file-like object backed by a file descriptor.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    self = cls(loadDRM(), handle.fileno())&#xA;    # We must keep the handle alive, and we cannot trust the caller to&#xA;    # keep it alive for us.&#xA;    self._handle = handle&#xA;    return self&#xA;&#xA;    def version(self):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Obtain the version.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    v = self._l.drmGetVersion(self._fd).contents&#xA;    v._l = self._l&#xA;    return v&#xA;&#xA;    def resources(self):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Obtain the modesetting resources.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    r = self._l.drmModeGetResources(self._fd).contents&#xA;    r._fd = self._fd&#xA;    r._l = self._l&#xA;    return r&#xA;&#xA;&#xA;def drmFromMinor(minor):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Given a DRM node number, open the corresponding node.&#xA;&#xA;    @param minor: The number of the minor node to open.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    path = &amp;quot;/dev/dri/card%d&amp;quot; % minor&#xA;    handle = open(path)&#xA;    return DRM.fromHandle(handle)&#xA;&#xA;&#xA;def _bgrx24(i):&#xA;    b = ord(next(i))&#xA;    g = ord(next(i))&#xA;    r = ord(next(i))&#xA;    next(i)&#xA;    return r, g, b&#xA;&#xA;&#xA;def _screenshot(image, fb):&#xA;    fb.map()&#xA;    m = fb._map&#xA;    lineLength = fb.width * fb.bpp // 8&#xA;    pitch = fb.pitch&#xA;    pixels = []&#xA;&#xA;    if fb.depth == 24:&#xA;    unformat = _bgrx24&#xA;    else:&#xA;    raise RuntimeError(&amp;quot;Couldn&#39;t unformat FB: %r&amp;quot; % fb)&#xA;&#xA;    for y in range(fb.height):&#xA;    offset = y * pitch&#xA;    m.seek(offset)&#xA;    channels = m.read(lineLength)&#xA;    ichannels = iter(channels)&#xA;    for x in range(fb.width):&#xA;        rgb = unformat(ichannels)&#xA;        image.putpixel((x, y), rgb)&#xA;&#xA;    fb.unmap()&#xA;&#xA;    return pixels&#xA;&#xA;&#xA;def screenshot():&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Take a screenshot, returning an image object.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;    d = drmFromMinor(0)&#xA;    fb = d.resources().getCrtc(0).fb()&#xA;    image = Image.new(&amp;quot;RGB&amp;quot;, (fb.width, fb.height))&#xA;    pixels = _screenshot(image, fb)&#xA;&#xA;    fd, screencap = tempfile.mkstemp(prefix=&#39;screencap_&#39;, suffix=&#39;.png&#39;)&#xA;    os.close(fd)&#xA;    image.save(screencap, optimize=True)&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;      screenshot()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>UBUNTU之RK3399编译QT与WebEngine</title>
      <link>http://www.nljb.net/default/UBUNTU%E4%B9%8BRK3399%E7%BC%96%E8%AF%91QT%E4%B8%8EWebEngine/</link>
      <pubDate>2020-10-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;UBUNTU之RK3399编译QT与WebEngine&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 技术文档 ...&#xA;https://wiki.qt.io/RaspberryPi2EGLFS&#xA;https://wiki.qt.io/RaspberryPiWithWebEngine&#xA;&#xA;// 打开插件 DEBUG&#xA;export QT_DEBUG_PLUGINS=1&#xA;&#xA;// Qt WebEngine 禁用 GPU 线程 ...&#xA;export QTWEBENGINE_DISABLE_GPU_THREAD=1&#xA;/usr/local/bin/simplebrowser -platform xcb&#xA;/usr/local/bin/simplebrowser -platform eglfs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// QT 源码&#xA;qt-everywhere-src-5.14.2.tar.xz&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译环境 &#xA;sudo apt-get install bison build-essential gperf flex ruby python libasound2-dev libbz2-dev libcap-dev&#xA;libcups2-dev libdrm-dev libegl1-mesa-dev libgcrypt11-dev libnss3-dev libpci-dev libpulse-dev libudev-dev&#xA;libxtst-dev gyp ninja-build libglu1-mesa-dev libfontconfig1-dev libx11-xcb-dev libicu-dev &#xA;libinput-dev libts-dev libxcb-xinerama0-dev libgles2-mesa-dev libgl1-mesa-dev libxcomposite-dev libxcursor-dev&#xA;libevent-dev libjsoncpp-dev libwebp-dev libsnappy-dev libopus-dev libxml2-dev libxslt-dev liblcms2-dev libminizip-dev &#xA;libtiff-dev libpulse-dev libxrandr-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Build Qt Base &#xA;git clone git://code.qt.io/qt/qtbase.git&#xA;git checkout 5.13.1&#xA;./configure -release -opengl es2 -opensource -confirm-license -nomake tests -nomake examples -verbose -no-pch -eglfs -xcb&#xA;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Build Qt Declarative&#xA;git clone git://code.qt.io/qt/qtdeclarative.git&#xA;git checkout 5.13.1&#xA;qmake&#xA;make &#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Build Qt WebEngine&#xA;git clone git://code.qt.io/qt/qtwebengine.git&#xA;git submodule init&#xA;git checkout 5.13.1&#xA;git submodule update&#xA;qmake&#xA;    make&#xA;    make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意：移除 config.cache 可重新 configure 或 qmake ...&#xA;// ninja -j 2 -v  -C ../qtwebengine/src/core/release QtWebEngineCore&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试 ...&#xA;/root/qtwebengine/examples/webenginewidgets/simplebrowser&#xA;qmake&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Gstreamer之应用项目实践</title>
      <link>http://www.nljb.net/default/Gstreamer%E4%B9%8B%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>2020-09-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Gstreamer之应用项目实践&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Pad Templates 中 Pad 的三种状态 ...&#xA;&#xA;Always Pad&#xA;// 一直存在的 Pad 被称为 Always Pad，使用时直接连接即可 ...&#xA;// 例如：audiotestsrc、videotestsrc 等 ...&#xA;// 查询：gst-inspect-1.0 videotestsrc ...&#xA;&#xA;Request Pad&#xA;// 这是根据需要来建立的 ...&#xA;// 例如：tee 等 ...&#xA;tee_audio_pad = gst_element_release_request_pad(tee, tee_audio_pad); &#xA;queue_audio_pad = gst_element_get_static_pad(audio_queue, &amp;quot;sink&amp;quot;);&#xA;gst_pad_link(tee_audio_pad, queue_audio_pad)&#xA;gst_object_unref(tee_audio_pad);&#xA;// 说明：&#xA;gst_element_get_request_pad (GstElement *element, const gchar *name);&#xA;// 功能：获取指定element中的指定pad，此接口仅适用于 request pads&#xA;// 使用后必须调用gst_element_release_request_pad()释放。&#xA;gst_element_request_pad (GstElement *element,GstPadTemplate *templ,const gchar *name,const GstCaps *caps);&#xA;// 功能：通过模板获取指定element的pad。此接口仅适用于request pads&#xA;// 使用后必须调用gst_element_release_request_pad()释放。比 gst_element_get_request_pad 快一些&#xA;&#xA;Sometimes Pad&#xA;​// 初始时没有 Pad 的 Element, Pad 会在数据流到 Element 时才会出现。&#xA;// 这种 Pad 被称为 Sometimes Pad，例如: uridecodebin 等 ...  &#xA;// 监听 pad-added 信号，回调 pad_added_handler 建立连接 ...&#xA;g_signal_connect(source, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_handler), &amp;amp;data);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;win32 {&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\glib-2.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\lib\glib-2.0\include&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\gstreamer-1.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\lib\gstreamer-1.0\include&#xA;    LIBS += -LD:/gstreamer/1.0/x86/lib -lgstreamer-1.0 -lgobject-2.0 -lglib-2.0 -lgstvideo-1.0&#xA;}&#xA;&#xA;unix {&#xA;    INCLUDEPATH += /usr/include/gstreamer-1.0&#xA;    INCLUDEPATH += /usr/include/glib-2.0&#xA;    INCLUDEPATH += /usr/lib/aarch64-linux-gnu/glib-2.0/include&#xA;    LIBS += -lgstreamer-1.0 -lgobject-2.0 -lglib-2.0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 设置 DEBUG LEVEL &#xA;&#xA;// GST_LEVEL_NONE = 0,&#xA;// GST_LEVEL_ERROR = 1,&#xA;// GST_LEVEL_WARNING = 2,&#xA;// GST_LEVEL_FIXME = 3,&#xA;// GST_LEVEL_INFO = 4,&#xA;// GST_LEVEL_DEBUG = 5,&#xA;// GST_LEVEL_LOG = 6,&#xA;// GST_LEVEL_TRACE = 7,&#xA;// GST_LEVEL_MEMDUMP = 9,&#xA;gst_debug_set_default_threshold(GST_LEVEL_DEBUG);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Gstreamer AppSrc 简介&#xA;&#xA;appsrc&#xA;// 应用程序可以通过 appsrc 元件向管道中插入数据。&#xA;// appsrc 有别于其他 GStreamer 元件，它提供额外的API函数。&#xA;// 通过链接libgstapp库来使用appsrc，直接调用其方法或者使用appsrc的响应信号&#xA;&#xA;caps&#xA;// 在操作appsrc前，caps属性必须被设定为一个固定的caps，以描述被推进appsrc数据的格式。&#xA;// 当推送缓存搭到一个未知的caps即caps没有被设置，这时会发生一个异常。&#xA;// 当使用类似文件一样的源时，推送其原始数据到appsrc将会典型地发生这种情况。&#xA;// 如果你不想准确地设定caps，你可以使用gst_app_src_push_sample函数，该函数获取与采样数据关联的caps，&#xA;// 且该caps取代appsrc上先前已设定的caps（如果你设定的caps不同于原来采样的caps）。&#xA;&#xA;gst_app_src_push_buffer | push-buffer&#xA;// 主要的操作数据到appsrc元件中的方式是调用gst_app_src_push_buffer方法，或者是发送push-buffer响应信号，&#xA;// 该操作将缓存放进了一个队列，appsrc将在它的流线程中读取该队列中的数据。&#xA;// 值得注意的是数据传输过程不是在执行push-buffer操作的线程。&#xA;&#xA;max-bytes、enough-data、need-data&#xA;// max-bytes 属性控制了在被appsrc认为队列满之前有多少数据可以被放进appsrc里的队列中。&#xA;// 内部队列满时将发出“enough-data”信号，该信号通知应用程序应该停止向appsrc中推送数据了。&#xA;// block属性将是appsrc阻塞push-buffer方法直到可以推进去数据。&#xA;// 当内部队列没有可用的数据，“need-data”信号将被发送，该信号将通知应用程序应该推送更多的数据到appsrc中。&#xA;&#xA;stream-mode、seek-data&#xA;// 在“need-data”和“enough-data”之外，当stream-mode属性设置为seekable或者random-access时，&#xA;// appsrc能够发送“seek-data”信号。该信号的参数包含了新的希望在stream中设定的位置，且该参数以format属性为单位。&#xA;// 在接收到seek-data信号后，应用程序应该从新的位置开始推送数据。&#xA;// 这些信号（need-data,enought-data,和seek-data）允许应用程序以两种不同的方式操作appsrc。&#xA;&#xA;推模式&#xA;// 推模式，应用程序重复的调用push-buffer/push-sample函数（来向appsrc中）推送一个新的buffer/sample。&#xA;// appsrc中队列里缓存的数量能够被控制，通过enough-data、need-data信号相应的停止或者开始调用push-buffer/push-sample。&#xA;// 在stream-type属性为stream和seekable时，这是一种典型的模式。处理各种网络协议或者硬件设备（打交道）时使用这种模式。&#xA;&#xA;拉模式&#xA;// 拉模式，该模式下，need-data信号触发下一次push-buffer函数调用。&#xA;// 该模式在random-access流类型下被典型使用。对于文件操作或者其他的可随机操作源使用这种模式，&#xA;// 在这种模式下，由need-data信号确定字节数的缓存应该被推进appsrc中。&#xA;&#xA;// 在所有模式下，appsrc的size属性都将以字节数表示包含的总的流数量。&#xA;// 在random-access模式下务必要设置该属性，对于stream好seekable模式，该属性是可选但被推荐设置的。&#xA;&#xA;// 当应用程序完成推送数据到appsrc，其应该调用gst_app_src_end_of_stream函数，或者发送end-of-stream响应信号。&#xA;// 在调用该函数后，不应该再由缓存被推送到appsrc，直到立即定位发生或者是appsrc切换到了REAY状态。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 简单的序列播放 ...&#xA;&#xA;restart:&#xA;&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,(GstMessageType)(GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;    if(msg != NULL) {&#xA;        GError *err;&#xA;        gchar *debug_info;&#xA;        switch(GST_MESSAGE_TYPE(msg)) {&#xA;        case GST_MESSAGE_ERROR:&#xA;            gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;            g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;            g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;            g_clear_error(&amp;amp;err);&#xA;            g_free(debug_info);&#xA;            break;&#xA;        case GST_MESSAGE_EOS: // 在结束时播放下一个视频 ...&#xA;            g_print(&amp;quot;End-Of-Stream reached.\n&amp;quot;);&#xA;            gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;            g_object_set(data.source, &amp;quot;location&amp;quot;, &amp;quot;e:/yiyezi.mp4&amp;quot;, NULL);&#xA;            gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;            goto restart;&#xA;        default:&#xA;            /* We should not reach here because we only asked for ERRORs and EOS */&#xA;            g_printerr(&amp;quot;Unexpected message received.\n&amp;quot;);&#xA;            break;&#xA;        }&#xA;        gst_message_unref(msg);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 默认视频播放 ...&#xA;// uridecodebin&#xA;// queue &amp;gt; audioconvert &amp;gt; audioresample &amp;gt; autoaudiosink&#xA;// queue &amp;gt; videoconvert &amp;gt; autovideosink&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline;&#xA;    GstElement *source;&#xA;    GstElement *audio_queue;&#xA;    GstElement *audio_convert;&#xA;    GstElement *audio_resample;&#xA;    GstElement *audio_sink;&#xA;    GstElement *video_queue;&#xA;    GstElement *video_convert;&#xA;    GstElement *video_sink;&#xA;} CustomData;&#xA;&#xA;// uridecodebin 的 pad_added 信号回调 ...&#xA;static void pad_added_handler(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    // ----------------------------------------- //&#xA;    // 获取新的 Pad 的 Type ...&#xA;    /* Check the new pad&#39;s type */&#xA;    // 获取 Pad 当前的 Caps 根据不同的 Element 状态会有不同的结果&#xA;    GstCaps *new_pad_caps = gst_pad_get_current_caps(new_pad);&#xA;    // 从 Caps 中获取第一个结构 ...&#xA;    GstStructure *new_pad_struct = gst_caps_get_structure(new_pad_caps, 0);&#xA;    // 获取结构的名称 ...&#xA;    const gchar *new_pad_type = gst_structure_get_name(new_pad_struct);&#xA;    // ----------------------------------------- //&#xA;&#xA;    // 当 new pad 类型为 audio 时 ...&#xA;    if (g_str_has_prefix(new_pad_type, &amp;quot;audio/x-raw&amp;quot;)) {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;audio_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;            goto exit;&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        if(GST_PAD_LINK_FAILED(ret)) {&#xA;            g_print(&amp;quot;Type is &#39;%s&#39; but link failed.\n&amp;quot;, new_pad_type);&#xA;        } else {&#xA;            g_print(&amp;quot;Link succeeded(type &#39;%s&#39;).\n&amp;quot;, new_pad_type);&#xA;        }&#xA;    }&#xA;&#xA;    // 当 new pad 类型未 video 时 ...&#xA;    if (g_str_has_prefix(new_pad_type, &amp;quot;video/x-raw&amp;quot;)) {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取视频 Queue 的输入接口 ...&#xA;        GstPad *video_sink_pad = gst_element_get_static_pad(data-&amp;gt;video_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(video_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(video_sink_pad);&#xA;            goto exit;&#xA;        }&#xA;        // 将 New Pad 数据连接到 视频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, video_sink_pad);&#xA;        if(GST_PAD_LINK_FAILED(ret)) {&#xA;            g_print(&amp;quot;Type is &#39;%s&#39; but link failed.\n&amp;quot;, new_pad_type);&#xA;        } else {&#xA;            g_print(&amp;quot;Link succeeded(type &#39;%s&#39;).\n&amp;quot;, new_pad_type);&#xA;        }&#xA;    }&#xA;&#xA;exit:&#xA;    /* Unreference the new pad&#39;s caps, if we got them */&#xA;    if(new_pad_caps != NULL)&#xA;        gst_caps_unref(new_pad_caps);&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 个人数据 ...&#xA;    CustomData data;&#xA;&#xA;    // Element 就像一个黑盒子, 一个管道 ...&#xA;    // 从 Element 的一端输入数据, Element 对数据进行一些处理，然后数据从 Element 的另一端输出&#xA;    GstElement *pipeline;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    // uridecodebin&#xA;    // queue &amp;gt; audioconvert &amp;gt; audioresample &amp;gt; autoaudiosink&#xA;    // queue &amp;gt; videoconvert &amp;gt; autovideosink&#xA;&#xA;    // gst_element_factory_make 创建 Element 元件&#xA;    data.source = gst_element_factory_make(&amp;quot;uridecodebin&amp;quot;, &amp;quot;source&amp;quot;);&#xA;    data.audio_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;audio_queue&amp;quot;);&#xA;    data.audio_convert = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;audio_convert&amp;quot;);&#xA;    data.audio_resample = gst_element_factory_make(&amp;quot;audioresample&amp;quot;, &amp;quot;audio_resample&amp;quot;);&#xA;    data.audio_sink = gst_element_factory_make(&amp;quot;autoaudiosink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;    data.video_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;video_queue&amp;quot;);&#xA;    data.video_convert = gst_element_factory_make(&amp;quot;videoconvert&amp;quot;, &amp;quot;video_convert&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;&#xA;    /* Create the empty pipeline */&#xA;    // 创建管道 ...&#xA;    pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;&#xA;    // 将元素添加到管道中（注意转换），并按顺序连接起来 ...&#xA;    gst_bin_add_many(GST_BIN(pipeline), data.source, data.audio_queue, data.audio_convert, data.audio_resample, data.audio_sink,&#xA;                     data.video_queue, data.video_convert, data.video_sink, NULL);&#xA;&#xA;    // 将一系列元素链接在一起 ...&#xA;    gst_element_link_many(data.audio_queue, data.audio_convert, data.audio_resample, data.audio_sink, NULL);&#xA;    gst_element_link_many(data.video_queue, data.video_convert, data.video_sink, NULL);&#xA;&#xA;    // 修改管道的 uri 地址 ...&#xA;    g_object_set(data.source, &amp;quot;uri&amp;quot;, &amp;quot;file:///e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;    // 连接到 uridecodebin 的 pad-added 信号, 通过回调 ...&#xA;    g_signal_connect(data.source, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_handler), &amp;amp;data);&#xA;&#xA;    /* Start playing the pipeline */&#xA;    // 修改状态为 PLAYING ...&#xA;    gst_element_set_state(pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Wait until error or EOS */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(pipeline);&#xA;&#xA;    // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;    // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,(GstMessageType)(GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Free resources */&#xA;    if(msg != NULL)&#xA;        gst_message_unref(msg);&#xA;    gst_object_unref(bus);&#xA;    gst_element_set_state(pipeline, GST_STATE_NULL);&#xA;&#xA;    gst_object_unref(pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Rockchip 提供的常用 plugins ...&#xA;https://github.com/rockchip-linux/gstreamer-rockchip&#xA;https://github.com/rockchip-linux/gstreamer-rockchip-extra&#xA;&#xA;Elements    Type    Comments    Origin&#xA;rkximagesink | Video Render (sink) | kmssink on X11, for overlay display     | ximagesink + kmssink&#xA;kmssink      | Video Render (sink) | overlay display                         | kmssink&#xA;rgaconvert   | Video Converter     | video colorspace,format,size conversion | v4l2 transform&#xA;rkcamsrc     | Device Sources      | rockchip isp camera source              | v4l2src&#xA;&#xA;rkximage:  rkximagesink: Video sink&#xA;rkisp:  rkisp: Gstreamer Plugin For Rockchip ISP Source&#xA;rockchipmpp:  mppvideodec: Rockchip&#39;s MPP video decoder&#xA;rockchipmpp:  mpph264enc: Rockchip Mpp H264 Encoder&#xA;rockchipmpp:  mppjpegenc: Rockchip Mpp JPEG Encoder&#xA;rockchipmpp:  mppjpegdec: Rockchip&#39;s MPP JPEG image decoder&#xA;&#xA;// Rockchip 高效输出 ...&#xA;mppvideodec &amp;gt; rkximagesink (基于 X Window 输出)&#xA;mppvideodec &amp;gt; kmssink (基于 KMS/DRM 输出)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// H264 视频播放 ...&#xA;// filesrc &amp;gt; qtdemux&#xA;// queue &amp;gt; decodebin &amp;gt; audioconvert &amp;gt; audioresample &amp;gt; autoaudiosink&#xA;// queue &amp;gt; h264parse &amp;gt; avdec_h264 &amp;gt; autovideosink&#xA;// 可扩展 queue &amp;gt; h264parse &amp;gt; mppvideodec &amp;gt; kmssink&#xA;// 可扩展 queue &amp;gt; h265parse &amp;gt; mppvideodec &amp;gt; kmssink&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline;&#xA;    GstElement *source;&#xA;    GstElement *demux;&#xA;    GstElement *audio_queue;&#xA;    GstElement *audio_decbin;&#xA;    GstElement *audio_convert;&#xA;    GstElement *audio_resample;&#xA;    GstElement *audio_sink;&#xA;    GstElement *video_queue;&#xA;    GstElement *h264_parse;&#xA;    GstElement *avdec_h264;&#xA;    GstElement *video_sink;&#xA;} CustomData;&#xA;&#xA;// demux 的 pad_added 信号回调 ...&#xA;static void pad_added_demux(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    if (strcmp(GST_PAD_NAME(new_pad), &amp;quot;audio_0&amp;quot;) == 0)&#xA;    {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;audio_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        gst_object_unref(audio_sink_pad);&#xA;    } else {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取视频 Queue 的输入接口 ...&#xA;        GstPad *video_sink_pad = gst_element_get_static_pad(data-&amp;gt;video_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(video_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(video_sink_pad);&#xA;        }&#xA;        // 将 New Pad 数据连接到 视频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, video_sink_pad);&#xA;        gst_object_unref(video_sink_pad);&#xA;    }&#xA;}&#xA;&#xA;// decbin 的 pad_added 信号回调 ...&#xA;static void pad_added_decbin(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    // ----------------------------------------- //&#xA;    // 获取新的 Pad 的 Type ...&#xA;    /* Check the new pad&#39;s type */&#xA;    // 获取 Pad 当前的 Caps 根据不同的 Element 状态会有不同的结果&#xA;    GstCaps *new_pad_caps = gst_pad_get_current_caps(new_pad);&#xA;    // 从 Caps 中获取第一个结构 ...&#xA;    GstStructure *new_pad_struct = gst_caps_get_structure(new_pad_caps, 0);&#xA;    // 获取结构的名称 ...&#xA;    const gchar *new_pad_type = gst_structure_get_name(new_pad_struct);&#xA;    // ----------------------------------------- //&#xA;&#xA;    // 当 new pad 类型为 audio 时 ...&#xA;    if (g_str_has_prefix(new_pad_type, &amp;quot;audio/x-raw&amp;quot;)) {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;audio_convert, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;            goto exit;&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        if(GST_PAD_LINK_FAILED(ret)) {&#xA;            g_print(&amp;quot;Type is &#39;%s&#39; but link failed.\n&amp;quot;, new_pad_type);&#xA;        } else {&#xA;            g_print(&amp;quot;Link succeeded(type &#39;%s&#39;).\n&amp;quot;, new_pad_type);&#xA;        }&#xA;    }&#xA;&#xA;exit:&#xA;    /* Unreference the new pad&#39;s caps, if we got them */&#xA;    if(new_pad_caps != NULL)&#xA;        gst_caps_unref(new_pad_caps);&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 个人数据 ...&#xA;    CustomData data;&#xA;    memset(&amp;amp;data, 0, sizeof(data));&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    // gst_element_factory_make 创建 Element 元件&#xA;    data.source = gst_element_factory_make(&amp;quot;filesrc&amp;quot;, &amp;quot;file-source&amp;quot;);&#xA;    data.demux = gst_element_factory_make(&amp;quot;qtdemux&amp;quot;, &amp;quot;demux&amp;quot;);&#xA;    data.audio_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;audio_queue&amp;quot;);&#xA;    data.audio_decbin = gst_element_factory_make(&amp;quot;decodebin&amp;quot;, &amp;quot;audio_decodebin&amp;quot;);&#xA;    data.audio_convert = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;audio_convert&amp;quot;);&#xA;    data.audio_resample = gst_element_factory_make(&amp;quot;audioresample&amp;quot;, &amp;quot;audio_resample&amp;quot;);&#xA;    data.audio_sink = gst_element_factory_make(&amp;quot;autoaudiosink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;    data.video_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;video_queue&amp;quot;);&#xA;    data.h264_parse = gst_element_factory_make(&amp;quot;h264parse&amp;quot;, &amp;quot;h264_parse&amp;quot;);&#xA;    data.avdec_h264 = gst_element_factory_make(&amp;quot;avdec_h264&amp;quot;, &amp;quot;avdec_h264&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;&#xA;    /* Create the empty pipeline */&#xA;    // 创建管道 ...&#xA;    data.pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;&#xA;    if (!data.pipeline || !data.source || !data.demux ||&#xA;            !data.audio_queue || !data.audio_decbin || !data.audio_convert || !data.audio_resample || !data.audio_sink ||&#xA;            !data.video_queue || !data.h264_parse || !data.avdec_h264 || !data.video_sink ) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    // 将元素添加到管道中（注意转换），并按顺序连接起来 ...&#xA;    gst_bin_add_many(GST_BIN(data.pipeline), data.source, data.demux,&#xA;                     data.audio_queue, data.audio_decbin, data.audio_convert, data.audio_resample, data.audio_sink,&#xA;                     data.video_queue, data.h264_parse, data.avdec_h264, data.video_sink, NULL);&#xA;&#xA;    // 将一系列元素链接在一起 ...&#xA;    if (gst_element_link(data.source, data.demux) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if (gst_element_link_many(data.audio_queue, data.audio_decbin, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if (gst_element_link_many(data.audio_convert, data.audio_resample, data.audio_sink, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if (gst_element_link_many(data.video_queue, data.h264_parse, data.avdec_h264, data.video_sink, NULL) != TRUE ) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    // 修改管道的 location 地址 ...&#xA;    g_object_set(data.source, &amp;quot;location&amp;quot;, &amp;quot;e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;    // 连接到 uridecodebin 的 pad-added 信号, 通过回调 ...&#xA;    g_signal_connect(data.demux, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_demux), &amp;amp;data);&#xA;    g_signal_connect(data.audio_decbin, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_decbin), &amp;amp;data);&#xA;&#xA;    /* Start playing the pipeline */&#xA;    // 修改状态为 PLAYING ...&#xA;    gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Wait until error or EOS */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(data.pipeline);&#xA;&#xA;    // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;    // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,(GstMessageType)(GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Free resources */&#xA;    if(msg != NULL)&#xA;        gst_message_unref(msg);&#xA;    gst_object_unref(bus);&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;&#xA;    gst_object_unref(data.pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 显示帧率 ...&#xA;&#xA;// filesrc &amp;gt; qtdemux&#xA;// queue &amp;gt; decodebin &amp;gt; audioconvert &amp;gt; audioresample &amp;gt; autoaudiosink&#xA;// queue &amp;gt; h264parse &amp;gt; avdec_h264 &amp;gt; autovideosink&#xA;// queue &amp;gt; h264parse &amp;gt; avdec_h264 &amp;gt; fpsdisplaysink -&amp;gt; autovideosink&#xA;&#xA;GST_DEBUG=fpsdisplaysink:5 gst-launch-1.0 ... ! fpsdisplaysink text-overlay=false video-sink=kmssink&#xA;GST_DEBUG=fpsdisplaysink:5 gst-launch-1.0 ... ! fpsdisplaysink text-overlay=false video-sink=autovideosink&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;math.h&amp;gt;&#xA;&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline;&#xA;    GstElement *source;&#xA;    GstElement *demux;&#xA;    GstElement *audio_queue;&#xA;    GstElement *audio_decbin;&#xA;    GstElement *audio_convert;&#xA;    GstElement *audio_resample;&#xA;    GstElement *audio_sink;&#xA;    GstElement *video_queue;&#xA;    GstElement *video_parse;&#xA;    GstElement *video_decode;&#xA;    GstElement *video_sink;&#xA;    GstElement *fpsdisplaysink;&#xA;} CustomData;&#xA;&#xA;// demux 的 pad_added 信号回调 ...&#xA;static void pad_added_demux(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    if(strcmp(GST_PAD_NAME(new_pad), &amp;quot;audio_0&amp;quot;) == 0)&#xA;    {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;audio_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        gst_object_unref(audio_sink_pad);&#xA;    } else {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取视频 Queue 的输入接口 ...&#xA;        GstPad *video_sink_pad = gst_element_get_static_pad(data-&amp;gt;video_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(video_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(video_sink_pad);&#xA;        }&#xA;        // 将 New Pad 数据连接到 视频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, video_sink_pad);&#xA;        gst_object_unref(video_sink_pad);&#xA;    }&#xA;}&#xA;&#xA;// decbin 的 pad_added 信号回调 ...&#xA;static void pad_added_decbin(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    // ----------------------------------------- //&#xA;    // 获取新的 Pad 的 Type ...&#xA;    /* Check the new pad&#39;s type */&#xA;    // 获取 Pad 当前的 Caps 根据不同的 Element 状态会有不同的结果&#xA;    GstCaps *new_pad_caps = gst_pad_get_current_caps(new_pad);&#xA;    // 从 Caps 中获取第一个结构 ...&#xA;    GstStructure *new_pad_struct = gst_caps_get_structure(new_pad_caps, 0);&#xA;    // 获取结构的名称 ...&#xA;    const gchar *new_pad_type = gst_structure_get_name(new_pad_struct);&#xA;    // ----------------------------------------- //&#xA;&#xA;    // 当 new pad 类型为 audio 时 ...&#xA;    if(g_str_has_prefix(new_pad_type, &amp;quot;audio/x-raw&amp;quot;)) {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;audio_convert, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;            goto exit;&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        if(GST_PAD_LINK_FAILED(ret)) {&#xA;            g_print(&amp;quot;Type is &#39;%s&#39; but link failed.\n&amp;quot;, new_pad_type);&#xA;        } else {&#xA;            g_print(&amp;quot;Link succeeded(type &#39;%s&#39;).\n&amp;quot;, new_pad_type);&#xA;        }&#xA;    }&#xA;&#xA;exit:&#xA;    /* Unreference the new pad&#39;s caps, if we got them */&#xA;    if(new_pad_caps != NULL)&#xA;        gst_caps_unref(new_pad_caps);&#xA;}&#xA;&#xA;// fps 回调 ...&#xA;void user_function(GstElement *fpsdisplaysink,&#xA;                   gdouble fps, // 当前测量的 fps&#xA;                   gdouble droprate, // 缓冲区丢失的速率&#xA;                   gdouble avgfps, // 平均 fps&#xA;                   gpointer user_data) {&#xA;    g_print(&amp;quot;fps is %f\n&amp;quot;, avgfps);&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 是否开启显示 FPS ...&#xA;    bool fps = true;&#xA;&#xA;    // 个人数据 ...&#xA;    CustomData data;&#xA;    memset(&amp;amp;data, 0, sizeof(data));&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    // gst_element_factory_make 创建 Element 元件&#xA;    data.source = gst_element_factory_make(&amp;quot;filesrc&amp;quot;, &amp;quot;file-source&amp;quot;);&#xA;    data.demux = gst_element_factory_make(&amp;quot;qtdemux&amp;quot;, &amp;quot;demux&amp;quot;);&#xA;    data.audio_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;audio_queue&amp;quot;);&#xA;    data.audio_decbin = gst_element_factory_make(&amp;quot;decodebin&amp;quot;, &amp;quot;audio_decodebin&amp;quot;);&#xA;    data.audio_convert = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;audio_convert&amp;quot;);&#xA;    data.audio_resample = gst_element_factory_make(&amp;quot;audioresample&amp;quot;, &amp;quot;audio_resample&amp;quot;);&#xA;    data.audio_sink = gst_element_factory_make(&amp;quot;autoaudiosink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;    data.video_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;video_queue&amp;quot;);&#xA;    data.video_parse = gst_element_factory_make(&amp;quot;h264parse&amp;quot;, &amp;quot;video_parse&amp;quot;);&#xA;    data.video_decode = gst_element_factory_make(&amp;quot;avdec_h264&amp;quot;, &amp;quot;video_decoder&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;    data.fpsdisplaysink = gst_element_factory_make(&amp;quot;fpsdisplaysink&amp;quot;, &amp;quot;fpsdisplay_sink&amp;quot;);&#xA;&#xA;    /* Create the empty pipeline */&#xA;    // 创建管道 ...&#xA;    data.pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;&#xA;    if(!data.pipeline || !data.source || !data.demux ||&#xA;            !data.audio_queue || !data.audio_decbin || !data.audio_convert || !data.audio_resample || !data.audio_sink ||&#xA;            !data.video_queue || !data.video_parse || !data.video_decode || !data.video_sink || !data.fpsdisplaysink) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    if (fps) { // 开启 FPS&#xA;        // 将元素添加到管道中（注意转换），并按顺序连接起来 ...&#xA;        gst_bin_add_many(GST_BIN(data.pipeline), data.source, data.demux,&#xA;                         data.audio_queue, data.audio_decbin, data.audio_convert, data.audio_resample, data.audio_sink,&#xA;                         data.video_queue, data.video_parse, data.video_decode, data.fpsdisplaysink, NULL);&#xA;    } else {&#xA;        // 将元素添加到管道中（注意转换），并按顺序连接起来 ...&#xA;        gst_bin_add_many(GST_BIN(data.pipeline), data.source, data.demux,&#xA;                         data.audio_queue, data.audio_decbin, data.audio_convert, data.audio_resample, data.audio_sink,&#xA;                         data.video_queue, data.video_parse, data.video_decode, data.video_sink, NULL);&#xA;    }&#xA;&#xA;    // 将一系列元素链接在一起 ...&#xA;    if(gst_element_link(data.source, data.demux) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if(gst_element_link_many(data.audio_queue, data.audio_decbin, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if(gst_element_link_many(data.audio_convert, data.audio_resample, data.audio_sink, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if (fps) { // 开启 FPS&#xA;        if(gst_element_link_many(data.video_queue, data.video_parse, data.video_decode, data.fpsdisplaysink, NULL) != TRUE ) {&#xA;            g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;            gst_object_unref(data.pipeline);&#xA;            return -1;&#xA;        }&#xA;    } else {&#xA;        if(gst_element_link_many(data.video_queue, data.video_parse, data.video_decode, data.video_sink, NULL) != TRUE ) {&#xA;            g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;            gst_object_unref(data.pipeline);&#xA;            return -1;&#xA;        }&#xA;    }&#xA;&#xA;    // 修改管道的 location 地址 ...&#xA;    g_object_set(data.source, &amp;quot;location&amp;quot;, &amp;quot;e:/kaoya720.mp4&amp;quot;, NULL);&#xA;&#xA;    if (fps) { // 开启 FPS&#xA;        g_object_set(data.fpsdisplaysink, &amp;quot;signal-fps-measurements&amp;quot;, TRUE,&#xA;                     &amp;quot;fps-update-interval&amp;quot;, 2000, &amp;quot;text-overlay&amp;quot;, FALSE,&#xA;                     &amp;quot;video-sink&amp;quot;, data.video_sink, NULL);&#xA;        g_signal_connect(data.fpsdisplaysink, &amp;quot;fps-measurements&amp;quot;, G_CALLBACK(user_function), NULL);&#xA;    }&#xA;&#xA;    // 连接到 uridecodebin 的 pad-added 信号, 通过回调 ...&#xA;    g_signal_connect(data.demux, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_demux), &amp;amp;data);&#xA;    g_signal_connect(data.audio_decbin, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_decbin), &amp;amp;data);&#xA;&#xA;    /* Start playing the pipeline */&#xA;    // 修改状态为 PLAYING ...&#xA;    gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Wait until error or EOS */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(data.pipeline);&#xA;&#xA;restart:&#xA;&#xA;    // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;    // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE, (GstMessageType)(GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Parse message */&#xA;    if(msg != NULL) {&#xA;        GError *err;&#xA;        gchar *debug_info;&#xA;&#xA;        switch(GST_MESSAGE_TYPE(msg)) {&#xA;        case GST_MESSAGE_ERROR:&#xA;            gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;            g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;            g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;            g_clear_error(&amp;amp;err);&#xA;            g_free(debug_info);&#xA;            break;&#xA;        case GST_MESSAGE_EOS:&#xA;            g_print(&amp;quot;End-Of-Stream reached.\n&amp;quot;);&#xA;            gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;            g_object_set(data.source, &amp;quot;location&amp;quot;, &amp;quot;e:/yiyezi.mp4&amp;quot;, NULL);&#xA;            gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;            goto restart;&#xA;        default:&#xA;            /* We should not reach here because we only asked for ERRORs and EOS */&#xA;            g_printerr(&amp;quot;Unexpected message received.\n&amp;quot;);&#xA;            break;&#xA;        }&#xA;        gst_message_unref(msg);&#xA;    }&#xA;&#xA;    gst_object_unref(bus);&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;&#xA;    gst_object_unref(data.pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用 appsrc 实现 push-buffer 至 qtdemux&#xA;// appsrc &amp;gt; qtdemux&#xA;// queue &amp;gt; decodebin &amp;gt; audioconvert &amp;gt; audioresample &amp;gt; autoaudiosink&#xA;// queue &amp;gt; h264parse &amp;gt; avdec_h264 &amp;gt; autovideosink&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;#include &amp;lt;gst/audio/audio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;&#xA;#define CHUNK_SIZE 1024&#xA;&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline;&#xA;    GstElement *app_source;&#xA;    GstElement *demux;&#xA;&#xA;    GstElement *audio_queue;&#xA;    GstElement *audio_decode;&#xA;    GstElement *audio_convert;&#xA;    GstElement *audio_resample;&#xA;    GstElement *audio_sink;&#xA;&#xA;    GstElement *video_queue;&#xA;    GstElement *video_parse;&#xA;    GstElement *video_decode;&#xA;    GstElement *video_sink;&#xA;&#xA;    GMappedFile *file;&#xA;    guint8 *data;&#xA;    gsize length;&#xA;    guint64 offset;&#xA;&#xA;    guint sourceid;        /* To control the GSource */&#xA;    GMainLoop *main_loop;  /* GLib&#39;s Main Loop */&#xA;} CustomData;&#xA;&#xA;// 推送数据 ...&#xA;static gboolean push_data(CustomData *data)&#xA;{&#xA;    GstBuffer *buffer;&#xA;    guint len;&#xA;    GstFlowReturn ret;&#xA;&#xA;    if(data-&amp;gt;offset &amp;gt;= data-&amp;gt;length) {&#xA;        /* we are EOS, send end-of-stream and remove the source */&#xA;        g_signal_emit_by_name(data-&amp;gt;app_source, &amp;quot;end-of-stream&amp;quot;, &amp;amp;ret);&#xA;        return FALSE;&#xA;    }&#xA;&#xA;    /* read the next chunk */&#xA;    buffer = gst_buffer_new();&#xA;&#xA;    len = CHUNK_SIZE;&#xA;    if(data-&amp;gt;offset + len &amp;gt; data-&amp;gt;length)&#xA;        len = data-&amp;gt;length - data-&amp;gt;offset;&#xA;&#xA;    gst_buffer_append_memory(buffer,&#xA;                             gst_memory_new_wrapped(GST_MEMORY_FLAG_READONLY,&#xA;                                                    data-&amp;gt;data, data-&amp;gt;length, data-&amp;gt;offset, len, NULL, NULL));&#xA;&#xA;    GST_DEBUG(&amp;quot;feed buffer %p, offset %&amp;quot; G_GUINT64_FORMAT &amp;quot;-%u&amp;quot;, buffer,&#xA;              data-&amp;gt;offset, len);&#xA;&#xA;    g_signal_emit_by_name(data-&amp;gt;app_source, &amp;quot;push-buffer&amp;quot;, buffer, &amp;amp;ret);&#xA;    gst_buffer_unref(buffer);&#xA;    if(ret != GST_FLOW_OK) {&#xA;        /* some error, stop sending data */&#xA;        g_print(&amp;quot;some error, stop sending data&amp;quot;);&#xA;        return FALSE;&#xA;    }&#xA;&#xA;    data-&amp;gt;offset += len;&#xA;&#xA;    return TRUE;&#xA;}&#xA;&#xA;// 当内部队列 appsrc 快要用尽（数据用完）时，将调用此函数&#xA;static void start_feed(GstElement *source, guint size, CustomData *data) {&#xA;    if(data-&amp;gt;sourceid == 0) {&#xA;        g_print(&amp;quot;Start feeding\n&amp;quot;);&#xA;        // g_idle_add() 增加一个空闲任务，让应用程序在空闲时执行指定的函数&#xA;        // g_idle_add() 该函数将数据写入到 appsrc 中，直到数据再次填满 ...&#xA;        data-&amp;gt;sourceid = g_idle_add((GSourceFunc) push_data, data);&#xA;    }&#xA;}&#xA;&#xA;// 当 appsrc 有足够的数据并且我们可以停止发送时，这个回调就会触发。&#xA;// 我们从主循环中删除空闲处理程序 ...&#xA;static void stop_feed(GstElement *source, CustomData *data) {&#xA;    if(data-&amp;gt;sourceid != 0) {&#xA;        g_print(&amp;quot;Stop feeding\n&amp;quot;);&#xA;        // 当 appsrc 中的数据填满，则移除任务 ...&#xA;        g_source_remove(data-&amp;gt;sourceid);&#xA;        data-&amp;gt;sourceid = 0;&#xA;    }&#xA;}&#xA;&#xA;// demux 的 pad_added 信号回调 ...&#xA;static void pad_added_demux(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Demux &amp;gt; Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    if(strcmp(GST_PAD_NAME(new_pad), &amp;quot;video_0&amp;quot;) == 0)&#xA;    {&#xA;        // sink 是输入，即上游Element向本元素发送的数据。&#xA;        // 获取视频 Queue 的输入接口 ...&#xA;        GstPad *video_sink_pad = gst_element_get_static_pad(data-&amp;gt;video_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(video_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(video_sink_pad);&#xA;        }&#xA;        // 将 New Pad 数据连接到 视频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, video_sink_pad);&#xA;        gst_object_unref(video_sink_pad);&#xA;    } else {&#xA;        // sink 是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;audio_queue, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        gst_object_unref(audio_sink_pad);&#xA;    }&#xA;}&#xA;&#xA;// decbin 的 pad_added 信号回调 ...&#xA;static void pad_added_decbin(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Decbin &amp;gt; Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    // ----------------------------------------- //&#xA;    // 获取新的 Pad 的 Type ...&#xA;    // 获取 Pad 当前的 Caps 根据不同的 Element 状态会有不同的结果&#xA;    GstCaps *new_pad_caps = gst_pad_get_current_caps(new_pad);&#xA;    // 从 Caps 中获取第一个结构 ...&#xA;    GstStructure *new_pad_struct = gst_caps_get_structure(new_pad_caps, 0);&#xA;    // 获取结构的名称 ...&#xA;    const gchar *new_pad_type = gst_structure_get_name(new_pad_struct);&#xA;    // ----------------------------------------- //&#xA;&#xA;    // 当 new pad 类型为 audio 时 ...&#xA;    if(g_str_has_prefix(new_pad_type, &amp;quot;audio/x-raw&amp;quot;)) {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;audio_convert, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;            goto exit;&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        if(GST_PAD_LINK_FAILED(ret)) {&#xA;            g_print(&amp;quot;Type is &#39;%s&#39; but link failed.\n&amp;quot;, new_pad_type);&#xA;        } else {&#xA;            g_print(&amp;quot;Link succeeded(type &#39;%s&#39;).\n&amp;quot;, new_pad_type);&#xA;        }&#xA;    }&#xA;&#xA;exit:&#xA;    /* Unreference the new pad&#39;s caps, if we got them */&#xA;    if(new_pad_caps != NULL)&#xA;        gst_caps_unref(new_pad_caps);&#xA;}&#xA;&#xA;&#xA;// 此函数在总线上发布错误消息时调用 ...&#xA;static void error_cb(GstBus *bus, GstMessage *msg, CustomData *data) {&#xA;    GError *err;&#xA;    gchar *debug_info;&#xA;    /* Print error details on the screen */&#xA;    gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;    g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;    g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;    g_clear_error(&amp;amp;err);&#xA;    g_free(debug_info);&#xA;    g_main_loop_quit(data-&amp;gt;main_loop);&#xA;}&#xA;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 用户数据&#xA;    CustomData data;&#xA;    memset(&amp;amp;data, 0, sizeof(data));&#xA;&#xA;    // Bus&#xA;    GstBus *bus;&#xA;&#xA;    // 初始化 Gst&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;    // gst_debug_set_default_threshold(GST_LEVEL_DEBUG);&#xA;&#xA;    // 映射本地文件 ...&#xA;    GError *error = NULL;&#xA;    data.file = g_mapped_file_new(&amp;quot;e:/yiyezi.mp4&amp;quot;, FALSE, &amp;amp;error);&#xA;    if(error) {&#xA;        g_print(&amp;quot;failed to open file: %s\n&amp;quot;, error-&amp;gt;message);&#xA;        g_error_free(error);&#xA;        return -2;&#xA;    }&#xA;&#xA;    // 初始化本地文件 ...&#xA;    data.length = g_mapped_file_get_length(data.file);&#xA;    data.data =(guint8 *) g_mapped_file_get_contents(data.file);&#xA;    data.offset = 0;&#xA;&#xA;    // 创建 Element ...&#xA;    data.app_source = gst_element_factory_make(&amp;quot;appsrc&amp;quot;, &amp;quot;app_source&amp;quot;);&#xA;    data.demux = gst_element_factory_make(&amp;quot;qtdemux&amp;quot;, &amp;quot;demux&amp;quot;);&#xA;    // audio ...&#xA;    data.audio_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;audio_queue&amp;quot;);&#xA;    data.audio_decode = gst_element_factory_make(&amp;quot;decodebin&amp;quot;, &amp;quot;audio_decode&amp;quot;);&#xA;    data.audio_convert = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;audio_convert&amp;quot;);&#xA;    data.audio_resample = gst_element_factory_make(&amp;quot;audioresample&amp;quot;, &amp;quot;audio_resample&amp;quot;);&#xA;    data.audio_sink = gst_element_factory_make(&amp;quot;autoaudiosink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;    // video ...&#xA;    data.video_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;video_queue&amp;quot;);&#xA;    data.video_parse = gst_element_factory_make(&amp;quot;h264parse&amp;quot;, &amp;quot;video_parse&amp;quot;);&#xA;    data.video_decode = gst_element_factory_make(&amp;quot;avdec_h264&amp;quot;, &amp;quot;video_decode&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;&#xA;    // 创建管道 ...&#xA;    data.pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;&#xA;    // 判断是否创建成功 ...&#xA;    if(!data.pipeline || !data.app_source || !data.demux ||&#xA;            !data.audio_queue || !data.audio_decode || !data.audio_convert || !data.audio_resample || !data.audio_sink ||&#xA;            !data.video_queue || !data.video_parse || !data.video_decode || !data.video_sink) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    // 设置 appsrc size ...&#xA;    g_object_set(data.app_source, &amp;quot;size&amp;quot;, (gint64) data.length, NULL);&#xA;&#xA;    // 当 appsrc 内需要数据时，通知回调填充 ...&#xA;    g_signal_connect(data.app_source, &amp;quot;need-data&amp;quot;, G_CALLBACK(start_feed), &amp;amp;data);&#xA;    // 当 appsrc 内数据填满时，通过回调停止 ...&#xA;    g_signal_connect(data.app_source, &amp;quot;enough-data&amp;quot;, G_CALLBACK(stop_feed), &amp;amp;data);&#xA;&#xA;    // 将元素添加到管道中 ...&#xA;    gst_bin_add_many(GST_BIN(data.pipeline), data.app_source, data.demux,&#xA;                     data.audio_queue, data.audio_decode, data.audio_convert, data.audio_resample, data.audio_sink,&#xA;                     data.video_queue, data.video_parse, data.video_decode, data.video_sink, NULL);&#xA;&#xA;    // 建立元素间的连接 ...&#xA;    if(gst_element_link(data.app_source, data.demux) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if(gst_element_link_many(data.audio_queue, data.audio_decode, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if(gst_element_link_many(data.audio_convert, data.audio_resample, data.audio_sink, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    if(gst_element_link_many(data.video_queue, data.video_parse, data.video_decode, data.video_sink, NULL) != TRUE ) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    // 针对 Sometimes 类型 Pad 进行连接 ...&#xA;    g_signal_connect(data.demux, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_demux), &amp;amp;data);&#xA;    g_signal_connect(data.audio_decode, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_decbin), &amp;amp;data);&#xA;&#xA;    // 获取 Bus 连接 message::error 回调 ...&#xA;    bus = gst_element_get_bus(data.pipeline);&#xA;    gst_bus_add_signal_watch(bus);&#xA;    g_signal_connect(G_OBJECT(bus), &amp;quot;message::error&amp;quot;,(GCallback) error_cb, &amp;amp;data);&#xA;    gst_object_unref(bus);&#xA;&#xA;    // 更新 Element 状态为 GST_STATE_PLAYING ...&#xA;    gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;&#xA;    // Main Loop ...&#xA;    data.main_loop = g_main_loop_new(NULL, FALSE);&#xA;    g_main_loop_run(data.main_loop);&#xA;&#xA;    /* Free resources */&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;    gst_object_unref(data.pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 播放图片 ...&#xA;gst-launch-1.0 filesrc location=/root/b.jpg ! jpegparse ! mppjpegdec ! imagefreeze ! kmssink&#xA;&#xA;// 检查输入格式，并且查看是否需要 parsed ...&#xA;SINK template: &#39;sink&#39;&#xA;Availability: Always&#xA;Capabilities:&#xA;  image/jpeg&#xA;             parsed: true&#xA;&#xA;// 默认图片播放 ...&#xA;// filesrc &amp;gt; decodebin &amp;gt; imagefreeze &amp;gt; autovideosink&#xA;// gst-launch-1.0 filesrc location=e:/b.jpg ! jpegdec ! imagefreeze ! autovideosink&#xA;// gst-launch-1.0 filesrc location=e:/b.png ! pngdec ! imagefreeze ! autovideosink&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;#include &amp;lt;glib.h&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline;&#xA;    GstElement *source;&#xA;    GstElement *decbin;&#xA;    GstElement *freeze;&#xA;    GstElement *sink;&#xA;    GMainLoop *loop;&#xA;} CustomData;&#xA;&#xA;// decbin 的 pad_added 信号回调 ...&#xA;static void pad_added_decbin(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // sink 是输入，即上游 Element 向本元素发送的数据。&#xA;    // src 是输出，本元素向下游元素发送的数据。也就是输入数据经过本元素处理之后的输出。&#xA;&#xA;    g_print(&amp;quot;Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    // ----------------------------------------- //&#xA;    // 获取新的 Pad 的 Type ...&#xA;    /* Check the new pad&#39;s type */&#xA;    // 获取 Pad 当前的 Caps 根据不同的 Element 状态会有不同的结果&#xA;    GstCaps *new_pad_caps = gst_pad_get_current_caps(new_pad);&#xA;    // 从 Caps 中获取第一个结构 ...&#xA;    GstStructure *new_pad_struct = gst_caps_get_structure(new_pad_caps, 0);&#xA;    // 获取结构的名称 ...&#xA;    const gchar *new_pad_type = gst_structure_get_name(new_pad_struct);&#xA;    // ----------------------------------------- //&#xA;&#xA;    // 当 new pad 类型为 video 时 ...&#xA;    if (g_str_has_prefix(new_pad_type, &amp;quot;video/x-raw&amp;quot;)) {&#xA;        // sink是输入，即上游Element向本元素发送的数据。&#xA;        // 获取音频 Queue 的输入接口 ...&#xA;        GstPad *audio_sink_pad = gst_element_get_static_pad(data-&amp;gt;freeze, &amp;quot;sink&amp;quot;);&#xA;        if(gst_pad_is_linked(audio_sink_pad)) {&#xA;            g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;            gst_object_unref(audio_sink_pad);&#xA;            goto exit;&#xA;        }&#xA;        // 将 New Pad 数据连接到 音频 Queue 的输入接口 ...&#xA;        GstPadLinkReturn ret = gst_pad_link(new_pad, audio_sink_pad);&#xA;        if(GST_PAD_LINK_FAILED(ret)) {&#xA;            g_print(&amp;quot;Type is &#39;%s&#39; but link failed.\n&amp;quot;, new_pad_type);&#xA;        } else {&#xA;            g_print(&amp;quot;Link succeeded(type &#39;%s&#39;).\n&amp;quot;, new_pad_type);&#xA;        }&#xA;    }&#xA;&#xA;exit:&#xA;    /* Unreference the new pad&#39;s caps, if we got them */&#xA;    if(new_pad_caps != NULL)&#xA;        gst_caps_unref(new_pad_caps);&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    CustomData data;&#xA;    memset(&amp;amp;data, 0, sizeof(data));&#xA;&#xA;    GstBus *bus;&#xA;    GstMessage *msg;&#xA;&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    data.pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;    data.source = gst_element_factory_make(&amp;quot;filesrc&amp;quot;, &amp;quot;source&amp;quot;);&#xA;    data.decbin = gst_element_factory_make(&amp;quot;decodebin&amp;quot;, &amp;quot;decoder&amp;quot;);&#xA;    data.freeze = gst_element_factory_make(&amp;quot;imagefreeze&amp;quot;, &amp;quot;image_freeze&amp;quot;);&#xA;    data.sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;image_sink&amp;quot;);&#xA;&#xA;    if(!data.pipeline || !data.source || !data.decbin || !data.freeze || !data.sink) {&#xA;        g_print(&amp;quot;One element could not be created\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    g_object_set(G_OBJECT(data.source), &amp;quot;location&amp;quot;, &amp;quot;e:/b.jpg&amp;quot;, NULL);&#xA;&#xA;    gst_bin_add_many(GST_BIN(data.pipeline), data.source, data.decbin, data.freeze, data.sink, NULL);&#xA;    if (gst_element_link_many(data.source, data.decbin, NULL) != TRUE ||&#xA;            gst_element_link_many(data.freeze, data.sink, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    g_signal_connect(data.decbin, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_decbin), &amp;amp;data);&#xA;&#xA;    gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;    g_print(&amp;quot;Running\n&amp;quot;);&#xA;&#xA;    bus = gst_pipeline_get_bus(GST_PIPELINE(data.pipeline));&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,(GstMessageType)(GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Free resources */&#xA;    if(msg != NULL)&#xA;        gst_message_unref(msg);&#xA;&#xA;    gst_object_unref(bus);&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;    gst_object_unref(data.pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 Playbin 中使用 Ghost_Pad 创建连接 ...&#xA;&#xA;void user_function(GstElement *fpsdisplaysink,&#xA;                   gdouble fps, // 当前测量的 fps&#xA;                   gdouble droprate, // 缓冲区丢失的速率&#xA;                   gdouble avgfps, // 平均 fps&#xA;                   gpointer user_data) {&#xA;    g_print(&amp;quot;fps is %f\n&amp;quot;, avgfps);&#xA;}&#xA;&#xA;data.playbin = gst_parse_launch(&amp;quot;playbin3&amp;quot;, NULL);&#xA;data.fpsdisplaysink = gst_element_factory_make(&amp;quot;fpsdisplaysink&amp;quot;, &amp;quot;fpsdisplay_sink&amp;quot;);&#xA;&#xA;#ifdef G_OS_WIN32&#xA;    data.video_convert = gst_element_factory_make(&amp;quot;videoconvert&amp;quot;, &amp;quot;video_convert&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;#else&#xA;    data.video_convert = gst_element_factory_make(&amp;quot;mppvideodec&amp;quot;, &amp;quot;video_convert&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;kmssink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;#endif&#xA;&#xA;g_object_set(data.fpsdisplaysink, &amp;quot;signal-fps-measurements&amp;quot;, TRUE,&#xA;             &amp;quot;fps-update-interval&amp;quot;, 2000, &amp;quot;text-overlay&amp;quot;, FALSE,&#xA;             &amp;quot;video-sink&amp;quot;, data.video_sink, NULL);&#xA;g_signal_connect(data.fpsdisplaysink, &amp;quot;fps-measurements&amp;quot;, G_CALLBACK(user_function), NULL);&#xA;&#xA;GstElement *video_sink_bin = gst_bin_new(&amp;quot;video_sink_bin&amp;quot;);&#xA;gst_bin_add_many(GST_BIN(video_sink_bin), data.video_convert, data.fpsdisplaysink, NULL);&#xA;gst_element_link_many(data.video_convert, data.fpsdisplaysink, NULL);&#xA;GstPad *pad = gst_element_get_static_pad(data.video_convert, &amp;quot;sink&amp;quot;);&#xA;GstPad *ghost_pad = gst_ghost_pad_new(&amp;quot;sink&amp;quot;, pad);&#xA;gst_pad_set_active(ghost_pad, TRUE);&#xA;gst_element_add_pad(video_sink_bin, ghost_pad);&#xA;gst_object_unref(pad);&#xA;&#xA;g_object_set(GST_OBJECT(data.playbin), &amp;quot;video-sink&amp;quot;, video_sink_bin, NULL);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 自定义 playbin 接收器 + 循环播放 ...&#xA;// playbin &amp;gt; videoconvert &amp;gt; autovideosink&#xA;// playbin &amp;gt; mppvideodec &amp;gt; kmssink&#xA;&#xA;// playbin 允许选择所需的音频和视频接收器的两个属性 audio-sink 和 video-sink。&#xA;// 应用程序只需要实例化适当的 GstElement 并将其传递给 playbin 这些属性&#xA;&#xA;// 关于切换播放&#xA;// playbin 允许在 about-to-finish 信号时设置新的 uri 来指定下一个视频 ...&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;#include &amp;quot;gst/gst.h&amp;quot;&#xA;&#xA;using namespace std;&#xA;&#xA;typedef struct _CustomData {&#xA;    GstElement *playbin;&#xA;    GstElement *video_convert;&#xA;    GstElement *video_sink;&#xA;    GstElement *fpsdisplaysink;&#xA;    GstElement *audio_sink;&#xA;    vector&amp;lt;QString&amp;gt; playlist;&#xA;    int playindex = 0;&#xA;    GMainLoop *main_loop;&#xA;} CustomData;&#xA;&#xA;void about_to_finish_callback(GstElement *playbin, CustomData *data)&#xA;{&#xA;    QString old = data-&amp;gt;playlist.at(data-&amp;gt;playindex);&#xA;    data-&amp;gt;playindex = data-&amp;gt;playindex + 1 == data-&amp;gt;playlist.size() ? 0 : data-&amp;gt;playindex + 1;&#xA;    QString name = data-&amp;gt;playlist.at(data-&amp;gt;playindex);&#xA;    g_object_set(playbin, &amp;quot;uri&amp;quot;, QString(&amp;quot;file:///%1&amp;quot;).arg(name).toStdString().c_str(), NULL);&#xA;    g_print(&amp;quot;&amp;gt; NEXT &amp;gt; %s &amp;gt; %s\n&amp;quot;, old.toStdString().c_str(), name.toStdString().c_str());&#xA;}&#xA;&#xA;static void error_callback(GstBus *bus, GstMessage *msg, CustomData *data) {&#xA;    GError *err;&#xA;    gchar *debug_info;&#xA;&#xA;    /* Print error details on the screen */&#xA;    gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;    g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;    g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;    g_clear_error(&amp;amp;err);&#xA;    g_free(debug_info);&#xA;&#xA;    g_main_loop_quit(data-&amp;gt;main_loop);&#xA;}&#xA;&#xA;static void state_changed_callback(GstBus *bus, GstMessage *msg, CustomData *data) {&#xA;    GstState old_state, new_state, pending_state;&#xA;    gst_message_parse_state_changed(msg, &amp;amp;old_state, &amp;amp;new_state, &amp;amp;pending_state);&#xA;    if (GST_MESSAGE_SRC(msg) == GST_OBJECT(data-&amp;gt;playbin)) {&#xA;        g_print(&amp;quot;Pipeline state changed from %s to %s:\n&amp;quot;,&#xA;                gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));&#xA;    }&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    CustomData data;&#xA;&#xA;#ifdef G_OS_WIN32&#xA;    data.playlist.push_back(&amp;quot;e:/yiyezi.mp4&amp;quot;);&#xA;    data.playlist.push_back(&amp;quot;e:/kaoya720.mp4&amp;quot;);&#xA;#else&#xA;    data.playlist.push_back(&amp;quot;/root/bright_me_up_h265_4k_30fps_15s.mp4&amp;quot;);&#xA;    data.playlist.push_back(&amp;quot;/root/beijing_kaoya_h265_4k_30fps_15s.mp4&amp;quot;);&#xA;#endif&#xA;&#xA;    GstBus *bus;&#xA;    GstMessage *msg;&#xA;&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    // playbin3 可以解决最后一帧丢失问题 ...&#xA;    data.playbin = gst_parse_launch(&amp;quot;playbin&amp;quot;, NULL);&#xA;    data.audio_sink = gst_element_factory_make(&amp;quot;alsasink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;&#xA;#ifdef G_OS_WIN32&#xA;    data.video_convert = gst_element_factory_make(&amp;quot;videoconvert&amp;quot;, &amp;quot;video_convert&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;#else&#xA;    // data.video_convert = gst_element_factory_make(&amp;quot;mppvideodec&amp;quot;, &amp;quot;video_convert&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;kmssink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;#endif&#xA;&#xA;    if(!data.playbin || !data.video_sink ) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    g_object_set(data.playbin, &amp;quot;uri&amp;quot;, QString(&amp;quot;file:///%1&amp;quot;).arg(data.playlist.at(data.playindex)).toStdString().c_str(), NULL);&#xA;    g_object_set(GST_OBJECT(data.playbin), &amp;quot;video-sink&amp;quot;, data.video_sink, NULL);&#xA;    g_object_set(GST_OBJECT(data.playbin), &amp;quot;audio-sink&amp;quot;, data.audio_sink, NULL);&#xA;    g_signal_connect(data.playbin, &amp;quot;about-to-finish&amp;quot;, G_CALLBACK(about_to_finish_callback), &amp;amp;data);&#xA;&#xA;    bus = gst_element_get_bus(data.playbin);&#xA;    gst_bus_add_signal_watch(bus);&#xA;    g_signal_connect(G_OBJECT(bus), &amp;quot;message::error&amp;quot;,(GCallback)error_callback, &amp;amp;data);&#xA;    g_signal_connect(G_OBJECT(bus), &amp;quot;message::state-changed&amp;quot;, (GCallback)state_changed_callback, &amp;amp;data);&#xA;    // g_signal_connect(G_OBJECT(bus), &amp;quot;message::eos&amp;quot;, (GCallback)eos_callback, &amp;amp;data);&#xA;&#xA;    gst_object_unref(bus);&#xA;&#xA;    // 暂停来实现图片切换需要监听 GST_MESSAGE_STATE_CHANGED 必要状态来获取素材的切换 ...&#xA;    gst_element_set_state(data.playbin, GST_STATE_PLAYING);&#xA;&#xA;    data.main_loop = g_main_loop_new(NULL, FALSE);&#xA;    g_main_loop_run(data.main_loop);&#xA;&#xA;    gst_element_set_state(data.playbin, GST_STATE_NULL);&#xA;    gst_object_unref(data.playbin);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 混合图像处理 ...&#xA;&#xA;gst-launch-1.0 videomixer name=mix sink_1::xpos=50 sink_1::ypos=50 sink_1::alpha=1.0 sink_1::zorder=3 sink_2::xpos=40 sink_2::ypos=40 sink_2::zorder=2 ! \&#xA;videoconvert ! autovideosink \&#xA;uridecodebin3 uri=file:///e:/kaoya720.mp4 name=dec_1 \&#xA;dec_1. ! queue ! audioconvert ! audioresample ! autoaudiosink \&#xA;dec_1. ! queue ! videoconvert ! videoscale ! mix. \&#xA;uridecodebin3 uri=file:///e:/yiyezi.mp4 name=dec_2 \&#xA;dec_2. ! queue ! videoconvert ! videoscale ! mix. \&#xA;videotestsrc ! video/x-raw,framerate=10/1,width=800, height=540 ! queue ! mix.&#xA;&#xA;// 官方案例&#xA;&#xA;gst-launch-1.0 \&#xA;  videotestsrc pattern=1 ! \&#xA;  video/x-raw,format=AYUV,framerate=\(fraction\)10/1,width=100,height=100 ! \&#xA;  videobox border-alpha=0 top=-70 bottom=-70 right=-220 ! \&#xA;  videomixer name=mix sink_0::alpha=0.7 sink_1::alpha=0.5 ! \&#xA;  videoconvert ! xvimagesink \&#xA;  videotestsrc ! \&#xA;  video/x-raw,format=AYUV,framerate=\(fraction\)5/1,width=320,height=240 ! mix.&#xA;&#xA;gst-launch-1.0 videotestsrc pattern=1 ! \&#xA;  video/x-raw, framerate=\(fraction\)10/1, width=100, height=100 ! \&#xA;  videomixer name=mix ! videoconvert ! ximagesink \&#xA;  videotestsrc !  \&#xA;  video/x-raw, framerate=\(fraction\)5/1, width=320, height=240 ! mix.&#xA;&#xA;gst-launch-1.0 videotestsrc pattern=1 ! \&#xA;  video/x-raw,format =I420, framerate=\(fraction\)10/1, width=100, height=100 ! \&#xA;  videomixer name=mix ! videoconvert ! ximagesink \&#xA;  videotestsrc ! \&#xA;  video/x-raw,format=I420, framerate=\(fraction\)5/1, width=320, height=240 ! mix.&#xA;&#xA;gst-launch-1.0 videomixer name=mixer sink_1::alpha=0.5 sink_1::xpos=50 sink_1::ypos=50 ! \&#xA;  videoconvert ! ximagesink \&#xA;  videotestsrc pattern=snow timestamp-offset=3000000000 ! \&#xA;  &amp;quot;video/x-raw,format=AYUV,width=640,height=480,framerate=(fraction)30/1&amp;quot; ! \&#xA;  timeoverlay ! queue2 ! mixer. \&#xA;  videotestsrc pattern=smpte ! \&#xA;  &amp;quot;video/x-raw,format=AYUV,width=800,height=600,framerate=(fraction)10/1&amp;quot; ! \&#xA;  timeoverlay ! queue2 ! mixer.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Gstreamer之在Windows与Linux系统上安装</title>
      <link>http://www.nljb.net/default/Gstreamer%E4%B9%8B%E5%9C%A8Windows%E4%B8%8ELinux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85/</link>
      <pubDate>2020-08-30 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;什么是 Gstreamer？&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Gstreamer是一个支持Windows，Linux，Android， iOS的跨平台的多媒体框架，&#xA;应用程序可以通过管道（Pipeline）的方式，将多媒体处理的各个步骤串联起来，达到预期的效果。&#xA;每个步骤通过元素（Element）基于GObject对象系统通过插件（plugins）的方式实现，方便了各项功能的扩展。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-08-30-Gstreamer之在Windows与Linux系统上安装/aa.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Gstreamer框架根据各个模块的成熟度以及所使用的开源协议，将core及plugins置于不同的源码包中：&#xA;1. gstreamer: 包含core framework及core elements。&#xA;2. gst-plugins-base: gstreamer应用所需的必要插件。&#xA;3. gst-plugins-good: 高质量的采用LGPL授权的插件。&#xA;4. gst-plugins-ugly: 高质量，但使用了GPL等其他授权方式的库的插件，比如使用GPL的x264，x265。&#xA;5. gst-plugins-bad: 质量有待提高的插件，成熟后可以移到good插件列表中。&#xA;6. gst-libav: 对libav封装，使其能在gstreamer框架中使用。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方文档&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-plugins/html/&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-plugins/html/&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-bad-plugins/html/&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good-plugins/html/&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-gl-plugins/&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-ugly-plugins/html/&#xA;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-vaapi-plugins/html/&#xA;&#xA;// 官方样例&#xA;https://github.com/GStreamer/gst-plugins-base/tree/master/tests/examples&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Gstreamer之在Windows与Linux系统上安装&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 Linux 系统上安装 ...&#xA;&#xA;// 官方安装文档 ...&#xA;https://.freedesktop.org/documentation/installing/on-linux.html?gi-language=c&#xA;&#xA;// 官方安装&#xA;apt-get install &#xA;libgstreamer1.0-0 &#xA;gstreamer1.0-plugins-base &#xA;gstreamer1.0-plugins-good &#xA;gstreamer1.0-plugins-bad &#xA;gstreamer1.0-plugins-ugly &#xA;gstreamer1.0-libav gstreamer1.0-doc &#xA;gstreamer1.0-tools gstreamer1.0-x &#xA;gstreamer1.0-alsa gstreamer1.0-gl &#xA;gstreamer1.0-gtk3 &#xA;gstreamer1.0-qt5 &#xA;gstreamer1.0-pulseaudio&#xA;&#xA;// 开发 ...&#xA;apt-get install libgstreamer1.0-dev&#xA;apt-get install libgstreamer-plugins-base1.0-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在 Windows 系统上安装 &amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方安装文档 ...&#xA;https://gstreamer.freedesktop.org/documentation/installing/on-windows.html?gi-language=c&#xA;&#xA;// 下载 MinGw 或 MSVC 运行时与开发包 ...&#xA;https://gstreamer.freedesktop.org/download/&#xA;&#xA;// 安装 ... 这里使用 MinGw 32 样例&#xA;gstreamer-1.0-devel-mingw-x86-1.16.2.msi&#xA;gstreamer-1.0-mingw-x86-1.16.2.msi&#xA;&#xA;// 环境变量&#xA;PATH 增加 D:\gstreamer\1.0\x86\bin&#xA;GST_PLUGIN_PATH 设置 D:\gstreamer\1.0\x86&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Linux 测试指令 &amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gst-launch-1.0&#xA;// 列出当前系统中支持的所有Element&#xA;// 这些Element可用于构造Pipeline.&#xA;&#xA;// DEBUG&#xA;GST_DEBUG=fpsdisplaysink:5&#xA;--gst-debug=kmssink:5  &#xA;--gst-debug=qtdemux:5 &#xA;&#xA;// 测试&#xA;gst-launch-1.0 videotestsrc ! kmssink&#xA;gst-launch-1.0 videotestsrc ! xvimagesink &#xA;gst-launch-1.0 videotestsrc ! kmssink plane-properties=s,rotation=4&#xA;gst-launch-1.0 audiotestsrc ! audioconvert ! audioresample ! osssink&#xA;gst-launch-1.0 videotestsrc ! kmssink render-rectangle=&#39;&amp;lt;0,0,1920,1080&amp;gt;&#39; can-scale=0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Windows 测试代码 &amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 Qt 环境下 MinGW 32 编译 ...&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;#include &amp;quot;gst/gst.h&amp;quot;&#xA;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // Element 就像一个黑盒子, 一个管道 ...&#xA;    // 从 Element 的一端输入数据, Element 对数据进行一些处理，然后数据从 Element 的另一端输出&#xA;    GstElement *pipeline;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Build the pipeline */&#xA;    // gst_parse_launch 通过分析管道说明创建管道 ...&#xA;    // playbin 整合的元件，内部建立工厂管道&#xA;    pipeline = gst_parse_launch(&amp;quot;playbin uri=file:///e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;    /* Start playing */&#xA;    // GST_STATE_VOID_PENDING   无效挂起状态&#xA;    // GST_STATE_NULL           元素的空状态或初始状态&#xA;    // GST_STATE_READY          元素已准备好转到“暂停”。&#xA;    // GST_STATE_PAUSED         元素已暂停&#xA;    // GST_STATE_PLAYING        元素正在播放&#xA;    // 设置 Element 状态为 GST_STATE_PLAYING&#xA;    gst_element_set_state(pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Wait until error or EOS */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(pipeline);&#xA;&#xA;    // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;    // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE, (GstMessageType) (GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Free resources */&#xA;    if (msg != NULL)&#xA;    // 减少 Message 的引用计数, 如果为零则销毁&#xA;    gst_message_unref(msg);&#xA;&#xA;    // 减少 Bus(总线) 的引用计数, 如果为零则销毁&#xA;    gst_object_unref(bus);&#xA;    // 设置 Element 状态为 GST_STATE_NULL&#xA;    gst_element_set_state(pipeline, GST_STATE_NULL);&#xA;    // 减少 Element(管道) 的引用计数, 如果为零则销毁&#xA;    gst_object_unref(pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;win32 {&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\gstreamer-1.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\glib-2.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\lib\glib-2.0\include&#xA;    LIBS += D:\gstreamer\1.0\x86\lib\gstreamer-1.0.lib&#xA;}&#xA;&#xA;unix {&#xA;    INCLUDEPATH += /usr/include/gstreamer-1.0&#xA;    INCLUDEPATH += /usr/include/glib-2.0&#xA;    INCLUDEPATH += /usr/lib/aarch64-linux-gnu/glib-2.0/include&#xA;    LIBS += -lgstreamer-1.0 -lgobject-2.0 -lglib-2.0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Rockchip Linux 扩展&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译安装 ...&#xA;https://github.com/rockchip-linux/mpp&#xA;https://github.com/rockchip-linux/gstreamer-rockchip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 视频播放 ...&#xA;gst-launch-1.0 --gst-plugin-path=/usr/local/lib/gstreamer-1.0 filesrc location=/root/bright_me_up_3840x2160_30fps.mp4 ! qtdemux ! queue ! h264parse ! mppvideodec ! fpsdisplaysink text-overlay=false video-sink=kmssink&#xA;&#xA;// 视频 and 音频播放 ...&#xA;gst-launch-1.0 filesrc location=bright_me_up_3840x2160_30fps.mp4 ! qtdemux name=demux  demux.audio_0 ! queue ! decodebin ! audioconvert ! audioresample ! autoaudiosink demux.video_0 ! queue ! h264parse ! mppvideodec ! fpsdisplaysink text-overlay=false video-sink=kmssink&#xA;&#xA;// Debug ...&#xA;GST_DEBUG=fpsdisplaysink:5 gst-launch-1.0  filesrc location=bright_me_up_3840x2160_30fps.mp4 ! qtdemux name=demux  demux.audio_0 ! queue ! decodebin ! audioconvert ! audioresample ! autoaudiosink demux.video_0 ! queue ! h264parse ! mppvideodec ! videorate ! video/x-raw,framerate=30/1,width=3840,height=2160 ! fpsdisplaysink text-overlay=false video-sink=kmssink&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Gstreamer之基础教程案例分析</title>
      <link>http://www.nljb.net/default/Gstreamer%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>2020-08-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Gstreamer之基础教程案例分析&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 名词解释&#xA;&#xA;元件(Elements)&#xA;// 元件(element)是 GStreamer 中最重要的概念。&#xA;// 你可以通过创建一系列的元件(Elements),并把它们连接起来&#xA;// 从而让数据流在这个被连接的各个元件(Elements)之间传输&#xA;&#xA;箱柜(Bins)&#xA;// 箱柜(Bins)是一个可以装载元件(element)的容器。&#xA;// 管道(pipelines)是箱柜(Bins)的一个特殊的子类型,&#xA;// 管道(pipelines)可以操作包含在它自身内部的所有元件(element)。&#xA;// 因为箱柜(Bins)本身又是元件(element)的子集&#xA;// 所以你能够象操作普通元件(element)一样的操作一个箱柜(Bins), &#xA;// 通过这种方法可以降低你的应用程序的复杂度。&#xA;// 你可以改变一个箱柜(Bins)的状态来改变箱柜(Bins)内部所有元件(element)的状态。&#xA;// 箱柜(Bins)可以发送总线消息(bus messages)给它的子集元件(element)&#xA;// (这些消息包括:错误消息(error messages),标签消息(tag messages),EOS 消息(EOS messages))&#xA;&#xA;管道(pipelines)&#xA;// 管道(pipeline)是高级的箱柜(Bins)。&#xA;// 当你设定管道的暂停或者播放状态的时候,数据流将开始流动,并且媒体数据处理也开始处理。&#xA;// 一旦开始,管道将在一个单独的线程中运行,直到被停止或者数据流播放完毕。&#xA;&#xA;衬垫(Pads)&#xA;// 衬垫(Pads)在 GStreamer 中被用于多个元件的链接,从而让数据流能在这样的链接中流动。&#xA;// 一个衬垫(Pads)可以被看作是一个元件(element)插座或者端口, 元件(element)之间的链接就是依靠着衬垫(Pads)。&#xA;// 衬垫(Pads)有处理特殊数据的能力: 一个衬垫(Pads)能够限制数据流类型的通过。&#xA;// 链接成功的条件是：只有在两个衬垫(Pads)允许通过的数据类型一致的时候才被建立。&#xA;// 数据类型的设定使用了一个叫做 caps negotiation 的方法。数据类型被为一个 GstCaps 变量所描述。&#xA;&#xA;总线(Bus)&#xA;// 总线是一个简单的系统，它采用自己的线程机制将一个管道线程的消息分发到一个应用程序当中。&#xA;// 总线的优势是：当使用 GStreamer 的时候，应用程序不需要线程识别，即便 GStreamer 已经被加载了多个线程&#xA;// 每一个管道默认包含一个总线，所以应用程序不需要再创建总线。&#xA;// 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器。&#xA;// 当主循环运行的时候，总线将会轮询这个消息处理器是否有新的消息，当消息被采集到后，总线将呼叫相应的回调函数来完成任务&#xA;&#xA;消息类型(Message types)&#xA;// GStreamer 有几种由总线传递的预定义消息类型，这些消息都是可扩展的。&#xA;// 插件可以定义另外的一些消息，应用程序可以有这些消息的绝对代码或者忽略它们。&#xA;// 强烈推荐应用程序至少要处理错误消息并直接的反馈给用户&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 便携元素（常用的Element）&#xA;// 这些是 Bin element，它们在内部包含其他的element，已经组成了内部的pipeline，但在外部，我们还是把它们当成一个element&#xA;&#xA;playbin、playbin2&#xA;// 这个 Element 在整个系列的教程里面广泛的被使用了。&#xA;// 它会处理播放的方方面面，从源经过解复用、解码到最后的显示。&#xA;// 同时它也非常灵活，有很多设置项，在后面有教程会更详细的讲述到。&#xA;&#xA;uridecodebin&#xA;// 这个 Element 从一个URI获得数据然后解码成原始媒体数据。&#xA;// 它会选择一个能处理给定的URI的source element，然后和decodebin2连接起来。&#xA;// 它在一个媒体里面发现多少流就提供多少source pad来输出，这点和解复用很像。&#xA;gst-launch-1.0 uridecodebin uri=https://www.freedesktop.org/sintel_trailer-480p.webm ! videoconvert ! autovideosink&#xA;gst-launch-1.0 uridecodebin uri=https://www.freedesktop.org/sintel_trailer-480p.webm ! audioconvert ! autoaudiosink&#xA;&#xA;decodebin2、decodebin2&#xA;// 这个 Element 会自动用解复用插件和解码插件创建解码pipeline&#xA;// 它被使用起来更方便的 uridecodebin 作为一个source element集成在自己内部了。&#xA;// 以前还有一个旧的decodebin，目前已经废弃不用了。&#xA;// 和uridecodebin一样，它也是在媒体里面发现多少流就提供多少source pad来输出。&#xA;gst-launch-0.10 souphttpsrc location=http://docs.gstreamer.com/media/sintel_trailer-480p.webm ! decodebin2 ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 文件输入/输出&#xA;&#xA;filesrc&#xA;// 这个 Element 会读取一个本地文件然后用Caps来输出媒体数据。&#xA;// 如果你想要获得一个正确地Caps，那么需要用typefind element来搜索流或者把filesrc的typefind属性设置成TRUE。&#xA;gst-launch-0.10 filesrc location=f:\\media\\sintel\\sintel_trailer-480p.webm ! decodebin2 ! autovideosink&#xA;&#xA;filesink&#xA;// 这个 Element 会把所有收到的媒体数据存成文件。使用location属性来指定路径和文件名。&#xA;gst-launch-0.10 audiotestsrc ! vorbisenc ! oggmux ! filesink location=test.ogg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 网络   &#xA;&#xA;souphttpsrc&#xA;// 这个 Element 作为一个客户端，使用SOUP库经由HTTP来接收数据。通过location属性来设置URL。&#xA;gst-launch-0.10 souphttpsrc location=http://docs.gstreamer.com/media/sintel_trailer-480p.webm ! decodebin2 ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试媒体数据生成&#xA;// 这些 Element 在测试 pipeline 是否工作时是非常有用的，它们是确保可以工作生成数据的，所以可以取代数据源。&#xA;&#xA;videotestsrc&#xA;// 这个 Element 生成一个固定的video输出（通过pattern属性来设置），用来测试视频的pipeline。&#xA;gst-launch-0.10 videotestsrc ! ffmpegcolorspace ! autovideosink&#xA;&#xA;audiotestsrc&#xA;// 这个 Element 生成一个音频信号（通过设置wave属性来设置），用来测试音频的pipeline。&#xA;gst-launch-0.10 audiotestsrc ! audioconvert ! autoaudiosink&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 视频适配&#xA;&#xA;ffmpegcolorspace&#xA;// 这个 Element 会把一个色彩空间转换到另一个色彩空间（比如从RGB转到YUV）。它也可以在转换不同的YUV格式或者RGB格式。&#xA;gst-launch-0.10 videotestsrc ! ffmpegcolorspace ! autovideosink&#xA;&#xA;videorate&#xA;// 这个 Element 接受带时间戳的视频数据转换成匹配source pad帧率的流。&#xA;// 通过丢弃或者复制帧来执行改正，而不是通过古怪的算法。&#xA;// 这个在连接不同帧率的 Element 时很有用。&#xA;// 正如其他的适配插件，如果不需要的话会直通过去（上下游element能匹配上）。&#xA;// 如果实际帧率未知的情况下，为了以防万一，使用这个element是个不错的主意。&#xA;gst-launch-0.10 videotestsrc ! video/x-raw-rgb,framerate=30/1 ! videorate ! video/x-raw-rgb,framerate=1/1 ! ffmpegcolorspace ! autovideosink&#xA;&#xA;videoscale&#xA;// 这个 Element 可以修改视频帧的尺寸。&#xA;// 这个 Element 会先检查不修改视频尺寸是否可行，如果可行，就不在进行尺寸的转换。&#xA;// 这个 Element 支持很多色彩空间，包括不同的YUV和RGB格式。而且可以放在pipeline的任何地方。&#xA;// 如果视频是往一个用户控制的窗口输出时，加上videoscale这个element是个好主意，因为并不是所有的视频输出都是支持缩放的。&#xA;gst-launch-0.10 uridecodebin uri=http://docs.gstreamer.com/media/sintel_trailer-480p.webm ! videoscale ! video/x-raw-yuv,width=178,height=100 ! ffmpegcolorspace ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 音频适配&#xA;&#xA;audioconvert&#xA;// 这个 Element 会转化原始的不同音频格式之间的缓冲。&#xA;// 它支持从整数到浮点数的转化，符号数/字节序转换以及声道转换。&#xA;gst-launch-0.10 audiotestsrc ! audioconvert ! autoaudiosink&#xA;&#xA;audioresample&#xA;// 这个 Element 使用可配置的窗口函数重采样音频缓冲到不同的采样率来增强质量。&#xA;gst-launch-0.10 uridecodebin uri=http://docs.gstreamer.com/media/sintel_trailer-480p.webm ! audioresample ! audio/x-raw-float,rate=4000 ! audioconvert ! autoaudiosink&#xA;&#xA;audiorate&#xA;// 这个 Element 接受带时间戳的音频帧，然后通过增加或者降低采样来获得一个标准流。&#xA;// 它不能修改采样率，只能通过移除重叠部分和填充空白部分来获得连续“干净”的输出。&#xA;// 当时间戳丢失接收器要求所有的采样同时渲染时这个element比较有用。&#xA;// 大多数时候，audiorate这不是您想要的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 多线程&#xA;&#xA;queue&#xA;// Queue 已经在《GStreamer基础教程07——多线程和Pad的有效性》里面介绍过了。&#xA;// 基本上，一个 queue 执行两个任务：数据可以一直放进队列直到满为止&#xA;// Queue 会给source pad创建一个新的线程，这样就可以解耦对于sink和source pad的处理&#xA;// 另外，Queue 在变空或满的时候会触发信号，可以抛弃一些缓冲数据来避免阻塞。&#xA;// 如果你不面临网络缓冲的困境，那么使用更简单的queue element而不是queue2，&#xA;// 具体例子同样参考《GStreamer基础教程07——多线程和Pad的有效性》&#xA;&#xA;queue2 &#xA;// 这个 Queue2 Element 不是 Queue 的进化版本。&#xA;// 它和queue有同样地设计目标，但实现方法不同，这也导致了一些功能不太一致。不幸的是，通常来说很难说孰优孰劣。&#xA;// Queue2 同样执行了上面列出的queue的两个任务，此外，还可以把收到的数据存在硬盘上。&#xA;// 它同时用更通用更方便的缓冲消息来取代了空/满这些信号，这个缓冲消息在《GStreamer基础教程12——流》里面描述过了。&#xA;// 当涉及到网络缓冲时，请使用queue2而不是queue。请参考《GStreamer基础教程12——流》。&#xA;&#xA;multiqueue&#xA;// 这个 Element 可以对多个流同时提供 Queue，并且简化对流的管理。&#xA;// 此外，它可以同步不同的流，确保任何一个流都不会运行的特别快。&#xA;// 这是一个先进的 Element。&#xA;// decodebin2里面包含着这个 Element，你在一个通常的播放应用里面很少会直接使用。&#xA;&#xA;tee&#xA;// 在《GStreamer基础教程07——多线程和Pad的有效性》这篇里面，我们已经演示了如何使用tee这个element。&#xA;// 把数据分成相同的多份是非常有用的，比如，可以同时在屏幕上播放图像和保存文件到硬盘。&#xA;// 在每个分支上使用独立的playbin2 element，提供相互独立的线程。否则一旦数据在一个分支上阻塞了，那么其它分支也会停止。&#xA;gst-launch-0.10 audiotestsrc ! tee name=t ! queue ! audioconvert ! autoaudiosink t. ! queue ! wavescope ! ffmpegcolorspace ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 能力&#xA;&#xA;capsfilter&#xA;// 在《GStreamer基础教程10——GStreamer工具》里面已经解释了gst-launch怎么使用Caps过滤。&#xA;// 当我们编程实现一个pipeline时，Caps过滤通常用capsfilter这个element来实现。&#xA;// 这个element不会修改数据，但会限制数据的类型。&#xA;gst-launch-0.10 videotestsrc ! video/x-raw-gray ! ffmpegcolorspace ! autovideosink&#xA;&#xA;typefind&#xA;// 这个 Element 决定了一个流所包含的媒体的类型。它按照他们的等级调用typefind函数。&#xA;// 一旦检测到，它就会把source pad设置成发现的媒体类型，然后发出have-type信号。&#xA;// decodebin2这个element内部就包含了typefind，虽然我们通常是使用GstDiscoverer来获得更多地信息，但你也可以用这个element来确定媒体类型。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 调试&#xA;&#xA;fakesink&#xA;// 这个 sink element 仅仅简单的抛弃所有输入的数据。&#xA;// 在调试过程中它是很有用的，你可以用它来取代你想使用的sink来确保不会出现意外。&#xA;// 它在gst-lauch命令行并出现-v参数后会显得非常冗余，如果你觉得无用信息太多，那么可以设置silent属性。&#xA;gst-launch-0.10 audiotestsrc num-buffers=1000 ! fakesink sync=false&#xA;&#xA;identity&#xA;// 这是一个哑巴 Element 仅仅把输入数据不加修改的传过来。&#xA;// 它也有一些有用的调试函数，例如偏移量和时间戳检测，或者丢弃缓冲。&#xA;// 想要进一步了解请阅读它的文档。&#xA;gst-launch-0.10 audiotestsrc ! identity drop-probability=0.1 ! audioconvert ! autoaudiosink&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 平台相关的 Element&#xA;&#xA;// 跨平台&#xA;&#xA;glimagesink&#xA;// 该视频接收器基于 OpenGL或OpenGL ES。&#xA;// 它支持缩放图像的重新缩放和过滤，以减轻锯齿。&#xA;// 它实现了VideoOverlay接口，因此可以重新设置视频窗口的父级（嵌入在其他窗口中）。&#xA;// 这是大多数平台上推荐的视频接收器。&#xA;// 特别是在Android和iOS上，它是唯一可用的视频接收器。&#xA;// 可以将其分解为 glupload ! glcolorconvert ! glimagesinkelement 将进一步的OpenGL硬件加速处理插入到管道中。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Linux&#xA;&#xA;ximagesink&#xA;// 标准的基于X系统的视频sink。它实现了XOverlay接口，所以视频窗口可以嵌入其他窗口。&#xA;// 它不支持视频缩放，需要实现这个功能必须使用其他的方法（比如videoscale element）。&#xA;&#xA;xvimagesink&#xA;// 一个基于X系统的视频sink，使用了XVideo_Extension(Xv)方法。&#xA;// 它实现了XOverlay接口，所以视频窗口可以嵌入其他窗口。&#xA;// 它支持在GPU上进行高效的视频缩放。&#xA;// 它仅在硬件和驱动支持Xv扩充的情况下才可以使用。&#xA;&#xA;cluttersink&#xA;// 这个Gstreamer视频sink会给ClutterTexture发送数据用来显示。&#xA;// Clutter是一个跨平台的库，所以每个平台都可以使用这个sink。&#xA;// Clutter通过使用OpenGL作为后台渲染的方法来获得平台无关性，所以必须保证系统支持OpenGL。&#xA;&#xA;alsasink&#xA;// 这个音频sink会通过ALSA来输出到声卡。&#xA;// 这个sink在几乎所有的linux平台上都有。它通常被看做声卡底层的接口，同时配置起来比较复杂。&#xA;&#xA;plusesink&#xA;// 这个sink在一个PulseAudio服务器上播放声音。&#xA;// 它是比ALSA更高层级的抽象，而且使用更加方便并且提供更多地一些高级功能。&#xA;// 但是，在一些旧的linux系统上不够稳定。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Mac OS X&#xA;&#xA;osxvideosink&#xA;// 这是在Mac OSX系统上唯一提供的视频sink。&#xA;&#xA;cluttersink&#xA;// 这个Gstreamer视频sink会给ClutterTexture发送数据用来显示。&#xA;// Clutter是一个跨平台的库，所以每个平台都可以使用这个sink。&#xA;// Clutter通过使用OpenGL作为后台渲染的方法来获得平台无关性，所以必须保证系统支持OpenGL。&#xA;&#xA;osxaudiosink&#xA;// 这是在Mac OSX系统上唯一提供的音频sink。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Windows&#xA;&#xA;directdrawsink  &#xA;// 这是Windows下最老的基于DirectDraw的视频sink。&#xA;// 它仅需要DirectX7，所以在目前几乎所有的Windows平台上都支持。&#xA;&#xA;dshowvideosink   &#xA;// 这是基于DirectShow的一个视频sink。&#xA;// 它可以使用不同的后端做渲染，比如EVR，VMR9或VMR7。&#xA;// 它支持视频图像尺寸调节并且可以过滤调节过得图像来避免混淆。&#xA;// 它实现了XOverlay的接口，所以视频窗口可以嵌入其他窗口中。&#xA;&#xA;d3dvideosink&#xA;// 这是最新的基于Direct3D的视频sink。&#xA;// 它支持视频图像尺寸调节并且可以过滤调节过得图像来避免混淆。&#xA;// 它实现了XOverlay的接口，所以视频窗口可以嵌入其他窗口中。&#xA;&#xA;cluttersink&#xA;// 这个Gstreamer视频sink会给ClutterTexture发送数据用来显示。&#xA;// Clutter是一个跨平台的库，所以每个平台都可以使用这个sink。&#xA;// Clutter通过使用OpenGL作为后台渲染的方法来获得平台无关性，所以必须保证系统支持OpenGL。&#xA;&#xA;directsoundsink&#xA;// 这是Windows默认的音频sink，基于所有Windows版本都支持的DirectSound。&#xA;&#xA;dshowdecwrapper&#xA;// DirectShow是类似于GStreamer的一个多媒体框架。&#xA;// 但它们也有很多的不同，pipeline是不能相互连接的。&#xA;// 但是，通过这个element，GStreamer就可以使用DirectShow的解码element的输出了。&#xA;// dshowdecwrapper可以包装多个DirectShow的解码器，然后放进GStreamer的pipeline。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Android&#xA;&#xA;eglglessink&#xA;// 这个视频sink是基于OpenGLES和EGL的。&#xA;// 它支持视频图像尺寸调节并且可以过滤调节过得图像来避免混淆。&#xA;// 它实现了XOverlay的接口，所以视频窗口可以嵌入其他窗口中。&#xA;&#xA;openslessink&#xA;// 这是GStreamer在Android平台上唯一的音频sink，它基于OpenSL ES。&#xA;&#xA;androidmedia&#xA;// android.media.MediaCodec是一个支持在设备侧编解码包括硬件编解码的一个Android上的API。&#xA;// 它在JellyBean之后就可以用了，GStreamer可以通过androidmedia插件来用这个API做音频和视频的解码。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// iOS&#xA;&#xA;eglglessink&#xA;// 这个视频sink是基于OpenGLES和EGL的。&#xA;// 它支持视频图像尺寸调节并且可以过滤调节过得图像来避免混淆。&#xA;// 它实现了XOverlay的接口，所以视频窗口可以嵌入其他窗口中。&#xA;&#xA;osxaudiosink&#xA;// 这是iOS上唯一支持的音频sink。&#xA;&#xA;iosassertsrc&#xA;// 读取iOS设备上内容（比如：照片，音乐，录像等等）的source element。&#xA;// 当你使用playbin2并且URI使用assets-library://这个格式的时候会用到这个element。&#xA;&#xA;iosavassetsrc&#xA;// 读取iOS设备上音视频内容（比如：照片，音乐，录像等等）的source element。&#xA;// 当你使用playbin2并且URI使用ipod-library://这个格式的时候会用到这个element。&#xA;// 这里的解码是针对系统优化过的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 你好世界 ...&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;#include &amp;quot;gst/gst.h&amp;quot;&#xA;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // Element 就像一个黑盒子, 一个管道 ...&#xA;    // 从 Element 的一端输入数据, Element 对数据进行一些处理，然后数据从 Element 的另一端输出&#xA;    GstElement *pipeline;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Build the pipeline */&#xA;    // gst_parse_launch 通过分析管道说明创建管道 ...&#xA;    // playbin 整合的元件，内部建立工厂管道&#xA;    pipeline = gst_parse_launch(&amp;quot;playbin uri=file:///e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;    /* Start playing */&#xA;    // GST_STATE_VOID_PENDING   无效挂起状态&#xA;    // GST_STATE_NULL           元素的空状态或初始状态&#xA;    // GST_STATE_READY          元素已准备好转到“暂停”。&#xA;    // GST_STATE_PAUSED         元素已暂停&#xA;    // GST_STATE_PLAYING        元素正在播放&#xA;    // 设置 Element 状态为 GST_STATE_PLAYING&#xA;    gst_element_set_state(pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Wait until error or EOS */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(pipeline);&#xA;&#xA;    // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;    // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE, (GstMessageType) (GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Free resources */&#xA;    if (msg != NULL)&#xA;        // 减少 Message 的引用计数, 如果为零则销毁&#xA;        gst_message_unref(msg);&#xA;&#xA;    // 减少 Bus(总线) 的引用计数, 如果为零则销毁&#xA;    gst_object_unref(bus);&#xA;    // 设置 Element 状态为 GST_STATE_NULL&#xA;    gst_element_set_state(pipeline, GST_STATE_NULL);&#xA;    // 减少 Element(管道) 的引用计数, 如果为零则销毁&#xA;    gst_object_unref(pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;win32 {&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\gstreamer-1.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\glib-2.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\lib\glib-2.0\include&#xA;    LIBS += -LD:/gstreamer/1.0/x86/lib -lgstreamer-1.0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// GStreamer 概念&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;#include &amp;quot;gst/gst.h&amp;quot;&#xA;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // Element 就像一个黑盒子, 一个管道 ...&#xA;    // 从 Element 的一端输入数据, Element 对数据进行一些处理，然后数据从 Element 的另一端输出&#xA;    GstElement *pipeline, *source, *sink;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    // 改变状态的返回结果 ...&#xA;    GstStateChangeReturn ret;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Create the elements */&#xA;    // gst_element_factory_make 创建 Element 元件&#xA;    // videotestsrc  是一个源元素（它产生数据）, 它创建一个测试视频模式&#xA;    // autovideosink 是一个接收器元素（它消耗数据）, 它在窗口上显示它接收到的图像&#xA;    source = gst_element_factory_make(&amp;quot;videotestsrc&amp;quot;, &amp;quot;source&amp;quot;);&#xA;    sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;sink&amp;quot;);&#xA;&#xA;    /* Create the empty pipeline */&#xA;    // 创建管道 ...&#xA;    pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;    if (!pipeline || !source || !sink) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Build the pipeline */&#xA;    // 管道是的一种特殊类型 bin 它是用于包含其他元素的元素&#xA;    // gst_bin_add_many 将元素添加到管道中（注意转换）&#xA;    gst_bin_add_many(GST_BIN(pipeline), source, sink, NULL);&#xA;    // 从源元素到接收器元素, 建立链接 ...&#xA;    if (gst_element_link(source, sink) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref (pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Modify the source&#39;s properties */&#xA;    // 元素具有可自定义的属性：g_object_get() 和 g_object_set()。&#xA;    // 可以修改以更改元素的行为的可命名属性（可写属性）&#xA;    // 也可以查询以了解元素的内部状态（可读属性）&#xA;    g_object_set(source, &amp;quot;pattern&amp;quot;, 0, NULL);&#xA;&#xA;    /* Start playing */&#xA;    // GST_STATE_VOID_PENDING   无效挂起状态&#xA;    // GST_STATE_NULL           元素的空状态或初始状态&#xA;    // GST_STATE_READY          元素已准备好转到“暂停”。&#xA;    // GST_STATE_PAUSED         元素已暂停&#xA;    // GST_STATE_PLAYING        元素正在播放&#xA;    // 设置 Element 状态为 GST_STATE_PLAYING&#xA;    ret = gst_element_set_state(pipeline, GST_STATE_PLAYING);&#xA;    if (ret == GST_STATE_CHANGE_FAILURE) {&#xA;        g_printerr(&amp;quot;Unable to set the pipeline to the playing state.\n&amp;quot;);&#xA;        gst_object_unref (pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Wait until error or EOS */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus (pipeline);&#xA;&#xA;    // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;    // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;    // 超时时间为 GST_CLOCK_TIME_NONE 永不超时 ... &#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE, (GstMessageType)(GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Parse message */&#xA;    if (msg != NULL) {&#xA;        GError *err;&#xA;        gchar *debug_info;&#xA;&#xA;        switch (GST_MESSAGE_TYPE(msg)) {&#xA;        case GST_MESSAGE_ERROR:&#xA;            gst_message_parse_error (msg, &amp;amp;err, &amp;amp;debug_info);&#xA;            g_printerr (&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME (msg-&amp;gt;src), err-&amp;gt;message);&#xA;            g_printerr (&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;            g_clear_error (&amp;amp;err);&#xA;            g_free (debug_info);&#xA;            break;&#xA;        case GST_MESSAGE_EOS:&#xA;            g_print (&amp;quot;End-Of-Stream reached.\n&amp;quot;);&#xA;            break;&#xA;        default:&#xA;            /* We should not reach here because we only asked for ERRORs and EOS */&#xA;            g_printerr (&amp;quot;Unexpected message received.\n&amp;quot;);&#xA;            break;&#xA;        }&#xA;        gst_message_unref (msg);&#xA;    }&#xA;&#xA;    /* Free resources */&#xA;    gst_object_unref (bus);&#xA;    gst_element_set_state (pipeline, GST_STATE_NULL);&#xA;    gst_object_unref (pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;win32 {&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\gstreamer-1.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\include\glib-2.0&#xA;    INCLUDEPATH += D:\gstreamer\1.0\x86\lib\glib-2.0\include&#xA;    LIBS += -LD:/gstreamer/1.0/x86/lib -lgstreamer-1.0 -lglib-2.0 -lgobject-2.0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 动态管道 ...&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;#include &amp;quot;gst/gst.h&amp;quot;&#xA;&#xA;using namespace std;&#xA;&#xA;/* Structure to contain all our information, so we can pass it to callbacks */&#xA;// Element 就像一个黑盒子, 一个管道 ...&#xA;// 从 Element 的一端输入数据, Element 对数据进行一些处理，然后数据从 Element 的另一端输出&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline;&#xA;    GstElement *source;&#xA;    GstElement *convert;&#xA;    GstElement *resample;&#xA;    GstElement *sink;&#xA;} CustomData;&#xA;&#xA;/* Handler for the pad-added signal */&#xA;static void pad_added_handler(GstElement *src, GstPad *pad, CustomData *data);&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 个人数据 ...&#xA;    CustomData data;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    // 改变状态的返回结果 ...&#xA;    GstStateChangeReturn ret;&#xA;&#xA;    gboolean terminate = FALSE;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Create the elements */&#xA;    // gst_element_factory_make 创建 Element 元件&#xA;    // uridecodebin 将在内部实例化所有必要的元素(sources, demuxers and decoders)&#xA;    // audioconvert 对于在不同的音频格式之间进行转换 ...&#xA;    // audioresample 对于在不同的音频采样率之间进行转换 ...&#xA;    // autoaudiosink 用于音频。它将音频流呈现到声卡 ...&#xA;    data.source = gst_element_factory_make(&amp;quot;uridecodebin&amp;quot;, &amp;quot;source&amp;quot;);&#xA;    data.convert = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;convert&amp;quot;);&#xA;    data.resample = gst_element_factory_make(&amp;quot;audioresample&amp;quot;, &amp;quot;resample&amp;quot;);&#xA;    data.sink = gst_element_factory_make(&amp;quot;autoaudiosink&amp;quot;, &amp;quot;sink&amp;quot;);&#xA;&#xA;    /* Create the empty pipeline */&#xA;    // 创建管道 ...&#xA;    data.pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;&#xA;    // 全部 Element 是否创建成功 ...&#xA;    if(!data.pipeline || !data.source || !data.convert || !data.resample || !data.sink) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Build the pipeline. Note that we are NOT linking the source at this point. We will do it later. */&#xA;    // 将元素添加到管道中（注意转换），并按顺序连接起来 ...&#xA;    gst_bin_add_many(GST_BIN(data.pipeline), data.source, data.convert, data.resample, data.sink, NULL);&#xA;&#xA;    // 将一系列元素链接在一起 ...&#xA;    if(!gst_element_link_many(data.convert, data.resample, data.sink, NULL)) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Set the URI to play */&#xA;    // 修改 URI 地址 ...&#xA;    g_object_set(data.source, &amp;quot;uri&amp;quot;, &amp;quot;file:///e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;    /* Connect to the pad-added signal */&#xA;    // 连接到 pad-added 信号, 通过回调 ... 收到通知 ...&#xA;    g_signal_connect(data.source, &amp;quot;pad-added&amp;quot;, G_CALLBACK(pad_added_handler), &amp;amp;data);&#xA;&#xA;    /* Start playing */&#xA;    // GST_STATE_VOID_PENDING   无效挂起状态&#xA;    // GST_STATE_NULL           元素的空状态或初始状态&#xA;    // GST_STATE_READY          元素已准备好转到“暂停”。&#xA;    // GST_STATE_PAUSED         元素已暂停&#xA;    // GST_STATE_PLAYING        元素正在播放&#xA;    // 设置 Element 状态为 GST_STATE_PLAYING&#xA;    ret = gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;    if(ret == GST_STATE_CHANGE_FAILURE) {&#xA;        g_printerr(&amp;quot;Unable to set the pipeline to the playing state.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Listen to the bus */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(data.pipeline);&#xA;    do {&#xA;        // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;        // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;        // 超时时间为 GST_CLOCK_TIME_NONE 永不超时 ...&#xA;        msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,(GstMessageType)(GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;        /* Parse message */&#xA;        if(msg != NULL) {&#xA;            GError *err;&#xA;            gchar *debug_info;&#xA;&#xA;            switch(GST_MESSAGE_TYPE(msg)) {&#xA;            case GST_MESSAGE_ERROR:&#xA;                gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;                g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;                g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;                g_clear_error(&amp;amp;err);&#xA;                g_free(debug_info);&#xA;                terminate = TRUE;&#xA;                break;&#xA;            case GST_MESSAGE_EOS:&#xA;                g_print(&amp;quot;End-Of-Stream reached.\n&amp;quot;);&#xA;                terminate = TRUE;&#xA;                break;&#xA;            case GST_MESSAGE_STATE_CHANGED:&#xA;                /* We are only interested in state-changed messages from the pipeline */&#xA;                if(GST_MESSAGE_SRC(msg) == GST_OBJECT(data.pipeline)) {&#xA;                    GstState old_state, new_state, pending_state;&#xA;                    gst_message_parse_state_changed(msg, &amp;amp;old_state, &amp;amp;new_state, &amp;amp;pending_state);&#xA;                    g_print(&amp;quot;Pipeline state changed from %s to %s:\n&amp;quot;,&#xA;                            gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));&#xA;                }&#xA;                break;&#xA;            default:&#xA;                /* We should not reach here */&#xA;                g_printerr(&amp;quot;Unexpected message received.\n&amp;quot;);&#xA;                break;&#xA;            }&#xA;            gst_message_unref(msg);&#xA;        }&#xA;    } while(!terminate);&#xA;&#xA;    /* Free resources */&#xA;    gst_object_unref(bus);&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;    gst_object_unref(data.pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&#xA;/* This function will be called by the pad-added signal */&#xA;// 此函数将由 pad-added 信号调用 ...&#xA;static void pad_added_handler(GstElement *src, GstPad *new_pad, CustomData *data) {&#xA;&#xA;    // Pad 是 Element 之间的数据的接口，一个src pad只能与一个sink pad相连。&#xA;    // 每个 Element 可以通过 Pad 过滤数据，接收自己支持的数据类型。&#xA;    // Pad 通过 Pad Capabilities（简称为Pad Caps）来描述支持的数据类型。&#xA;    // &amp;quot;video/x-raw,format=RGB,width=300,height=200,framerate=30/1&amp;quot;&#xA;    // &amp;quot;audio/x-raw,format=S16LE,rate=44100,channels=2&amp;quot;&#xA;    // &amp;quot;audio/x-vorbis” &amp;quot;video/x-vp8&amp;quot;&#xA;&#xA;    // 获取 Pad ...&#xA;    // 我们在之前已经创建了一组连接 data.convert &amp;gt; data.resample &amp;gt; data.sink&#xA;    // 此时获取到 data-&amp;gt;convert 的 sink_pad 就是为了 data.source &amp;gt; data.convert&#xA;    // 最终 data.source &amp;gt; data.convert &amp;gt; data.resample &amp;gt; data.sink ...&#xA;    GstPad *sink_pad = gst_element_get_static_pad(data-&amp;gt;convert, &amp;quot;sink&amp;quot;);&#xA;&#xA;    // Pad 的连接结果 ...&#xA;    GstPadLinkReturn ret;&#xA;    // Pad Caps ...&#xA;    GstCaps *new_pad_caps = NULL;&#xA;    // Pad Caps Struce ...&#xA;    GstStructure *new_pad_struct = NULL;&#xA;    // Pad Caps Struce Name ...&#xA;    const gchar *new_pad_type = NULL;&#xA;&#xA;    g_print(&amp;quot;Received new pad &#39;%s&#39; from &#39;%s&#39;:\n&amp;quot;, GST_PAD_NAME(new_pad), GST_ELEMENT_NAME(src));&#xA;&#xA;    /* If our converter is already linked, we have nothing to do here */&#xA;    // 判断 pad 是否连接 ... 处理未连接的 ...&#xA;    if(gst_pad_is_linked(sink_pad)) {&#xA;        g_print(&amp;quot;We are already linked. Ignoring.\n&amp;quot;);&#xA;        goto exit;&#xA;    }&#xA;&#xA;    /* Check the new pad&#39;s type */&#xA;    // 获取 Pad 当前的 Caps 根据不同的 Element 状态会有不同的结果&#xA;    new_pad_caps = gst_pad_get_current_caps(new_pad);&#xA;    // 从 Caps 中获取第一个结构 ...&#xA;    new_pad_struct = gst_caps_get_structure(new_pad_caps, 0);&#xA;    // 获取结构的名称 ...&#xA;    new_pad_type = gst_structure_get_name(new_pad_struct);&#xA;    // 判断结构是否为音频 ... 如果是 video/x-raw 则 goto exit ...&#xA;    if(!g_str_has_prefix(new_pad_type, &amp;quot;audio/x-raw&amp;quot;)) {&#xA;        g_print(&amp;quot;It has type &#39;%s&#39; which is not raw audio. Ignoring.\n&amp;quot;, new_pad_type);&#xA;        goto exit;&#xA;    }&#xA;&#xA;    /* Attempt the link */&#xA;    // 为两个 Pad 创建连接 ...&#xA;    ret = gst_pad_link(new_pad, sink_pad);&#xA;    if(GST_PAD_LINK_FAILED(ret)) {&#xA;        g_print(&amp;quot;Type is &#39;%s&#39; but link failed.\n&amp;quot;, new_pad_type);&#xA;    } else {&#xA;        g_print(&amp;quot;Link succeeded(type &#39;%s&#39;).\n&amp;quot;, new_pad_type);&#xA;    }&#xA;&#xA;exit:&#xA;    /* Unreference the new pad&#39;s caps, if we got them */&#xA;    if(new_pad_caps != NULL)&#xA;        gst_caps_unref(new_pad_caps);&#xA;&#xA;    /* Unreference the sink pad */&#xA;    gst_object_unref(sink_pad);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 时间管理 ...&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;#include &amp;quot;gst/gst.h&amp;quot;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;&#xA;/* Structure to contain all our information, so we can pass it around */&#xA;typedef struct _CustomData {&#xA;    GstElement *playbin;    // playbin Element 唯一管道&#xA;    gboolean playing;       // 是否处于 PLAYING 状态 ...&#xA;    gboolean terminate;     // 是否停止 ...&#xA;    gboolean seek_enabled;  // 是否开启（支持）跳转查询 ...&#xA;    gboolean seek_done;     // 跳转查询是否结束&#xA;    gint64 duration;        // 视频的持续时间（纳秒）&#xA;} CustomData;&#xA;&#xA;/* Forward definition of the message processing function */&#xA;static void handle_message(CustomData *data, GstMessage *msg);&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 个人数据 ...&#xA;    CustomData data;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    // 改变状态的返回结果 ...&#xA;    GstStateChangeReturn ret;&#xA;&#xA;    // 初始化默认值 ...&#xA;    data.playing = FALSE;&#xA;    data.terminate = FALSE;&#xA;    data.seek_enabled = FALSE;&#xA;    data.seek_done = FALSE;&#xA;    data.duration = GST_CLOCK_TIME_NONE;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Create the elements */&#xA;    // gst_element_factory_make 创建 Element 元件&#xA;    // playbin 整合的元件，内部建立工厂管道&#xA;    data.playbin = gst_element_factory_make(&amp;quot;playbin&amp;quot;, &amp;quot;playbin&amp;quot;);&#xA;&#xA;    // 创建管道是否成功 ...&#xA;    if(!data.playbin) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Set the URI to play */&#xA;    // 修改管道的 uri 地址 ...&#xA;    g_object_set(data.playbin, &amp;quot;uri&amp;quot;, &amp;quot;file:///e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;    /* Start playing */&#xA;    // 修改状态为 PLAYING ...&#xA;    ret = gst_element_set_state(data.playbin, GST_STATE_PLAYING);&#xA;    if(ret == GST_STATE_CHANGE_FAILURE) {&#xA;        g_printerr(&amp;quot;Unable to set the pipeline to the playing state.\n&amp;quot;);&#xA;        gst_object_unref(data.playbin);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Listen to the bus */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(data.playbin);&#xA;    do {&#xA;        // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;        // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;        // 增加获取 GST_MESSAGE_STATE_CHANGED 与 GST_MESSAGE_DURATION 消息返回 ...&#xA;        // 增加超时时间 100ms ... 超时未获取到 Message 则返回 NULL ...&#xA;        msg = gst_bus_timed_pop_filtered(bus, 100 * GST_MSECOND,&#xA;                                         (GstMessageType)(GST_MESSAGE_STATE_CHANGED |&#xA;                                                          GST_MESSAGE_ERROR |&#xA;                                                          GST_MESSAGE_EOS |&#xA;                                                          GST_MESSAGE_DURATION));&#xA;        /* Parse message */&#xA;        if(msg != NULL) {&#xA;            // 消息处理 ...&#xA;            handle_message(&amp;amp;data, msg);&#xA;        } else {&#xA;            /* We got no message, this means the timeout expired */&#xA;            // 我们没有收到消息，这意味着超时已过期&#xA;            if(data.playing)&#xA;            {&#xA;                // 当前时间 ...&#xA;                gint64 current = -1;&#xA;&#xA;                /* Query the current position of the stream */&#xA;                // 查询流的当前时间 ...&#xA;                if(!gst_element_query_position(data.playbin, GST_FORMAT_TIME, &amp;amp;current)) {&#xA;                    g_printerr(&amp;quot;Could not query current position.\n&amp;quot;);&#xA;                }&#xA;&#xA;                /* If we didn&#39;t know it yet, query the stream duration */&#xA;                // 如果 data.duration 不是有效的 (GST_CLOCK_TIME_NONE) 则查询 ...&#xA;                if(!GST_CLOCK_TIME_IS_VALID(data.duration)) {&#xA;                    // 查询流的总时间（持续时间）赋值到 data.duration ...&#xA;                    if(!gst_element_query_duration(data.playbin, GST_FORMAT_TIME, &amp;amp;data.duration)) {&#xA;                        g_printerr(&amp;quot;Could not query current duration.\n&amp;quot;);&#xA;                    }&#xA;                }&#xA;&#xA;                /* Print current position and total duration */&#xA;                // 打印当前位置和总持续时间&#xA;                g_print(&amp;quot;Position %&amp;quot; GST_TIME_FORMAT &amp;quot; / %&amp;quot; GST_TIME_FORMAT &amp;quot;\r&amp;quot;,&#xA;                        GST_TIME_ARGS(current), GST_TIME_ARGS(data.duration));&#xA;&#xA;                /* If seeking is enabled, we have not done it yet, and the time is right, seek */&#xA;                // data.seek_enabled 开启了跳转查询 ...&#xA;                // data.seek_done 跳转查询还未结束 ...&#xA;                // current &amp;gt; 5 * GST_SECOND 已经开始播放了 5 秒 ...&#xA;                if(data.seek_enabled &amp;amp;&amp;amp; !data.seek_done &amp;amp;&amp;amp; current &amp;gt; 5 * GST_SECOND) {&#xA;                    g_print(&amp;quot;\nReached 5s, performing seek...\n&amp;quot;);&#xA;                    // 使用 gst_element_seek_simple() 来执行跳转操作 ...&#xA;                    // 跳转到 10 秒的播放位置 ...&#xA;                    // format 执行seek的类型，这里使用 GST_FORMAT_TIME 表示我们基于时间的方式进行跳转&#xA;                    // seek_flags 通过标识指定seek的行为 GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT | GST_SEEK_FLAG_ACCURATE&#xA;                    // seek_pos 需要跳转的位置，前面指定了seek的类型为时间 ...&#xA;                    gst_element_seek_simple(data.playbin, GST_FORMAT_TIME,&#xA;                                            (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT), 10 * GST_SECOND);&#xA;                    // 跳转完成 ...&#xA;                    data.seek_done = TRUE;&#xA;                }&#xA;            }&#xA;        }&#xA;    } while(!data.terminate); // 未停止则继续循环 ...&#xA;&#xA;    /* Free resources */&#xA;    gst_object_unref(bus);&#xA;    gst_element_set_state(data.playbin, GST_STATE_NULL);&#xA;    gst_object_unref(data.playbin);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&#xA;static void handle_message(CustomData *data, GstMessage *msg) {&#xA;    GError *err;&#xA;    gchar *debug_info;&#xA;&#xA;    switch(GST_MESSAGE_TYPE(msg))&#xA;    {&#xA;    case GST_MESSAGE_ERROR:&#xA;        gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;        g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;        g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;        g_clear_error(&amp;amp;err);&#xA;        g_free(debug_info);&#xA;        data-&amp;gt;terminate = TRUE; // 出错停止&#xA;        break;&#xA;    case GST_MESSAGE_EOS:&#xA;        g_print(&amp;quot;End-Of-Stream reached.\n&amp;quot;);&#xA;        data-&amp;gt;terminate = TRUE; // 结尾停止&#xA;        break;&#xA;    case GST_MESSAGE_DURATION:&#xA;        // 每当流的持续时间更改时，此消息就会发布在总线上&#xA;        /* The duration has changed, mark the current one as invalid */&#xA;        data-&amp;gt;duration = GST_CLOCK_TIME_NONE;&#xA;        break;&#xA;    case GST_MESSAGE_STATE_CHANGED: {&#xA;        // 由于所有元素都有机会接收信息并自行配置&#xA;        // 因此寻求和时间查询通常仅在PAUSED或PLAYING状态下才能获得有效答复&#xA;        // GstState 状态 ...&#xA;        GstState old_state, new_state, pending_state;&#xA;        // 分析 Message 获取 State ...&#xA;        gst_message_parse_state_changed(msg, &amp;amp;old_state, &amp;amp;new_state, &amp;amp;pending_state);&#xA;        // 判断 Message 是否来自 data-&amp;gt;playbin ...&#xA;        if(GST_MESSAGE_SRC(msg) == GST_OBJECT(data-&amp;gt;playbin)) {&#xA;            // 获取旧状态与新状态 ... Element State Name ...&#xA;            g_print(&amp;quot;Pipeline state changed from %s to %s:\n&amp;quot;,&#xA;                    gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));&#xA;            /* Remember whether we are in the PLAYING state or not */&#xA;            // 标记当前状态是否处于 PLAYING ...&#xA;            data-&amp;gt;playing = (new_state == GST_STATE_PLAYING);&#xA;            // 如果 PLAYING ...&#xA;            if(data-&amp;gt;playing)&#xA;            {&#xA;                // ----------------------------------------------------- //&#xA;                /* We just moved to PLAYING. Check if seeking is possible */&#xA;                // GstQuery 查询机制，用于查询Element或Pad的相应信息。&#xA;                // 例如：查询当前的播放速率，产生的延迟，是否支持跳转等。&#xA;                GstQuery *query; // 跳转查询&#xA;                gint64 start, end; // 开始时间、结束时间&#xA;                // 构造一个跳转的查询对象，使用GST_FORMAT_TIME作为参数&#xA;                // 表明我们需要知道当前的文件是否支持通过时间进行跳转 ...&#xA;                // 简单说，仅仅，创建了一个跳转查询对象 ...&#xA;                query = gst_query_new_seeking(GST_FORMAT_TIME);&#xA;                // 将需要查询的 Element 传入查询获得结果 ...&#xA;                if(gst_element_query(data-&amp;gt;playbin, query)) {&#xA;                    // 解析结果查看是否支持跳转及所支持的范围 ...&#xA;                    gst_query_parse_seeking(query, NULL, &amp;amp;data-&amp;gt;seek_enabled, &amp;amp;start, &amp;amp;end);&#xA;                    // 是否开启（支持）跳转 ...&#xA;                    if(data-&amp;gt;seek_enabled) {&#xA;                        // 开始时间 GST_TIME_ARGS(start) 格式为 GST_TIME_FORMAT&#xA;                        // 结束时间 GST_TIME_ARGS(end) 格式为 GST_TIME_FORMAT&#xA;                        g_print(&amp;quot;Seeking is ENABLED from %&amp;quot; GST_TIME_FORMAT &amp;quot; to %&amp;quot; GST_TIME_FORMAT &amp;quot;\n&amp;quot;,&#xA;                                GST_TIME_ARGS(start), GST_TIME_ARGS(end));&#xA;                    } else {&#xA;                        g_print(&amp;quot;Seeking is DISABLED for this stream.\n&amp;quot;);&#xA;                    }&#xA;                }&#xA;                else {&#xA;                    g_printerr(&amp;quot;Seeking query failed.&amp;quot;);&#xA;                }&#xA;                // 释放查询对象 ...&#xA;                gst_query_unref(query);&#xA;                // ----------------------------------------------------- //&#xA;            }&#xA;        }&#xA;    } break;&#xA;    default:&#xA;        /* We should not reach here */&#xA;        g_printerr(&amp;quot;Unexpected message received.\n&amp;quot;);&#xA;        break;&#xA;    }&#xA;    gst_message_unref(msg);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-08-27-Gstreamer之基础教程案例分析.md/thread.jpg&#34; alt=&#34;&#34; width=&#34;700&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 多线程和 Pad 的可用性&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // Element 就像一个黑盒子, 一个管道 ...&#xA;    // 从 Element 的一端输入数据, Element 对数据进行一些处理，然后数据从 Element 的另一端输出&#xA;    GstElement *pipeline, *audio_source, *tee, *audio_queue, *audio_convert, *audio_resample, *audio_sink;&#xA;    GstElement *video_queue, *visual, *video_convert, *video_sink;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    // Bus 发出的消息是 GstMessage 结构&#xA;    GstMessage *msg;&#xA;&#xA;    // Pad 是 Element 之间的数据的接口，一个src pad只能与一个sink pad相连。&#xA;    // 每个 Element 可以通过 Pad 过滤数据，接收自己支持的数据类型。&#xA;    // Pad 通过 Pad Capabilities（简称为Pad Caps）来描述支持的数据类型。&#xA;    GstPad *tee_audio_pad, *tee_video_pad;&#xA;    GstPad *queue_audio_pad, *queue_video_pad;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Create the elements */&#xA;    // 创建 Elements ...&#xA;    // audiotestsrc 会产生测试的音频及波形数据 ...&#xA;    audio_source = gst_element_factory_make(&amp;quot;audiotestsrc&amp;quot;, &amp;quot;audio_source&amp;quot;);&#xA;    // 使用 tee Element 将数据分为两路，一路被用于播放，通过声卡输出，另一路被用于转换为视频波形，用于输出到屏幕&#xA;    tee = gst_element_factory_make(&amp;quot;tee&amp;quot;, &amp;quot;tee&amp;quot;); // 查询 gst-inspect-1.0 tee&#xA;    // queue 会创建单独的线程 ...&#xA;    audio_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;audio_queue&amp;quot;);&#xA;    // 转换元素 audioresample 和 videoconvert 对于保证管道的链接是必需的 ...&#xA;    audio_convert = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;audio_convert&amp;quot;);&#xA;    audio_resample = gst_element_factory_make(&amp;quot;audioresample&amp;quot;, &amp;quot;audio_resample&amp;quot;);&#xA;    // 音频输出 ...&#xA;    audio_sink = gst_element_factory_make(&amp;quot;autoaudiosink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;    // queue 会创建单独的线程 ...&#xA;    video_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;video_queue&amp;quot;);&#xA;    // wavescope 会将输入的音频数据转换为波形图像 ...&#xA;    visual = gst_element_factory_make(&amp;quot;wavescope&amp;quot;, &amp;quot;visual&amp;quot;);&#xA;    // 转换元素 audioconvert 对于保证管道的链接是必需的 ...&#xA;    video_convert = gst_element_factory_make(&amp;quot;videoconvert&amp;quot;, &amp;quot;csp&amp;quot;);&#xA;    // 视频输出 ...&#xA;    video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;&#xA;    /* Create the empty pipeline */&#xA;    // 创建管道 ...&#xA;    pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;&#xA;    // 检查是否创建成功 ...&#xA;    if(!pipeline || !audio_source || !tee || !audio_queue || !audio_convert || !audio_resample || !audio_sink ||&#xA;            !video_queue || !visual || !video_convert || !video_sink) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Configure elements */&#xA;    // 设置波的频率 ...&#xA;    g_object_set(audio_source, &amp;quot;freq&amp;quot;, 215.0f, NULL);&#xA;    // 设置着色器样式 ...&#xA;    g_object_set(visual, &amp;quot;shader&amp;quot;, 0, &amp;quot;style&amp;quot;, 1, NULL);&#xA;&#xA;    /* Link all elements that can be automatically linked because they have &amp;quot;Always&amp;quot; pads */&#xA;    // 管道是的一种特殊类型 bin 它是用于包含其他元素的元素&#xA;    // gst_bin_add_many 将元素添加到管道中（注意转换）&#xA;    gst_bin_add_many(GST_BIN(pipeline), audio_source, tee, audio_queue, audio_convert, audio_resample, audio_sink,&#xA;                     video_queue, visual, video_convert, video_sink, NULL);&#xA;    // 将一系列元素链接在一起 ...&#xA;    // audio_source &amp;gt; tee &amp;gt; tee Element 将数据分为两路 ...&#xA;    // audio_queue &amp;gt; audio_convert &amp;gt; audio_resample &amp;gt; audio_sink&#xA;    // video_queue &amp;gt; visual &amp;gt; video_convert &amp;gt; video_sink&#xA;    if(gst_element_link_many(audio_source, tee, NULL) != TRUE ||&#xA;            gst_element_link_many(audio_queue, audio_convert, audio_resample, audio_sink, NULL) != TRUE ||&#xA;            gst_element_link_many(video_queue, visual, video_convert, video_sink, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Manually link the Tee, which has &amp;quot;Request&amp;quot; pads */&#xA;    // 通过 gst_element_get_request_pad(tee, &amp;quot;src_%u&amp;quot;) 获取两个 Request Pad&#xA;    // 两个 Request Pad 的 src_0 和 src_1 分别用于 audio 和 video ...&#xA;    tee_audio_pad = gst_element_get_request_pad(tee, &amp;quot;src_%u&amp;quot;);&#xA;    g_print(&amp;quot;Obtained request pad %s for audio branch.\n&amp;quot;, gst_pad_get_name(tee_audio_pad));&#xA;    tee_video_pad = gst_element_get_request_pad(tee, &amp;quot;src_%u&amp;quot;);&#xA;    g_print(&amp;quot;Obtained request pad %s for video branch.\n&amp;quot;, gst_pad_get_name(tee_video_pad));&#xA;    // 获取 video_queue 与 audio_queue 的 Pad ...&#xA;    queue_video_pad = gst_element_get_static_pad(video_queue, &amp;quot;sink&amp;quot;);&#xA;    queue_audio_pad = gst_element_get_static_pad(audio_queue, &amp;quot;sink&amp;quot;);&#xA;    // 创建连接 tee_audio_pad &amp;gt; queue_audio_pad ...&#xA;    // 创建连接 tee_video_pad &amp;gt; queue_video_pad ...&#xA;    if(gst_pad_link(tee_audio_pad, queue_audio_pad) != GST_PAD_LINK_OK ||&#xA;            gst_pad_link(tee_video_pad, queue_video_pad) != GST_PAD_LINK_OK) {&#xA;        g_printerr(&amp;quot;Tee could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(pipeline);&#xA;        return -1;&#xA;    }&#xA;    // 释放 ...&#xA;    gst_object_unref(queue_audio_pad);&#xA;    gst_object_unref(queue_video_pad);&#xA;&#xA;    /* Start playing the pipeline */&#xA;    // 修改状态为 PLAYING ...&#xA;    gst_element_set_state(pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Wait until error or EOS */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(pipeline);&#xA;&#xA;    // 从总线上获取一条消息，该消息的类型与消息类型的掩码类型匹配，直到指定的超时时间为止（并丢弃所有与提供的掩码不匹配的消息）&#xA;    // 也就是直到从 Bus(总线) 总获取到 GST_MESSAGE_ERROR 或 GST_MESSAGE_EOS 消息时才返回 ...&#xA;    msg = gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,(GstMessageType)(GST_MESSAGE_ERROR | GST_MESSAGE_EOS));&#xA;&#xA;    /* Release the request pads from the Tee, and unref them */&#xA;    // 从 tee 中释放 pad 但仍需要使用 gst_object_unref() 取消引用（释放）&#xA;    gst_element_release_request_pad(tee, tee_audio_pad);&#xA;    gst_element_release_request_pad(tee, tee_video_pad);&#xA;    gst_object_unref(tee_audio_pad);&#xA;    gst_object_unref(tee_video_pad);&#xA;&#xA;    /* Free resources */&#xA;    if(msg != NULL)&#xA;        gst_message_unref(msg);&#xA;    gst_object_unref(bus);&#xA;    gst_element_set_state(pipeline, GST_STATE_NULL);&#xA;&#xA;    gst_object_unref(pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-08-27-Gstreamer之基础教程案例分析.md/thread2.jpg&#34; alt=&#34;&#34; width=&#34;700&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 捷径 ...&#xA;&#xA;// 之所以视频穿插着音频的转换与波形都是为了让音频数据转换为视频数据所做 ...&#xA;// Element 与 连接管道 ...&#xA;// appsrc &amp;gt; tee&#xA;// audio queue &amp;gt; audioconvert &amp;gt; audioresample &amp;gt; autoaudiosink&#xA;// video queue &amp;gt; audioconvert &amp;gt; wavescope &amp;gt; videoconvert &amp;gt; autovideosink&#xA;// app queue &amp;gt; appsink&#xA;&#xA;// Pad 组合&#xA;// tee &amp;gt; audio queue&#xA;// tee &amp;gt; video queue&#xA;// tee &amp;gt; app queue&#xA;&#xA;// 讲解一下这个捷径案例 ...&#xA;// appsrc 作为数据输出端，分别为 audio queue、video queue、app queue 输入数据 ...&#xA;// appsrc 监听两个信号 need-data(需要数据) enough-data(不需要数据，已满）&#xA;// appsrc 需要数据时调用 start_feed 函数添加空闲任务 push_data 来添加数据 ...&#xA;// appsrc 不需要数据时调用 stop_feed 函数移除空闲任务 ...&#xA;&#xA;// appsink 同时也接收来自 tee 的数据 ...&#xA;// appsink 监听 new-sample（接收新缓存数据）触发回调函数 new_sample()  ...&#xA;// appsink 在 new_sample() 函数中仅 pull-sample(接收缓冲) 并输出日志 ...&#xA;// appsink 目的只是让我们更加直观的看到发送缓冲与接收缓冲的过程 ...&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;#include &amp;lt;gst/audio/audio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;&#xA;#define CHUNK_SIZE 1024   /* Amount of bytes we are sending in each buffer */&#xA;#define SAMPLE_RATE 44100 /* Samples per second we are sending */&#xA;&#xA;/* Structure to contain all our information, so we can pass it to callbacks */&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline, *app_source, *tee, *audio_queue, *audio_convert1, *audio_resample, *audio_sink;&#xA;    GstElement *video_queue, *audio_convert2, *visual, *video_convert, *video_sink;&#xA;    GstElement *app_queue, *app_sink;&#xA;&#xA;    guint64 num_samples;   /* Number of samples generated so far(for timestamp generation) */&#xA;    gfloat a, b, c, d;     /* For waveform generation */&#xA;&#xA;    guint sourceid;        /* To control the GSource */&#xA;&#xA;    GMainLoop *main_loop;  /* GLib&#39;s Main Loop */&#xA;} CustomData;&#xA;&#xA;/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.&#xA; * The idle handler is added to the mainloop when appsrc requests us to start sending data(need-data signal)&#xA; * and is removed when appsrc has enough data(enough-data signal).&#xA; */&#xA;static gboolean push_data(CustomData *data) {&#xA;&#xA;    GstBuffer *buffer;&#xA;    GstFlowReturn ret;&#xA;    int i;&#xA;    GstMapInfo map;&#xA;    gint16 *raw;&#xA;    gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */&#xA;    gfloat freq;&#xA;&#xA;    /* Create a new empty buffer */&#xA;    // 创建一个新的空 BUFFER ...&#xA;    buffer = gst_buffer_new_and_alloc(CHUNK_SIZE);&#xA;&#xA;    /* Set its timestamp and duration */&#xA;    // 设置 BUFFER 时间戳和持续时间 ...&#xA;    GST_BUFFER_TIMESTAMP(buffer) = gst_util_uint64_scale(data-&amp;gt;num_samples, GST_SECOND, SAMPLE_RATE);&#xA;    GST_BUFFER_DURATION(buffer) = gst_util_uint64_scale(num_samples, GST_SECOND, SAMPLE_RATE);&#xA;&#xA;    /* Generate some psychodelic waveforms */&#xA;    // 生成一些自定义波形到 buffer ...&#xA;    gst_buffer_map(buffer, &amp;amp;map, GST_MAP_WRITE);&#xA;    raw =(gint16 *)map.data;&#xA;    data-&amp;gt;c += data-&amp;gt;d;&#xA;    data-&amp;gt;d -= data-&amp;gt;c / 1000;&#xA;    freq = 1100 + 1000 * data-&amp;gt;d;&#xA;    for(i = 0; i &amp;lt; num_samples; i++) {&#xA;        data-&amp;gt;a += data-&amp;gt;b;&#xA;        data-&amp;gt;b -= data-&amp;gt;a / freq;&#xA;        raw[i] =(gint16)(500 * data-&amp;gt;a);&#xA;    }&#xA;    gst_buffer_unmap(buffer, &amp;amp;map);&#xA;    data-&amp;gt;num_samples += num_samples;&#xA;&#xA;    /* Push the buffer into the appsrc */&#xA;    // 将缓冲区推入 appsrc ...&#xA;    g_signal_emit_by_name(data-&amp;gt;app_source, &amp;quot;push-buffer&amp;quot;, buffer, &amp;amp;ret);&#xA;&#xA;    /* Free the buffer now that we are done with it */&#xA;    // 释放缓冲区 ...&#xA;    gst_buffer_unref(buffer);&#xA;&#xA;    if(ret != GST_FLOW_OK) {&#xA;        /* We got some error, stop sending data */&#xA;        return FALSE;&#xA;    }&#xA;&#xA;    return TRUE;&#xA;}&#xA;&#xA;/* This signal callback triggers when appsrc needs data. Here, we add an idle handler&#xA; * to the mainloop to start pushing data into the appsrc */&#xA;// 当内部队列 appsrc 快要用尽（数据用完）时，将调用此函数&#xA;static void start_feed(GstElement *source, guint size, CustomData *data) {&#xA;    if(data-&amp;gt;sourceid == 0) {&#xA;        g_print(&amp;quot;Start feeding\n&amp;quot;);&#xA;        // g_idle_add() 增加一个空闲任务，让应用程序在空闲时执行指定的函数&#xA;        // g_idle_add() 该函数将数据写入到 appsrc 中，直到数据再次填满 ...&#xA;        data-&amp;gt;sourceid = g_idle_add((GSourceFunc) push_data, data);&#xA;    }&#xA;}&#xA;&#xA;/* This callback triggers when appsrc has enough data and we can stop sending.&#xA; * We remove the idle handler from the mainloop */&#xA;// 当 appsrc 有足够的数据并且我们可以停止发送时，这个回调就会触发。&#xA;// 我们从主循环中删除空闲处理程序 ...&#xA;static void stop_feed(GstElement *source, CustomData *data) {&#xA;    if(data-&amp;gt;sourceid != 0) {&#xA;        g_print(&amp;quot;Stop feeding\n&amp;quot;);&#xA;        // 当 appsrc 中的数据填满，则移除任务 ...&#xA;        g_source_remove(data-&amp;gt;sourceid);&#xA;        data-&amp;gt;sourceid = 0;&#xA;    }&#xA;}&#xA;&#xA;/* The appsink has received a buffer */&#xA;// appsink 已接收到缓冲区 ...&#xA;static GstFlowReturn new_sample(GstElement *sink, CustomData *data) {&#xA;    GstSample *sample;&#xA;&#xA;    /* Retrieve the buffer */&#xA;    // 接收这个缓冲区 BUFFER ...&#xA;    g_signal_emit_by_name(sink, &amp;quot;pull-sample&amp;quot;, &amp;amp;sample);&#xA;    if(sample) {&#xA;        /* The only thing we do in this example is print a * to indicate a received buffer */&#xA;        g_print(&amp;quot;*&amp;quot;);&#xA;        gst_sample_unref(sample);&#xA;        return GST_FLOW_OK;&#xA;    }&#xA;&#xA;    return GST_FLOW_ERROR;&#xA;}&#xA;&#xA;/* This function is called when an error message is posted on the bus */&#xA;// 此函数在总线上发布错误消息时调用 ...&#xA;static void error_cb(GstBus *bus, GstMessage *msg, CustomData *data) {&#xA;    GError *err;&#xA;    gchar *debug_info;&#xA;&#xA;    /* Print error details on the screen */&#xA;    gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;    g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;    g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;    g_clear_error(&amp;amp;err);&#xA;    g_free(debug_info);&#xA;&#xA;    g_main_loop_quit(data-&amp;gt;main_loop);&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 个人数据 ...&#xA;    CustomData data;&#xA;&#xA;    // GstPad ...&#xA;    GstPad *tee_audio_pad, *tee_video_pad, *tee_app_pad;&#xA;    GstPad *queue_audio_pad, *queue_video_pad, *queue_app_pad;&#xA;&#xA;    // 描述音频属性的信息。&#xA;    // 可以从 GstCaps 获取此信息 gst_audio_info_from_caps()。&#xA;    GstAudioInfo info;&#xA;&#xA;    // Pad 通过 Pad Capabilities（简称为Pad Caps）来描述支持的数据类型&#xA;    GstCaps *audio_caps;&#xA;&#xA;    // Bus(总线) 主要用于向用户提供内部 Elements 的事件信息&#xA;    // 每一个管道默认包含一个总线，所以应用程序不需要再创建总线&#xA;    // 应用程序只需要在总线上设置一个类似于对象的信号处理器的消息处理器&#xA;    GstBus *bus;&#xA;&#xA;    /* Initialize cumstom data structure */&#xA;    memset(&amp;amp;data, 0, sizeof(data));&#xA;    data.b = 1; /* For waveform generation */&#xA;    data.d = 1;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Create the elements */&#xA;    // gst_element_factory_make 创建 Element 元件&#xA;    data.app_source = gst_element_factory_make(&amp;quot;appsrc&amp;quot;, &amp;quot;audio_source&amp;quot;);&#xA;    data.tee = gst_element_factory_make(&amp;quot;tee&amp;quot;, &amp;quot;tee&amp;quot;);&#xA;    // audio ...&#xA;    data.audio_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;audio_queue&amp;quot;);&#xA;    data.audio_convert1 = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;audio_convert1&amp;quot;);&#xA;    data.audio_resample = gst_element_factory_make(&amp;quot;audioresample&amp;quot;, &amp;quot;audio_resample&amp;quot;);&#xA;    data.audio_sink = gst_element_factory_make(&amp;quot;autoaudiosink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;    // video ...&#xA;    data.video_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;video_queue&amp;quot;);&#xA;    data.audio_convert2 = gst_element_factory_make(&amp;quot;audioconvert&amp;quot;, &amp;quot;audio_convert2&amp;quot;);&#xA;    data.visual = gst_element_factory_make(&amp;quot;wavescope&amp;quot;, &amp;quot;visual&amp;quot;);&#xA;    data.video_convert = gst_element_factory_make(&amp;quot;videoconvert&amp;quot;, &amp;quot;video_convert&amp;quot;);&#xA;    data.video_sink = gst_element_factory_make(&amp;quot;autovideosink&amp;quot;, &amp;quot;video_sink&amp;quot;);&#xA;    // ...&#xA;    data.app_queue = gst_element_factory_make(&amp;quot;queue&amp;quot;, &amp;quot;app_queue&amp;quot;);&#xA;    data.app_sink = gst_element_factory_make(&amp;quot;appsink&amp;quot;, &amp;quot;app_sink&amp;quot;);&#xA;&#xA;    /* Create the empty pipeline */&#xA;    // 创建管道 ...&#xA;    data.pipeline = gst_pipeline_new(&amp;quot;test-pipeline&amp;quot;);&#xA;&#xA;    // 是否创建成功 ...&#xA;    if(!data.pipeline || !data.app_source || !data.tee || !data.audio_queue || !data.audio_convert1 ||&#xA;            !data.audio_resample || !data.audio_sink || !data.video_queue || !data.audio_convert2 || !data.visual ||&#xA;            !data.video_convert || !data.video_sink || !data.app_queue || !data.app_sink) {&#xA;        g_printerr(&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Configure wavescope */&#xA;    // 设置着色器样式 ...&#xA;    g_object_set(data.visual, &amp;quot;shader&amp;quot;, 0, &amp;quot;style&amp;quot;, 0, NULL);&#xA;&#xA;    /* Configure appsrc */&#xA;    // 生成 caps(来描述支持的数据类型) ...&#xA;    gst_audio_info_set_format(&amp;amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);&#xA;    audio_caps = gst_audio_info_to_caps(&amp;amp;info);&#xA;    // 需要在 appsrc 上设置的第一个属性是 caps 它指定元素将生成的数据类型 ...&#xA;    g_object_set(data.app_source, &amp;quot;caps&amp;quot;, audio_caps, &amp;quot;format&amp;quot;, GST_FORMAT_TIME, NULL);&#xA;&#xA;    // 当 appsrc 内部队列没有可用的数据时，触发 need-data 信号，执行 start_feed 填充 ...&#xA;    // 当 appsrc 内部队列写满时，触发 enough-data 信号，执行 stop_feed 停止填充 ...&#xA;&#xA;    // 连接到 app_source 的 need-data 信号, 通过回调 ... 收到通知 ...&#xA;    // 当内部队列没有可用的数据，“need-data”信号将被发送，该信号将通知应用程序应该推送更多的数据到appsrc中&#xA;    g_signal_connect(data.app_source, &amp;quot;need-data&amp;quot;, G_CALLBACK(start_feed), &amp;amp;data);&#xA;&#xA;    // 连接到 app_source 的 enough-data 信号, 通过回调 ... 收到通知 ...&#xA;    // 内部队列满时将发出“enough-data”信号，该信号通知应用程序应该停止向appsrc中推送数据了&#xA;    g_signal_connect(data.app_source, &amp;quot;enough-data&amp;quot;, G_CALLBACK(stop_feed), &amp;amp;data);&#xA;&#xA;    /* Configure appsink */&#xA;    // 需要通过该 emit-signals 属性启用信号发射 ，因为默认情况下它是禁用的.&#xA;    g_object_set(data.app_sink, &amp;quot;emit-signals&amp;quot;, TRUE, &amp;quot;caps&amp;quot;, audio_caps, NULL);&#xA;    // 我们连接到 new-sample 信号，该信号在接收器每次接收缓冲区时发出。&#xA;    g_signal_connect(data.app_sink, &amp;quot;new-sample&amp;quot;, G_CALLBACK(new_sample), &amp;amp;data);&#xA;    gst_caps_unref(audio_caps);&#xA;&#xA;    /* Link all elements that can be automatically linked because they have &amp;quot;Always&amp;quot; pads */&#xA;    // gst_bin_add_many 将元素添加到管道中（注意转换）&#xA;    gst_bin_add_many(GST_BIN(data.pipeline), data.app_source, data.tee, data.audio_queue, data.audio_convert1, data.audio_resample,&#xA;                     data.audio_sink, data.video_queue, data.audio_convert2, data.visual, data.video_convert, data.video_sink, data.app_queue,&#xA;                     data.app_sink, NULL);&#xA;    // 将一系列元素链接在一起 ...&#xA;    if(gst_element_link_many(data.app_source, data.tee, NULL) != TRUE ||&#xA;            gst_element_link_many(data.audio_queue, data.audio_convert1, data.audio_resample, data.audio_sink, NULL) != TRUE ||&#xA;            gst_element_link_many(data.video_queue, data.audio_convert2, data.visual, data.video_convert, data.video_sink, NULL) != TRUE ||&#xA;            gst_element_link_many(data.app_queue, data.app_sink, NULL) != TRUE) {&#xA;        g_printerr(&amp;quot;Elements could not be linked.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;&#xA;    /* Manually link the Tee, which has &amp;quot;Request&amp;quot; pads */&#xA;    // data.app_source tee 的 src_0(音频) 与 src_1(视频) 的数据输出接口 ...&#xA;    tee_audio_pad = gst_element_get_request_pad(data.tee, &amp;quot;src_%u&amp;quot;);&#xA;    g_print(&amp;quot;Obtained request pad %s for audio branch.\n&amp;quot;, gst_pad_get_name(tee_audio_pad));&#xA;    tee_video_pad = gst_element_get_request_pad(data.tee, &amp;quot;src_%u&amp;quot;);&#xA;    g_print(&amp;quot;Obtained request pad %s for video branch.\n&amp;quot;, gst_pad_get_name(tee_video_pad));&#xA;    tee_app_pad = gst_element_get_request_pad(data.tee, &amp;quot;src_%u&amp;quot;);&#xA;    g_print(&amp;quot;Obtained request pad %s for app branch.\n&amp;quot;, gst_pad_get_name(tee_app_pad));&#xA;    // 获取 data.audio_queue 与 data.video_queue 的数据输入接口 ...&#xA;    queue_audio_pad = gst_element_get_static_pad(data.audio_queue, &amp;quot;sink&amp;quot;);&#xA;    queue_video_pad = gst_element_get_static_pad(data.video_queue, &amp;quot;sink&amp;quot;);&#xA;    queue_app_pad = gst_element_get_static_pad(data.app_queue, &amp;quot;sink&amp;quot;);&#xA;    // 将数据输出接口与数据输入接口连接 ...&#xA;    if(gst_pad_link(tee_audio_pad, queue_audio_pad) != GST_PAD_LINK_OK ||&#xA;            gst_pad_link(tee_video_pad, queue_video_pad) != GST_PAD_LINK_OK ||&#xA;            gst_pad_link(tee_app_pad, queue_app_pad) != GST_PAD_LINK_OK) {&#xA;        g_printerr(&amp;quot;Tee could not be linked\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    // 释放 ...&#xA;    gst_object_unref(queue_audio_pad);&#xA;    gst_object_unref(queue_video_pad);&#xA;    gst_object_unref(queue_app_pad);&#xA;&#xA;    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(data.pipeline);&#xA;    // 主循环将轮询总线上是否存在新的消息，当存在新的消息的时候，总线会马上通知你&#xA;    // 每当管道发出一个消息到总线，这个消息处理器就会被触发 ...&#xA;    gst_bus_add_signal_watch(bus);&#xA;    // 连接到 message::error 信号，通过回调 ...&#xA;    g_signal_connect(G_OBJECT(bus), &amp;quot;message::error&amp;quot;,(GCallback)error_cb, &amp;amp;data);&#xA;    // 释放 ...&#xA;    gst_object_unref(bus);&#xA;&#xA;    /* Start playing the pipeline */&#xA;    // 设置 Element 状态为 GST_STATE_PLAYING&#xA;    gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Create a GLib Main Loop and set it to run */&#xA;    data.main_loop = g_main_loop_new(NULL, FALSE);&#xA;    // 主循环将持续不断的检查每个事件源产生的新事件，然后分发它们&#xA;    // 直到处理来自某个事件源的事件的时候触发了 g_main_loop_quit() 调用退出主循环为止&#xA;    g_main_loop_run(data.main_loop);&#xA;&#xA;    /* Release the request pads from the Tee, and unref them */&#xA;    gst_element_release_request_pad(data.tee, tee_audio_pad);&#xA;    gst_element_release_request_pad(data.tee, tee_video_pad);&#xA;    gst_element_release_request_pad(data.tee, tee_app_pad);&#xA;    gst_object_unref(tee_audio_pad);&#xA;    gst_object_unref(tee_video_pad);&#xA;    gst_object_unref(tee_app_pad);&#xA;&#xA;    /* Free resources */&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;    gst_object_unref(data.pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 播放速度&#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;&#xA;typedef struct _CustomData&#xA;{&#xA;    GstElement *pipeline;&#xA;    GstElement *video_sink;&#xA;    GMainLoop *loop;&#xA;&#xA;    gboolean playing;             // 播放状态 OR 暂停&#xA;    gdouble rate;                 // 播放速率&#xA;} CustomData;&#xA;&#xA;/* Send seek event to change rate */&#xA;// 发送 seek 事件修改播放速率 ...&#xA;static void send_seek_event(CustomData * data)&#xA;{&#xA;&#xA;    // GStreamer 提供了两种来变换播放的速度：Step事件和Seek事件。&#xA;    // Step 事件可以在改变后面的播放速度的情况下跳过一个指定的间隔（只能向前播放）。&#xA;    // Seek 事件，就可以跳转到任意一个地方并且可以设置播放速度（正向反向都可以）&#xA;&#xA;    gint64 position;&#xA;    GstEvent *seek_event;&#xA;&#xA;    /* Obtain the current position, needed for the seek event */&#xA;    if(!gst_element_query_position(data-&amp;gt;pipeline, GST_FORMAT_TIME, &amp;amp;position)) {&#xA;        g_printerr(&amp;quot;Unable to retrieve current position.\n&amp;quot;);&#xA;        return;&#xA;    }&#xA;&#xA;    /* Create the seek event */&#xA;    if(data-&amp;gt;rate &amp;gt; 0) {&#xA;        seek_event = gst_event_new_seek(data-&amp;gt;rate, GST_FORMAT_TIME,&#xA;                                        (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE), GST_SEEK_TYPE_SET,&#xA;                                        position, GST_SEEK_TYPE_END, 0);&#xA;    } else {&#xA;        seek_event = gst_event_new_seek(data-&amp;gt;rate, GST_FORMAT_TIME,&#xA;                                        (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE), GST_SEEK_TYPE_SET, 0,&#xA;                                        GST_SEEK_TYPE_SET, position);&#xA;    }&#xA;&#xA;    if(data-&amp;gt;video_sink == NULL) {&#xA;        /* If we have not done so, obtain the sink through which we will send the seek events */&#xA;        g_object_get(data-&amp;gt;pipeline, &amp;quot;video-sink&amp;quot;, &amp;amp;data-&amp;gt;video_sink, NULL);&#xA;    }&#xA;&#xA;    /* Send the event */&#xA;    gst_element_send_event(data-&amp;gt;video_sink, seek_event);&#xA;&#xA;    g_print(&amp;quot;Current rate: %g\n&amp;quot;, data-&amp;gt;rate);&#xA;}&#xA;&#xA;/* Process keyboard input */&#xA;// 处理键盘输入 ...&#xA;static gboolean handle_keyboard(GIOChannel * source, GIOCondition cond, CustomData * data)&#xA;{&#xA;&#xA;    // GStreamer 提供了两种来变换播放的速度：Step事件和Seek事件。&#xA;    // Step 事件可以在改变后面的播放速度的情况下跳过一个指定的间隔（只能向前播放）。&#xA;    // Seek 事件，就可以跳转到任意一个地方并且可以设置播放速度（正向反向都可以）&#xA;&#xA;    // 读取到的字符串 ...&#xA;    gchar *str = NULL;&#xA;&#xA;    // 从 GIOChannel 读取一行（包括终止字符）到新分配的字符串&#xA;    if(g_io_channel_read_line(source, &amp;amp;str, NULL, NULL, NULL) != G_IO_STATUS_NORMAL) {&#xA;        return TRUE;&#xA;    }&#xA;&#xA;    // 字符转换到小写 ...&#xA;    switch(g_ascii_tolower(str[0])) {&#xA;    case &#39;p&#39;: // 播放 OR 暂停&#xA;        data-&amp;gt;playing = !data-&amp;gt;playing;&#xA;        // 直接修改管道播放状态为暂停 ...&#xA;        gst_element_set_state(data-&amp;gt;pipeline, data-&amp;gt;playing ? GST_STATE_PLAYING : GST_STATE_PAUSED);&#xA;        g_print(&amp;quot;Setting state to %s\n&amp;quot;, data-&amp;gt;playing ? &amp;quot;PLAYING&amp;quot; : &amp;quot;PAUSE&amp;quot;);&#xA;        break;&#xA;    case &#39;s&#39;: // 提高速度 OR 降低速度&#xA;        // 判断字符串是否为大写 ...&#xA;        if(g_ascii_isupper(str[0])) {&#xA;            // 加速 ...&#xA;            data-&amp;gt;rate *= 2.0;&#xA;        } else {&#xA;            // 降速 ...&#xA;            data-&amp;gt;rate /= 2.0;&#xA;        }&#xA;        // 发送 seek 事件 ...&#xA;        send_seek_event(data);&#xA;        break;&#xA;    case &#39;d&#39;: // 切换播放方向 ...&#xA;        // 播放速度为负值 ...&#xA;        data-&amp;gt;rate *= -1.0;&#xA;        // 发送 seek 事件 ...&#xA;        send_seek_event(data);&#xA;        break;&#xA;    case &#39;n&#39;: // 移至下一帧 ...&#xA;        // 判断是否获取了 playbin video_sink ...&#xA;        // video_sink 要使用的视频输出元素 ...&#xA;        if(data-&amp;gt;video_sink == NULL) {&#xA;            /* If we have not done so, obtain the sink through which we will send the step events */&#xA;            // 如果 video_sink 为空则从 playbin pipeline 中获取 video_sink ...&#xA;            g_object_get(data-&amp;gt;pipeline, &amp;quot;video-sink&amp;quot;, &amp;amp;data-&amp;gt;video_sink, NULL);&#xA;        }&#xA;        // 向 video_sink 发送 step 事件 ...&#xA;        gst_element_send_event(data-&amp;gt;video_sink, gst_event_new_step(GST_FORMAT_BUFFERS, 1, ABS(data-&amp;gt;rate), TRUE, FALSE));&#xA;        g_print(&amp;quot;Stepping one frame\n&amp;quot;);&#xA;        break;&#xA;    case &#39;q&#39;:&#xA;        // 退出 ...&#xA;        g_main_loop_quit(data-&amp;gt;loop);&#xA;        break;&#xA;    default:&#xA;        break;&#xA;    }&#xA;&#xA;    g_free(str);&#xA;&#xA;    return TRUE;&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 个人数据&#xA;    CustomData data;&#xA;&#xA;    // 改变状态的返回结果 ...&#xA;    GstStateChangeReturn ret;&#xA;&#xA;    // GIOChannel 数据类型旨在提供一种可移植的方法&#xA;    // 用于使用文件描述符，管道和套接字&#xA;    // 并将它们集成到 main event loop&#xA;    GIOChannel *io_stdin;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Initialize our data structure */&#xA;    memset(&amp;amp;data, 0, sizeof(data));&#xA;&#xA;    /* Print usage map */&#xA;    // P 暂停或播放 ...&#xA;    // S 提高播放速度 OR s 降低播放速度&#xA;    // D 切换播放方向 ... 倒放 ...&#xA;    // N 移至下一帧（暂停效果更好）&#xA;    // Q 退出 ...&#xA;    g_print(&amp;quot;USAGE: Choose one of the following options, then press enter:\n&amp;quot;&#xA;            &amp;quot; &#39;P&#39; to toggle between PAUSE and PLAY\n&amp;quot;&#xA;            &amp;quot; &#39;S&#39; to increase playback speed, &#39;s&#39; to decrease playback speed\n&amp;quot;&#xA;            &amp;quot; &#39;D&#39; to toggle playback direction\n&amp;quot;&#xA;            &amp;quot; &#39;N&#39; to move to next frame(in the current direction, better in PAUSE)\n&amp;quot;&#xA;            &amp;quot; &#39;Q&#39; to quit\n&amp;quot;);&#xA;&#xA;    /* Build the pipeline */&#xA;    // playbin 整合的元件，内部建立工厂管道&#xA;    data.pipeline = gst_parse_launch(&amp;quot;playbin uri=file:///e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;    /* Add a keyboard watch so we get notified of keystrokes */&#xA;    // 添加键盘监听，以便我们收到有关击键的通知&#xA;#ifdef G_OS_WIN32&#xA;    // 在 Win32 系统上创建新的 GIOChannel&#xA;    io_stdin = g_io_channel_win32_new_fd(fileno(stdin));&#xA;#else&#xA;    // 在 UNIX 系统上创建新的 GIOChannel&#xA;    io_stdin = g_io_channel_unix_new(fileno(stdin));&#xA;#endif&#xA;    // 使用默认优先级将 GIOChannel 添加到默认主循环上下文中 ...&#xA;    // 当有IO输入时回调函数 handle_keyboard ...&#xA;    g_io_add_watch(io_stdin, G_IO_IN, (GIOFunc) handle_keyboard, &amp;amp;data);&#xA;&#xA;    /* Start playing */&#xA;    // 开始播放 ...&#xA;    ret = gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;    if(ret == GST_STATE_CHANGE_FAILURE) {&#xA;        g_printerr(&amp;quot;Unable to set the pipeline to the playing state.\n&amp;quot;);&#xA;        gst_object_unref(data.pipeline);&#xA;        return -1;&#xA;    }&#xA;    // 状态为播放&#xA;    data.playing = TRUE;&#xA;    // 播放速度&#xA;    data.rate = 1.0;&#xA;&#xA;    /* Create a GLib Main Loop and set it to run */&#xA;    // 创建一个 GLib 主循环并将其设置为运行 ...&#xA;    data.loop = g_main_loop_new(NULL, FALSE);&#xA;    g_main_loop_run(data.loop);&#xA;&#xA;    /* Free resources */&#xA;    g_main_loop_unref(data.loop);&#xA;    g_io_channel_unref(io_stdin);&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;    if(data.video_sink != NULL)&#xA;        gst_object_unref(data.video_sink);&#xA;    gst_object_unref(data.pipeline);&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 捷径二，此案例主要讲的的如何连接与配置 playbin 中的 appsrc  &#xA;&#xA;#include &amp;lt;QCoreApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;#include &amp;lt;gst/audio/audio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;&#xA;#define CHUNK_SIZE 1024   /* Amount of bytes we are sending in each buffer */&#xA;#define SAMPLE_RATE 44100 /* Samples per second we are sending */&#xA;&#xA;/* Structure to contain all our information, so we can pass it to callbacks */&#xA;typedef struct _CustomData {&#xA;    GstElement *pipeline;&#xA;    GstElement *app_source;&#xA;&#xA;    guint64 num_samples;   /* Number of samples generated so far(for timestamp generation) */&#xA;    gfloat a, b, c, d;     /* For waveform generation */&#xA;&#xA;    guint sourceid;        /* To control the GSource */&#xA;&#xA;    GMainLoop *main_loop;  /* GLib&#39;s Main Loop */&#xA;} CustomData;&#xA;&#xA;/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.&#xA; * The ide handler is added to the mainloop when appsrc requests us to start sending data(need-data signal)&#xA; * and is removed when appsrc has enough data(enough-data signal).&#xA; */&#xA;static gboolean push_data(CustomData *data) {&#xA;    GstBuffer *buffer;&#xA;    GstFlowReturn ret;&#xA;    int i;&#xA;    GstMapInfo map;&#xA;    gint16 *raw;&#xA;    gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */&#xA;    gfloat freq;&#xA;&#xA;    /* Create a new empty buffer */&#xA;    buffer = gst_buffer_new_and_alloc(CHUNK_SIZE);&#xA;&#xA;    /* Set its timestamp and duration */&#xA;    GST_BUFFER_TIMESTAMP(buffer) = gst_util_uint64_scale(data-&amp;gt;num_samples, GST_SECOND, SAMPLE_RATE);&#xA;    GST_BUFFER_DURATION(buffer) = gst_util_uint64_scale(num_samples, GST_SECOND, SAMPLE_RATE);&#xA;&#xA;    /* Generate some psychodelic waveforms */&#xA;    gst_buffer_map(buffer, &amp;amp;map, GST_MAP_WRITE);&#xA;    raw =(gint16 *)map.data;&#xA;    data-&amp;gt;c += data-&amp;gt;d;&#xA;    data-&amp;gt;d -= data-&amp;gt;c / 1000;&#xA;    freq = 1100 + 1000 * data-&amp;gt;d;&#xA;    for(i = 0; i &amp;lt; num_samples; i++) {&#xA;        data-&amp;gt;a += data-&amp;gt;b;&#xA;        data-&amp;gt;b -= data-&amp;gt;a / freq;&#xA;        raw[i] =(gint16)(500 * data-&amp;gt;a);&#xA;    }&#xA;    gst_buffer_unmap(buffer, &amp;amp;map);&#xA;    data-&amp;gt;num_samples += num_samples;&#xA;&#xA;    /* Push the buffer into the appsrc */&#xA;    g_signal_emit_by_name(data-&amp;gt;app_source, &amp;quot;push-buffer&amp;quot;, buffer, &amp;amp;ret);&#xA;&#xA;    /* Free the buffer now that we are done with it */&#xA;    gst_buffer_unref(buffer);&#xA;&#xA;    if(ret != GST_FLOW_OK) {&#xA;        /* We got some error, stop sending data */&#xA;        return FALSE;&#xA;    }&#xA;&#xA;    return TRUE;&#xA;}&#xA;&#xA;/* This signal callback triggers when appsrc needs data. Here, we add an idle handler&#xA; * to the mainloop to start pushing data into the appsrc */&#xA;static void start_feed(GstElement *source, guint size, CustomData *data) {&#xA;    if(data-&amp;gt;sourceid == 0) {&#xA;        g_print(&amp;quot;Start feeding\n&amp;quot;);&#xA;        data-&amp;gt;sourceid = g_idle_add((GSourceFunc) push_data, data);&#xA;    }&#xA;}&#xA;&#xA;/* This callback triggers when appsrc has enough data and we can stop sending.&#xA; * We remove the idle handler from the mainloop */&#xA;static void stop_feed(GstElement *source, CustomData *data) {&#xA;    if(data-&amp;gt;sourceid != 0) {&#xA;        g_print(&amp;quot;Stop feeding\n&amp;quot;);&#xA;        g_source_remove(data-&amp;gt;sourceid);&#xA;        data-&amp;gt;sourceid = 0;&#xA;    }&#xA;}&#xA;&#xA;/* This function is called when an error message is posted on the bus */&#xA;static void error_cb(GstBus *bus, GstMessage *msg, CustomData *data) {&#xA;    GError *err;&#xA;    gchar *debug_info;&#xA;&#xA;    /* Print error details on the screen */&#xA;    gst_message_parse_error(msg, &amp;amp;err, &amp;amp;debug_info);&#xA;    g_printerr(&amp;quot;Error received from element %s: %s\n&amp;quot;, GST_OBJECT_NAME(msg-&amp;gt;src), err-&amp;gt;message);&#xA;    g_printerr(&amp;quot;Debugging information: %s\n&amp;quot;, debug_info ? debug_info : &amp;quot;none&amp;quot;);&#xA;    g_clear_error(&amp;amp;err);&#xA;    g_free(debug_info);&#xA;&#xA;    g_main_loop_quit(data-&amp;gt;main_loop);&#xA;}&#xA;&#xA;/* This function is called when playbin has created the appsrc element, so we have&#xA; * a chance to configure it. */&#xA;// 这个函数是在 playbin 创建 appsrc 元素时调用的，提供一个配置它的机会 ...&#xA;static void source_setup(GstElement *pipeline, GstElement *source, CustomData *data) {&#xA;    GstAudioInfo info;&#xA;    GstCaps *audio_caps;&#xA;&#xA;    g_print(&amp;quot;Source has been created. Configuring.\n&amp;quot;);&#xA;    data-&amp;gt;app_source = source;&#xA;&#xA;    /* Configure appsrc */&#xA;    // 生成 caps(来描述支持的数据类型) ...&#xA;    gst_audio_info_set_format(&amp;amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);&#xA;    audio_caps = gst_audio_info_to_caps(&amp;amp;info);&#xA;    // 需要在 appsrc 上设置的第一个属性是 caps 它指定元素将生成的数据类型 ...&#xA;    g_object_set(source, &amp;quot;caps&amp;quot;, audio_caps, &amp;quot;format&amp;quot;, GST_FORMAT_TIME, NULL);&#xA;    // 当 appsrc 内部队列没有可用的数据时，触发 need-data 信号，执行 start_feed 填充 ...&#xA;    // 当 appsrc 内部队列写满时，触发 enough-data 信号，执行 stop_feed 停止填充 ...&#xA;    g_signal_connect(source, &amp;quot;need-data&amp;quot;, G_CALLBACK(start_feed), data);&#xA;    g_signal_connect(source, &amp;quot;enough-data&amp;quot;, G_CALLBACK(stop_feed), data);&#xA;    gst_caps_unref(audio_caps);&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QCoreApplication a(argc, argv);&#xA;&#xA;    // 个人数据&#xA;    CustomData data;&#xA;&#xA;    // 总线(Bus) ...&#xA;    GstBus *bus;&#xA;&#xA;    /* Initialize cumstom data structure */&#xA;    memset(&amp;amp;data, 0, sizeof(data));&#xA;    data.b = 1; /* For waveform generation */&#xA;    data.d = 1;&#xA;&#xA;    /* Initialize GStreamer */&#xA;    gst_init(&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;    /* Create the playbin element */&#xA;    // gst_parse_launch 通过分析管道说明创建管道 ...&#xA;    // playbin 整合的元件，内部建立工厂管道&#xA;    data.pipeline = gst_parse_launch(&amp;quot;playbin uri=appsrc://&amp;quot;, NULL);&#xA;&#xA;    // 连接到 source-setup 信号, 回调 source_setup ...&#xA;    // playbin 将创建一个内部 appsrc 元素并触发 source-setup 信号以允许应用程序对其进行配置 ...&#xA;    g_signal_connect(data.pipeline, &amp;quot;source-setup&amp;quot;, G_CALLBACK(source_setup), &amp;amp;data);&#xA;&#xA;    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */&#xA;    // 从 Element(管道) 中获得 Bus(总线)&#xA;    bus = gst_element_get_bus(data.pipeline);&#xA;    // 主循环将轮询总线上是否存在新的消息，当存在新的消息的时候，总线会马上通知你&#xA;    // 每当管道发出一个消息到总线，这个消息处理器就会被触发 ...&#xA;    gst_bus_add_signal_watch(bus);&#xA;    // 连接到 message::error 信号，通过回调 ...&#xA;    g_signal_connect(G_OBJECT(bus), &amp;quot;message::error&amp;quot;,(GCallback)error_cb, &amp;amp;data);&#xA;    gst_object_unref(bus);&#xA;&#xA;    /* Start playing the pipeline */&#xA;    // 设置 Element 状态为 GST_STATE_PLAYING&#xA;    gst_element_set_state(data.pipeline, GST_STATE_PLAYING);&#xA;&#xA;    /* Create a GLib Main Loop and set it to run */&#xA;    // 主循环将持续不断的检查每个事件源产生的新事件，然后分发它们&#xA;    // 直到处理来自某个事件源的事件的时候触发了 g_main_loop_quit() 调用退出主循环为止&#xA;    data.main_loop = g_main_loop_new(NULL, FALSE);&#xA;    g_main_loop_run(data.main_loop);&#xA;&#xA;    /* Free resources */&#xA;    gst_element_set_state(data.pipeline, GST_STATE_NULL);&#xA;    gst_object_unref(data.pipeline);&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 自定义播放器接收器&#xA;// playbin 允许选择所需的音频和视频接收器的两个属性 audio-sink 和 video-sink。&#xA;// 应用程序只需要实例化适当的 GstElement并将其传递给 playbin 这些属性&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;&#xA;  GstElement *pipeline, *bin, *equalizer, *convert, *sink;&#xA;  GstPad *pad, *ghost_pad;&#xA;  GstBus *bus;&#xA;  GstMessage *msg;&#xA;&#xA;  /* Initialize GStreamer */&#xA;  gst_init (&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;  /* Build the pipeline */&#xA;  pipeline = gst_parse_launch (&amp;quot;playbin uri=file:///e:/yiyezi.mp4&amp;quot;, NULL);&#xA;&#xA;  /* Create the elements inside the sink bin */&#xA;  // 创建 Element 元件 ...&#xA;  equalizer = gst_element_factory_make (&amp;quot;equalizer-3bands&amp;quot;, &amp;quot;equalizer&amp;quot;);&#xA;  convert = gst_element_factory_make (&amp;quot;audioconvert&amp;quot;, &amp;quot;convert&amp;quot;);&#xA;  sink = gst_element_factory_make (&amp;quot;autoaudiosink&amp;quot;, &amp;quot;audio_sink&amp;quot;);&#xA;  if (!equalizer || !convert || !sink) {&#xA;    g_printerr (&amp;quot;Not all elements could be created.\n&amp;quot;);&#xA;    return -1;&#xA;  }&#xA;&#xA;  /* Create the sink bin, add the elements and link them */&#xA;  // 创建 sink bin 添加 Element 并链接它们 ...&#xA;  bin = gst_bin_new (&amp;quot;audio_sink_bin&amp;quot;);&#xA;  // 添加 Element 到 sink bin 中 ...&#xA;  gst_bin_add_many (GST_BIN (bin), equalizer, convert, sink, NULL);&#xA;  // 创建连接 ...&#xA;  gst_element_link_many (equalizer, convert, sink, NULL);&#xA;  // 获取输入端 sink pad ...&#xA;  pad = gst_element_get_static_pad (equalizer, &amp;quot;sink&amp;quot;);&#xA;  // 创建虚拟 pad ...&#xA;  ghost_pad = gst_ghost_pad_new (&amp;quot;sink&amp;quot;, pad);&#xA;  // 激活虚拟 pad ...&#xA;  gst_pad_set_active (ghost_pad, TRUE);&#xA;  // 把虚拟 pad 加入到 sink bin 中 ...&#xA;  gst_element_add_pad (bin, ghost_pad);&#xA;  // 释放 ...&#xA;  gst_object_unref (pad);&#xA;&#xA;  /* Configure the equalizer */&#xA;  g_object_set (G_OBJECT (equalizer), &amp;quot;band1&amp;quot;, (gdouble)-24.0, NULL);&#xA;  g_object_set (G_OBJECT (equalizer), &amp;quot;band2&amp;quot;, (gdouble)-24.0, NULL);&#xA;&#xA;  /* Set playbin&#39;s audio sink to be our sink bin */&#xA;  // 将 playbin 的音频接收器设置为我们的接收器箱 ...&#xA;  g_object_set (GST_OBJECT (pipeline), &amp;quot;audio-sink&amp;quot;, bin, NULL);&#xA;&#xA;  /* Start playing */&#xA;  gst_element_set_state (pipeline, GST_STATE_PLAYING);&#xA;&#xA;  /* Wait until error or EOS */&#xA;  bus = gst_element_get_bus (pipeline);&#xA;  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);&#xA;&#xA;  /* Free resources */&#xA;  if (msg != NULL)&#xA;    gst_message_unref (msg);&#xA;  gst_object_unref (bus);&#xA;  gst_element_set_state (pipeline, GST_STATE_NULL);&#xA;  gst_object_unref (pipeline);&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方案例 appsrc-stream.c&#xA;// playbin 使用 appsrc push-buffer 来播放 ...&#xA;// https://github.com/GStreamer/gst-plugins-base/blob/master/tests/examples/app/appsrc-stream.c&#xA;&#xA;/* GStreamer&#xA; *&#xA; * appsrc-stream.c: example for using appsrc in streaming mode.&#xA; *&#xA; * Copyright (C) 2008 Wim Taymans &amp;lt;wim.taymans@gmail.com&amp;gt;&#xA; *&#xA; * This library is free software; you can redistribute it and/or&#xA; * modify it under the terms of the GNU Library General Public&#xA; * License as published by the Free Software Foundation; either&#xA; * version 2 of the License, or (at your option) any later version.&#xA; *&#xA; * This library is distributed in the hope that it will be useful,&#xA; * but WITHOUT ANY WARRANTY; without even the implied warranty of&#xA; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&#xA; * Library General Public License for more details.&#xA; *&#xA; * You should have received a copy of the GNU Library General Public&#xA; * License along with this library; if not, write to the&#xA; * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,&#xA; * Boston, MA 02110-1301, USA.&#xA; */&#xA;&#xA;#ifdef HAVE_CONFIG_H&#xA;#include &amp;quot;config.h&amp;quot;&#xA;#endif&#xA;&#xA;#include &amp;lt;gst/gst.h&amp;gt;&#xA;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;&#xA;GST_DEBUG_CATEGORY (appsrc_playbin_debug);&#xA;#define GST_CAT_DEFAULT appsrc_playbin_debug&#xA;&#xA;/*&#xA; * an example application of using appsrc in streaming push mode. We simply push&#xA; * buffers into appsrc. The size of the buffers we push can be any size we&#xA; * choose.&#xA; *&#xA; * This example is very close to how one would deal with a streaming webserver&#xA; * that does not support range requests or does not report the total file size.&#xA; *&#xA; * Some optimisations are done so that we don&#39;t push too much data. We connect&#xA; * to the need-data and enough-data signals to start/stop sending buffers.&#xA; *&#xA; * Appsrc in streaming mode (the default) does not support seeking so we don&#39;t&#xA; * have to handle any seek callbacks.&#xA; *&#xA; * Some formats are able to estimate the duration of the media file based on the&#xA; * file length (mp3, mpeg,..), others report an unknown length (ogg,..).&#xA; */&#xA;typedef struct _App App;&#xA;&#xA;struct _App&#xA;{&#xA;  GstElement *playbin;&#xA;  GstElement *appsrc;&#xA;&#xA;  GMainLoop *loop;&#xA;  guint sourceid;&#xA;&#xA;  GMappedFile *file;&#xA;  guint8 *data;&#xA;  gsize length;&#xA;  guint64 offset;&#xA;};&#xA;&#xA;App s_app;&#xA;&#xA;#define CHUNK_SIZE  4096&#xA;&#xA;/* This method is called by the idle GSource in the mainloop. We feed CHUNK_SIZE&#xA; * bytes into appsrc.&#xA; * The ide handler is added to the mainloop when appsrc requests us to start&#xA; * sending data (need-data signal) and is removed when appsrc has enough data&#xA; * (enough-data signal).&#xA; */&#xA;static gboolean&#xA;read_data (App * app)&#xA;{&#xA;  GstBuffer *buffer;&#xA;  guint len;&#xA;  GstFlowReturn ret;&#xA;&#xA;  if (app-&amp;gt;offset &amp;gt;= app-&amp;gt;length) {&#xA;    /* we are EOS, send end-of-stream and remove the source */&#xA;    g_signal_emit_by_name (app-&amp;gt;appsrc, &amp;quot;end-of-stream&amp;quot;, &amp;amp;ret);&#xA;    return FALSE;&#xA;  }&#xA;&#xA;  /* read the next chunk */&#xA;  buffer = gst_buffer_new ();&#xA;&#xA;  len = CHUNK_SIZE;&#xA;  if (app-&amp;gt;offset + len &amp;gt; app-&amp;gt;length)&#xA;    len = app-&amp;gt;length - app-&amp;gt;offset;&#xA;&#xA;  gst_buffer_append_memory (buffer,&#xA;      gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY,&#xA;          app-&amp;gt;data, app-&amp;gt;length, app-&amp;gt;offset, len, NULL, NULL));&#xA;&#xA;  GST_DEBUG (&amp;quot;feed buffer %p, offset %&amp;quot; G_GUINT64_FORMAT &amp;quot;-%u&amp;quot;, buffer,&#xA;      app-&amp;gt;offset, len);&#xA;  g_signal_emit_by_name (app-&amp;gt;appsrc, &amp;quot;push-buffer&amp;quot;, buffer, &amp;amp;ret);&#xA;  gst_buffer_unref (buffer);&#xA;  if (ret != GST_FLOW_OK) {&#xA;    /* some error, stop sending data */&#xA;    return FALSE;&#xA;  }&#xA;&#xA;  app-&amp;gt;offset += len;&#xA;&#xA;  return TRUE;&#xA;}&#xA;&#xA;/* This signal callback is called when appsrc needs data, we add an idle handler&#xA; * to the mainloop to start pushing data into the appsrc */&#xA;static void&#xA;start_feed (GstElement * playbin, guint size, App * app)&#xA;{&#xA;  if (app-&amp;gt;sourceid == 0) {&#xA;    GST_DEBUG (&amp;quot;start feeding&amp;quot;);&#xA;    app-&amp;gt;sourceid = g_idle_add ((GSourceFunc) read_data, app);&#xA;  }&#xA;}&#xA;&#xA;/* This callback is called when appsrc has enough data and we can stop sending.&#xA; * We remove the idle handler from the mainloop */&#xA;static void&#xA;stop_feed (GstElement * playbin, App * app)&#xA;{&#xA;  if (app-&amp;gt;sourceid != 0) {&#xA;    GST_DEBUG (&amp;quot;stop feeding&amp;quot;);&#xA;    g_source_remove (app-&amp;gt;sourceid);&#xA;    app-&amp;gt;sourceid = 0;&#xA;  }&#xA;}&#xA;&#xA;/* this callback is called when playbin has constructed a source object to read&#xA; * from. Since we provided the appsrc:// uri to playbin, this will be the&#xA; * appsrc that we must handle. We set up some signals to start and stop pushing&#xA; * data into appsrc */&#xA;static void&#xA;found_source (GObject * object, GObject * orig, GParamSpec * pspec, App * app)&#xA;{&#xA;  /* get a handle to the appsrc */&#xA;  g_object_get (orig, pspec-&amp;gt;name, &amp;amp;app-&amp;gt;appsrc, NULL);&#xA;&#xA;  GST_DEBUG (&amp;quot;got appsrc %p&amp;quot;, app-&amp;gt;appsrc);&#xA;&#xA;  /* we can set the length in appsrc. This allows some elements to estimate the&#xA;   * total duration of the stream. It&#39;s a good idea to set the property when you&#xA;   * can but it&#39;s not required. */&#xA;  g_object_set (app-&amp;gt;appsrc, &amp;quot;size&amp;quot;, (gint64) app-&amp;gt;length, NULL);&#xA;&#xA;  /* configure the appsrc, we will push data into the appsrc from the&#xA;   * mainloop. */&#xA;  g_signal_connect (app-&amp;gt;appsrc, &amp;quot;need-data&amp;quot;, G_CALLBACK (start_feed), app);&#xA;  g_signal_connect (app-&amp;gt;appsrc, &amp;quot;enough-data&amp;quot;, G_CALLBACK (stop_feed), app);&#xA;}&#xA;&#xA;static gboolean&#xA;bus_message (GstBus * bus, GstMessage * message, App * app)&#xA;{&#xA;  GST_DEBUG (&amp;quot;got message %s&amp;quot;,&#xA;      gst_message_type_get_name (GST_MESSAGE_TYPE (message)));&#xA;&#xA;  switch (GST_MESSAGE_TYPE (message)) {&#xA;    case GST_MESSAGE_ERROR:&#xA;      g_error (&amp;quot;received error&amp;quot;);&#xA;      g_main_loop_quit (app-&amp;gt;loop);&#xA;      break;&#xA;    case GST_MESSAGE_EOS:&#xA;      g_main_loop_quit (app-&amp;gt;loop);&#xA;      break;&#xA;    default:&#xA;      break;&#xA;  }&#xA;  return TRUE;&#xA;}&#xA;&#xA;int&#xA;main (int argc, char *argv[])&#xA;{&#xA;  App *app = &amp;amp;s_app;&#xA;  GError *error = NULL;&#xA;  GstBus *bus;&#xA;&#xA;  gst_init (&amp;amp;argc, &amp;amp;argv);&#xA;&#xA;  GST_DEBUG_CATEGORY_INIT (appsrc_playbin_debug, &amp;quot;appsrc-playbin&amp;quot;, 0,&#xA;      &amp;quot;appsrc playbin example&amp;quot;);&#xA;&#xA;  if (argc &amp;lt; 2) {&#xA;    g_print (&amp;quot;usage: %s &amp;lt;filename&amp;gt;\n&amp;quot;, argv[0]);&#xA;    return -1;&#xA;  }&#xA;&#xA;  /* try to open the file as an mmapped file */&#xA;  app-&amp;gt;file = g_mapped_file_new (argv[1], FALSE, &amp;amp;error);&#xA;  if (error) {&#xA;    g_print (&amp;quot;failed to open file: %s\n&amp;quot;, error-&amp;gt;message);&#xA;    g_error_free (error);&#xA;    return -2;&#xA;  }&#xA;  /* get some vitals, this will be used to read data from the mmapped file and&#xA;   * feed it to appsrc. */&#xA;  app-&amp;gt;length = g_mapped_file_get_length (app-&amp;gt;file);&#xA;  app-&amp;gt;data = (guint8 *) g_mapped_file_get_contents (app-&amp;gt;file);&#xA;  app-&amp;gt;offset = 0;&#xA;&#xA;  /* create a mainloop to get messages and to handle the idle handler that will&#xA;   * feed data to appsrc. */&#xA;  app-&amp;gt;loop = g_main_loop_new (NULL, TRUE);&#xA;&#xA;  app-&amp;gt;playbin = gst_element_factory_make (&amp;quot;playbin&amp;quot;, NULL);&#xA;  g_assert (app-&amp;gt;playbin);&#xA;&#xA;  bus = gst_pipeline_get_bus (GST_PIPELINE (app-&amp;gt;playbin));&#xA;&#xA;  /* add watch for messages */&#xA;  gst_bus_add_watch (bus, (GstBusFunc) bus_message, app);&#xA;&#xA;  /* set to read from appsrc */&#xA;  g_object_set (app-&amp;gt;playbin, &amp;quot;uri&amp;quot;, &amp;quot;appsrc://&amp;quot;, NULL);&#xA;&#xA;  /* get notification when the source is created so that we get a handle to it&#xA;   * and can configure it */&#xA;  g_signal_connect (app-&amp;gt;playbin, &amp;quot;deep-notify::source&amp;quot;,&#xA;      (GCallback) found_source, app);&#xA;&#xA;  /* go to playing and wait in a mainloop. */&#xA;  gst_element_set_state (app-&amp;gt;playbin, GST_STATE_PLAYING);&#xA;&#xA;  /* this mainloop is stopped when we receive an error or EOS */&#xA;  g_main_loop_run (app-&amp;gt;loop);&#xA;&#xA;  GST_DEBUG (&amp;quot;stopping&amp;quot;);&#xA;&#xA;  gst_element_set_state (app-&amp;gt;playbin, GST_STATE_NULL);&#xA;&#xA;  /* free the file */&#xA;  g_mapped_file_unref (app-&amp;gt;file);&#xA;&#xA;  gst_object_unref (bus);&#xA;  g_main_loop_unref (app-&amp;gt;loop);&#xA;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 硬件加速视频解码&#xA;&#xA;// 硬件加速视频解码已迅速成为必需。&#xA;// 本教程（实际上是讲座的更多内容）提供了有关硬件加速的背景知识，并说明了GStreamer如何从中受益。&#xA;// 如果设置正确，则无需执行任何特殊操作即可激活硬件加速。GStreamer会自动利用它。&#xA;&#xA;VAAPI（视频加速API）&#xA;// 最初由Intel在2007年设计, 目标是基于Unix的操作系统上的X Window System，现在是开源的。&#xA;// 现在它也通过dmabuf支持Wayland。当前不限于Intel GPU，因为其他制造商可以自由使用此API&#xA;// 例如 Imagination Technologies或 S3 Graphics。可通过gstreamer-vaapi软件包访问GStreamer 。&#xA;&#xA;VDPAU（UNIX视频解码和演示API）&#xA;// 最初由NVidia在2008年设计 ，目标是基于Unix操作系统上的X Window System，现在是开源的。&#xA;// 尽管它也是一个开源库，但除NVidia之外，没有其他制造商在使用它。&#xA;// 可通过plugins-bad中的vdpau元素访问GStreamer 。&#xA;&#xA;OpenMAX（开放媒体加速）&#xA;// 由非营利性技术联盟Khronos Group管理，它是“免版税的，跨平台的C语言编程接口集&#xA;// 可为例程（尤其对音频，视频和静态影像有用）提供抽象图片”。&#xA;// 可通过gst-omx插件访问GStreamer 。&#xA;&#xA;DCE （分布式编解码器引擎）&#xA;// 德州仪器（TI）针对Linux系统和ARM平台的开源软件库（“ libdce”）和API规范。&#xA;// 可通过gstreamer-ducati插件访问GStreamer 。&#xA;&#xA;Android MediaCodec&#xA;// 这是Android的API，用于访问设备的硬件解码器和编码器（如果有）。&#xA;// 可通过androidmediagst-plugins-bad中的插件进行访问 。这包括编码和解码。&#xA;&#xA;Apple VideoTool Box Framework&#xA;// 可通过applemedia插件访问Apple的h的API，该API 包括通过vtenc元素进行编码和通过元素进行解码vtdec。&#xA;&#xA;Video4Linux&#xA;// 最近的Linux内核具有内核API，可以以标准方式公开硬件编解码器，&#xA;// 现在该v4l2插件中的插件支持 gst-plugins-good。根据平台的不同，这可以支持解码和编码。&#xA;&#xA;Rockchip MPP&#xA;// 这是瑞芯微的API，用于访问设备的硬件解码器和编码器（如果有）。&#xA;// https://github.com/rockchiplinux/gstreamer-rockchip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看当前系统中各 Element 的优先级&#xA;root@orangepi4:~# gst-inspect-1.0 |grep mpp&#xA;rockchipmpp:  mppvideodec: Rockchip&#39;s MPP video decoder&#xA;rockchipmpp:  mpph264enc: Rockchip Mpp H264 Encoder&#xA;rockchipmpp:  mppjpegenc: Rockchip Mpp JPEG Encoder&#xA;rockchipmpp:  mppjpegdec: Rockchip&#39;s MPP JPEG image decoder&#xA;typefindfunctions: audio/x-musepack: mpc, mpp, mp+&#xA;root@orangepi4:~# gst-inspect-1.0 mppjpegdec&#xA;Factory Details:&#xA;  Rank                     primary (256) // 这里 Rank 就是优先级 ...&#xA;  Long-name                Rockchip&#39;s MPP JPEG image decoder&#xA;  Klass                    Decoder/Image&#xA;  Description              JPEG hardware decoder&#xA;  Author                   Randy Li &amp;lt;randy.li@rock-chips.com&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果有合适的API和相应的GStreamer插件可用，则应用程序无需执行任何特殊操作即可启用硬件加速。&#xA;// 通过使用更改解码元素的等级，可以启用或禁用硬件加速gst_plugin_feature_set_rank()。&#xA;&#xA;// 确保启用或禁用硬件加速的最简单方法是更改​​关联元素的等级，如以下代码所示：&#xA;&#xA;static void enable_factory (const gchar *name, gboolean enable) {&#xA;    GstRegistry *registry = NULL;&#xA;    GstElementFactory *factory = NULL;&#xA;&#xA;    registry = gst_registry_get_default ();&#xA;    if (!registry) return;&#xA;&#xA;    factory = gst_element_factory_find (name);&#xA;    if (!factory) return;&#xA;&#xA;    if (enable) {&#xA;        gst_plugin_feature_set_rank (GST_PLUGIN_FEATURE (factory), GST_RANK_PRIMARY + 1);&#xA;    }&#xA;    else {&#xA;        gst_plugin_feature_set_rank (GST_PLUGIN_FEATURE (factory), GST_RANK_NONE);&#xA;    }&#xA;&#xA;    gst_registry_add_feature (registry, GST_PLUGIN_FEATURE (factory));&#xA;    return;&#xA;}&#xA;&#xA;// 传递给此方法的第一个参数是要修改的元素的名称，例如vaapidecode或fluvadec&#xA;// 关键方法是gst_plugin_feature_set_rank()，它将设置所请求元素工厂的等级为所需级别。&#xA;// 为方便起见，等级分为NONE，MARGINAL，SECONDARY和PRIMARY，但是任何数字都可以。&#xA;// 启用元素时，我们将其设置为PRIMARY + 1，因此其等级高于通常具有PRIMARY等级的其余元素。&#xA;// 将元素的等级设置为NONE将使自动插入机制永远不会选择它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 获取管道图&#xA;&#xA;GST_DEBUG_DUMP_DOT_DIR&#xA;// 要获取.dot文件，只需将环境变量设置为指向您要放置文件的文件夹。&#xA;// gst-launch-1.0会.dot在每次状态更改时创建一个文件，因此您可以看到上限协商的演变。取消设置变量以禁用此功能。&#xA;&#xA;GST_DEBUG_BIN_TO_DOT_FILE(GST_BIN(app-&amp;gt;playbin), GST_DEBUG_GRAPH_SHOW_ALL, &amp;quot;pipeline-playing&amp;quot;);&#xA;// 在应用程序中，您可以方便地使用 GST_DEBUG_BIN_TO_DOT_FILE()和 GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS()宏来生成.dot文件。&#xA;// .dot文件存放了pipeline在不同的state的时候的结构，你可以用graphviz 工具打开.dot文件。&#xA;&#xA;// Graphviz 转换 dot 至 png&#xA;dot -Tpng src.dot -o dst.png&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 获取 gst_parse_launch 中的 GstElement ...&#xA;&#xA;GstElement *pipeline = gst_parse_launch(&amp;quot;udpsrc port=5801 ! rtph264depay ! h264parse ! omxh264dec ! glimagesink name=mySink&amp;quot;, NULL);&#xA;GstElement *sink = gst_bin_get_by_name((GstBin*)pipeline, &amp;quot;mySink&amp;quot;);&#xA;WId xwinid = w.OpenGLWidgetWId();&#xA;gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(sink), (guintptr)xwinid);&#xA;&#xA;m_playbin = gst_parse_launch(&amp;quot;playbin3 video-sink=glimagesink&amp;quot;, nullptr);&#xA;g_object_get(G_OBJECT(m_playbin), &amp;quot;video-sink&amp;quot;, &amp;amp;video_sink, nullptr);&#xA;gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(video_sink), this-&amp;gt;winId());&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>OrangePi之RK系列主板自定义DRM分辨率</title>
      <link>http://www.nljb.net/default/OrangePi%E4%B9%8BRK%E7%B3%BB%E5%88%97%E4%B8%BB%E6%9D%BF%E8%87%AA%E5%AE%9A%E4%B9%89DRM%E5%88%86%E8%BE%A8%E7%8E%87/</link>
      <pubDate>2020-08-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;OrangePi之RK系列主板自定义DRM分辨率&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OrangePi_Build 需要重新编译 kernel ...&#xA;https://github.com/orangepi-xunlong/OrangePi_Build&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Orange Pi RK 系列默认使用 DRM ...&#xA;kernel/drivers/gpu/drm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 drm_edid.c 的 edid_cea_modes 中查找 EDID &#xA;kernel/drivers/gpu/drm/drm_edid.c&#xA;&#xA;// 在 dw-hdmi.c 的 def_modes 中指定 EDID ...&#xA;kernel/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// kernel/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c &#xA;&#xA;static int dw_hdmi_connector_get_modes(struct drm_connector *connector)&#xA;{&#xA;    struct dw_hdmi *hdmi = container_of(connector, struct dw_hdmi,&#xA;                         connector);&#xA;    struct edid *edid;&#xA;    struct drm_display_mode *mode;&#xA;    // const u8 def_modes[6] = {4, 16, 31, 19, 17, 2};&#xA;    const u8 def_modes[1] = {1}; // 指定 EDID ... &#xA;    struct drm_display_info *info = &amp;amp;connector-&amp;gt;display_info;&#xA;    struct hdr_static_metadata *metedata =&#xA;            &amp;amp;connector-&amp;gt;display_info.hdmi.hdr_panel_metadata;&#xA;    int i, ret = 0;&#xA;&#xA;    if (!hdmi-&amp;gt;ddc)&#xA;        return 0;&#xA;&#xA;    edid = drm_get_edid(connector, hdmi-&amp;gt;ddc);&#xA;    if(0) { // 关闭使用获取到的EDID, 使用指定EDID ...&#xA;        dev_dbg(hdmi-&amp;gt;dev, &amp;quot;got edid: width[%d] x height[%d]\n&amp;quot;,&#xA;            edid-&amp;gt;width_cm, edid-&amp;gt;height_cm);&#xA;&#xA;        hdmi-&amp;gt;sink_is_hdmi = drm_detect_hdmi_monitor(edid);&#xA;        hdmi-&amp;gt;sink_has_audio = drm_detect_monitor_audio(edid);&#xA;        drm_mode_connector_update_edid_property(connector, edid);&#xA;        cec_notifier_set_phys_addr_from_edid(hdmi-&amp;gt;cec_notifier, edid);&#xA;        ret = drm_add_edid_modes(connector, edid);&#xA;        /* Store the ELD */&#xA;        drm_edid_to_eld(connector, edid);&#xA;        drm_mode_connector_update_hdr_property(connector, metedata);&#xA;        kfree(edid);&#xA;    } else {&#xA;        hdmi-&amp;gt;sink_is_hdmi = true;&#xA;        hdmi-&amp;gt;sink_has_audio = true;&#xA;        for (i = 0; i &amp;lt; sizeof(def_modes); i++) {&#xA;            mode = drm_display_mode_from_vic_index(connector,&#xA;                                   def_modes,&#xA;                                   31, i);&#xA;            if (mode) {&#xA;                if (!i)&#xA;                    mode-&amp;gt;type = DRM_MODE_TYPE_PREFERRED;&#xA;                drm_mode_probed_add(connector, mode);&#xA;                ret++;&#xA;            }&#xA;        }&#xA;        info-&amp;gt;edid_hdmi_dc_modes = 0;&#xA;        info-&amp;gt;hdmi.y420_dc_modes = 0;&#xA;        info-&amp;gt;color_formats = 0;&#xA;&#xA;        dev_info(hdmi-&amp;gt;dev, &amp;quot;failed to get edid\n&amp;quot;);&#xA;    }&#xA;&#xA;    return ret;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// kernel/drivers/gpu/drm/drm_edid.c&#xA;&#xA;/*&#xA; * Probably taken from CEA-861 spec.&#xA; * This table is converted from xorg&#39;s hw/xfree86/modes/xf86EdidModes.c.&#xA; *&#xA; * Index using the VIC.&#xA; */&#xA;static const struct drm_display_mode edid_cea_modes[] = {&#xA;    /* 0 - dummy, VICs start at 1 */&#xA;    { },&#xA;    /* 1 - 640x480@60Hz */&#xA;    { DRM_MODE(&amp;quot;640x480&amp;quot;, DRM_MODE_TYPE_DRIVER, 25175, 640, 656,&#xA;           752, 800, 0, 480, 490, 492, 525, 0,&#xA;           DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),&#xA;      .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },&#xA;    /* 2 - 720x480@60Hz */&#xA;    { DRM_MODE(&amp;quot;720x480&amp;quot;, DRM_MODE_TYPE_DRIVER, 27000, 720, 736,&#xA;           798, 858, 0, 480, 489, 495, 525, 0,&#xA;           DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查询当前分辨率 ...&#xA;&#xA;root@danoo:~# fbset -i&#xA;&#xA;mode &amp;quot;800x600&amp;quot;&#xA;    geometry 800 600 2048 2048 32&#xA;    timings 0 0 0 0 0 0 0&#xA;    rgba 8/16,8/8,8/0,0/0&#xA;endmode&#xA;&#xA;Frame buffer device information:&#xA;    Name        : svgadrmfb&#xA;    Address     : 0&#xA;    Size        : 16777216&#xA;    Type        : PACKED PIXELS&#xA;    Visual      : TRUECOLOR&#xA;    XPanStep    : 1&#xA;    YPanStep    : 1&#xA;    YWrapStep   : 0&#xA;    LineLength  : 8192&#xA;    Accelerator : No&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看 DRM DEBUG 信息&#xA;echo 0x1f &amp;gt; /sys/module/drm/parameters/debug&#xA;&#xA;// 重新插拔 HDMI 后即可通过 dmesg 查看 ...&#xA;dmesg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>OrangePi之Android_7.0获取Root权限</title>
      <link>http://www.nljb.net/default/OrangePi%E4%B9%8BAndroid_7.0%E8%8E%B7%E5%8F%96Root%E6%9D%83%E9%99%90/</link>
      <pubDate>2020-05-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OrangePi之Android_7.0获取Root权限&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;准备工作：&#xA;&#xA;  1. Orange Pi PC H3 // 开发板一块&#xA;  2. OrangePi_Pc_One_Android_7.0_beta_v1.1.img // 系统镜像 Android 7.0&#xA;    http://www.orangepi.cn/downloadresourcescn/&#xA;  3. Magisk Manager v7.5.1 // 下载  Magisk Manager APK&#xA;    https://github.com/topjohnwu/Magisk/releases &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;开始：&#xA;&#xA;  1. OrangePi_Pc_One_Android_7.0_beta_v1.1.img 刷入 Orange Pi PC H3 并启动 ...&#xA;  2. 开发者选项 -&amp;gt; 开启 USB调试 and USB0切换到设备模式，并且 usb 连接到电脑 ...&#xA;  3. adb install MagiskManager-v7.5.1.apk 安装 Magisk Manager APK ...&#xA;  4. adb shell -&amp;gt; dd if=/dev/block/by-name/boot of=/sdcard/boot.img 克隆引导镜像 ...&#xA;  5. adb pull /sdcard/boot.img boot.img 拷贝引导镜像到本地 ...&#xA;  6. 复制 boot.img 到u盘，并将u盘插入到 Orange Pi PC H3 上 ...&#xA;  7. 打开 Magisk Manager 选择 Magisk 安装 -&amp;gt; 选择并修补一个文件 -&amp;gt; 选择u盘中的 boot.img ...&#xA;  8. 完成后 /storage/emulated/0/Download/magisk_patched.img 文件拷贝到u盘中备份 ...&#xA;  9. 回写 dd if=/sdcard/MagiskManager/magisk_patched.img of=/dev/block/by-name/boot&#xA;  10. 完成后重启即可 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;翻墙：&#xA;&#xA;  1. Magisk Manager 侧边栏 -&amp;gt; 设置 -&amp;gt; 更新通道 -&amp;gt; 自定义 &#xA;  通道1：http://101.133.237.130/Magisk/Magisk_Latest.json（基本和官方同步）&#xA;  通道2：http://magisk.tsyinpin.com/canary.json（美化测试版面具）&#xA;  通道3：https://qianyegroup.gitee.io/magiskbuilds/updates/custom.json (备用通道)&#xA;  通道4: https://api.pearik.com/magisk/stable.json&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;{&#xA;  &amp;quot;app&amp;quot;: {&#xA;    &amp;quot;version&amp;quot;: &amp;quot;7.4.0&amp;quot;,&#xA;    &amp;quot;versionCode&amp;quot;: &amp;quot;253&amp;quot;,&#xA;    &amp;quot;link&amp;quot;: &amp;quot;http://101.133.237.130/Magisk/Magisk_APP/MagiskManager-v7.4.0.apk&amp;quot;,&#xA;    &amp;quot;note&amp;quot;: &amp;quot;https://github.com/topjohnwu/Magisk/blob/manager-v7.4.0/app/src/main/res/raw/changelog.md&amp;quot;&#xA;  },&#xA;  &amp;quot;uninstaller&amp;quot;: {&#xA;    &amp;quot;link&amp;quot;: &amp;quot;https://github.com/topjohnwu/Magisk/releases/download/v19.3/Magisk-uninstaller-20190604.zip&amp;quot;&#xA;  },&#xA;  &amp;quot;magisk&amp;quot;: {&#xA;    &amp;quot;version&amp;quot;: &amp;quot;20.4&amp;quot;,&#xA;    &amp;quot;versionCode&amp;quot;: &amp;quot;20400&amp;quot;,&#xA;    &amp;quot;link&amp;quot;: &amp;quot;http://101.133.237.130/Magisk/Magisk_zip/Magisk-v20.4.zip&amp;quot;,&#xA;    &amp;quot;md5&amp;quot;: &amp;quot;9503fc692e03d60cb8897ff2753c193f&amp;quot;&#xA;  },&#xA;  &amp;quot;message&amp;quot;:{&#xA;    &amp;quot;Power By&amp;quot;:&amp;quot;Mintimate&amp;quot;,&#xA;    &amp;quot;Address&amp;quot;:&amp;quot;https://www.mintimate.cn&amp;quot;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;测试：&#xA;&#xA;    static boolean checkRootExecutable() {&#xA;&#xA;    Process process = null;&#xA;    DataOutputStream os = null;&#xA;    try {&#xA;        process = Runtime.getRuntime().exec(&amp;quot;su&amp;quot;);&#xA;        os = new DataOutputStream(process.getOutputStream());&#xA;        os.writeBytes(&amp;quot;exit\n&amp;quot;);&#xA;        os.flush();&#xA;        int exitValue = process.waitFor();&#xA;        if (exitValue == 0) {&#xA;        return true;&#xA;        } else {&#xA;        return false;&#xA;        }&#xA;    } catch (Exception e) {&#xA;        Log.d(&amp;quot;*** DEBUG ***&amp;quot;, &amp;quot;Unexpected error - Here is what I know: &amp;quot; + e.getMessage());&#xA;        return false;&#xA;    } finally {&#xA;        try {&#xA;        if (os != null) {&#xA;            os.close();&#xA;        }&#xA;        process.destroy();&#xA;        } catch (Exception e) {&#xA;        e.printStackTrace();&#xA;        }&#xA;    }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 获取 ROOT 权限后就可以对只读分区进行文件修改&#xA;# /sbin/magisk --unlock-blocks&#xA;# mount -o rw,remount -t ext4 /sbin/.magisk/block/system_root /sbin/adbd&#xA;# mount -o rw,remount -t ext4 /sbin/.magisk/block/system_root  /sbin/.magisk/mirror/system_root&#xA;# mount -o rw,remount -t ext4 /sbin/.magisk/block/system_root /sbin/healthd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之FFmpeg使用VAAPI硬解H264</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8BFFmpeg%E4%BD%BF%E7%94%A8VAAPI%E7%A1%AC%E8%A7%A3H264/</link>
      <pubDate>2020-04-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Linux之FFmpeg使用VAAPI硬解H264&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// FFmpeg 请使用最新的 4.4.2 旧版本 3.x 不支持 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意：如果使用的是 iHD 的驱动那直接就 h264_qsv 吧 ...&#xA;// 检查驱动是否正常 ...&#xA;$ vainfo&#xA;libva info: VA-API version 0.39.4&#xA;libva info: va_getDriverName() returns 0&#xA;libva info: Trying to open /usr/lib/dri/i965_drv_video.so&#xA;libva info: Found init function __vaDriverInit_0_39&#xA;libva info: va_openDriver() returns 0&#xA;vainfo: VA-API version: 0.39 (libva 1.7.3)&#xA;vainfo: Driver version: Intel i965 driver for Intel(R) Skylake - 1.7.3&#xA;vainfo: Supported profile and entrypoints&#xA;      VAProfileMPEG2Simple            : VAEntrypointVLD&#xA;      VAProfileMPEG2Simple            : VAEntrypointEncSlice&#xA;      VAProfileMPEG2Main              : VAEntrypointVLD&#xA;      VAProfileMPEG2Main              : VAEntrypointEncSlice&#xA;      VAProfileH264ConstrainedBaseline: VAEntrypointVLD&#xA;      VAProfileH264ConstrainedBaseline: VAEntrypointEncSlice&#xA;      VAProfileH264ConstrainedBaseline: VAEntrypointEncSliceLP&#xA;      VAProfileH264Main               : VAEntrypointVLD&#xA;      VAProfileH264Main               : VAEntrypointEncSlice&#xA;      VAProfileH264Main               : VAEntrypointEncSliceLP&#xA;      VAProfileH264High               : VAEntrypointVLD&#xA;      VAProfileH264High               : VAEntrypointEncSlice&#xA;      VAProfileH264High               : VAEntrypointEncSliceLP&#xA;      VAProfileH264MultiviewHigh      : VAEntrypointVLD&#xA;      VAProfileH264MultiviewHigh      : VAEntrypointEncSlice&#xA;      VAProfileH264StereoHigh         : VAEntrypointVLD&#xA;      VAProfileH264StereoHigh         : VAEntrypointEncSlice&#xA;      VAProfileVC1Simple              : VAEntrypointVLD&#xA;      VAProfileVC1Main                : VAEntrypointVLD&#xA;      VAProfileVC1Advanced            : VAEntrypointVLD&#xA;      VAProfileNone                   : VAEntrypointVideoProc&#xA;      VAProfileJPEGBaseline           : VAEntrypointVLD&#xA;      VAProfileJPEGBaseline           : VAEntrypointEncPicture&#xA;      VAProfileVP8Version0_3          : VAEntrypointVLD&#xA;      VAProfileVP8Version0_3          : VAEntrypointEncSlice&#xA;      VAProfileHEVCMain               : VAEntrypointVLD&#xA;      VAProfileHEVCMain               : VAEntrypointEncSlice&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方文档 ...&#xA;http://trac.ffmpeg.org/wiki/Hardware/VAAPI&#xA;http://trac.ffmpeg.org/wiki/Hardware/QuickSync&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解决方案, 官方案例&#xA;https://github.com/FFmpeg/FFmpeg/blob/release/4.1/doc/examples/hw_decode.c&#xA;/*&#xA; * Copyright (c) 2017 Jun Zhao&#xA; * Copyright (c) 2017 Kaixuan Liu&#xA; *&#xA; * HW Acceleration API (video decoding) decode sample&#xA; *&#xA; * Permission is hereby granted, free of charge, to any person obtaining a copy&#xA; * of this software and associated documentation files (the &amp;quot;Software&amp;quot;), to deal&#xA; * in the Software without restriction, including without limitation the rights&#xA; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#xA; * copies of the Software, and to permit persons to whom the Software is&#xA; * furnished to do so, subject to the following conditions:&#xA; *&#xA; * The above copyright notice and this permission notice shall be included in&#xA; * all copies or substantial portions of the Software.&#xA; *&#xA; * THE SOFTWARE IS PROVIDED &amp;quot;AS IS&amp;quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xA; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xA; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL&#xA; * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xA; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xA; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#xA; * THE SOFTWARE.&#xA; */&#xA;&#xA;/**&#xA; * @file&#xA; * HW-Accelerated decoding example.&#xA; *&#xA; * @example hw_decode.c&#xA; * This example shows how to do HW-accelerated decoding with output&#xA; * frames from the HW video surfaces.&#xA; */&#xA;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;#include &amp;lt;libavcodec/avcodec.h&amp;gt;&#xA;#include &amp;lt;libavformat/avformat.h&amp;gt;&#xA;#include &amp;lt;libavutil/pixdesc.h&amp;gt;&#xA;#include &amp;lt;libavutil/hwcontext.h&amp;gt;&#xA;#include &amp;lt;libavutil/opt.h&amp;gt;&#xA;#include &amp;lt;libavutil/avassert.h&amp;gt;&#xA;#include &amp;lt;libavutil/imgutils.h&amp;gt;&#xA;&#xA;static AVBufferRef *hw_device_ctx = NULL;&#xA;static enum AVPixelFormat hw_pix_fmt;&#xA;static FILE *output_file = NULL;&#xA;&#xA;static int hw_decoder_init(AVCodecContext *ctx, const enum AVHWDeviceType type)&#xA;{&#xA;    int err = 0;&#xA;&#xA;    if ((err = av_hwdevice_ctx_create(&amp;amp;hw_device_ctx, type,&#xA;                      NULL, NULL, 0)) &amp;lt; 0) {&#xA;    fprintf(stderr, &amp;quot;Failed to create specified HW device.\n&amp;quot;);&#xA;    return err;&#xA;    }&#xA;    ctx-&amp;gt;hw_device_ctx = av_buffer_ref(hw_device_ctx);&#xA;&#xA;    return err;&#xA;}&#xA;&#xA;static enum AVPixelFormat get_hw_format(AVCodecContext *ctx,&#xA;                    const enum AVPixelFormat *pix_fmts)&#xA;{&#xA;    const enum AVPixelFormat *p;&#xA;&#xA;    for (p = pix_fmts; *p != -1; p++) {&#xA;    if (*p == hw_pix_fmt)&#xA;        return *p;&#xA;    }&#xA;&#xA;    fprintf(stderr, &amp;quot;Failed to get HW surface format.\n&amp;quot;);&#xA;    return AV_PIX_FMT_NONE;&#xA;}&#xA;&#xA;static int decode_write(AVCodecContext *avctx, AVPacket *packet)&#xA;{&#xA;    AVFrame *frame = NULL, *sw_frame = NULL;&#xA;    AVFrame *tmp_frame = NULL;&#xA;    uint8_t *buffer = NULL;&#xA;    int size;&#xA;    int ret = 0;&#xA;&#xA;    ret = avcodec_send_packet(avctx, packet);&#xA;    if (ret &amp;lt; 0) {&#xA;    fprintf(stderr, &amp;quot;Error during decoding\n&amp;quot;);&#xA;    return ret;&#xA;    }&#xA;&#xA;    while (1) {&#xA;    if (!(frame = av_frame_alloc()) || !(sw_frame = av_frame_alloc())) {&#xA;        fprintf(stderr, &amp;quot;Can not alloc frame\n&amp;quot;);&#xA;        ret = AVERROR(ENOMEM);&#xA;        goto fail;&#xA;    }&#xA;&#xA;    ret = avcodec_receive_frame(avctx, frame);&#xA;    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {&#xA;        av_frame_free(&amp;amp;frame);&#xA;        av_frame_free(&amp;amp;sw_frame);&#xA;        return 0;&#xA;    } else if (ret &amp;lt; 0) {&#xA;        fprintf(stderr, &amp;quot;Error while decoding\n&amp;quot;);&#xA;        goto fail;&#xA;    }&#xA;&#xA;    if (frame-&amp;gt;format == hw_pix_fmt) {&#xA;        /* retrieve data from GPU to CPU */&#xA;        if ((ret = av_hwframe_transfer_data(sw_frame, frame, 0)) &amp;lt; 0) {&#xA;        fprintf(stderr, &amp;quot;Error transferring the data to system memory\n&amp;quot;);&#xA;        goto fail;&#xA;        }&#xA;        tmp_frame = sw_frame;&#xA;    } else&#xA;        tmp_frame = frame;&#xA;&#xA;    size = av_image_get_buffer_size(tmp_frame-&amp;gt;format, tmp_frame-&amp;gt;width,&#xA;                    tmp_frame-&amp;gt;height, 1);&#xA;    buffer = av_malloc(size);&#xA;    if (!buffer) {&#xA;        fprintf(stderr, &amp;quot;Can not alloc buffer\n&amp;quot;);&#xA;        ret = AVERROR(ENOMEM);&#xA;        goto fail;&#xA;    }&#xA;    ret = av_image_copy_to_buffer(buffer, size,&#xA;                      (const uint8_t * const *)tmp_frame-&amp;gt;data,&#xA;                      (const int *)tmp_frame-&amp;gt;linesize, tmp_frame-&amp;gt;format,&#xA;                      tmp_frame-&amp;gt;width, tmp_frame-&amp;gt;height, 1);&#xA;    if (ret &amp;lt; 0) {&#xA;        fprintf(stderr, &amp;quot;Can not copy image to buffer\n&amp;quot;);&#xA;        goto fail;&#xA;    }&#xA;&#xA;    if ((ret = fwrite(buffer, 1, size, output_file)) &amp;lt; 0) {&#xA;        fprintf(stderr, &amp;quot;Failed to dump raw data.\n&amp;quot;);&#xA;        goto fail;&#xA;    }&#xA;&#xA;    fail:&#xA;    av_frame_free(&amp;amp;frame);&#xA;    av_frame_free(&amp;amp;sw_frame);&#xA;    av_freep(&amp;amp;buffer);&#xA;    if (ret &amp;lt; 0)&#xA;        return ret;&#xA;    }&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    AVFormatContext *input_ctx = NULL;&#xA;    int video_stream, ret;&#xA;    AVStream *video = NULL;&#xA;    AVCodecContext *decoder_ctx = NULL;&#xA;    AVCodec *decoder = NULL;&#xA;    AVPacket packet;&#xA;    enum AVHWDeviceType type;&#xA;    int i;&#xA;&#xA;    if (argc &amp;lt; 4) {&#xA;    fprintf(stderr, &amp;quot;Usage: %s &amp;lt;device type&amp;gt; &amp;lt;input file&amp;gt; &amp;lt;output file&amp;gt;\n&amp;quot;, argv[0]);&#xA;    return -1;&#xA;    }&#xA;&#xA;    type = av_hwdevice_find_type_by_name(argv[1]);&#xA;    if (type == AV_HWDEVICE_TYPE_NONE) {&#xA;    fprintf(stderr, &amp;quot;Device type %s is not supported.\n&amp;quot;, argv[1]);&#xA;    fprintf(stderr, &amp;quot;Available device types:&amp;quot;);&#xA;    while((type = av_hwdevice_iterate_types(type)) != AV_HWDEVICE_TYPE_NONE)&#xA;        fprintf(stderr, &amp;quot; %s&amp;quot;, av_hwdevice_get_type_name(type));&#xA;    fprintf(stderr, &amp;quot;\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    /* open the input file */&#xA;    if (avformat_open_input(&amp;amp;input_ctx, argv[2], NULL, NULL) != 0) {&#xA;    fprintf(stderr, &amp;quot;Cannot open input file &#39;%s&#39;\n&amp;quot;, argv[2]);&#xA;    return -1;&#xA;    }&#xA;&#xA;    if (avformat_find_stream_info(input_ctx, NULL) &amp;lt; 0) {&#xA;    fprintf(stderr, &amp;quot;Cannot find input stream information.\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    /* find the video stream information */&#xA;    ret = av_find_best_stream(input_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, &amp;amp;decoder, 0);&#xA;    if (ret &amp;lt; 0) {&#xA;    fprintf(stderr, &amp;quot;Cannot find a video stream in the input file\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;    video_stream = ret;&#xA;&#xA;    for (i = 0;; i++) {&#xA;    const AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);&#xA;    if (!config) {&#xA;        fprintf(stderr, &amp;quot;Decoder %s does not support device type %s.\n&amp;quot;,&#xA;            decoder-&amp;gt;name, av_hwdevice_get_type_name(type));&#xA;        return -1;&#xA;    }&#xA;    if (config-&amp;gt;methods &amp;amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;amp;&amp;amp;&#xA;        config-&amp;gt;device_type == type) {&#xA;        hw_pix_fmt = config-&amp;gt;pix_fmt;&#xA;        break;&#xA;    }&#xA;    }&#xA;&#xA;    if (!(decoder_ctx = avcodec_alloc_context3(decoder)))&#xA;    return AVERROR(ENOMEM);&#xA;&#xA;    video = input_ctx-&amp;gt;streams[video_stream];&#xA;    if (avcodec_parameters_to_context(decoder_ctx, video-&amp;gt;codecpar) &amp;lt; 0)&#xA;    return -1;&#xA;&#xA;    decoder_ctx-&amp;gt;get_format  = get_hw_format;&#xA;&#xA;    if (hw_decoder_init(decoder_ctx, type) &amp;lt; 0)&#xA;    return -1;&#xA;&#xA;    if ((ret = avcodec_open2(decoder_ctx, decoder, NULL)) &amp;lt; 0) {&#xA;    fprintf(stderr, &amp;quot;Failed to open codec for stream #%u\n&amp;quot;, video_stream);&#xA;    return -1;&#xA;    }&#xA;&#xA;    /* open the file to dump raw data */&#xA;    output_file = fopen(argv[3], &amp;quot;w+&amp;quot;);&#xA;&#xA;    /* actual decoding and dump the raw data */&#xA;    while (ret &amp;gt;= 0) {&#xA;    if ((ret = av_read_frame(input_ctx, &amp;amp;packet)) &amp;lt; 0)&#xA;        break;&#xA;&#xA;    if (video_stream == packet.stream_index)&#xA;        ret = decode_write(decoder_ctx, &amp;amp;packet);&#xA;&#xA;    av_packet_unref(&amp;amp;packet);&#xA;    }&#xA;&#xA;    /* flush the decoder */&#xA;    packet.data = NULL;&#xA;    packet.size = 0;&#xA;    ret = decode_write(decoder_ctx, &amp;amp;packet);&#xA;    av_packet_unref(&amp;amp;packet);&#xA;&#xA;    if (output_file)&#xA;    fclose(output_file);&#xA;    avcodec_free_context(&amp;amp;decoder_ctx);&#xA;    avformat_close_input(&amp;amp;input_ctx);&#xA;    av_buffer_unref(&amp;amp;hw_device_ctx);&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 文档 ...&#xA;https://www.jianshu.com/p/3ea9ef713211&#xA;https://my.oschina.net/u/4416603/blog/3239100/print&#xA;&#xA;// Golang 封装的 FFmepg&#xA;https://github.com/ailumiyana/streaming/blob/master/vaapi_qsv_test/qsv-test.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install libva-dev&#xA;apt-get install build-essential&#xA;apt-get install pkg-config&#xA;./configure --prefix=/usr/local --enable-version3 --disable-static --enable-shared --enable-vaapi --disable-x86asm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>ubuntu之取消uuid从sdx启动</title>
      <link>http://www.nljb.net/default/ubuntu%E4%B9%8B%E5%8F%96%E6%B6%88uuid%E4%BB%8Esdx%E5%90%AF%E5%8A%A8/</link>
      <pubDate>2020-04-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;ubuntu之取消uuid从sdx启动&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@nulijiabei:/usr/lib/grub# lsb_release -a&#xA;No LSB modules are available.&#xA;Distributor ID: Ubuntu&#xA;Description:    Ubuntu 20.04 LTS&#xA;Release:    20.04&#xA;Codename:   focal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  vi /usr/lib/grub/grub-mkconfig_lib &#xA;&#xA;  // 按以下代码注释 ...&#xA;  # If there&#39;s a filesystem UUID that GRUB is capable of identifying, use it;&#xA;  # otherwise set root as per value in device.map.&#xA;  fs_hint=&amp;quot;`&amp;quot;${grub_probe}&amp;quot; --device $@ --target=compatibility_hint`&amp;quot;&#xA;  if [ &amp;quot;x$fs_hint&amp;quot; != x ]; then&#xA;    echo &amp;quot;set root=&#39;$fs_hint&#39;&amp;quot;&#xA;  fi&#xA;#  if fs_uuid=&amp;quot;`&amp;quot;${grub_probe}&amp;quot; --device $@ --target=fs_uuid 2&amp;gt; /dev/null`&amp;quot; ; then&#xA;#    hints=&amp;quot;`&amp;quot;${grub_probe}&amp;quot; --device $@ --target=hints_string 2&amp;gt; /dev/null`&amp;quot; || hints=&#xA;#    echo &amp;quot;if [ x\$feature_platform_search_hint = xy ]; then&amp;quot;&#xA;#    echo &amp;quot;  search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}&amp;quot;&#xA;#    echo &amp;quot;else&amp;quot;&#xA;#    echo &amp;quot;  search --no-floppy --fs-uuid --set=root ${fs_uuid}&amp;quot;&#xA;#    echo &amp;quot;fi&amp;quot;&#xA;#  fi&#xA;  IFS=&amp;quot;$old_ifs&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vi /etc/default/grub&#xA;&#xA;// 打开注释 ...&#xA;# Uncomment if you don&#39;t want GRUB to pass &amp;quot;root=UUID=xxx&amp;quot; parameter to Linux&#xA;GRUB_DISABLE_LINUX_UUID=true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 生成即可 ...&#xA;sudo update-grub&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 手动修改 &#xA;/etc/fstab&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之使用DRM输出时设置FrameBuffer分辨率</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8B%E4%BD%BF%E7%94%A8DRM%E8%BE%93%E5%87%BA%E6%97%B6%E8%AE%BE%E7%BD%AEFrameBuffer%E5%88%86%E8%BE%A8%E7%8E%87/</link>
      <pubDate>2020-04-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Linux之使用DRM输出时设置FrameBuffer分辨率&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 设置 DRM FrameBuffer 就决定了 DRM 输出的分辨率 ...&#xA;它是一块内存区域，我把它理解为一块画布，驱动和应用层都能访问它。&#xA;画画之前需要将它格式化，我们需要设定你要画油画还是国画&#xA;（色彩模式，比如 RGB24，YUV 等），画布需要多大（分辨率）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过 fbset 查看 /dev/fb0 设备 ...&#xA;root@danoo-YANYU:/home/danoo# fbset -i&#xA;&#xA;mode &amp;quot;3840x2160&amp;quot;&#xA;    geometry 3840 2160 3840 2160 32&#xA;    timings 0 0 0 0 0 0 0&#xA;    accel true&#xA;    rgba 8/16,8/8,8/0,0/0&#xA;endmode&#xA;&#xA;Frame buffer device information:&#xA;    Name        : i915drmfb&#xA;    Address     : 0&#xA;    Size        : 33177600&#xA;    Type        : PACKED PIXELS&#xA;    Visual      : TRUECOLOR&#xA;    XPanStep    : 1&#xA;    YPanStep    : 1&#xA;    YWrapStep   : 0&#xA;    LineLength  : 15360&#xA;    Accelerator : No&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 FrameBuffer 分辨率 ...&#xA;vi /etc/default/grub&#xA;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet splash video=3840x2160 text&amp;quot;&#xA;sudo update-grub&#xA;reboot&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之Intel多媒体解决方案libyami</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8BIntel%E5%A4%9A%E5%AA%92%E4%BD%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88libyami/</link>
      <pubDate>2020-04-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Linux之Intel多媒体解决方案libyami&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Intel 官方发布的 Intel 多媒体解决方案&#xA;&#xA;Yet Another Media Infrastructure.&#xA;It is YUMMY to your video experience on Linux like platform.&#xA;Yami is core building block for media solution. it parses video stream&#xA;and decodes them leverage hardware acceleration.&#xA;Copyright (c) 2010, The WebM Project authors.&#xA;Copyright (C) 2011-2018 Intel Corporation&#xA;Copyright (C) 2015-2016 Alibaba&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装 libyami&#xA;git clone https://github.com/intel/libyami.git&#xA;./autogen.sh&#xA;make -j4&#xA;&#xA;// 安装 libyami utils&#xA;git clone https://github.com/intel/libyami-utils&#xA;./autogen.sh&#xA;make -j4&#xA;&#xA;// 测试 (需要X11)&#xA;libyami-utils/examples/simpleplayer test.h264&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装文档 ...&#xA;https://github.com/intel/libyami/wiki/Build&#xA;&#xA;&#xA;// 安装 ffmpeg libyami &#xA;git clone https://github.com/intel/ffmpeg_libyami&#xA;./configure --arch=x86_64 --disable-yasm --enable-vaapi --enable-libmfx --enable-libyami --enable-version3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试&#xA;ffmpeg -hwaccel vaapi -i kaoya.mp4 -vcodec libyami_h264 output.yuv&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Ubuntu 20.04 新系统内核及内置软件已经符合要求直接安装即可 ...&#xA;&#xA;libva-dev - Video Acceleration (VA) API for Linux -- development files&#xA;libva-drm2 - Video Acceleration (VA) API for Linux -- DRM runtime&#xA;libva-glx2 - Video Acceleration (VA) API for Linux -- GLX runtime&#xA;libva-wayland2 - Video Acceleration (VA) API for Linux -- Wayland runtime&#xA;libva-x11-2 - Video Acceleration (VA) API for Linux -- X11 runtime&#xA;libva2 - Video Acceleration (VA) API for Linux -- runtime&#xA;vainfo - Video Acceleration (VA) API for Linux -- info program&#xA;&#xA;i965-va-driver - VAAPI driver for Intel G45 &amp;amp; HD Graphics family&#xA;libgles2-mesa-dev - transitional dummy package&#xA;libegl1-mesa-dev - free implementation of the EGL API -- development files&#xA;&#xA;libyami-dev - high-level abstraction for Video Acceleration (VA) API (development files)&#xA;libyami-utils - high-level abstraction for Video Acceleration (VA) API (utils)&#xA;libyami1 - high-level abstraction for Video Acceleration (VA) API (shared library)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Intel J1900 - H264 4K - yamidecode &amp;gt; FPS 40&#xA;// Intel J3160 - H264 4K - yamidecode &amp;gt; FPS 60&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之FFmepg使用Intel-Media-SDK硬解</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8BFFmepg%E4%BD%BF%E7%94%A8Intel-Media-SDK%E7%A1%AC%E8%A7%A3/</link>
      <pubDate>2020-04-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Linux之FFmepg使用 Intel Media SDK 硬解&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 支持硬件&#xA;BDW (Broadwell)&#xA;SKL (Skylake)&#xA;BXT (Broxton) / APL (Apollo Lake)&#xA;KBLx (KBL/Kaby Lake; CFL/Coffe Lake; WHL/Whiskey Lake; CML/Comet Lake; AML/Amber Lake)&#xA;ICL (Ice Lake)&#xA;JSL (Jasper Lake)/EHL (Elkhart Lake)&#xA;TGL (Tiger Lake)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 系统 Ubuntu 19.10 安装 ...&#xA;sudo apt-get install libva-dev libmfx-dev intel-media-va-driver-non-free vainfo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;// i965_drv_video.so 为旧版驱动不受 Intel Media SDK 支持&#xA;// iHD_drv_video.so 检查正常才可以进行下一步 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看驱动支持情况 ...&#xA;export LIBVA_DRIVER_NAME=iHD&#xA;vainfo &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译 FFmpeg 4.4.2&#xA;./configure --arch=x86_64 --disable-yasm --enable-vaapi --enable-libmfx&#xA;make &#xA;&#xA;// 查看编译后的支持情况 ...&#xA;danoo@nulijiabei:~$ ffmpeg -decoders |grep h264&#xA;ffmpeg version 4.2.2 Copyright (c) 2000-2019 the FFmpeg developers&#xA;  built with gcc 9 (Ubuntu 9.2.1-9ubuntu2)&#xA;  configuration: --arch=x86_64 --disable-yasm --enable-vaapi --enable-libmfx --disable-static --enable-shared&#xA;  libavutil      56. 31.100 / 56. 31.100&#xA;  libavcodec     58. 54.100 / 58. 54.100&#xA;  libavformat    58. 29.100 / 58. 29.100&#xA;  libavdevice    58.  8.100 / 58.  8.100&#xA;  libavfilter     7. 57.100 /  7. 57.100&#xA;  libswscale      5.  5.100 /  5.  5.100&#xA;  libswresample   3.  5.100 /  3.  5.100&#xA; VFS..D h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10&#xA; V..... h264_v4l2m2m         V4L2 mem2mem H.264 decoder wrapper (codec h264)&#xA; V....D h264_qsv             H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (Intel Quick Sync Video acceleration) (codec h264)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 关于 FFmepg Hardware QuickSync&#xA;// http://trac.ffmpeg.org/wiki/Hardware/QuickSync   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/Intel-Media-SDK/MediaSDK/wiki/Build-and-use-ffmpeg-with-MediaSDK&#xA;https://github.com/intel/media-driver   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>ffmpeg android jni端调用mediaCodec实现硬解码</title>
      <link>http://www.nljb.net/default/ffmpeg-android-jni%E7%AB%AF%E8%B0%83%E7%94%A8mediaCodec%E5%AE%9E%E7%8E%B0%E7%A1%AC%E8%A7%A3%E7%A0%81/</link>
      <pubDate>2020-04-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;ffmpeg android jni端调用mediaCodec实现硬解码&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;硬解码&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1、在jni层导入 ffmpeg的jni.h头文件&#xA;&#xA;extern &amp;quot;C&amp;quot;{&#xA;    #include &amp;quot;libavcodec/avcodec.h&amp;quot;&#xA;    #include &amp;lt;libavformat/avformat.h&amp;gt;&#xA;    #include &amp;quot;libavcodec/jni.h&amp;quot;&#xA;}&#xA;&#xA;2、实现jni.h里的方法，固定的方法名&#xA;&#xA;extern &amp;quot;C&amp;quot;&#xA;JNIEXPORT&#xA;jint JNI_OnLoad(JavaVM *vm, void *res) {&#xA;    av_jni_set_java_vm(vm, 0);&#xA;    // 返回jni版本&#xA;    return JNI_VERSION_1_4;&#xA;}&#xA;&#xA;&#xA;3、打开硬解码，编译ffmpeg的时候要支持硬解码。&#xA;&#xA;AVCodec *videoCodec = avcodec_find_decoder_by_name(&amp;quot;h264_mediacodec&amp;quot;);&#xA;AVCodecContext*videoCodecContext = avcodec_alloc_context3(videoCodec);&#xA;avcodec_parameters_to_context(videoCodecContext, ic-&amp;gt;streams[videoStream]-&amp;gt;codecpar);&#xA;videoCodecContext-&amp;gt;thread_count = 1;&#xA;re = avcodec_open2(videoCodecContext,0,0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 转自网络：https://blog.csdn.net/zhangpengzp/article/details/88943867 感谢&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之raspi-config设置自动化</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8Braspi-config%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96/</link>
      <pubDate>2020-04-01 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;树莓派之raspi-config设置自动化&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/RPi-Distro/raspi-config&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* Command strings */&#xA;#define GET_CAN_EXPAND  &amp;quot;sudo raspi-config nonint get_can_expand&amp;quot;&#xA;#define EXPAND_FS       &amp;quot;sudo raspi-config nonint do_expand_rootfs&amp;quot;&#xA;#define GET_HOSTNAME    &amp;quot;sudo raspi-config nonint get_hostname&amp;quot;&#xA;#define SET_HOSTNAME    &amp;quot;sudo raspi-config nonint do_hostname %s&amp;quot;&#xA;#define GET_BOOT_CLI    &amp;quot;sudo raspi-config nonint get_boot_cli&amp;quot;&#xA;#define GET_AUTOLOGIN   &amp;quot;sudo raspi-config nonint get_autologin&amp;quot;&#xA;#define SET_BOOT_CLI    &amp;quot;sudo raspi-config nonint do_boot_behaviour B1&amp;quot;&#xA;#define SET_BOOT_CLIA   &amp;quot;sudo raspi-config nonint do_boot_behaviour B2&amp;quot;&#xA;#define SET_BOOT_GUI    &amp;quot;sudo raspi-config nonint do_boot_behaviour B3&amp;quot;&#xA;#define SET_BOOT_GUIA   &amp;quot;sudo raspi-config nonint do_boot_behaviour B4&amp;quot;&#xA;#define GET_BOOT_WAIT   &amp;quot;sudo raspi-config nonint get_boot_wait&amp;quot;&#xA;#define SET_BOOT_WAIT   &amp;quot;sudo raspi-config nonint do_boot_wait %d&amp;quot;&#xA;#define GET_SPLASH      &amp;quot;sudo raspi-config nonint get_boot_splash&amp;quot;&#xA;#define SET_SPLASH      &amp;quot;sudo raspi-config nonint do_boot_splash %d&amp;quot;&#xA;#define GET_OVERSCAN    &amp;quot;sudo raspi-config nonint get_overscan&amp;quot;&#xA;#define SET_OVERSCAN    &amp;quot;sudo raspi-config nonint do_overscan %d&amp;quot;&#xA;#define GET_CAMERA      &amp;quot;sudo raspi-config nonint get_camera&amp;quot;&#xA;#define SET_CAMERA      &amp;quot;sudo raspi-config nonint do_camera %d&amp;quot;&#xA;#define GET_SSH         &amp;quot;sudo raspi-config nonint get_ssh&amp;quot;&#xA;#define SET_SSH         &amp;quot;sudo raspi-config nonint do_ssh %d&amp;quot;&#xA;#define GET_VNC         &amp;quot;sudo raspi-config nonint get_vnc&amp;quot;&#xA;#define SET_VNC         &amp;quot;sudo raspi-config nonint do_vnc %d&amp;quot;&#xA;#define GET_SPI         &amp;quot;sudo raspi-config nonint get_spi&amp;quot;&#xA;#define SET_SPI         &amp;quot;sudo raspi-config nonint do_spi %d&amp;quot;&#xA;#define GET_I2C         &amp;quot;sudo raspi-config nonint get_i2c&amp;quot;&#xA;#define SET_I2C         &amp;quot;sudo raspi-config nonint do_i2c %d&amp;quot;&#xA;#define GET_SERIAL      &amp;quot;sudo raspi-config nonint get_serial&amp;quot;&#xA;#define GET_SERIALHW    &amp;quot;sudo raspi-config nonint get_serial_hw&amp;quot;&#xA;#define SET_SERIAL      &amp;quot;sudo raspi-config nonint do_serial %d&amp;quot;&#xA;#define GET_1WIRE       &amp;quot;sudo raspi-config nonint get_onewire&amp;quot;&#xA;#define SET_1WIRE       &amp;quot;sudo raspi-config nonint do_onewire %d&amp;quot;&#xA;#define GET_RGPIO       &amp;quot;sudo raspi-config nonint get_rgpio&amp;quot;&#xA;#define SET_RGPIO       &amp;quot;sudo raspi-config nonint do_rgpio %d&amp;quot;&#xA;#define GET_PI_TYPE     &amp;quot;sudo raspi-config nonint get_pi_type&amp;quot;&#xA;#define GET_OVERCLOCK   &amp;quot;sudo raspi-config nonint get_config_var arm_freq /boot/config.txt&amp;quot;&#xA;#define SET_OVERCLOCK   &amp;quot;sudo raspi-config nonint do_overclock %s&amp;quot;&#xA;#define GET_GPU_MEM     &amp;quot;sudo raspi-config nonint get_config_var gpu_mem /boot/config.txt&amp;quot;&#xA;#define GET_GPU_MEM_256 &amp;quot;sudo raspi-config nonint get_config_var gpu_mem_256 /boot/config.txt&amp;quot;&#xA;#define GET_GPU_MEM_512 &amp;quot;sudo raspi-config nonint get_config_var gpu_mem_512 /boot/config.txt&amp;quot;&#xA;#define GET_GPU_MEM_1K  &amp;quot;sudo raspi-config nonint get_config_var gpu_mem_1024 /boot/config.txt&amp;quot;&#xA;#define SET_GPU_MEM     &amp;quot;sudo raspi-config nonint do_memory_split %d&amp;quot;&#xA;#define GET_HDMI_GROUP  &amp;quot;sudo raspi-config nonint get_config_var hdmi_group /boot/config.txt&amp;quot;&#xA;#define GET_HDMI_MODE   &amp;quot;sudo raspi-config nonint get_config_var hdmi_mode /boot/config.txt&amp;quot;&#xA;#define SET_HDMI_GP_MOD &amp;quot;sudo raspi-config nonint do_resolution %d %d&amp;quot;&#xA;#define GET_WIFI_CTRY   &amp;quot;sudo raspi-config nonint get_wifi_country&amp;quot;&#xA;#define SET_WIFI_CTRY   &amp;quot;sudo raspi-config nonint do_wifi_country %s&amp;quot;&#xA;#define CHANGE_PASSWD   &amp;quot;(echo \&amp;quot;%s\&amp;quot; ; echo \&amp;quot;%s\&amp;quot; ; echo \&amp;quot;%s\&amp;quot;) | passwd&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>在树莓派上调试ESP8266模块</title>
      <link>http://www.nljb.net/default/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E8%B0%83%E8%AF%95ESP8266%E6%A8%A1%E5%9D%97/</link>
      <pubDate>2020-03-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;在树莓派上调试ESP8266模块&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;WiFi模块 ESP8266串口转WiFi/无线透传/工业级/安信可/ESP-01S &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;设置树莓派使用PL011 UART串口通信&#xA;&#xA;/boot/cmdline.txt  &#xA;    移除 console=serial0,115200 &#xA;/boot/config.txt &#xA;    添加 enable_uart=1&#xA;    添加 dtoverlay=pi3-miniuart-bt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi:~# gpio readall&#xA; +-----+-----+---------+------+---+---Pi 3B+-+---+------+---------+-----+-----+&#xA; | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |&#xA; +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+&#xA; |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |&#xA; |   2 |   8 |   SDA.1 |   IN | 1 |  3 || 4  |   |      | 5v      |     |     |&#xA; |   3 |   9 |   SCL.1 |   IN | 1 |  5 || 6  |   |      | 0v      |     |     |&#xA; |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 1 | ALT0 | TxD     | 15  | 14  |&#xA; |     |     |      0v |      |   |  9 || 10 | 1 | ALT0 | RxD     | 16  | 15  |&#xA; |  17 |   0 | GPIO. 0 |   IN | 0 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |&#xA; |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |&#xA; |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |&#xA; |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |&#xA; |  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |&#xA; |   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |&#xA; |  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |&#xA; |     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |&#xA; |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |&#xA; |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |&#xA; |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |&#xA; |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |&#xA; |  19 |  24 | GPIO.24 |   IN | 0 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |&#xA; |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |&#xA; |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |&#xA; +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+&#xA; | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |&#xA; +-----+-----+---------+------+---+---Pi 3B+-+---+------+---------+-----+-----+&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ESP8266 连接树莓派 UART 串口   &#xA;&#xA;UART 1  3.3v -&amp;gt; ESP8266 3v3&#xA;UART 8  TxD  -&amp;gt; ESP8266 RX&#xA;UART 10 RXD  -&amp;gt; ESP8266 TX &#xA;UART 6  GND  -&amp;gt; ESP8266 GND&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;安装串口工具&#xA;sudo apt-get install minicom&#xA;&#xA;端口设置    &#xA;Serial port setup&#xA;&#xA;| A -    Serial Device      : /dev/ttyAMA0                              |&#xA;| B - Lockfile Location     : /var/lock                                 |&#xA;| C -   Callin Program      :                                           |&#xA;| D -  Callout Program      :                                           |&#xA;| E -    Bps/Par/Bits       : 115200 8N1                                |&#xA;| F - Hardware Flow Control : No                                        |&#xA;| G - Software Flow Control : No &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意: AT命令的结束不能用回车键，要用组合键Ctrl+M和Ctrl+J&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>使用ESP8266实现微信Airkiss智能配网</title>
      <link>http://www.nljb.net/default/%E4%BD%BF%E7%94%A8ESP8266%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1Airkiss%E6%99%BA%E8%83%BD%E9%85%8D%E7%BD%91/</link>
      <pubDate>2020-03-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;使用ESP8266实现微信Airkiss智能配网&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;微信硬件平台合作伙伴&#xA;https://iot.weixin.qq.com/wiki/partner.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 准备工具&#xA;WiFi模块 ESP8266串口转WiFi ESP-01S &#xA;USB转串口|CP2102|2.4G|433M|USB转TTL|通信模块|USB-T1转接板 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// CP2102 连接 ESP8266&#xA;CP2102 Vo  -&amp;gt; ESP8266 3v3&#xA;CP2102 TXD -&amp;gt; ESP8266 RX&#xA;CP2102 RXD -&amp;gt; ESP8266 TX &#xA;CP2102 GND -&amp;gt; ESP8266 GND&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ESP8266使用AT指令开发示例&#xA;http://wiki.ai-thinker.com/esp8266/examples/at_demo&#xA;&#xA;// 开发工具清单(驱动与串口调试工具)&#xA;http://wiki.ai-thinker.com/tools&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-03-29-使用ESP8266实现微信Airkiss智能配网/0.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-03-29-使用ESP8266实现微信Airkiss智能配网/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-03-29-使用ESP8266实现微信Airkiss智能配网/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-03-29-使用ESP8266实现微信Airkiss智能配网/3.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之string常用方法总结</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8Bstring%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>2020-03-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;C++之string常用方法总结&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 常用方法 ...&#xA;// http://www.cplusplus.com/reference/string/string&#xA;c_str&#xA;    Get C string equivalent (public member function )&#xA;data&#xA;    Get string data (public member function )&#xA;get_allocator&#xA;    Get allocator (public member function )&#xA;copy&#xA;    Copy sequence of characters from string (public member function )&#xA;find&#xA;    Find content in string (public member function )&#xA;rfind&#xA;    Find last occurrence of content in string (public member function )&#xA;find_first_of&#xA;    Find character in string (public member function )&#xA;find_last_of&#xA;    Find character in string from the end (public member function )&#xA;find_first_not_of&#xA;    Find absence of character in string (public member function )&#xA;find_last_not_of&#xA;    Find non-matching character in string from the end (public member function )&#xA;substr&#xA;    Generate substring (public member function )&#xA;compare&#xA;    Compare strings (public member function )&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str.find(str1)&#xA;说明：从pos(默认是是0，即从头开始查找)开始查找，&#xA;找到第一个和str1相匹配的子串，**返回该子串的起始索引位置**&#xA;如果没有找到则返回string::npos&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str.find_first_of(str1)&#xA;说明：从pos(默认是是0，即从头开始查找)开始查找，&#xA;找到第一个和str1相匹配的子串，**返回该子串的起始索引位置**&#xA;如果没有找到则返回string::npos&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str.find_last_of(str1)&#xA;说明：从npos(默认是字符串最后一个，即从后向前查找)开始查找，&#xA;找到第一个和str1相匹配的子串，**返回该子串的最后一个字符的索引位置**&#xA;如果没有找到则返回string::npos&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 获取视频文件路径中的文件名 ...&#xA;string str = &amp;quot;/root/video/a.mp4&amp;quot;&#xA;unsigned int pos = str.find_last_of(&amp;quot;/&amp;quot;);&#xA;if (pos != string::npos)&#xA;    str.substr(pos + 1, str.size() - 1)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str.erase(pos); &#xA;说明：删除str中下标pos到末尾的所有字符&#xA;str.erase(first,num)&#xA;说明：删除从first开始num个字符&#xA;&#xA;#include&amp;lt;string&amp;gt;&#xA;#include&amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;&#xA;int main()&#xA;{&#xA;    string str = &amp;quot;0123456789&amp;quot;;&#xA;    str.erase(7);&#xA;    cout &amp;lt;&amp;lt; str  &amp;lt;&amp;lt; endl;   //结果：0123456&#xA;    str.erase(0, 2);&#xA;    cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;    // 结果：23456&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之在Class中使用Thread</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8B%E5%9C%A8Class%E4%B8%AD%E4%BD%BF%E7%94%A8Thread/</link>
      <pubDate>2020-03-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;C++之在Class中使用Thread&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;thread&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;&#xA;class Wrapper {&#xA;  public:&#xA;      void member1() {&#xA;      std::cout &amp;lt;&amp;lt; &amp;quot;i am member1&amp;quot; &amp;lt;&amp;lt; std::endl;&#xA;      }&#xA;      void member2(const char *arg1, unsigned arg2) {&#xA;      std::cout &amp;lt;&amp;lt; &amp;quot;i am member2 and my first arg is (&amp;quot; &amp;lt;&amp;lt; arg1 &amp;lt;&amp;lt; &amp;quot;) and second arg is (&amp;quot; &amp;lt;&amp;lt; arg2 &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; std::endl;&#xA;      }&#xA;      std::thread member1Thread() {&#xA;      return std::thread(&amp;amp;Wrapper::member1, this);&#xA;      }&#xA;      std::thread member2Thread(const char *arg1, unsigned arg2) {&#xA;      return std::thread(&amp;amp;Wrapper::member2, this, arg1, arg2);&#xA;      }&#xA;};&#xA;&#xA;int main() {&#xA;  Wrapper *w = new Wrapper();&#xA;  std::thread tw1 = w-&amp;gt;member1Thread();&#xA;  tw1.join();&#xA;  w-&amp;gt;member2Thread(&amp;quot;hello&amp;quot;, 100).detach();&#xA;&#xA;return 0;&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;join()为主线程等待子线程的阻塞模式&#xA;&#xA;detach()为主线程不管子线程的非阻塞模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 摘自网络：https://www.cnblogs.com/c4isr/p/9205164.html 感谢&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之集成FFmpeg到SDL项目</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E9%9B%86%E6%88%90FFmpeg%E5%88%B0SDL%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>2020-03-21 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之集成FFmpeg到SDL项目&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// FFmpeg 下载&#xA;// 本教程使用 FFmpeg 4.2.2 &amp;quot;Ada&amp;quot; 下进行 ...&#xA;http://ffmpeg.org/download.html#releases&#xA;&#xA;// 拷贝库文件(Android之NDK编译FFmpeg教程)&#xA;// 拷贝 ffmpeg-4.2.2/include 至 jni/ffmpeg &#xA;// 拷贝 arm64-v8、armeabi-v7a、... 至 jni/ffmpeg/libs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 app\jni\src\Android.mk&#xA;&#xA;LOCAL_PATH := $(call my-dir)&#xA;&#xA;FFMPEG_PATH := ../FFMPEG&#xA;&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE :=  libavutil&#xA;LOCAL_SRC_FILES := ../ffmpeg/libs/$(TARGET_ARCH_ABI)/libavutil.so&#xA;LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/$(FFMPEG_PATH)/include&#xA;include $(PREBUILT_SHARED_LIBRARY)&#xA;&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE :=  libswresample&#xA;LOCAL_SRC_FILES := ../ffmpeg/libs/$(TARGET_ARCH_ABI)/libswresample.so&#xA;LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/$(FFMPEG_PATH)/include&#xA;include $(PREBUILT_SHARED_LIBRARY)&#xA;&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE :=  libswscale&#xA;LOCAL_SRC_FILES := ../ffmpeg/libs/$(TARGET_ARCH_ABI)/libswscale.so&#xA;LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/$(FFMPEG_PATH)/include&#xA;include $(PREBUILT_SHARED_LIBRARY)&#xA;&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE := libavcodec&#xA;LOCAL_SRC_FILES := ../ffmpeg/libs/$(TARGET_ARCH_ABI)/libavcodec.so&#xA;LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/$(FFMPEG_PATH)/include&#xA;include $(PREBUILT_SHARED_LIBRARY)&#xA;&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE := libavformat&#xA;LOCAL_SRC_FILES := ../ffmpeg/libs/$(TARGET_ARCH_ABI)/libavformat.so&#xA;LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/$(FFMPEG_PATH)/include&#xA;include $(PREBUILT_SHARED_LIBRARY)&#xA;&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE := libavfilter&#xA;LOCAL_SRC_FILES := ../ffmpeg/libs/$(TARGET_ARCH_ABI)/libavfilter.so&#xA;LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/$(FFMPEG_PATH)/include&#xA;include $(PREBUILT_SHARED_LIBRARY)&#xA;&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE := main&#xA;SDL_PATH := ../SDL&#xA;LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include&#xA;# Add your application source files here...&#xA;LOCAL_SRC_FILES := YourSourceHere.c&#xA;LOCAL_SHARED_LIBRARIES := SDL2 SDL2_image&#xA;LOCAL_SHARED_LIBRARIES += libavcodec libavfilter libavformat libavutil libswresample libswscale&#xA;LOCAL_LDLIBS := -lGLESv1_CM -lGLESv2 -llog&#xA;include $(BUILD_SHARED_LIBRARY)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 app\jni\src\YourSourceHere.c &#xA;&#xA;#include &amp;lt;android/log.h&amp;gt;&#xA;#include &amp;quot;SDL.h&amp;quot;&#xA;#include &amp;quot;SDL_image.h&amp;quot;&#xA;&#xA;#include &amp;lt;libavcodec/avcodec.h&amp;gt;&#xA;#include &amp;lt;libavformat/avformat.h&amp;gt;&#xA;#include &amp;lt;libswscale/swscale.h&amp;gt;&#xA;#include &amp;lt;libavutil/imgutils.h&amp;gt;&#xA;&#xA;#define LOG_TAG &amp;quot;xplay&amp;quot;&#xA;&#xA;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)&#xA;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG , LOG_TAG, __VA_ARGS__)&#xA;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , LOG_TAG, __VA_ARGS__)&#xA;#define LOGW(...) __android_log_print(ANDROID_LOG_WARN , LOG_TAG, __VA_ARGS__)&#xA;#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR , LOG_TAG, __VA_ARGS__)&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;    SDL_Window *window;&#xA;    SDL_Renderer *renderer;&#xA;    SDL_Event event;&#xA;    //配置一个图像缩放的效果,linear效果更平滑,也叫抗锯齿&#xA;    //SDL_setenv(SDL_HINT_RENDER_SCALE_QUALITY,&amp;quot;linear&amp;quot;,0);&#xA;&#xA;    // FFMPEG ...&#xA;    LOGD(&amp;quot;%s&amp;quot;, av_version_info());&#xA;&#xA;    // 初始化SDL&#xA;    IMG_Init(IMG_INIT_JPG | IMG_INIT_PNG);&#xA;    if (SDL_Init(SDL_INIT_VIDEO) &amp;lt; 0)&#xA;    return 1;&#xA;    // 创建一个窗口&#xA;    window = SDL_CreateWindow(&amp;quot;SDL_RenderClear&amp;quot; , SDL_WINDOWPOS_CENTERED,&#xA;                  SDL_WINDOWPOS_CENTERED, 0, 0, SDL_WINDOW_SHOWN);&#xA;    // 创建一个渲染器&#xA;    renderer = SDL_CreateRenderer(window, -1, 0);&#xA;    // 创建一个Surface，加载刚才下载的图片&#xA;    SDL_Surface *jpg = IMG_Load(&amp;quot;a1.jpg&amp;quot;);&#xA;//    SDL_Surface *bmp = SDL_LoadBMP(&amp;quot;test.bmp&amp;quot;);&#xA;//    //设置图片中的白色为透明色&#xA;//    SDL_SetColorKey(bmp, SDL_TRUE, 0xffffff);&#xA;    // 创建一个Texture&#xA;    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, jpg);&#xA;    //清除所有事件&#xA;    SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);&#xA;    //进入主循环&#xA;    while  (1) {&#xA;    Uint32 a = SDL_GetTicks();&#xA;    if  (SDL_PollEvent(&amp;amp;event)) {&#xA;        if  (event.type == SDL_QUIT || event.type == SDL_KEYDOWN || event.type == SDL_FINGERDOWN)&#xA;        break;&#xA;    }&#xA;    //使用红色填充背景&#xA;    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);&#xA;    SDL_RenderClear(renderer);&#xA;    // 将纹理布置到渲染器&#xA;    SDL_RenderCopy(renderer, texture, NULL, NULL);&#xA;    // 刷新屏幕&#xA;    SDL_RenderPresent(renderer);&#xA;    Uint32 b = SDL_GetTicks();&#xA;    LOGD(&amp;quot;&amp;gt;&amp;gt;&amp;gt; %d&amp;quot;, b - a);&#xA;    }&#xA;    // 释放Surface&#xA;    SDL_FreeSurface(jpg);&#xA;    //  释放Texture&#xA;    SDL_DestroyTexture(texture);&#xA;    //释放渲染器&#xA;    SDL_DestroyRenderer(renderer);&#xA;    //释放窗口&#xA;    SDL_DestroyWindow(window);&#xA;    //延时&#xA;    //SDL_Delay(8000);&#xA;    //退出&#xA;    SDL_Quit();&#xA;    return  0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之使用SDL播放图片</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E4%BD%BF%E7%94%A8SDL%E6%92%AD%E6%94%BE%E5%9B%BE%E7%89%87/</link>
      <pubDate>2020-03-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之使用SDL播放图片&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载 SDL version 2.0.12 (stable)&#xA;// SDL2-2.0.12.zip - GPG signed&#xA;https://www.libsdl.org/download-2.0.php&#xA;&#xA;// 下载 SDL_image 2.0&#xA;// SDL2_image-2.0.5.zip&#xA;https://www.libsdl.org/projects/SDL_image/&#xA;&#xA;解压 SDL2-2.0.12.zip 至 E:/SDL2-2.0.12&#xA;复制 E:/SDL2-2.0.12/android-project 至 E:\android-project&#xA;复制 E:/SDL2-2.0.12 至 E:\android-project\app\jni\sdl&#xA;解压 SDL2_image-2.0.5.zip 至 E:\android-project\app\jni\sdl_image&#xA;移除 E:/SDL2-2.0.12/android-project/app/jni/CMakeLists.txt&#xA;移除 E:/SDL2-2.0.12/android-project/app/jni/src/CMakeLists.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用 android studio 打开 E:\android-project 项目&#xA;&#xA;// 配置 local.properties 中 NDK 路径&#xA;sdk.dir=D\:\\Android\\SDK&#xA;&#xA;// 使用的 NDK 版本&#xA;Pkg.Desc = Android NDK&#xA;Pkg.Revision = 20.1.5948944&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 app\jni\src 下新建 YourSourceHere.c &#xA;&#xA;#include &amp;lt;android/log.h&amp;gt;&#xA;#include &amp;quot;SDL.h&amp;quot;&#xA;#include &amp;quot;SDL_image.h&amp;quot;&#xA;&#xA;#define LOG_TAG &amp;quot;xplay&amp;quot;&#xA;&#xA;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)&#xA;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG , LOG_TAG, __VA_ARGS__)&#xA;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , LOG_TAG, __VA_ARGS__)&#xA;#define LOGW(...) __android_log_print(ANDROID_LOG_WARN , LOG_TAG, __VA_ARGS__)&#xA;#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR , LOG_TAG, __VA_ARGS__)&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;    SDL_Window *window;&#xA;    SDL_Renderer *renderer;&#xA;    SDL_Event event;&#xA;    //配置一个图像缩放的效果,linear效果更平滑,也叫抗锯齿&#xA;    //SDL_setenv(SDL_HINT_RENDER_SCALE_QUALITY,&amp;quot;linear&amp;quot;,0);&#xA;    // 初始化SDL&#xA;    IMG_Init(IMG_INIT_JPG | IMG_INIT_PNG);&#xA;    if (SDL_Init(SDL_INIT_VIDEO) &amp;lt; 0)&#xA;    return 1;&#xA;    // 创建一个窗口&#xA;    window = SDL_CreateWindow(&amp;quot;SDL_RenderClear&amp;quot; , SDL_WINDOWPOS_CENTERED,&#xA;                  SDL_WINDOWPOS_CENTERED, 0, 0, SDL_WINDOW_SHOWN);&#xA;    // 创建一个渲染器&#xA;    renderer = SDL_CreateRenderer(window, -1, 0);&#xA;    // 创建一个Surface，加载刚才下载的图片&#xA;    SDL_Surface *jpg = IMG_Load(&amp;quot;a1.jpg&amp;quot;);&#xA;//    SDL_Surface *bmp = SDL_LoadBMP(&amp;quot;test.bmp&amp;quot;);&#xA;//    //设置图片中的白色为透明色&#xA;//    SDL_SetColorKey(bmp, SDL_TRUE, 0xffffff);&#xA;    // 创建一个Texture&#xA;    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, jpg);&#xA;    //清除所有事件&#xA;    SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);&#xA;    //进入主循环&#xA;    while  (1) {&#xA;    Uint32 a = SDL_GetTicks();&#xA;    if  (SDL_PollEvent(&amp;amp;event)) {&#xA;        if  (event.type == SDL_QUIT || event.type == SDL_KEYDOWN || event.type == SDL_FINGERDOWN)&#xA;        break;&#xA;    }&#xA;    //使用红色填充背景&#xA;    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);&#xA;    SDL_RenderClear(renderer);&#xA;    // 将纹理布置到渲染器&#xA;    SDL_RenderCopy(renderer, texture, NULL, NULL);&#xA;    // 刷新屏幕&#xA;    SDL_RenderPresent(renderer);&#xA;    Uint32 b = SDL_GetTicks();&#xA;    LOGD(&amp;quot;&amp;gt;&amp;gt;&amp;gt; %d&amp;quot;, b - a);&#xA;    }&#xA;    // 释放Surface&#xA;    SDL_FreeSurface(jpg);&#xA;    //  释放Texture&#xA;    SDL_DestroyTexture(texture);&#xA;    //释放渲染器&#xA;    SDL_DestroyRenderer(renderer);&#xA;    //释放窗口&#xA;    SDL_DestroyWindow(window);&#xA;    //延时&#xA;    //SDL_Delay(8000);&#xA;    //退出&#xA;    SDL_Quit();&#xA;    return  0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 app\jni\src\Android.mk&#xA;&#xA;LOCAL_PATH := $(call my-dir)&#xA;&#xA;include $(CLEAR_VARS)&#xA;&#xA;LOCAL_MODULE := main&#xA;&#xA;SDL_PATH := ../SDL&#xA;&#xA;LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include&#xA;&#xA;# Add your application source files here...&#xA;LOCAL_SRC_FILES := YourSourceHere.c&#xA;&#xA;LOCAL_SHARED_LIBRARIES := SDL2 SDL2_image&#xA;&#xA;LOCAL_LDLIBS := -lGLESv1_CM -lGLESv2 -llog&#xA;&#xA;include $(BUILD_SHARED_LIBRARY)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建目录 app\src\main\assets&#xA;// 向目录拷贝一张 a1.jpg 图片&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 更改 org.libsdl.app 为 com.nljb.xplay&#xA;// 新建目录 app\src\main\java\com\danoo\xplay &#xA;// 在目录中新建一个空白的 MainActivity.java&#xA;&#xA;package com.nljb.xplay;&#xA;&#xA;import android.support.v7.app.AppCompatActivity;&#xA;import android.os.Bundle;&#xA;&#xA;public class MainActivity extends AppCompatActivity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 AndroidManifest.xml 中 org.libsdl.app 为 com.nljb.xplay&#xA;&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    package=&amp;quot;com.nljb.xplay&amp;quot;&#xA;    android:installLocation=&amp;quot;auto&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- OpenGL ES 2.0 --&amp;gt;&#xA;    &amp;lt;uses-feature android:glEsVersion=&amp;quot;0x00020000&amp;quot; /&amp;gt; &amp;lt;!-- Touchscreen support --&amp;gt;&#xA;    &amp;lt;uses-feature&#xA;    android:name=&amp;quot;android.hardware.touchscreen&amp;quot;&#xA;    android:required=&amp;quot;false&amp;quot; /&amp;gt; &amp;lt;!-- Game controller support --&amp;gt;&#xA;    &amp;lt;uses-feature&#xA;    android:name=&amp;quot;android.hardware.bluetooth&amp;quot;&#xA;    android:required=&amp;quot;false&amp;quot; /&amp;gt;&#xA;    &amp;lt;uses-feature&#xA;    android:name=&amp;quot;android.hardware.gamepad&amp;quot;&#xA;    android:required=&amp;quot;false&amp;quot; /&amp;gt;&#xA;    &amp;lt;uses-feature&#xA;    android:name=&amp;quot;android.hardware.usb.host&amp;quot;&#xA;    android:required=&amp;quot;false&amp;quot; /&amp;gt; &amp;lt;!-- External mouse input events --&amp;gt;&#xA;    &amp;lt;uses-feature&#xA;    android:name=&amp;quot;android.hardware.type.pc&amp;quot;&#xA;    android:required=&amp;quot;false&amp;quot; /&amp;gt; &amp;lt;!-- Audio recording support --&amp;gt;&#xA;    &amp;lt;!-- if you want to capture audio, uncomment this. --&amp;gt;&#xA;    &amp;lt;!--&#xA; &amp;lt;uses-feature&#xA;    android:name=&amp;quot;android.hardware.microphone&amp;quot;&#xA;    android:required=&amp;quot;false&amp;quot; /&amp;gt;&#xA;    --&amp;gt;&#xA;    &amp;lt;!-- Allow writing to external storage --&amp;gt;&#xA;    &amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot; /&amp;gt; &amp;lt;!-- Allow access to Bluetooth devices --&amp;gt;&#xA;    &amp;lt;uses-permission android:name=&amp;quot;android.permission.BLUETOOTH&amp;quot; /&amp;gt; &amp;lt;!-- Allow access to the vibrator --&amp;gt;&#xA;    &amp;lt;uses-permission android:name=&amp;quot;android.permission.VIBRATE&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;application&#xA;    android:allowBackup=&amp;quot;true&amp;quot;&#xA;    android:hardwareAccelerated=&amp;quot;true&amp;quot;&#xA;    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;&#xA;    android:label=&amp;quot;@string/app_name&amp;quot;&#xA;    android:theme=&amp;quot;@android:style/Theme.NoTitleBar.Fullscreen&amp;quot;&amp;gt;&#xA;    &amp;lt;activity android:name=&amp;quot;.MainActivity&amp;quot;&amp;gt;&amp;lt;/activity&amp;gt;&#xA;    &amp;lt;!--&#xA;     Example of setting SDL hints from AndroidManifest.xml:&#xA;    &amp;lt;meta-data android:name=&amp;quot;SDL_ENV.SDL_ACCELEROMETER_AS_JOYSTICK&amp;quot; android:value=&amp;quot;0&amp;quot;/&amp;gt;&#xA;    --&amp;gt;&#xA;    &amp;lt;activity&#xA;        android:name=&amp;quot;org.libsdl.app.SDLActivity&amp;quot;&#xA;        android:alwaysRetainTaskState=&amp;quot;true&amp;quot;&#xA;        android:configChanges=&amp;quot;orientation|uiMode|screenLayout|screenSize|smallestScreenSize|keyboard|keyboardHidden|navigation&amp;quot;&#xA;        android:label=&amp;quot;@string/app_name&amp;quot;&#xA;        android:launchMode=&amp;quot;singleInstance&amp;quot;&amp;gt;&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;        &amp;lt;!-- Drop file event --&amp;gt;&#xA;        &amp;lt;!--&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.VIEW&amp;quot; /&amp;gt;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.DEFAULT&amp;quot; /&amp;gt;&#xA;        &amp;lt;data android:mimeType=&amp;quot;*/*&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;        --&amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;/application&amp;gt;&#xA;&#xA;&amp;lt;/manifest&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 build.gradle&#xA;applicationId &amp;quot;com.danoo.xplay&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Windows使用WSL备份Linux子系统</title>
      <link>http://www.nljb.net/default/Windows%E4%BD%BF%E7%94%A8WSL%E5%A4%87%E4%BB%BDLinux%E5%AD%90%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>2020-03-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Windows使用WSL备份Linux子系统&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看Windows中的子系统&#xA;wsl -l&#xA;适用于 Linux 的 Windows 子系统:&#xA;Ubuntu-18.04-20190707 (默认)&#xA;&#xA;// 停止子系统&#xA;wsl -t Ubuntu-18.04-20190707&#xA;或者&#xA;wsl --terminate Ubuntu-18.04-20190707&#xA;&#xA;// 运行子系统&#xA;wsl --distribution Ubuntu-18.04-20190707&#xA;或者&#xA;wsl -d Ubuntu-18.04-20190707&#xA;&#xA;// 查看运行中的子系统&#xA;wsl -l --running&#xA;适用于 Linux 的 Windows 子系统:&#xA;Ubuntu-18.04-20190707 (默认)&#xA;&#xA;// 注意：备份/还原/删除 子系统之前需要先停止子系统 !!!&#xA;&#xA;// 备份子系统&#xA;wsl --export Ubuntu-18.04-20190707 c:\temp\Ubuntu-18.04-20190707.tar&#xA;&#xA;// 删除子系统&#xA;wsl --unregister Ubuntu-18.04-20190707&#xA;&#xA;// 还原子系统&#xA;wsl --import Ubuntu-18.04-20190707 c:\WSL c:\temp\Ubuntu-18.04-20190707.tar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之编译SDL2教程</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E7%BC%96%E8%AF%91SDL2%E6%95%99%E7%A8%8B/</link>
      <pubDate>2020-03-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之编译SDL2教程&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载 SDL version 2.0.12 (stable)&#xA;// Source Code SDL2-2.0.12.zip &#xA;https://www.libsdl.org/download-2.0.php&#xA;&#xA;// 拷贝 SDL2-2.0.10/android-project 到项目目录&#xA;拷贝 SDL2-2.0.10/android-project 至 E:/android-project &#xA;&#xA;// Android Studio 3.6.1 导入项目&#xA;File -&amp;gt; New -&amp;gt; import Project -&amp;gt; E:/android-project&#xA;&#xA;// 移动 jni 目录&#xA;E:\android-project\app\jni 至 E:\android-project\app\src\main\jni&#xA;&#xA;// 在 jni 目录中创建一个 sdl 文件夹&#xA;E:\android-project\app\src\main\jni\sdl&#xA;拷贝 SDL2-2.0.10 源码中 include、src、Android.mk 到 sdl 目录中&#xA;&#xA;// 编辑 E:\android-project\app\src\main\jni\Application.mk 文件&#xA;# Uncomment this if you&#39;re using STL in your project&#xA;# You can find more information here:&#xA;# https://developer.android.com/ndk/guides/cpp-support&#xA;APP_STL := c++_shared&#xA;APP_ABI := armeabi-v7a arm64-v8a x86 x86_64&#xA;# Min runtime API level&#xA;APP_PLATFORM=android-21&#xA;&#xA;// 编辑 E:\android-project\app\src\main\jni\src\Android.mk 文件&#xA;LOCAL_PATH := $(call my-dir)&#xA;include $(CLEAR_VARS)&#xA;LOCAL_MODULE := main&#xA;SDL_PATH := ../sdl&#xA;LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include&#xA;# Add your application source files here...&#xA;LOCAL_SRC_FILES := YourSourceHere.c&#xA;LOCAL_SHARED_LIBRARIES := SDL2&#xA;LOCAL_LDLIBS := -lGLESv1_CM -lGLESv2 -llog&#xA;include $(BUILD_SHARED_LIBRARY)&#xA;&#xA;// 在 E:\android-project\app\src\main\jni\src 目录下创建 YourSourceHere.c&#xA;int main(int argc, char *argv[]) &#xA;{&#xA;}&#xA;// 或者&#xA;#include &amp;quot;SDL.h&amp;quot;&#xA;int main(int argc, char *argv[]) {&#xA;     SDL_Window *window;&#xA;     SDL_Renderer *renderer;&#xA;     SDL_Event event;&#xA;     //配置一个图像缩放的效果,linear效果更平滑,也叫抗锯齿&#xA;     //SDL_setenv(SDL_HINT_RENDER_SCALE_QUALITY,&amp;quot;linear&amp;quot;,0);&#xA;     // 初始化SDL&#xA;     if (SDL_Init(SDL_INIT_VIDEO) &amp;lt; 0)&#xA;     return 1;&#xA;     // 创建一个窗口&#xA;     window = SDL_CreateWindow(&amp;quot;SDL_RenderClear&amp;quot; , SDL_WINDOWPOS_CENTERED,&#xA;                   SDL_WINDOWPOS_CENTERED, 0, 0, SDL_WINDOW_SHOWN);&#xA;     // 创建一个渲染器&#xA;     renderer = SDL_CreateRenderer(window, -1, 0);&#xA;     // 创建一个Surface，加载刚才下载的图片&#xA;     SDL_Surface *bmp = SDL_LoadBMP(&amp;quot;image.bmp&amp;quot; );&#xA;     //设置图片中的白色为透明色&#xA;     SDL_SetColorKey(bmp, SDL_TRUE, 0xffffff);&#xA;     // 创建一个Texture&#xA;     SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, bmp);&#xA;     //清除所有事件&#xA;     SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);&#xA;     //进入主循环&#xA;     while  (1) {&#xA;     if  (SDL_PollEvent(&amp;amp;event)) {&#xA;         if  (event.type == SDL_QUIT || event.type == SDL_KEYDOWN || event.type == SDL_FINGERDOWN)&#xA;         break;&#xA;     }&#xA;     //使用红色填充背景&#xA;     SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);&#xA;     SDL_RenderClear(renderer);&#xA;     // 将纹理布置到渲染器&#xA;     SDL_RenderCopy(renderer, texture, NULL, NULL);&#xA;     // 刷新屏幕&#xA;     SDL_RenderPresent(renderer);&#xA;     }&#xA;      // 释放Surface&#xA;     SDL_FreeSurface(bmp);&#xA;     //  释放Texture&#xA;     SDL_DestroyTexture(texture);&#xA;     //释放渲染器&#xA;     SDL_DestroyRenderer(renderer);&#xA;     //释放窗口&#xA;     SDL_DestroyWindow(window);&#xA;     //延时&#xA;     //SDL_Delay(8000);&#xA;     //退出&#xA;     SDL_Quit();&#xA;     return  0;&#xA;}&#xA;&#xA;// build.gradle 修改 ...&#xA;def buildAsLibrary = project.hasProperty(&#39;BUILD_AS_LIBRARY&#39;);&#xA;def buildAsApplication = !buildAsLibrary&#xA;if (buildAsApplication) {&#xA;    apply plugin: &#39;com.android.application&#39;&#xA;}&#xA;else {&#xA;    apply plugin: &#39;com.android.library&#39;&#xA;}&#xA;&#xA;android {&#xA;    compileSdkVersion 29&#xA;    defaultConfig {&#xA;    if (buildAsApplication) {&#xA;        applicationId &amp;quot;org.libsdl.app&amp;quot;&#xA;    }&#xA;    minSdkVersion 21&#xA;    targetSdkVersion 29&#xA;    versionCode 1&#xA;    versionName &amp;quot;1.0&amp;quot;&#xA;    externalNativeBuild {&#xA;        ndkBuild {&#xA;        arguments &amp;quot;APP_PLATFORM=android-21&amp;quot;&#xA;        abiFilters &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;, &#39;x86&#39;, &#39;x86_64&#39;&#xA;        }&#xA;    }&#xA;    }&#xA;    buildTypes {&#xA;    release {&#xA;        minifyEnabled false&#xA;        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;&#xA;    }&#xA;    }&#xA;    if (!project.hasProperty(&#39;EXCLUDE_NATIVE_LIBS&#39;)) {&#xA;    sourceSets.main {&#xA;        jniLibs.srcDir &#39;src/main/jni&#39;&#xA;    }&#xA;    externalNativeBuild {&#xA;        ndkBuild {&#xA;        path &#39;src/main/jni/Android.mk&#39;&#xA;        }&#xA;    }&#xA;&#xA;    }&#xA;    lintOptions {&#xA;    abortOnError false&#xA;    }&#xA;&#xA;    if (buildAsLibrary) {&#xA;    libraryVariants.all { variant -&amp;gt;&#xA;        variant.outputs.each { output -&amp;gt;&#xA;        def outputFile = output.outputFile&#xA;        if (outputFile != null &amp;amp;&amp;amp; outputFile.name.endsWith(&amp;quot;.aar&amp;quot;)) {&#xA;            def fileName = &amp;quot;org.libsdl.app.aar&amp;quot;;&#xA;            output.outputFile = new File(outputFile.parent, fileName);&#xA;        }&#xA;        }&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;dependencies {&#xA;    implementation fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// so 会生成在 app/build/ndkBuild/debug/obj/local/ 目录中 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之使用FFmpeg播放视频</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E4%BD%BF%E7%94%A8FFmpeg%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</link>
      <pubDate>2020-03-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之使用FFmpeg播放视频&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-03-16-Android之使用FFmpeg播放视频/1824809.jpg&#34; alt=&#34;&#34; width=&#34;700&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2020-03-16-Android之使用FFmpeg播放视频/2019080717000187.jpg&#34; alt=&#34;&#34; width=&#34;700&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;库名&lt;/th&gt;&#xA;&lt;th&gt;工具&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libavformat&lt;/td&gt;&#xA;&lt;td&gt;用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；音视频的格式解析协议，为libavcodec分析码流提供独立的音频或视频码流源。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libavcodec&lt;/td&gt;&#xA;&lt;td&gt;用于各种类型声音/图像编解码；该库是音视频编解码核心，实现了市面上可见的绝大部分解码器的功能，libavcodec库被其他各大解码器ffdshow,MPlayer等所包含或应用。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libavdevice&lt;/td&gt;&#xA;&lt;td&gt;硬件采集、加速、显示。操作计算机中常用的音视频捕获或输出设备；&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libavfilter&lt;/td&gt;&#xA;&lt;td&gt;filter音视频滤波器的开发，如宽高比、剪裁、格式化、非格式化、伸缩。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libavutil&lt;/td&gt;&#xA;&lt;td&gt;包含一些公共的工具函数的使用库，包括算数运算、字符操作。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libavresample&lt;/td&gt;&#xA;&lt;td&gt;音视频封装编解码格式预设等。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libswscale&lt;/td&gt;&#xA;&lt;td&gt;(原始视频格式转换) 用于视频场景比例缩放、色彩映射转换；图像颜色空间或格式转换。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libswresample&lt;/td&gt;&#xA;&lt;td&gt;原始音频格式转码&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;libpostproc&lt;/td&gt;&#xA;&lt;td&gt;(同步、时间计算的简单算法) 用于后期效果处理；音视频应用的后期处理，如图像的去块效应。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 native-lib.cpp 文件&#xA;#include &amp;lt;jni.h&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;android/log.h&amp;gt;&#xA;#include &amp;lt;android/native_window_jni.h&amp;gt;&#xA;#include &amp;lt;android/native_window.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;&#xA;extern &amp;quot;C&amp;quot; {&#xA;#include &amp;lt;libavcodec/avcodec.h&amp;gt;&#xA;#include &amp;lt;libavformat/avformat.h&amp;gt;&#xA;#include &amp;lt;libswscale/swscale.h&amp;gt;&#xA;#include &amp;lt;libavutil/imgutils.h&amp;gt;&#xA;}&#xA;&#xA;#define  LOG_TAG    &amp;quot;ffmpegandroidplayer&amp;quot;&#xA;#define  LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,FORMAT,##__VA_ARGS__);&#xA;#define  LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,FORMAT,##__VA_ARGS__);&#xA;#define  LOGD(FORMAT,...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG,FORMAT, ##__VA_ARGS__)&#xA;&#xA;extern &amp;quot;C&amp;quot; JNIEXPORT jstring JNICALL&#xA;Java_com_danoo_xplay_VideoUtils_stringFromJNI(&#xA;    JNIEnv *env,&#xA;    jobject /* this */) {&#xA;    std::string hello = &amp;quot;Hello from C++&amp;quot;;&#xA;    return env-&amp;gt;NewStringUTF(av_version_info());//返回ffmpeg的版本&#xA;}&#xA;&#xA;extern &amp;quot;C&amp;quot; JNIEXPORT void JNICALL&#xA;Java_com_danoo_xplay_VideoUtils_render(&#xA;    JNIEnv *env,&#xA;    jobject jobj,&#xA;    jstring input_jstr, jobject surface) {&#xA;    const char* file_name = env-&amp;gt;GetStringUTFChars(input_jstr, NULL);&#xA;&#xA;&#xA;    LOGD(&amp;quot;play&amp;quot;);&#xA;&#xA;&#xA;    av_register_all();&#xA;&#xA;    AVFormatContext *pFormatCtx = avformat_alloc_context();&#xA;&#xA;    // Open video file&#xA;    int v = avformat_open_input(&amp;amp;pFormatCtx, file_name, NULL, NULL);&#xA;    if (v != 0) {&#xA;    LOGD(&amp;quot;Couldn&#39;t open file:%s(%d)\n&amp;quot;, file_name, v);&#xA;    return ; // Couldn&#39;t open file&#xA;    }&#xA;&#xA;    // Retrieve stream information&#xA;    if (avformat_find_stream_info(pFormatCtx, NULL) &amp;lt; 0) {&#xA;    LOGD(&amp;quot;Couldn&#39;t find stream information.&amp;quot;);&#xA;    return ;&#xA;    }&#xA;&#xA;    // Find the first video stream&#xA;    int videoStream = -1, i;&#xA;    for (i = 0; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; i++) {&#xA;    if (pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO&#xA;        &amp;amp;&amp;amp; videoStream &amp;lt; 0) {&#xA;        videoStream = i;&#xA;    }&#xA;    }&#xA;    if (videoStream == -1) {&#xA;    LOGD(&amp;quot;Didn&#39;t find a video stream.&amp;quot;);&#xA;    return ; // Didn&#39;t find a video stream&#xA;    }&#xA;&#xA;    // Get a pointer to the codec context for the video stream&#xA;    AVCodecContext *pCodecCtx = pFormatCtx-&amp;gt;streams[videoStream]-&amp;gt;codec;&#xA;&#xA;    // Find the decoder for the video stream&#xA;    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&amp;gt;codec_id);&#xA;    if (pCodec == NULL) {&#xA;    LOGD(&amp;quot;Codec not found.&amp;quot;);&#xA;    return ; // Codec not found&#xA;    }&#xA;&#xA;    if (avcodec_open2(pCodecCtx, pCodec, NULL) &amp;lt; 0) {&#xA;    LOGD(&amp;quot;Could not open codec.&amp;quot;);&#xA;    return ; // Could not open codec&#xA;    }&#xA;&#xA;    // 获取native window&#xA;    ANativeWindow *nativeWindow = ANativeWindow_fromSurface(env, surface);&#xA;&#xA;    // 获取视频宽高&#xA;    int videoWidth = pCodecCtx-&amp;gt;width;&#xA;    int videoHeight = pCodecCtx-&amp;gt;height;&#xA;&#xA;    // 设置native window的buffer大小,可自动拉伸&#xA;    ANativeWindow_setBuffersGeometry(nativeWindow, videoWidth, videoHeight,&#xA;                     WINDOW_FORMAT_RGBA_8888);&#xA;    ANativeWindow_Buffer windowBuffer;&#xA;&#xA;    if (avcodec_open2(pCodecCtx, pCodec, NULL) &amp;lt; 0) {&#xA;    LOGD(&amp;quot;Could not open codec.&amp;quot;);&#xA;    return ; // Could not open codec&#xA;    }&#xA;&#xA;    // Allocate video frame&#xA;    AVFrame *pFrame = av_frame_alloc();&#xA;&#xA;    // 用于渲染&#xA;    AVFrame *pFrameRGBA = av_frame_alloc();&#xA;    if (pFrameRGBA == NULL || pFrame == NULL) {&#xA;    LOGD(&amp;quot;Could not allocate video frame.&amp;quot;);&#xA;    return ;&#xA;    }&#xA;&#xA;    // Determine required buffer size and allocate buffer&#xA;    // buffer中数据就是用于渲染的,且格式为RGBA&#xA;    int numBytes = av_image_get_buffer_size(AV_PIX_FMT_RGBA, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,&#xA;                        1);&#xA;    uint8_t *buffer = (uint8_t *) av_malloc(numBytes * sizeof(uint8_t));&#xA;    av_image_fill_arrays(pFrameRGBA-&amp;gt;data, pFrameRGBA-&amp;gt;linesize, buffer, AV_PIX_FMT_RGBA,&#xA;             pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1);&#xA;&#xA;    // 由于解码出来的帧格式不是RGBA的,在渲染之前需要进行格式转换&#xA;    struct SwsContext *sws_ctx = sws_getContext(pCodecCtx-&amp;gt;width,&#xA;                        pCodecCtx-&amp;gt;height,&#xA;                        pCodecCtx-&amp;gt;pix_fmt,&#xA;                        pCodecCtx-&amp;gt;width,&#xA;                        pCodecCtx-&amp;gt;height,&#xA;                        AV_PIX_FMT_RGBA,&#xA;                        SWS_BILINEAR,&#xA;                        NULL,&#xA;                        NULL,&#xA;                        NULL);&#xA;&#xA;    int frameFinished;&#xA;    AVPacket packet;&#xA;    while (av_read_frame(pFormatCtx, &amp;amp;packet) &amp;gt;= 0) {&#xA;    // Is this a packet from the video stream?&#xA;    if (packet.stream_index == videoStream) {&#xA;&#xA;        // Decode video frame&#xA;        avcodec_decode_video2(pCodecCtx, pFrame, &amp;amp;frameFinished, &amp;amp;packet);&#xA;&#xA;        // 并不是decode一次就可解码出一帧&#xA;        if (frameFinished) {&#xA;&#xA;        // lock native window buffer&#xA;        ANativeWindow_lock(nativeWindow, &amp;amp;windowBuffer, 0);&#xA;&#xA;        // 格式转换&#xA;        sws_scale(sws_ctx, (uint8_t const *const *) pFrame-&amp;gt;data,&#xA;              pFrame-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height,&#xA;              pFrameRGBA-&amp;gt;data, pFrameRGBA-&amp;gt;linesize);&#xA;&#xA;        // 获取stride&#xA;        uint8_t *dst = (uint8_t *) windowBuffer.bits;&#xA;        int dstStride = windowBuffer.stride * 4;&#xA;        uint8_t *src = (pFrameRGBA-&amp;gt;data[0]);&#xA;        int srcStride = pFrameRGBA-&amp;gt;linesize[0];&#xA;&#xA;        // 由于window的stride和帧的stride不同,因此需要逐行复制&#xA;        int h;&#xA;        for (h = 0; h &amp;lt; videoHeight; h++) {&#xA;            memcpy(dst + h * dstStride, src + h * srcStride, srcStride);&#xA;        }&#xA;&#xA;        ANativeWindow_unlockAndPost(nativeWindow);&#xA;        //延时绘制 否则视频快速播放&#xA;        usleep(1000 * 16);&#xA;        }&#xA;&#xA;    }&#xA;    av_packet_unref(&amp;amp;packet);&#xA;    }&#xA;&#xA;    av_free(buffer);&#xA;    av_free(pFrameRGBA);&#xA;&#xA;    // Free the YUV frame&#xA;    av_free(pFrame);&#xA;&#xA;    // Close the codecs&#xA;    avcodec_close(pCodecCtx);&#xA;&#xA;    // Close the video file&#xA;    avformat_close_input(&amp;amp;pFormatCtx);&#xA;    env-&amp;gt;ReleaseStringUTFChars(input_jstr, file_name);&#xA;    return ;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 新建 VideoUtils&#xA;package com.danoo.xplay;&#xA;&#xA;import android.view.Surface;&#xA;&#xA;public class VideoUtils {&#xA;&#xA;    static {&#xA;    System.loadLibrary(&amp;quot;native-lib&amp;quot;);&#xA;    }&#xA;&#xA;    public native String stringFromJNI();&#xA;&#xA;    public native void render(String input, Surface surface);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 入口 SimplePlayActivity&#xA;package com.danoo.xplay;&#xA;&#xA;import android.app.Activity;&#xA;import android.os.Bundle;&#xA;import android.os.Environment;&#xA;import android.util.Log;&#xA;import android.view.SurfaceHolder;&#xA;import android.view.SurfaceView;&#xA;&#xA;import androidx.core.app.ActivityCompat;&#xA;&#xA;import java.io.File;&#xA;import java.io.IOException;&#xA;&#xA;import butterknife.BindView;&#xA;import butterknife.ButterKnife;&#xA;&#xA;public class SimplePlayActivity extends Activity implements SurfaceHolder.Callback {&#xA;&#xA;    @BindView(R.id.video_view)&#xA;    SurfaceView videoView;&#xA;    private VideoUtils player;&#xA;    SurfaceHolder surfaceHolder;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    ButterKnife.bind(this);&#xA;    player = new VideoUtils();&#xA;    surfaceHolder = videoView.getHolder();&#xA;    //surface&#xA;    surfaceHolder.addCallback(this);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void surfaceCreated(final SurfaceHolder holder) {&#xA;    new Thread(new Runnable() {&#xA;        @Override&#xA;        public void run() {&#xA;        ActivityCompat.requestPermissions(SimplePlayActivity.this, new String[]{android&#xA;            .Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);&#xA;        File sdCard = Environment.getExternalStorageDirectory();&#xA;        Log.d(&amp;quot;main&amp;quot;, sdCard.getAbsolutePath());&#xA;        player.render(sdCard.getAbsolutePath() + File.separator + &amp;quot;aaa.mp4&amp;quot; , holder.getSurface());&#xA;        }&#xA;    }).start();&#xA;    }&#xA;&#xA;    @Override&#xA;    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {&#xA;&#xA;    }&#xA;&#xA;    @Override&#xA;    public void surfaceDestroyed(SurfaceHolder holder) {&#xA;    holder.getSurface().release();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// activity_main.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;SurfaceView&#xA;    android:id=&amp;quot;@+id/video_view&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;/&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// AndroidManifest.xml &#xA;...&#xA;    &amp;lt;application&#xA;    android:allowBackup=&amp;quot;true&amp;quot;&#xA;    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;&#xA;    android:label=&amp;quot;@string/app_name&amp;quot;&#xA;    android:roundIcon=&amp;quot;@mipmap/ic_launcher_round&amp;quot;&#xA;    android:supportsRtl=&amp;quot;true&amp;quot;&#xA;    android:theme=&amp;quot;@style/AppTheme&amp;quot;&amp;gt;&#xA;    &amp;lt;activity android:name=&amp;quot;.SimplePlayActivity&amp;quot;&#xA;        &amp;gt;&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;/application&amp;gt;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// CMakeLists.txt&#xA;cmake_minimum_required(VERSION 3.4.1)&#xA;&#xA;add_library( # Sets the name of the library.&#xA;    native-lib&#xA;    SHARED&#xA;    src/main/cpp/native-lib.cpp)&#xA;include_directories(src/main/cpp/include)&#xA;set(CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/libs/${ANDROID_ABI}&amp;quot;)&#xA;&#xA;find_library( # Sets the name of the path variable.&#xA;    log-lib&#xA;    log)&#xA;&#xA;&#xA;target_link_libraries( # Specifies the target library.&#xA;    native-lib&#xA;    avcodec avfilter avformat avutil swresample swscale&#xA;    -landroid&#xA;    ${log-lib})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// build.gradle&#xA;apply plugin: &#39;com.android.application&#39;&#xA;&#xA;android {&#xA;    compileSdkVersion 29&#xA;    buildToolsVersion &amp;quot;29.0.3&amp;quot;&#xA;&#xA;    defaultConfig {&#xA;    applicationId &amp;quot;com.danoo.xplay&amp;quot;&#xA;    minSdkVersion 21&#xA;    targetSdkVersion 29&#xA;    versionCode 1&#xA;    versionName &amp;quot;1.0&amp;quot;&#xA;&#xA;    testInstrumentationRunner &amp;quot;androidx.test.runner.AndroidJUnitRunner&amp;quot;&#xA;&#xA;    externalNativeBuild {&#xA;        cmake {&#xA;        cppFlags &amp;quot;&amp;quot;&#xA;        abiFilters &amp;quot;armeabi-v7a&amp;quot;, &amp;quot;arm64-v8a&amp;quot;, &amp;quot;x86&amp;quot;&#xA;        }&#xA;    }&#xA;    }&#xA;&#xA;    sourceSets {&#xA;    main {&#xA;        jniLibs.srcDirs = [&#39;src/main/cpp/libs/&#39;]&#xA;    }&#xA;    }&#xA;&#xA;    buildTypes {&#xA;    release {&#xA;        minifyEnabled false&#xA;        proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;&#xA;    }&#xA;    }&#xA;&#xA;    compileOptions {&#xA;    sourceCompatibility JavaVersion.VERSION_1_8&#xA;    targetCompatibility JavaVersion.VERSION_1_8&#xA;    }&#xA;&#xA;    externalNativeBuild {&#xA;    cmake {&#xA;        path &amp;quot;CMakeLists.txt&amp;quot;&#xA;        version &amp;quot;3.10.2&amp;quot;&#xA;    }&#xA;    }&#xA;    ndkVersion = &#39;20.0.5594570&#39;&#xA;&#xA;}&#xA;&#xA;dependencies {&#xA;    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])&#xA;    implementation &#39;com.jakewharton:butterknife:10.0.0&#39;&#xA;    annotationProcessor &#39;com.jakewharton:butterknife-compiler:10.0.0&#39;&#xA;    implementation &#39;androidx.appcompat:appcompat:1.1.0&#39;&#xA;    implementation &#39;com.google.android.material:material:1.1.0&#39;&#xA;    implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39;&#xA;    implementation &#39;androidx.navigation:navigation-fragment:2.2.1&#39;&#xA;    implementation &#39;androidx.navigation:navigation-ui:2.2.1&#39;&#xA;    testImplementation &#39;junit:junit:4.12&#39;&#xA;    androidTestImplementation &#39;androidx.test.ext:junit:1.1.1&#39;&#xA;    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 感谢 https://www.jianshu.com/p/6b943ff8fec8 有修改&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之集成FFmpeg到APP项目</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E9%9B%86%E6%88%90FFmpeg%E5%88%B0APP%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>2020-03-14 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之集成FFmpeg到APP项目&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 国内源 ...&#xA;maven { url &#39;https://maven.aliyun.com/repository/google&#39; }&#xA;maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }&#xA;maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 环境 ...&#xA;Android Studio 3.6.1&#xA;SDK Platforms &amp;gt; Android 10.0 (Q) API Level 29 Revision 4&#xA;SDK Tools &amp;gt;&#xA;    Android SDK Build-Tools 30-rc1&#xA;    NDK (Side by side)&#xA;    CMake&#xA;    Android Emulator&#xA;    Android SDK Platform-Tools&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 准备工作：Android之NDK编译FFmpeg教程 &#xA;// 编译生成以下文件 ...&#xA;ffmpeg-4.2.2/android/armv7-a&#xA;ffmpeg-4.2.2/android/armv8-a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 新建一个Android Native C++工程 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;2. 拷贝库文件到项目 ...&#xA;2-1. 拷贝 armv7-a/lib 内 .so 文件到 MyApplication\app\src\main\cpp\libs\armeabi-v7a&#xA;2-2. 拷贝 armv8-a/lib 内 .so 文件到 MyApplication\app\src\main\cpp\libs\arm64-v8a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;3. 新建 MyApplication/appsrc/main/cpp 目录&#xA;3-1. 拷贝 armv7-a/include 文件夹到 MyApplication/appsrc/main/cpp &#xA;3-2. 在 MyApplication\app\src\main\cpp 中新建 native-lib.cpp 内容如下 ...&#xA;&#xA;    #include &amp;lt;jni.h&amp;gt;&#xA;    #include &amp;lt;string&amp;gt;&#xA;    extern &amp;quot;C&amp;quot; {&#xA;    #include &amp;lt;libavcodec/avcodec.h&amp;gt; //引入ffmpeg的包&#xA;    }&#xA;    extern &amp;quot;C&amp;quot; JNIEXPORT jstring JNICALL&#xA;    Java_com_goodboy_myplay_MainActivity_stringFromJNI(&#xA;        JNIEnv *env,&#xA;        jobject /* this */) {&#xA;        std::string hello = &amp;quot;Hello from C++&amp;quot;;&#xA;        return env-&amp;gt;NewStringUTF(av_version_info());//返回ffmpeg的版本&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;4. 在 MyApplication\app 目录中新建 CMakeLists.txt 内容如下 ...&#xA;&#xA;    cmake_minimum_required(VERSION 3.4.1)&#xA;&#xA;    add_library( # Sets the name of the library.&#xA;        native-lib&#xA;        SHARED&#xA;        src/main/cpp/native-lib.cpp)&#xA;    include_directories(src/main/cpp/include)&#xA;    set(CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/src/main/cpp/libs/${ANDROID_ABI}&amp;quot;)&#xA;&#xA;    find_library( # Sets the name of the path variable.&#xA;        log-lib&#xA;        log)&#xA;&#xA;&#xA;    target_link_libraries( # Specifies the target library.&#xA;        native-lib&#xA;        avcodec avfilter avformat avutil swresample swscale&#xA;        ${log-lib})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;5. 修改 MyApplication\app\build.gradle 文件部分内容 ...&#xA;&#xA;&#xA;    apply plugin: &#39;com.android.application&#39;&#xA;&#xA;    android {&#xA;        compileSdkVersion 29&#xA;        buildToolsVersion &amp;quot;29.0.3&amp;quot;&#xA;&#xA;        defaultConfig {&#xA;        applicationId &amp;quot;com.danoo.xplay&amp;quot;&#xA;        minSdkVersion 21 &#xA;        targetSdkVersion 29&#xA;        versionCode 1&#xA;        versionName &amp;quot;1.0&amp;quot;&#xA;&#xA;        testInstrumentationRunner &amp;quot;androidx.test.runner.AndroidJUnitRunner&amp;quot;&#xA;&#xA;        externalNativeBuild {&#xA;            cmake {&#xA;            cppFlags &amp;quot;&amp;quot;&#xA;            abiFilters &amp;quot;armeabi-v7a&amp;quot;, &amp;quot;arm64-v8a&amp;quot;&#xA;            }&#xA;        }&#xA;        }&#xA;&#xA;        sourceSets {&#xA;        main {&#xA;            jniLibs.srcDirs = [&#39;src/main/cpp/libs/&#39;]&#xA;        }&#xA;        }&#xA;&#xA;        buildTypes {&#xA;        release {&#xA;            minifyEnabled false&#xA;            proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;&#xA;        }&#xA;        }&#xA;&#xA;        externalNativeBuild {&#xA;        cmake {&#xA;            path &amp;quot;CMakeLists.txt&amp;quot;&#xA;            version &amp;quot;3.10.2&amp;quot;&#xA;        }&#xA;        }&#xA;        ndkVersion = &#39;20.0.5594570&#39;&#xA;&#xA;    }&#xA;&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;6. 修改 MainActivity 文件 ...&#xA;&#xA;    public class MainActivity extends AppCompatActivity {&#xA;&#xA;        static {&#xA;        System.loadLibrary(&amp;quot;native-lib&amp;quot;);&#xA;        }&#xA;&#xA;        @Override&#xA;        protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        Toolbar toolbar = findViewById(R.id.toolbar);&#xA;        setSupportActionBar(toolbar);&#xA;&#xA;        FloatingActionButton fab = findViewById(R.id.fab);&#xA;        fab.setOnClickListener(new View.OnClickListener() {&#xA;            @Override&#xA;            public void onClick(View view) {&#xA;            Snackbar.make(view, &amp;quot;Replace with your own action&amp;quot;, Snackbar.LENGTH_LONG)&#xA;                .setAction(&amp;quot;Action&amp;quot;, null).show();&#xA;            Log.d(&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;quot;, stringFromJNI());&#xA;            }&#xA;        });&#xA;        }&#xA;&#xA;        public native String stringFromJNI();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之NDK编译FFmpeg教程</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BNDK%E7%BC%96%E8%AF%91FFmpeg%E6%95%99%E7%A8%8B/</link>
      <pubDate>2020-03-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之NDK编译FFmpeg教程&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// CLANG&#xA;&#xA;// Android NDK 下载&#xA;// 本科教程使用 android-ndk-r20b-linux-x86_64.zip &#xA;// 在 ubuntu 18.04 x64 下进行 ...&#xA;https://developer.android.google.cn/ndk/downloads/&#xA;&#xA;// FFmpeg 下载&#xA;// 本教程使用 FFmpeg 4.2.2 &amp;quot;Ada&amp;quot; 下进行 ...&#xA;http://ffmpeg.org/download.html#releases&#xA;&#xA;// 注意: FFmpeg h264_mediacodec 最高版本 3.4.7&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 环境准备 ...&#xA;apt-get install yasm&#xA;apt-get install pkg-config&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 FFmpeg configure&#xA;SLIBNAME_WITH_MAJOR=&#39;$(SLIBNAME).$(LIBMAJOR)&#39;&#xA;LIB_INSTALL_EXTRA_CMD=&#39;$$(RANLIB)&amp;quot;$(LIBDIR)/$(LIBNAME)&amp;quot;&#39;&#xA;SLIB_INSTALL_NAME=&#39;$(SLIBNAME_WITH_VERSION)&#39;&#xA;SLIB_INSTALL_LINKS=&#39;$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)&#39;&#xA;// 将其修改为&#xA;SLIBNAME_WITH_MAJOR=&#39;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&#39;&#xA;LIB_INSTALL_EXTRA_CMD=&#39;$$(RANLIB)&amp;quot;$(LIBDIR)/$(LIBNAME)&amp;quot;&#39;&#xA;SLIB_INSTALL_NAME=&#39;$(SLIBNAME_WITH_MAJOR)&#39;&#xA;SLIB_INSTALL_LINKS=&#39;$(SLIBNAME)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;--disable-asm // 如出现 asm 异常则增加 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// FFmpeg Build 脚本&#xA;&#xA;#!/bin/bash&#xA;make clean&#xA;&#xA;export NDK=/home/kres/android-ndk-r20b&#xA;TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64/&#xA;API=21&#xA;&#xA;function build_android&#xA;{&#xA;    echo &amp;quot;Compiling FFmpeg for $CPU&amp;quot;&#xA;    ./configure \&#xA;    --prefix=$PREFIX \&#xA;    --enable-neon \&#xA;    --enable-hwaccels \&#xA;    --enable-gpl \&#xA;    --enable-shared \&#xA;    --enable-jni \&#xA;    --enable-mediacodec \&#xA;    --disable-decoders \&#xA;        --enable-decoder=h264_mediacodec \&#xA;        --enable-decoder=vp9 \&#xA;        --enable-decoder=h264 \&#xA;        --enable-decoder=mpeg4 \&#xA;        --enable-decoder=aac \&#xA;        --enable-decoder=aac_latm \&#xA;        --enable-decoder=mjpeg \&#xA;        --enable-decoder=png \&#xA;        --enable-decoder=mpeg4_mediacodec \&#xA;    --disable-encoders \  // 按需开启&#xA;        --enable-encoder=vp9_vaapi --enable-encoder=h264_nvenc --enable-encoder=h264_v4l2m2m --enable-encoder=hevc_nvenc \&#xA;    --disable-demuxers \ // 按需开启&#xA;        --enable-demuxer=rtsp --enable-demuxer=rtp --enable-demuxer=flv --enable-demuxer=h264 \&#xA;    --disable-muxers \ // 按需开启&#xA;        --enable-muxer=rtsp --enable-muxer=rtp --enable-muxer=flv --enable-muxer=h264 \&#xA;    --disable-parsers \ // 按需开启&#xA;        --enable-parser=mpeg4video --enable-parser=aac --enable-parser=h264 --enable-parser=vp9 \&#xA;    --disable-protocols \ // 按需开启&#xA;        --enable-protocol=rtmp --enable-protocol=rtp --enable-protocol=tcp --enable-protocol=udp \&#xA;    --disable-bsfs \&#xA;    --disable-indevs --enable-indev=v4l2 \&#xA;    --disable-outdevs \&#xA;    --disable-filters \&#xA;    --disable-postproc \&#xA;    --disable-static \&#xA;    --disable-doc \&#xA;    --disable-ffmpeg \&#xA;    --disable-ffplay \&#xA;    --disable-ffprobe \&#xA;    --enable-avdevice \&#xA;    --disable-doc \&#xA;    --disable-symver \&#xA;    --cross-prefix=$CROSS_PREFIX \&#xA;    --target-os=android \&#xA;    --arch=$ARCH \&#xA;    --cpu=$CPU \&#xA;    --cc=$CC \&#xA;    --cxx=$CXX \&#xA;    --enable-cross-compile \&#xA;    --sysroot=$SYSROOT \&#xA;    --extra-cflags=&amp;quot;-Os -fpic $OPTIMIZE_CFLAGS&amp;quot; \&#xA;    --extra-ldflags=&amp;quot;$ADDI_LDFLAGS&amp;quot; \&#xA;    $ADDITIONAL_CONFIGURE_FLAG&#xA;&#xA;    make clean&#xA;    make -j6&#xA;    make install&#xA;    echo &amp;quot;The Compilation of FFmpeg for $CPU is completed&amp;quot;&#xA;&#xA;}&#xA;&#xA;#armv8-a&#xA;ARCH=arm64&#xA;CPU=armv8-a&#xA;CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clang&#xA;CXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++&#xA;SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot&#xA;CROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-&#xA;PREFIX=$(pwd)/android/$CPU&#xA;OPTIMIZE_CFLAGS=&amp;quot;-march=$CPU&amp;quot;&#xA;build_android&#xA;&#xA;#armv7-a&#xA;ARCH=arm&#xA;CPU=armv7-a&#xA;CC=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang&#xA;CXX=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang++&#xA;SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot&#xA;CROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-&#xA;PREFIX=$(pwd)/android/$CPU&#xA;OPTIMIZE_CFLAGS=&amp;quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU &amp;quot;&#xA;build_android&#xA;&#xA;#x86&#xA;ARCH=x86&#xA;CPU=x86&#xA;CC=$TOOLCHAIN/bin/i686-linux-android$API-clang&#xA;CXX=$TOOLCHAIN/bin/i686-linux-android$API-clang++&#xA;SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot&#xA;CROSS_PREFIX=$TOOLCHAIN/bin/i686-linux-android-&#xA;PREFIX=$(pwd)/android/$CPU&#xA;OPTIMIZE_CFLAGS=&amp;quot;-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32&amp;quot;&#xA;build_android&#xA;&#xA;#x86_64&#xA;ARCH=x86_64&#xA;CPU=x86-64&#xA;CC=$TOOLCHAIN/bin/x86_64-linux-android$API-clang&#xA;CXX=$TOOLCHAIN/bin/x86_64-linux-android$API-clang++&#xA;SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot&#xA;CROSS_PREFIX=$TOOLCHAIN/bin/x86_64-linux-android-&#xA;PREFIX=$(pwd)/android/$CPU&#xA;OPTIMIZE_CFLAGS=&amp;quot;-march=$CPU -msse4.2 -mpopcnt -m64 -mtune=intel&amp;quot;&#xA;build_android&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在编译脚本中添加了宏：BIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD&#xA;&#xA;CC  libavdevice/v4l2.o&#xA;libavdevice/v4l2.c:135:9: error: assigning to &#39;int (*)(int, unsigned long, ...)&#39; from incompatible type &#39;&amp;lt;overloaded function type&amp;gt;&#39;&#xA;    SET_WRAPPERS();&#xA;    ^~~~~~~~~~~~~~&#xA;libavdevice/v4l2.c:121:17: note: expanded from macro &#39;SET_WRAPPERS&#39;&#xA;    s-&amp;gt;ioctl_f  = prefix ## ioctl;      \&#xA;        ^           ~~~~~&#xA;/home/cc/android-ndk-r19c/toolchains/llvm/prebuilt/linux-x86_64/bin/../sysroot/usr/include/bits/ioctl.h:56:5: note: candidate function has type mismatch at 2nd parameter&#xA;      (expected &#39;unsigned long&#39; but has &#39;unsigned int&#39;)&#xA;int ioctl(int __fd, unsigned __request, ...) __overloadable __enable_if(1, &amp;quot;&amp;quot;) __RENAME(ioctl);&#xA;    ^&#xA;/home/cc/android-ndk-r19c/toolchains/llvm/prebuilt/linux-x86_64/bin/../sysroot/usr/include/bits/ioctl.h:36:5: note: candidate function has type mismatch at 2nd parameter&#xA;      (expected &#39;unsigned long&#39; but has &#39;int&#39;)&#xA;int ioctl(int __fd, int __request, ...);&#xA;    ^&#xA;1 error generated.&#xA;make: *** [ffbuild/common.mak:60: libavdevice/v4l2.o] Error 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;export NDK=/root/android-ndk-r20b&#xA;TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64/&#xA;API=21&#xA;&#xA;#armv7-a&#xA;ARCH=arm&#xA;CPU=armv7-a&#xA;CC=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang&#xA;CXX=$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang++&#xA;SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot&#xA;CROSS_PREFIX=$TOOLCHAIN/bin/arm-linux-androideabi-&#xA;PREFIX=$(pwd)/android/$CPU&#xA;OPTIMIZE_CFLAGS=&amp;quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU -DBIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD&amp;quot;&#xA;&#xA;    echo &amp;quot;Compiling FFmpeg for $CPU&amp;quot;&#xA;    ./configure \&#xA;    --prefix=$PREFIX \&#xA;    --disable-asm \&#xA;    --enable-neon \&#xA;    --enable-hwaccels \&#xA;    --enable-shared \&#xA;    --enable-jni \&#xA;    --enable-mediacodec \&#xA;    --enable-decoders \&#xA;    --disable-encoders \&#xA;    --enable-demuxers \&#xA;    --enable-muxers \&#xA;    --enable-parsers \&#xA;    --enable-protocols \&#xA;    --disable-bsfs \&#xA;    --disable-indevs \&#xA;    --disable-outdevs \&#xA;    --disable-filters \&#xA;    --disable-postproc \&#xA;    --disable-static \&#xA;    --disable-doc \&#xA;    --disable-ffmpeg \&#xA;    --disable-ffplay \&#xA;    --disable-ffprobe \&#xA;    --enable-avdevice \&#xA;    --disable-doc \&#xA;    --disable-symver \&#xA;    --cross-prefix=$CROSS_PREFIX \&#xA;    --target-os=android \&#xA;    --arch=$ARCH \&#xA;    --cpu=$CPU \&#xA;    --cc=$CC \&#xA;    --cxx=$CXX \&#xA;    --enable-cross-compile \&#xA;    --sysroot=$SYSROOT \&#xA;    --extra-cflags=&amp;quot;-Os -fpic $OPTIMIZE_CFLAGS&amp;quot; \&#xA;    --extra-ldflags=&amp;quot;$ADDI_LDFLAGS&amp;quot; \&#xA;    $ADDITIONAL_CONFIGURE_FLAG&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>微信小程序之监听局域网广播</title>
      <link>http://www.nljb.net/default/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%9B%91%E5%90%AC%E5%B1%80%E5%9F%9F%E7%BD%91%E5%B9%BF%E6%92%AD/</link>
      <pubDate>2020-03-09 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;微信小程序之监听局域网广播&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 微信小程序客户端&#xA;initUdpSocket() {&#xA;  this.setData({&#xA;    udpSocket: wx.createUDPSocket()&#xA;  })&#xA;  if (this.data.udpSocket === null) {&#xA;    console.log(&#39;暂不支持&#39;)&#xA;    return;&#xA;  }&#xA;  const locationPort = udpSocket.bind(8888)&#xA;  this.setData({&#xA;    &#39;locationUrl.port&#39;: locationPort&#xA;  })&#xA;  udpSocket.onListening(function(res) {&#xA;    console.log(&#39;监听中...&#39;)&#xA;    console.log(res)&#xA;  })&#xA;  udpSocket.onMessage(function(res) {&#xA;    console.log(res)&#xA;    let unit8Arr = new Uint8Array(res.message.data);&#xA;    let encodedString = String.fromCharCode.apply(null, unit8Arr),&#xA;    decodedString = decodeURIComponent(escape((encodedString)));&#xA;    console.log(decodedString)&#xA;  })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 服务端广播程序&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;&#xA;    socket &amp;quot;github.com/nulijiabei/socketgo&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    // 开始&#xA;    for {&#xA;        // 建立UDP广播&#xA;        conn := socket.NewUDP(&amp;quot;255.255.255.255&amp;quot;, &amp;quot;8888&amp;quot;, 3)&#xA;        // 读写&#xA;        err := conn.ReadWrite(func(conn *net.UDPConn) error {&#xA;            // 循环广播发送&#xA;            for {&#xA;                // 发送本机MAC&#xA;                _, err := conn.Write([]byte(&amp;quot;www.nljb.net&amp;quot;))&#xA;                if err != nil {&#xA;                    return err&#xA;                }&#xA;                // 定时发送&#xA;                time.Sleep(time.Second * time.Duration(5))&#xA;            }&#xA;        })&#xA;        log.Println(err.Error())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>定制化树莓派镜像</title>
      <link>http://www.nljb.net/default/%E5%AE%9A%E5%88%B6%E5%8C%96%E6%A0%91%E8%8E%93%E6%B4%BE%E9%95%9C%E5%83%8F/</link>
      <pubDate>2020-03-07 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;定制化树莓派镜像&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 树莓派官方镜像下载地址&#xA;https://www.raspberrypi.org/downloads/&#xA;&#xA;// 本次定制使用官方镜像 &#xA;2020-02-13-raspbian-buster-lite.img&#xA;&#xA;// 可以通过两种方法来定制化镜像&#xA;// 方案一：直接修改源镜像内容 ...&#xA;// 方案二：安装包放入镜像内且在第一次启动时定制 &#xA;&#xA;// 方案一就不说了，直接改就可以了 ...&#xA;// 方案二就是在rc.local中加入install安装脚本在第一次启动时执行&#xA;// 别忘记在rc.local中移除install安装脚本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 挂载官方镜像&#xA;&#xA;fdisk --bytes -lo Id,Start,Size 2020-02-13-raspbian-buster-lite.img&#xA;Disk 2020-02-13-raspbian-buster-lite.img: 1.7 GiB, 1803550720 bytes, 3522560 sectors&#xA;Units: sectors of 1 * 512 = 512 bytes&#xA;Sector size (logical/physical): 512 bytes / 512 bytes&#xA;I/O size (minimum/optimal): 512 bytes / 512 bytes&#xA;Disklabel type: dos&#xA;Disk identifier: 0xc1dc39e5&#xA;&#xA;Id Start       Size&#xA; c  8192   44979712&#xA;83 98304 1753219072&#xA;&#xA;mount -o loop,offset=$((98304*512)),sizelimit=1753219072 2020-02-13-raspbian-buster-lite.img /mnt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果镜像剩余可用空间不足以放置安装包怎么办 ...&#xA;// 网上摘录，有修改，未做验证 ...&#xA;&#xA;// 创建一个10M大小的文件&#xA;dd if=/dev/zero of=/root/src.img bs=1M count=10&#xA;&#xA;// 把这个文件关联成一个块设备&#xA;losetup /dev/loop0 /root/src.img&#xA;&#xA;// 查看关联是否成功&#xA;losetup -a&#xA;/dev/loop0: [fd00]:176964 (/root/src.img)&#xA;&#xA;// 把它格式化成ext4文件系统&#xA;mkfs.ext4 /dev/loop0&#xA;&#xA;// 卸载关联关系，再查看&#xA;losetup -d /dev/loop0&#xA;losetup -a&#xA;&#xA;// 向目标镜像增加空间&#xA;cat /root/src.img &amp;gt;&amp;gt; /root/dst.img&#xA;&#xA;// 扫描检查&#xA;e2fsck -f /root/dst.img&#xA;&#xA;// 重新设置大小&#xA;resize2fs /root/dst.img&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>使用树莓派制作自己的多媒体播放机</title>
      <link>http://www.nljb.net/default/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%92%AD%E6%94%BE%E6%9C%BA/</link>
      <pubDate>2019-10-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;使用树莓派制作自己的多媒体播放机&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;准备工作&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;* 树莓派(Raspberry Pi Zero)一台&#xA;* SD卡一张&#xA;* 相关配件(电源、显示器、HDMI线、等 ...)&#xA;* 如果非HW的树莓派建议联网(USB-WIFI、USB-Ethernet Adapter、SPI-enc28j60)&#xA;* 当然也可以使用(3A+、3B+、4B)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;系统安装&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;* 下载镜像 https://www.raspberrypi.org/downloads/raspbian/&#xA;* 使用 rufus 或 Win32DiskImager 向 SD卡 写入镜像&#xA;* 配置网络、管理员密码、SSH、等 ...&#xA;* 以下操作均需要使用 root 下操作 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;系统设置&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;分辨率设置&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# /boot/config.txt&#xA;hdmi_group=2&#xA;hdmi_mode=85&#xA;# Raspberry Pi Zero 建议 720p 分辨率&#xA;# Raspberry Pi 3A+、3B+、4B 建议 1080p 分辨率&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;显存设置(重启生效)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# /boot/config.txt&#xA;gpu_mem=192&#xA;# 显存内存分配不能少于192M&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;多媒体播放程序安装&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载安装&#xA;git clone https://github.com/nulijiabei/xplay.git&#xA;cd xplay/&#xA;cd buster/ # Raspbian Buster with desktop&#xA;sh -x install&#xA;&#xA;// 运行测试(安装成功则出现欢迎使用画面)&#xA;// RPI Zero 建议分辨率 720p&#xA;root@raspberrypi:~#/usr/bin/xplay -R 0,0,1280,720&#xA;// RPI 3A+、3B+、4B 建议分辨率 1080p&#xA;root@raspberrypi:~#/usr/bin/xplay &#xA;root@raspberrypi:~#/usr/bin/xplay -R 0,0,1920,1080 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;自定义播放控制&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/python&#xA;# -*- coding: UTF-8 -*-&#xA;&#xA;import socket&#xA;import json&#xA;import time&#xA;import os&#xA;&#xA;def connect():&#xA;    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#xA;    client.connect((&#39;127.0.0.1&#39;, 8700))&#xA;    return client&#xA;&#xA;def stop(client):&#xA;    data = {}&#xA;    params = {}&#xA;    params[&#39;all&#39;] = True&#xA;    data[&#39;type&#39;] = &amp;quot;stop&amp;quot;&#xA;    data[&#39;params&#39;] = params&#xA;    js = json.dumps(data)&#xA;    client.send((js + &#39;\n#End\n&#39;).encode(&#39;utf-8&#39;))&#xA;&#xA;def play(client, libName, zIndex, path, top, left, width, height, screenMode, screenRotate):&#xA;    data = {}&#xA;    params = {}&#xA;    params[&#39;zIndex&#39;] = zIndex&#xA;    params[&#39;path&#39;] = path&#xA;    params[&#39;top&#39;] = top&#xA;    params[&#39;left&#39;] = left&#xA;    params[&#39;width&#39;] = width&#xA;    params[&#39;height&#39;] = height&#xA;    params[&#39;screen_mode&#39;] = screenMode&#xA;    params[&#39;screen_rotate&#39;] = screenRotate&#xA;    data[&#39;id&#39;] = (&amp;quot;PLAY_VIDEO_%d&amp;quot;) % (int(round(time.time() * 1000)))&#xA;    data[&#39;type&#39;] = &amp;quot;play&amp;quot;&#xA;    data[&#39;libName&#39;] = libName&#xA;    data[&#39;params&#39;] = params&#xA;    js = json.dumps(data)&#xA;    client.send((js + &#39;\n#End\n&#39;).encode(&#39;utf-8&#39;))&#xA;&#xA;def getFiles(str):&#xA;    fs = []&#xA;    for root,dirs,files in os.walk(str):&#xA;    for file in files:&#xA;        fs.append(str + &#39;/&#39; + file)&#xA;    return fs&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;&#xA;    # 建立连接&#xA;    client = connect()&#xA;&#xA;    # 停止全部&#xA;    stop(client)&#xA;&#xA;    # 循环播放&#xA;    while True:&#xA;&#xA;    # 获取目录素材文件&#xA;    fs = getFiles(r&#39;E:\test&#39;)&#xA;    if len(fs) == 0 :&#xA;        time.sleep(5)&#xA;        continue&#xA;&#xA;    # 遍历素材&#xA;    for f in fs:&#xA;        # 是否为视频&#xA;        if f.endswith(&amp;quot;.mp4&amp;quot;) :&#xA;        # 播放视频&#xA;        play(client, &amp;quot;video&amp;quot;, 10, f, 0, 0, 1920, 1080, &amp;quot;landscape&amp;quot;, 0)&#xA;        # 是否为图片&#xA;        if f.endswith(&amp;quot;.jpg&amp;quot;) or f.endswith(&amp;quot;.png&amp;quot;) :&#xA;        # 播放图片&#xA;        play(client, &amp;quot;pic&amp;quot;, 10, f, 0, 0, 1920, 1080, &amp;quot;landscape&amp;quot;, 0)&#xA;        # 间隔5s切换&#xA;        time.sleep(5)&#xA;&#xA;    # 断开连接&#xA;    client.close()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;更多&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nulijiabei/xplay&#34;&gt;https://github.com/nulijiabei/xplay&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>NVIDIA Jetson Nano 编译安装 OpenCV4</title>
      <link>http://www.nljb.net/default/NVIDIA-Jetson-Nano-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-OpenCV4/</link>
      <pubDate>2019-08-09 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;NVIDIA Jetson Nano 编译安装 OpenCV4&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;#&#xA;# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.&#xA;#&#xA;# NVIDIA Corporation and its licensors retain all intellectual property&#xA;# and proprietary rights in and to this software, related documentation&#xA;# and any modifications thereto.  Any use, reproduction, disclosure or&#xA;# distribution of this software and related documentation without an express&#xA;# license agreement from NVIDIA Corporation is strictly prohibited.&#xA;#&#xA;&#xA;if [ &amp;quot;$#&amp;quot; -ne 1 ]; then&#xA;    echo &amp;quot;Usage: $0 &amp;lt;Install Folder&amp;gt;&amp;quot;&#xA;    exit&#xA;fi&#xA;folder=&amp;quot;$1&amp;quot;&#xA;user=&amp;quot;nvidia&amp;quot;&#xA;passwd=&amp;quot;nvidia&amp;quot;&#xA;&#xA;echo &amp;quot;** Remove OpenCV3.3 first&amp;quot;&#xA;sudo sudo apt-get purge *libopencv*&#xA;&#xA;echo &amp;quot;** Install requirement&amp;quot;&#xA;sudo apt-get update&#xA;sudo apt-get install -y build-essential cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev&#xA;sudo apt-get install -y libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev&#xA;sudo apt-get install -y python2.7-dev python3.6-dev python-dev python-numpy python3-numpy&#xA;sudo apt-get install -y libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev&#xA;sudo apt-get install -y libv4l-dev v4l-utils qv4l2 v4l2ucp&#xA;sudo apt-get install -y curl&#xA;sudo apt-get update&#xA;&#xA;echo &amp;quot;** Download opencv-4.1.1&amp;quot;&#xA;cd $folder&#xA;curl -L https://github.com/opencv/opencv/archive/4.1.1.zip -o opencv-4.1.1.zip&#xA;curl -L https://github.com/opencv/opencv_contrib/archive/4.1.1.zip -o opencv_contrib-4.1.1.zip&#xA;unzip opencv-4.1.1.zip &#xA;unzip opencv_contrib-4.1.1.zip &#xA;cd opencv-4.1.1/&#xA;&#xA;echo &amp;quot;** Building...&amp;quot;&#xA;mkdir release&#xA;cd release/&#xA;cmake -D WITH_CUDA=ON -D CUDA_ARCH_BIN=&amp;quot;5.3&amp;quot; -D CUDA_ARCH_PTX=&amp;quot;&amp;quot; -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-4.1.1/modules -D WITH_GSTREAMER=ON -D WITH_LIBV4L=ON -D BUILD_opencv_python2=ON -D BUILD_opencv_python3=ON -D BUILD_TESTS=OFF -D BUILD_PERF_TESTS=OFF -D BUILD_EXAMPLES=OFF -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..&#xA;make -j3&#xA;sudo make install&#xA;&#xA;echo &amp;quot;** Install opencv-4.1.1 successfully&amp;quot;&#xA;echo &amp;quot;** Bye :)&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果出现 Eigen/Core 报错按以下修改 ...&#xA;.../opencv/modules/core/include/opencv2/core/private.hpp&#xA;# include &amp;lt;Eigen/Core&amp;gt;&#xA;改&#xA;# include &amp;lt;eigen3/Eigen/Core&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果 BUILD 时内存不足被 KILL 可以 init 3 释放视窗内存 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果下载 face_landmark_model.dat 出问题可以&#xA;// 手动下载然后保存到 /root/face_landmark_model.dat&#xA;https://raw.githubusercontent.com/opencv/opencv_3rdparty/8afa57abc8229d611c4937165d20e2a2d9fc5a12/face_landmark_model.dat&#xA;// 修改 opencv_contrib-4.1.1/modules/face/CMakeLists.txt 中 &#xA;    &amp;quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/${__commit_hash}/&amp;quot;&#xA;改&#xA;    &amp;quot;file:///root/&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之OpenCV4编译与安装</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8BOpenCV4%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%89%E8%A3%85/</link>
      <pubDate>2019-07-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之OpenCV4编译与安装&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装依赖&#xA;sudo apt-get install build-essential cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev&#xA;sudo apt-get install python-dev python-numpy python3-dev python3-numpy&#xA;sudo apt-get install libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载源码包&#xA;https://opencv.org/releases.html&#xA;&#xA;// 编译&#xA;unzip opencv-4.0.1.zip&#xA;cd opencv-4.0.1&#xA;mkdir release&#xA;cd release&#xA;cmake -DCMAKE_BUILD_TYPE=Release -DOPENCV_GENERATE_PKGCONFIG=ON -DCMAKE_INSTALL_PREFIX=/usr/local ..&#xA;make -j4&#xA;sudo make install&#xA;&#xA;// 测试&#xA;$ python &#xA;&amp;gt;&amp;gt;&amp;gt; import cv2&#xA;&amp;gt;&amp;gt;&amp;gt; cv2.__version__&#xA;&#39;4.0.1&#39;&#xA;&amp;gt;&amp;gt;&amp;gt; &#xA;&#xA;cd /etc/ld.so.conf.d/&#xA;sudo touch opencv4.conf&#xA;sudo sh -c &#39;echo &amp;quot;/usr/local/lib&amp;quot; &amp;gt; opencv4.conf&#39;&#xA;ldconfig&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;INCLUDEPATH += /usr/local/include/opencv4&#xA;LIBS += -L/usr/local/lib \&#xA;-lopencv_calib3d \&#xA;-lopencv_dnn \&#xA;-lopencv_flann \&#xA;-lopencv_highgui \&#xA;-lopencv_imgproc \&#xA;-lopencv_objdetect \&#xA;-lopencv_stitching \&#xA;-lopencv_video \&#xA;-lopencv_core \&#xA;-lopencv_features2d \&#xA;-lopencv_gapi \&#xA;-lopencv_imgcodecs \&#xA;-lopencv_ml \&#xA;-lopencv_photo \&#xA;-lopencv_videoio&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>在Qt上使用SDL2绘制QWidget</title>
      <link>http://www.nljb.net/default/%E5%9C%A8Qt%E4%B8%8A%E4%BD%BF%E7%94%A8SDL2%E7%BB%98%E5%88%B6QWidget/</link>
      <pubDate>2019-07-09 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;在Qt上使用SDL2绘制QWidget&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 方案主要是绘图部分使用 SDL 进行绘制，窗口部分使用 Qt ...&#xA;// 该案例中还有很多需要优化的部分 ... &#xA;// 比如：SDL_CreateRenderer 不需要反复创建 ...&#xA;// 比如：不需要 SDL_CreateTextureFromSurface 反复装转到纹理&#xA;// 比如：不需要反复释放 Renderer 和 Texture ...&#xA;// 但是该 SDL 与 Qt 结合的方案还是有很多可借鉴的地方 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;通过SDL2的SDL_CreateWindowFrom函数将QWidget转换为SDL_Window&#xA;&#xA;    SDL_Window *window = SDL_CreateWindowFrom((void*)this-&amp;gt;winId())&#xA;&#xA;Qt只能在QWidget的paintEvent事件里进行绘图&#xA;&#xA;    virtual void QWidget::paintEvent(QPaintEvent* event);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef SDL2WIDGET_H&#xA;#define SDL2WIDGET_H&#xA;&#xA;#include &amp;lt;SDL2/SDL.h&amp;gt;&#xA;#include &amp;lt;SDL2/SDL_image.h&amp;gt;&#xA;#include &amp;lt;QWidget&amp;gt;&#xA;#include &amp;lt;QPaintEvent&amp;gt;&#xA;&#xA;class SDL2Widget : public QWidget&#xA;{&#xA;    Q_OBJECT&#xA;public:&#xA;    SDL2Widget(QWidget* parent=0);&#xA;    ~SDL2Widget();&#xA;protected:&#xA;    void paintEvent(QPaintEvent* event);&#xA;&#xA;private:   &#xA;    SDL_Window *window;&#xA;    SDL_Renderer *render;&#xA;    SDL_Surface *surface;&#xA;    SDL_Texture *texture;&#xA;};&#xA;&#xA;&#xA;#endif&#xA;&#xA;#include &amp;lt;SDL2Widget.h&amp;gt;&#xA;&#xA;SDL2Widget::SDL2Widget(QWidget* parent):QWidget(parent)&#xA;{&#xA;    /* SDL2初始化 */&#xA;    SDL_Init(SDL_INIT_EVERYTHING);&#xA;    /* 把QWidget转换为SDL_Window */&#xA;    window = SDL_CreateWindowFrom((void*)this-&amp;gt;winId());&#xA;    /* SDL2 Image初始化 */&#xA;    IMG_Init(IMG_INIT_PNG);&#xA;    /* 加载图片，创建surface */&#xA;    surface = IMG_Load(&amp;quot;demo.jpg&amp;quot;);&#xA;}&#xA;&#xA;SDL2Widget::~SDL2Widget()&#xA;{&#xA;&#xA;}&#xA;&#xA;/* 绘图操作必须在paintEvent事件里进行 */&#xA;void SDL2Widget::paintEvent(QPaintEvent* event)&#xA;{&#xA;    /* 在window上创建一个render */&#xA;    render = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED &#xA;            | SDL_RENDERER_PRESENTVSYNC);&#xA;    /* 创建一个texture */&#xA;    texture = SDL_CreateTextureFromSurface(render, surface);&#xA;    /* 清空render的内容 */&#xA;    SDL_RenderClear(render);&#xA;    /* 将texture复制到render上 */&#xA;    SDL_RenderCopy(render, texture, NULL, NULL);&#xA;    /* 将render显示到window上 */&#xA;    SDL_RenderPresent(render);&#xA;    /* 销毁render和texture，释放内存 */&#xA;    SDL_DestroyTexture(texture);&#xA;    SDL_DestroyRenderer(render);&#xA;}&#xA;&#xA;#include &amp;lt;QApplication&amp;gt;&#xA;#include &amp;lt;SDL2Widget.h&amp;gt;&#xA;#include &amp;lt;QLayout&amp;gt;&#xA;#include &amp;lt;QPushButton&amp;gt;&#xA;&#xA;int main(int argc,char* argv[])&#xA;{&#xA;    QApplication app(argc,argv);&#xA;    QVBoxLayout* layout = new QVBoxLayout;&#xA;    SDL2Widget* sdlWidget = new SDL2Widget;&#xA;    QPushButton* button = new QPushButton(&amp;quot;Button&amp;quot;);&#xA;    layout-&amp;gt;addWidget(sdlWidget);&#xA;    layout-&amp;gt;addWidget(button);&#xA;    QWidget w;&#xA;    w.setLayout(layout);&#xA;    w.show();&#xA;    w.resize(640,400);&#xA;    QObject::connect(button,&amp;amp;QPushButton::clicked,&#xA;    sdlWidget,(void(SDL2Widget::*)(void))&amp;amp;SDL2Widget::repaint);&#xA;    return app.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;摘自：www.kurukurumi.com 感谢 !!!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qrencode生成二维码并通过SDL显示</title>
      <link>http://www.nljb.net/default/Qrencode%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E9%80%9A%E8%BF%87SDL%E6%98%BE%E7%A4%BA/</link>
      <pubDate>2019-07-09 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qrencode生成二维码并通过SDL显示&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;主要是在各种PI上面通过SDL显示二维码 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装 &#xA;apt-get install libqrencode-dev // 会自动关联安装 libqrencode&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这些都是摘抄于官方源码包中 ...&#xA;https://github.com/fukuchi/libqrencode&#xA;https://github.com/fukuchi/libqrencode/blob/master/tests/view_qrcode.c&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// L(QR_ECLEVEL_L，7%)，M(QR_ECLEVEL_M，15%)，Q(QR_ECLEVEL_Q，25%)，H(QR_ECLEVEL_H，30%)&#xA;// 这个参数控制二维码容错率，不同的参数表示二维码可被覆盖的区域百分比。&#xA;&#xA;// 实现字符串转二维码 ...&#xA;QRcode *qrcode = QRcode_encodeString(m_data.toStdString().c_str(), 2, QR_ECLEVEL_L, QR_MODE_8, 1);&#xA;&#xA;int margin = 1; // 控制生成二维码的空白区域大小&#xA;int size = 4; // 控制生成图片的大小，默认为 4&#xA;int colorize = 0;&#xA;&#xA;int width = (qrcode-&amp;gt;width + margin * 2) * size;&#xA;SDL_Surface *m_surface = SDL_CreateRGBSurface(0, width, width, 32, 0, 0, 0, 0);&#xA;SDL_FillRect(m_surface, nullptr, SDL_MapRGBA(m_surface-&amp;gt;format, 255, 255, 255, 255));&#xA;&#xA;int x, y;&#xA;unsigned char *p;&#xA;SDL_Rect rect;&#xA;Uint32 color[8];&#xA;int col;&#xA;&#xA;color[0] = SDL_MapRGBA(m_surface-&amp;gt;format, 255, 255, 255, 255);&#xA;color[1] = SDL_MapRGBA(m_surface-&amp;gt;format,   0,   0,   0, 255);&#xA;color[2] = SDL_MapRGBA(m_surface-&amp;gt;format, 192, 192, 255, 255);&#xA;color[3] = SDL_MapRGBA(m_surface-&amp;gt;format,   0,   0,  64, 255);&#xA;color[4] = SDL_MapRGBA(m_surface-&amp;gt;format, 255, 255, 192, 255);&#xA;color[5] = SDL_MapRGBA(m_surface-&amp;gt;format,  64,  64,   0, 255);&#xA;color[6] = SDL_MapRGBA(m_surface-&amp;gt;format, 255, 192, 192, 255);&#xA;color[7] = SDL_MapRGBA(m_surface-&amp;gt;format,  64,   0,   0, 255);&#xA;&#xA;int ox = 0;&#xA;int oy = 0;&#xA;ox += margin * size;&#xA;oy += margin * size;&#xA;width = qrcode-&amp;gt;width;&#xA;p = qrcode-&amp;gt;data;&#xA;for(y = 0; y &amp;lt; width; y++) {&#xA;    for(x = 0; x &amp;lt; width; x++) {&#xA;    rect.x = ox + x * size;&#xA;    rect.y = oy + y * size;&#xA;    rect.w = size;&#xA;    rect.h = size;&#xA;    if(!colorize) {&#xA;        col = 0;&#xA;    } else {&#xA;        if(*p &amp;amp; 0x80) {&#xA;        col = 6;&#xA;        } else if(*p &amp;amp; 0x02) {&#xA;        col = 4;&#xA;        } else {&#xA;        col = 2;&#xA;        }&#xA;    }&#xA;    col += (*p &amp;amp; 1);&#xA;    SDL_FillRect(m_surface, &amp;amp;rect, color[col]);&#xA;    p++;&#xA;    }&#xA;}&#xA;&#xA;// Surface to Texture ...&#xA;SDL_Texture *m_texture = SDL_CreateTextureFromSurface(_r, m_surface);&#xA;&#xA;// 释放 ...&#xA;SDL_DestroyTexture(m_texture);&#xA;SDL_FreeSurface(m_surface);&#xA;QRcode_free(qrcode);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之在VC4的KMS上使用Wayland方案</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E5%9C%A8VC4%E7%9A%84KMS%E4%B8%8A%E4%BD%BF%E7%94%A8Wayland%E6%96%B9%E6%A1%88/</link>
      <pubDate>2019-06-08 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之在VC4的KMS上使用Wayland方案&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;说明：经过测试可以的只有 Raspberry 3B+，Raspberry Zero / 3A+ 经过测试都不行 ...&#xA;说明：本文内容摘自网上，有修改，在我的环境中经过测试，有效 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;测试环境：&#xA;    Raspberry 3B+&#xA;2019-04-08-raspbian-stretch-lite.img&#xA;&#xA;准备工作：&#xA;# enable Broadcom VC4 driver &#xA;$ sudo raspi-config&#xA;Advanced Options -&amp;gt; GL Driver -&amp;gt; GL (Full KMS)  &#xA;&#xA;运行：&#xA;$ ./RPi3_build_weston.sh all&#xA;&#xA;$ export XDG_RUNTIME_DIR=/tmp/weston_runtime&#xA;$ mkdir $XDG_RUNTIME_DIR &amp;amp;&amp;amp; chmod 0700 $XDG_RUNTIME_DIR&#xA;$ export LD_LIBRARY_PATH=/usr/local/lib/&#xA;$ weston --tty=2 --idle-time=0 -B drm-backend.so &amp;amp;&#xA;// 必须插有鼠标否则会提示找不到输入设备而报错 ...&#xA;&#xA;Date: 2017-06-02 CST&#xA;[09:52:59.501] weston 2.0.0&#xA;           http://wayland.freedesktop.org&#xA;           Bug reports to: https://bugs.freedesktop.org/enter_bug.cgi?product=Wayland&amp;amp;component=weston&amp;amp;version=2.0.0&#xA;           Build: 2.0.0 configure.ac: bump to version 2.0.0 for the official release (2017-02-24 16:19:03 -0800)&#xA;[09:52:59.506] Command line: weston --tty=2 --idle-time=0 -B drm-backend.so&#xA;[09:52:59.507] OS: Linux, 4.9.24-v7+, #993 SMP Wed Apr 26 18:01:23 BST 2017, armv7l&#xA;[09:52:59.509] warning: XDG_RUNTIME_DIR &amp;quot;/tmp/weston_runtime&amp;quot; is not configured&#xA;correctly.  Unix access mode must be 0700 (current mode is 700),&#xA;and must be owned by the user (current owner is UID 1001).&#xA;Refer to your distribution on how to get it, or&#xA;http://www.freedesktop.org/wiki/Specifications/basedir-spec&#xA;on how to implement it.&#xA;[09:52:59.513] Starting with no config file.&#xA;[09:52:59.515] Output repaint window is 7 ms maximum.&#xA;[09:52:59.516] Loading module &#39;/usr/local/lib/libweston-2/drm-backend.so&#39;&#xA;[09:52:59.520] initializing drm backend&#xA;[09:52:59.526] using /dev/dri/card0&#xA;[09:52:59.528] Loading module &#39;/usr/local/lib/libweston-2/gl-renderer.so&#39;&#xA;[09:52:59.586] EGL client extensions: EGL_EXT_client_extensions&#xA;           EGL_EXT_platform_base EGL_KHR_client_get_all_proc_addresses&#xA;           EGL_KHR_debug EGL_EXT_platform_wayland EGL_MESA_platform_gbm&#xA;[09:52:59.588] warning: neither EGL_EXT_swap_buffers_with_damage or EGL_KHR_swap_buffers_with_damage is supported. Performance could be affected.&#xA;[09:52:59.588] EGL_KHR_surfaceless_context available&#xA;[09:52:59.596] EGL version: 1.4 (DRI2)&#xA;[09:52:59.596] EGL vendor: Mesa Project&#xA;[09:52:59.596] EGL client APIs: OpenGL OpenGL_ES &#xA;[09:52:59.597] EGL extensions: EGL_EXT_buffer_age EGL_EXT_image_dma_buf_import&#xA;           EGL_KHR_cl_event2 EGL_KHR_config_attribs EGL_KHR_create_context&#xA;           EGL_KHR_fence_sync EGL_KHR_get_all_proc_addresses&#xA;           EGL_KHR_gl_renderbuffer_image EGL_KHR_gl_texture_2D_image&#xA;           EGL_KHR_gl_texture_cubemap_image EGL_KHR_image&#xA;           EGL_KHR_image_base EGL_KHR_image_pixmap&#xA;           EGL_KHR_no_config_context EGL_KHR_reusable_sync&#xA;           EGL_KHR_surfaceless_context EGL_KHR_wait_sync&#xA;           EGL_MESA_configless_context EGL_MESA_drm_image&#xA;           EGL_MESA_image_dma_buf_export EGL_WL_bind_wayland_display&#xA;[09:52:59.597] GL version: OpenGL ES 2.0 Mesa 17.1.1 (git-ca0a148)&#xA;[09:52:59.598] GLSL version: OpenGL ES GLSL ES 1.0.16&#xA;[09:52:59.598] GL vendor: Broadcom&#xA;[09:52:59.598] GL renderer: Gallium 0.4 on VC4 V3D 2.1&#xA;[09:52:59.598] GL extensions: GL_EXT_blend_minmax GL_EXT_multi_draw_arrays&#xA;           GL_EXT_texture_format_BGRA8888&#xA;           GL_OES_compressed_ETC1_RGB8_texture GL_OES_depth24&#xA;           GL_OES_element_index_uint GL_OES_fbo_render_mipmap&#xA;           GL_OES_mapbuffer GL_OES_rgb8_rgba8 GL_OES_stencil8&#xA;           GL_OES_texture_3D GL_OES_texture_npot GL_OES_vertex_half_float&#xA;           GL_OES_EGL_image GL_OES_depth_texture&#xA;           GL_OES_packed_depth_stencil GL_EXT_texture_type_2_10_10_10_REV&#xA;           GL_OES_get_program_binary GL_APPLE_texture_max_level&#xA;           GL_EXT_discard_framebuffer GL_EXT_read_format_bgra&#xA;           GL_EXT_frag_depth GL_NV_fbo_color_attachments&#xA;           GL_OES_EGL_image_external GL_OES_EGL_sync&#xA;           GL_OES_vertex_array_object GL_EXT_unpack_subimage&#xA;           GL_NV_draw_buffers GL_NV_read_buffer GL_NV_read_depth&#xA;           GL_NV_read_depth_stencil GL_NV_read_stencil GL_EXT_draw_buffers&#xA;           GL_EXT_map_buffer_range GL_KHR_debug GL_OES_surfaceless_context&#xA;           GL_EXT_separate_shader_objects&#xA;           GL_EXT_compressed_ETC1_RGB8_sub_texture&#xA;           GL_EXT_draw_elements_base_vertex GL_EXT_texture_border_clamp&#xA;           GL_KHR_context_flush_control GL_OES_draw_elements_base_vertex&#xA;           GL_OES_texture_border_clamp&#xA;[09:52:59.599] GL ES 2 renderer features:&#xA;           read-back format: BGRA&#xA;           wl_shm sub-image to texture: yes&#xA;           EGL Wayland extension: yes&#xA;[09:52:59.601] event0  - [09:52:59.601] USB Keyboard: [09:52:59.601] is tagged by udev as: Keyboard&#xA;[09:52:59.601] event0  - [09:52:59.601] USB Keyboard: [09:52:59.601] device is a keyboard&#xA;[09:52:59.602] event1  - [09:52:59.602] USB Keyboard: [09:52:59.602] is tagged by udev as: Keyboard&#xA;[09:52:59.602] event1  - [09:52:59.602] USB Keyboard: [09:52:59.602] device is a keyboard&#xA;[09:52:59.603] event2  - [09:52:59.603] USB Optical Mouse: [09:52:59.603] is tagged by udev as: Mouse&#xA;[09:52:59.603] event2  - [09:52:59.604] USB Optical Mouse: [09:52:59.604] device is a pointer&#xA;[09:52:59.654] Registered plugin API &#39;weston_drm_output_api_v1&#39; of size 12&#xA;[09:52:59.655] Chosen EGL config details:&#xA;           RGBA bits: 8 8 8 0&#xA;           swap interval range: 0 - 0&#xA;[09:52:59.655] Failed to initialize backlight&#xA;[09:52:59.655] EDID data &#39;BNQ&#39;, &#39;BenQ GW2265&#39;, &#39;87E05314019&#39;&#xA;[09:52:59.656] Output HDMI-A-1, (connector 24, crtc 65)&#xA;           mode 1920x1080@60.0, preferred, current&#xA;           mode 1920x1080@59.9&#xA;           mode 1920x1080@60.0&#xA;           mode 1920x1080@59.9&#xA;           mode 1920x1080@50.0&#xA;           mode 1920x1080@50.0&#xA;           mode 1680x1050@59.9&#xA;           mode 1600x900@60.0&#xA;           mode 1280x1024@60.0&#xA;           mode 1280x800@59.9&#xA;           mode 1280x720@60.0&#xA;           mode 1280x720@59.9&#xA;           mode 1280x720@50.0&#xA;           mode 1024x768@60.0&#xA;           mode 800x600@60.3&#xA;           mode 720x576@50.0&#xA;           mode 720x576@50.0&#xA;           mode 720x480@60.0&#xA;           mode 720x480@59.9&#xA;           mode 720x480@60.0&#xA;           mode 720x480@59.9&#xA;           mode 640x480@60.0&#xA;           mode 640x480@59.9&#xA;[09:52:59.656] Compositor capabilities:&#xA;           arbitrary surface rotation: yes&#xA;           screen capture uses y-flip: yes&#xA;           presentation clock: CLOCK_MONOTONIC, id 1&#xA;           presentation clock resolution: 0.000000001 s&#xA;[09:52:59.657] Loading module &#39;/usr/local/lib/weston/desktop-shell.so&#39;&#xA;[09:52:59.658] launching &#39;/usr/local/libexec/weston-keyboard&#39;&#xA;[09:52:59.660] launching &#39;/usr/local/libexec/weston-desktop-shell&#39;&#xA;could not load cursor &#39;dnd-move&#39;&#xA;could not load cursor &#39;dnd-copy&#39;&#xA;could not load cursor &#39;dnd-none&#39;&#xA;could not load cursor &#39;dnd-move&#39;&#xA;could not load cursor &#39;dnd-copy&#39;&#xA;could not load cursor &#39;dnd-none&#39;&#xA;xkbcommon: ERROR: couldn&#39;t find a Compose file for locale &amp;quot;en_US.UTF-8&amp;quot;&#xA;could not create XKB compose table for locale &#39;en_US.UTF-8&#39;.  Disabiling compose&#xA;xkbcommon: ERROR: couldn&#39;t find a Compose file for locale &amp;quot;en_US.UTF-8&amp;quot;&#xA;could not create XKB compose table for locale &#39;en_US.UTF-8&#39;.  Disabiling compose&#xA;could not load cursor &#39;dnd-move&#39;&#xA;could not load cursor &#39;dnd-copy&#39;&#xA;could not load cursor &#39;dnd-none&#39;&#xA;xkbcommon: ERROR: couldn&#39;t find a Compose file for locale &amp;quot;en_US.UTF-8&amp;quot;&#xA;could not create XKB compose table for locale &#39;en_US.UTF-8&#39;.  Disabiling compose&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@RPi3:/home/oopsmonk# glmark2-es2-wayland &#xA;=======================================================&#xA;    glmark2 2014.03&#xA;=======================================================&#xA;    OpenGL Information&#xA;    GL_VENDOR:     Broadcom&#xA;    GL_RENDERER:   Gallium 0.4 on VC4 V3D 2.1&#xA;    GL_VERSION:    OpenGL ES 2.0 Mesa 17.1.1 (git-ca0a148)&#xA;=======================================================&#xA;[build] use-vbo=false: FPS: 281 FrameTime: 3.559 ms&#xA;[build] use-vbo=true: FPS: 303 FrameTime: 3.300 ms&#xA;[texture] texture-filter=nearest: FPS: 375 FrameTime: 2.667 ms&#xA;[texture] texture-filter=linear: FPS: 345 FrameTime: 2.899 ms&#xA;[texture] texture-filter=mipmap: FPS: 289 FrameTime: 3.460 ms&#xA;[shading] shading=gouraud: FPS: 199 FrameTime: 5.025 ms&#xA;[shading] shading=blinn-phong-inf: FPS: 145 FrameTime: 6.897 ms&#xA;[shading] shading=phong: FPS: 85 FrameTime: 11.765 ms&#xA;[shading] shading=cel: FPS: 84 FrameTime: 11.905 ms&#xA;[bump] bump-render=high-poly: FPS: 80 FrameTime: 12.500 ms&#xA;[bump] bump-render=normals: FPS: 461 FrameTime: 2.169 ms&#xA;[bump] bump-render=height: FPS: 390 FrameTime: 2.564 ms&#xA;[effect2d] kernel=0,1,0;1,-4,1;0,1,0;: FPS: 161 FrameTime: 6.211 ms&#xA;[effect2d] kernel=1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;: FPS: 85 FrameTime: 11.765 ms&#xA;[pulsar] light=false:quads=5:texture=false: FPS: 314 FrameTime: 3.185 ms&#xA;[desktop] blur-radius=5:effect=blur:passes=1:separable=true:windows=4: FPS: 40 FrameTime: 25.000 ms&#xA;[desktop] effect=shadow:windows=4: FPS: 121 FrameTime: 8.264 ms&#xA;[buffer] columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method=map: FPS: 59 FrameTime: 16.949 ms&#xA;[buffer] columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method=subdata: FPS: 59 FrameTime: 16.949 ms&#xA;[buffer] columns=200:interleave=true:update-dispersion=0.9:update-fraction=0.5:update-method=map: FPS: 75 FrameTime: 13.333 ms&#xA;[ideas] speed=duration: FPS: 269 FrameTime: 3.717 ms&#xA;[jellyfish] &amp;lt;default&amp;gt;: FPS: 138 FrameTime: 7.246 ms&#xA;[terrain] &amp;lt;default&amp;gt;: FPS: 5 FrameTime: 200.000 ms&#xA;[shadow] &amp;lt;default&amp;gt;: FPS: 106 FrameTime: 9.434 ms&#xA;[refract] &amp;lt;default&amp;gt;: FPS: 21 FrameTime: 47.619 ms&#xA;[conditionals] fragment-steps=0:vertex-steps=0: FPS: 392 FrameTime: 2.551 ms&#xA;[conditionals] fragment-steps=5:vertex-steps=0: FPS: 259 FrameTime: 3.861 ms&#xA;[conditionals] fragment-steps=0:vertex-steps=5: FPS: 389 FrameTime: 2.571 ms&#xA;[function] fragment-complexity=low:fragment-steps=5: FPS: 357 FrameTime: 2.801 ms&#xA;[function] fragment-complexity=medium:fragment-steps=5: FPS: 48 FrameTime: 20.833 ms&#xA;[loop] fragment-loop=false:fragment-steps=5:vertex-steps=5: FPS: 329 FrameTime: 3.040 ms&#xA;[loop] fragment-steps=5:fragment-uniform=false:vertex-steps=5: FPS: 329 FrameTime: 3.040 ms&#xA;[loop] fragment-steps=5:fragment-uniform=true:vertex-steps=5: FPS: 119 FrameTime: 8.403 ms&#xA;=======================================================&#xA;                  glmark2 Score: 203 &#xA;=======================================================&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@RPi3:/home/oopsmonk# glmark2-es2-wayland --fullscreen&#xA;=======================================================&#xA;glmark2 2014.03&#xA;=======================================================&#xA;OpenGL Information&#xA;GL_VENDOR:     Broadcom&#xA;GL_RENDERER:   Gallium 0.4 on VC4 V3D 2.1&#xA;GL_VERSION:    OpenGL ES 2.0 Mesa 17.1.1 (git-ca0a148)&#xA;=======================================================&#xA;[build] use-vbo=false: FPS: 183 FrameTime: 5.464 ms&#xA;[build] use-vbo=true: FPS: 200 FrameTime: 5.000 ms&#xA;[texture] texture-filter=nearest: FPS: 198 FrameTime: 5.051 ms&#xA;[texture] texture-filter=linear: FPS: 192 FrameTime: 5.208 ms&#xA;[texture] texture-filter=mipmap: FPS: 190 FrameTime: 5.263 ms&#xA;[shading] shading=gouraud: FPS: 166 FrameTime: 6.024 ms&#xA;[shading] shading=blinn-phong-inf: FPS: 162 FrameTime: 6.173 ms&#xA;[shading] shading=phong: FPS: 134 FrameTime: 7.463 ms&#xA;[shading] shading=cel: FPS: 128 FrameTime: 7.812 ms&#xA;[bump] bump-render=high-poly: FPS: 77 FrameTime: 12.987 ms&#xA;[bump] bump-render=normals: FPS: 202 FrameTime: 4.950 ms&#xA;[bump] bump-render=height: FPS: 188 FrameTime: 5.319 ms&#xA;[effect2d] kernel=0,1,0;1,-4,1;0,1,0;: FPS: 65 FrameTime: 15.385 ms&#xA;[effect2d] kernel=1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;: FPS: 33 FrameTime: 30.303 ms&#xA;[pulsar] light=false:quads=5:texture=false: FPS: 173 FrameTime: 5.780 ms&#xA;[desktop] blur-radius=5:effect=blur:passes=1:separable=true:windows=4: FPS: 16 FrameTime: 62.500 ms&#xA;[desktop] effect=shadow:windows=4: FPS: 48 FrameTime: 20.833 ms&#xA;[buffer] columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method=map: FPS: 51 FrameTime: 19.608 ms&#xA;[buffer] columns=200:interleave=false:update-dispersion=0.9:update-fraction=0.5:update-method=subdata: FPS: 51 FrameTime: 19.608 ms&#xA;[buffer] columns=200:interleave=true:update-dispersion=0.9:update-fraction=0.5:update-method=map: FPS: 51 FrameTime: 19.608 ms&#xA;[ideas] speed=duration: FPS: 126 FrameTime: 7.937 ms&#xA;[jellyfish] &amp;lt;default&amp;gt;: FPS: 70 FrameTime: 14.286 ms&#xA;[terrain] &amp;lt;default&amp;gt;: FPS: 2 FrameTime: 500.000 ms&#xA;[shadow] &amp;lt;default&amp;gt;: FPS: 84 FrameTime: 11.905 ms&#xA;[refract] &amp;lt;default&amp;gt;: FPS: 17 FrameTime: 58.824 ms&#xA;[conditionals] fragment-steps=0:vertex-steps=0: FPS: 205 FrameTime: 4.878 ms&#xA;[conditionals] fragment-steps=5:vertex-steps=0: FPS: 122 FrameTime: 8.197 ms&#xA;[conditionals] fragment-steps=0:vertex-steps=5: FPS: 209 FrameTime: 4.785 ms&#xA;[function] fragment-complexity=low:fragment-steps=5: FPS: 176 FrameTime: 5.682 ms&#xA;[function] fragment-complexity=medium:fragment-steps=5: FPS: 79 FrameTime: 12.658 ms&#xA;[loop] fragment-loop=false:fragment-steps=5:vertex-steps=5: FPS: 171 FrameTime: 5.848 ms&#xA;[loop] fragment-steps=5:fragment-uniform=false:vertex-steps=5: FPS: 172 FrameTime: 5.814 ms&#xA;[loop] fragment-steps=5:fragment-uniform=true:vertex-steps=5: FPS: 58 FrameTime: 17.241 ms&#xA;=======================================================&#xA;          glmark2 Score: 121 &#xA;=======================================================&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash &#xA;# &#xA;# Build script for wayland weston with DRM backdend &#xA;# RaspberryPi image: 2017-04-10-raspbian-jessie-lite &#xA;# By oopsmonk@gmail.com&#xA;# &#xA;&#xA;WLROOT=$PWD/weston-build/&#xA;&#xA;clone_or_update() {&#xA;    repo=$1&#xA;    dest=$(basename $repo)&#xA;&#xA;    cd ${WLROOT}&#xA;    if [ $? != 0 ]; then&#xA;    echo &amp;quot;Error: Could not cd to ${WLROOT}.  Does it exist?&amp;quot;&#xA;    exit 1&#xA;    fi&#xA;    echo&#xA;    echo checkout: $dest&#xA;    if [ ! -d ${dest} ]; then&#xA;    git clone ${repo} ${dest}&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Error: Could not clone repository&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    fi&#xA;    cd ${dest}&#xA;    git checkout master&#xA;    if [ $? != 0 ]; then&#xA;    echo &amp;quot;Error: Problem checking out master&amp;quot;&#xA;    exit 1&#xA;    fi&#xA;    git pull&#xA;    if [ $? != 0 ]; then&#xA;    echo &amp;quot;Error: Could not pull from upstream&amp;quot;&#xA;    exit 1&#xA;    fi&#xA;&#xA;    if [[ $2 ]]; then&#xA;    branch=$2&#xA;    git checkout ${branch} -b ${branch}_local&#xA;    if [ $? != 0 ]; then&#xA;        git checkout ${branch}_local&#xA;    fi&#xA;    fi&#xA;    cd ${WLROOT}&#xA;}&#xA;&#xA;do_deps(){&#xA;    sudo apt-get update &#xA;    sudo apt-get install git autoconf libtool build-essential -y&#xA;    # wayland&#xA;    sudo apt-get install libffi-dev libexpat1-dev libxml2-dev -y&#xA;    # libinput&#xA;    sudo apt-get install libmtdev-dev libudev-dev libevdev-dev libwacom-dev -y&#xA;    # drm&#xA;    sudo apt-get install xutils-dev -y&#xA;    # mesa&#xA;    sudo apt-get install bison flex python-mako gettext -y&#xA;    # weston &#xA;    sudo apt-get install libpam0g-dev libjpeg-dev -y&#xA;}&#xA;&#xA;do_checkout(){&#xA;    clone_or_update git://anongit.freedesktop.org/wayland/wayland 1.13.0&#xA;    clone_or_update git://anongit.freedesktop.org/wayland/wayland-protocols 1.7&#xA;    clone_or_update git://anongit.freedesktop.org/wayland/libinput 1.7.2&#xA;    clone_or_update git://anongit.freedesktop.org/git/mesa/drm libdrm-2.4.81&#xA;    clone_or_update git://anongit.freedesktop.org/mesa/mesa mesa-17.1.1&#xA;    clone_or_update git://github.com/xkbcommon/libxkbcommon xkbcommon-0.7.1&#xA;    clone_or_update git://anongit.freedesktop.org/pixman pixman-0.34.0&#xA;    clone_or_update git://anongit.freedesktop.org/cairo 1.15.4&#xA;    clone_or_update git://anongit.freedesktop.org/wayland/weston 2.0.0&#xA;    clone_or_update https://github.com/glmark2/glmark2.git&#xA;}&#xA;&#xA;gen(){                                                                                                                                                                    &#xA;    pkg=$1&#xA;    shift&#xA;    echo&#xA;    echo autogen $pkg&#xA;    cd $WLROOT/$pkg&#xA;    if [ ! -f &amp;quot;.done_gen&amp;quot; ]; then&#xA;    echo &amp;quot;./autogen.sh $*&amp;quot;&#xA;    ./autogen.sh $*&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Configure Error.  Terminating&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    touch .done_gen&#xA;    fi&#xA;}&#xA;&#xA;compile(){                                                                                                                                                                &#xA;    if [ ! -f &amp;quot;.done_make&amp;quot; ]; then&#xA;    make -j4&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Build Error.  Terminating&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    touch .done_make&#xA;    echo build done...&#xA;    fi&#xA;&#xA;    if [ ! -f &amp;quot;.done_install&amp;quot; ]; then&#xA;    sudo make install&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Install Error.  Terminating&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    touch .done_install&#xA;    echo install done... &#xA;    fi&#xA;}&#xA;&#xA;build_glmark2(){&#xA;    cd ${WLROOT}/glmark2.git&#xA;    if [ ! -f &amp;quot;.done_gen&amp;quot; ]; then&#xA;    echo &amp;quot;configure glmark2&amp;quot; &#xA;    ./waf configure --with-flavors=drm-glesv2,wayland-glesv2&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Configure Error.  Terminating&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    touch .done_gen&#xA;    fi&#xA;&#xA;    if [ ! -f &amp;quot;.done_make&amp;quot; ]; then&#xA;    ./waf&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Build Error.  Terminating&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    touch .done_make&#xA;    echo build done...&#xA;    fi&#xA;&#xA;    if [ ! -f &amp;quot;.done_install&amp;quot; ]; then&#xA;    sudo ./waf install&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Install Error.  Terminating&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    touch .done_install&#xA;    echo install done...&#xA;    fi&#xA;}&#xA;&#xA;do_build(){&#xA;    gen wayland --disable-documentation&#xA;    compile&#xA;&#xA;    gen wayland-protocols&#xA;    compile&#xA;&#xA;    gen libinput&#xA;    compile&#xA;&#xA;    gen drm&#xA;    compile&#xA;&#xA;    # VC4_CFLAGS for &#xA;    # Error: selected processor does not support ARM mode `vst1.8 d0,[r5],r3’&#xA;    export VC4_CFLAGS=&amp;quot;-march=armv7-a -mfpu=neon&amp;quot;&#xA;    gen mesa \&#xA;    --enable-gles2 --disable-glx --enable-gbm \&#xA;    --enable-shared-glapi --with-gallium-drivers=vc4 \&#xA;    --with-dri-drivers= --with-egl-platforms=wayland,drm \&#xA;    --disable-dri3 &#xA;    #--disable-dri3 VC4_CFLAGS=&amp;quot;-march=armv7-a -mfpu=neon&amp;quot;\&#39; &#xA;    # mesa hack src/egl/main/egl.pc&#xA;    sed -i &#39;/^Libs:/ s/$/ -ldrm/&#39; src/egl/main/egl.pc&#xA;    unset VC4_CFLAGS&#xA;    compile&#xA;&#xA;    gen libxkbcommon --disable-x11 --disable-docs&#xA;    compile&#xA;&#xA;    # --disable-arm-iwmmxt for compiler error:&#xA;    # internal compiler error: Max. number of generated reload insns per insn is achieved (90)&#xA;    gen pixman --disable-arm-iwmmxt &#xA;    compile&#xA;&#xA;    gen cairo&#xA;    compile&#xA;&#xA;    gen weston \&#xA;    --with-cairo=image \&#xA;    --enable-clients --enable-headless-compositor \&#xA;    --enable-demo-clients-install --enable-drm-compositor \&#xA;    --disable-xwayland --enable-setuid-install=no \&#xA;    --disable-x11-compositor&#xA;    compile&#xA;&#xA;    build_glmark2&#xA;&#xA;}&#xA;&#xA;pkg_uninstl(){&#xA;    pkg=$1&#xA;    shift&#xA;    echo&#xA;    echo uninstall $pkg&#xA;    cd $WLROOT/$pkg&#xA;    sudo make uninstall&#xA;    rm .done_install&#xA;}&#xA;&#xA;do_uninstall(){&#xA;    pkg_uninstl wayland&#xA;    pkg_uninstl wayland-protocols&#xA;    pkg_uninstl libinput&#xA;    pkg_uninstl drm&#xA;    pkg_uninstl mesa&#xA;    pkg_uninstl libxkbcommon&#xA;    pkg_uninstl pixman&#xA;    pkg_uninstl cairo&#xA;    pkg_uninstl weston&#xA;&#xA;    cd $WLROOT/glmark2.git&#xA;    sudo ./waf uninstall&#xA;    rm .done_install&#xA;}&#xA;&#xA;pkg_distc(){&#xA;    pkg=$1&#xA;    shift&#xA;    echo&#xA;    echo clean $pkg&#xA;    cd $WLROOT/$pkg&#xA;    git clean -dxf&#xA;}&#xA;&#xA;do_distclean(){&#xA;    pkg_distc wayland&#xA;    pkg_distc wayland-protocols&#xA;    pkg_distc libinput&#xA;    pkg_distc drm&#xA;    pkg_distc mesa&#xA;    pkg_distc libxkbcommon&#xA;    pkg_distc pixman&#xA;    pkg_distc cairo&#xA;    pkg_distc weston&#xA;    pkg_distc glmark2.git&#xA;}&#xA;&#xA;if [ &amp;quot;$1&amp;quot; = &amp;quot;&amp;quot; ]; then                                                                                                                                                       &#xA;    echo &amp;quot;$0 commands are:  &amp;quot;&#xA;    echo &amp;quot;    all           &amp;quot;&#xA;    echo &amp;quot;    deps          &amp;quot;&#xA;    echo &amp;quot;    checkout      &amp;quot;&#xA;    echo &amp;quot;    build         &amp;quot;&#xA;    echo &amp;quot;    uninstall     &amp;quot;&#xA;    echo &amp;quot;    distclean     &amp;quot;&#xA;else&#xA;    if [ ! -d ${WLROOT} ]; then&#xA;    mkdir -p ${WLROOT}&#xA;    if [ $? != 0 ]; then&#xA;        echo &amp;quot;Error: Could not create dir ${WLROOT}&amp;quot;&#xA;        exit 1&#xA;    fi&#xA;    fi&#xA;&#xA;    while [ &amp;quot;$1&amp;quot; != &amp;quot;&amp;quot; ]&#xA;    do&#xA;    case &amp;quot;$1&amp;quot; in&#xA;        all)&#xA;        do_deps&#xA;        do_checkout&#xA;        do_build&#xA;        ;;&#xA;        deps)&#xA;        do_deps&#xA;        ;;&#xA;        checkout)&#xA;        do_checkout&#xA;        ;;&#xA;        build)&#xA;        do_build&#xA;        ;;&#xA;        uninstall)&#xA;        do_uninstall&#xA;        ;;&#xA;        distclean)&#xA;        do_uninstall&#xA;        do_distclean&#xA;        ;;&#xA;        *)&#xA;        echo -e &amp;quot;$0 \033[47;31mUnknown CMD: $1\033[0m&amp;quot;&#xA;        exit 1&#xA;        ;;&#xA;    esac&#xA;    shift 1&#xA;    done&#xA;    cd $WLROOT&#xA;fi&#xA;&#xA;&#xA;exit 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Rockchip之FFmpeg通过MPP硬解并转储</title>
      <link>http://www.nljb.net/default/Rockchip%E4%B9%8BFFmpeg%E9%80%9A%E8%BF%87MPP%E7%A1%AC%E8%A7%A3%E5%B9%B6%E8%BD%AC%E5%82%A8/</link>
      <pubDate>2019-05-31 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Rockchip之FFmpeg通过MPP硬解并转储&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Rockchip Linux 官方网站 &#xA;https://github.com/rockchip-linux&#xA;&#xA;// Rockchip 支持硬件&#xA;RK29XX/RK30XX/RK31XX&#xA;RK3288/RK3368/RK3399&#xA;RK3228/RK3229/RK3228H/RK3328&#xA;RV1108/RV1107&#xA;&#xA;// Media Process Platform (MPP) module&#xA;https://github.com/rockchip-linux/mpp&#xA;&#xA;// FFmpeg 使用 4.1 版本（此时最新）&#xA;http://ffmpeg.org/&#xA;&#xA;// FFmpeg 编译命令 ...&#xA;./configure --enable-version3 --enable-libdrm --enable-rkmpp --enable-libx264 --enable-nonfree --enable-gpl&#xA;make ; make install&#xA;&#xA;// 编译完成后查看解码器 ...    &#xA;ffmpeg -decoders |grep h264_rkmpp&#xA;V..... h264_rkmpp           h264 (rkmpp) (codec h264)&#xA;&#xA;// 特别注意 &#xA;ffmpeg h264_rkmpp 解码获得的是 AV_PIX_FMT_DRM_PRIME 也就是 DRM 帧数据 ...&#xA;// 如果使用 drm 显示该帧可以直接 zero-copy 绘制帧 ...&#xA;&#xA;// 通过以下操作把 drm 帧拷贝到内存并且转换为NV12 ...&#xA;pFrameOK-&amp;gt;width = pFrame-&amp;gt;width;&#xA;pFrameOK-&amp;gt;height = pFrame-&amp;gt;height;&#xA;pFrameOK-&amp;gt;format = AV_PIX_FMT_NV12;&#xA;// Copy data to or from a hw surface ...&#xA;av_hwframe_transfer_data(pFrameOK, pFrame, 0)&#xA;&#xA;// 此时 pFrameOK 就是转储出来的 NV12 格式帧&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;通过 Rockchip MPP 硬解 FFmpeg AVPacket&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Rockchip MPP 官方&#xA;https://github.com/rockchip-linux/mpp&#xA;&#xA;// 通过以下项目实现 AVPacket 解码&#xA;https://github.com/MUZLATAN/ffmpeg_rtsp_mpp&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 但是上面项目为什么只能解码流而不能解码本地文件呢 ...&#xA;// 因为视频流与本地文件部分格式差异，如下解决&#xA;&#xA;// is video stream&#xA;const char start_code[4] = { 0, 0, 0, 1 };&#xA;if(memcmp(start_code, av_packet-&amp;gt;data, 4) != 0)&#xA;{   // is avc1 code, have no start code of H264&#xA;int len = 0;&#xA;uint8_t *p = av_packet-&amp;gt;data;&#xA;do&#xA;{   // add start_code for each NAL, one frame may have multi NALs.&#xA;    len = ntohl(*((long*)p));&#xA;    memcpy(p, start_code, 4);&#xA;    p += 4;&#xA;    p += len;&#xA;    if(p &amp;gt;= av_packet-&amp;gt;data + av_packet-&amp;gt;size)&#xA;    {&#xA;    break;&#xA;    }&#xA;} while (1);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过 dump_mpp_frame_to_file 可以拿到已经解码的 MppFrame &#xA;&#xA;...&#xA;if (data-&amp;gt;fp_output &amp;amp;&amp;amp; !err_info){&#xA;    dump_mpp_frame_to_file(frame, data-&amp;gt;fp_output);&#xA;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// MppFrame to SDL_Texture&#xA;&#xA;char* pixels;&#xA;int pitch;&#xA;&#xA;if (SDL_LockTexture(m_texture, nullptr, (void**)&amp;amp;pixels, &amp;amp;pitch) &amp;lt; 0)&#xA;    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, &amp;quot;SDL_LockTexture() failed: %s&amp;quot;, SDL_GetError());&#xA;&#xA;decode_simple(&amp;amp;m_decoder-&amp;gt;data, pkt-&amp;gt;avpkt, pixels);&#xA;&#xA;SDL_UnlockTexture(m_texture);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 其中 decode_simple ...&#xA;&#xA;RK_U32 width    = 0;&#xA;RK_U32 height   = 0;&#xA;RK_U32 h_stride = 0;&#xA;RK_U32 v_stride = 0;&#xA;&#xA;MppBuffer buffer = NULL;&#xA;RK_U8 *base = NULL;&#xA;&#xA;width    = mpp_frame_get_width(frame);&#xA;height   = mpp_frame_get_height(frame);&#xA;h_stride = mpp_frame_get_hor_stride(frame);&#xA;v_stride = mpp_frame_get_ver_stride(frame);&#xA;buffer   = mpp_frame_get_buffer(frame);&#xA;&#xA;base = (RK_U8 *)mpp_buffer_get_ptr(buffer);&#xA;RK_U32 buf_size = mpp_frame_get_buf_size(frame);&#xA;size_t base_length = mpp_buffer_get_size(buffer);&#xA;mpp_log(&amp;quot;base_length = %d\n&amp;quot;, base_length);&#xA;&#xA;RK_U32 i;&#xA;RK_U8 *base_y = base;&#xA;RK_U8 *base_c = base + h_stride * v_stride;&#xA;&#xA;// ---------------------------------------------- //&#xA;// 有问题，待修正 ...&#xA;&#xA;int idx = 0;&#xA;for (i = 0; i &amp;lt; height; i++, base_y += h_stride) {&#xA;    memcpy(pixels + idx, base_y, width);&#xA;    idx += width;&#xA;}&#xA;for (i = 0; i &amp;lt; height / 2; i++, base_c += h_stride) {&#xA;    memcpy(pixels + idx, base_c, width);&#xA;    idx += width;&#xA;}&#xA;&#xA;// ---------------------------------------------- //&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// AVPacket to MppPacket&#xA;&#xA;mpp_packet_init(&amp;amp;packet, av_packet-&amp;gt;data, av_packet-&amp;gt;size);&#xA;mpp_packet_set_pts(packet, av_packet-&amp;gt;pts);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之通过udev规则指定网络设备</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8B%E9%80%9A%E8%BF%87udev%E8%A7%84%E5%88%99%E6%8C%87%E5%AE%9A%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</link>
      <pubDate>2019-04-11 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Linux之通过udev规则指定网络设备&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo udevadm control --reload // 任何规则文件及相关脚本修改后都需要执行 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查询udev数据库中的设备信息&#xA;udevadm info -a -p /sys/class/net/eth0&#xA;&#xA;&#xA;// 获取到的设备信息 ...&#xA;looking at device &#39;/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.1/1-1.1.1:1.0/net/eth0&#39;:&#xA;KERNEL==&amp;quot;eth0&amp;quot;&#xA;SUBSYSTEM==&amp;quot;net&amp;quot;&#xA;DRIVER==&amp;quot;&amp;quot;&#xA;ATTR{addr_assign_type}==&amp;quot;0&amp;quot;&#xA;ATTR{addr_len}==&amp;quot;6&amp;quot;&#xA;ATTR{address}==&amp;quot;b8:27:eb:a7:c3:e6&amp;quot;&#xA;ATTR{broadcast}==&amp;quot;ff:ff:ff:ff:ff:ff&amp;quot;&#xA;ATTR{carrier}==&amp;quot;0&amp;quot;&#xA;ATTR{carrier_changes}==&amp;quot;1&amp;quot;&#xA;ATTR{dev_id}==&amp;quot;0x0&amp;quot;&#xA;ATTR{dev_port}==&amp;quot;0&amp;quot;&#xA;ATTR{dormant}==&amp;quot;0&amp;quot;&#xA;ATTR{duplex}==&amp;quot;half&amp;quot;&#xA;ATTR{flags}==&amp;quot;0x1003&amp;quot;&#xA;ATTR{gro_flush_timeout}==&amp;quot;0&amp;quot;&#xA;ATTR{ifalias}==&amp;quot;&amp;quot;&#xA;ATTR{ifindex}==&amp;quot;2&amp;quot;&#xA;ATTR{iflink}==&amp;quot;2&amp;quot;&#xA;ATTR{link_mode}==&amp;quot;0&amp;quot;&#xA;ATTR{mtu}==&amp;quot;1500&amp;quot;&#xA;ATTR{netdev_group}==&amp;quot;0&amp;quot;&#xA;ATTR{operstate}==&amp;quot;down&amp;quot;&#xA;ATTR{proto_down}==&amp;quot;0&amp;quot;&#xA;ATTR{speed}==&amp;quot;10&amp;quot;&#xA;ATTR{tx_queue_len}==&amp;quot;1000&amp;quot;&#xA;ATTR{type}==&amp;quot;1&amp;quot;&#xA;&#xA;looking at parent device &#39;/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.1/1-1.1.1:1.0&#39;:&#xA;KERNELS==&amp;quot;1-1.1.1:1.0&amp;quot;&#xA;SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;DRIVERS==&amp;quot;lan78xx&amp;quot;&#xA;ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;ATTRS{bAlternateSetting}==&amp;quot; 0&amp;quot;&#xA;ATTRS{bInterfaceClass}==&amp;quot;ff&amp;quot;&#xA;ATTRS{bInterfaceNumber}==&amp;quot;00&amp;quot;&#xA;ATTRS{bInterfaceProtocol}==&amp;quot;ff&amp;quot;&#xA;ATTRS{bInterfaceSubClass}==&amp;quot;00&amp;quot;&#xA;ATTRS{bNumEndpoints}==&amp;quot;03&amp;quot;&#xA;ATTRS{supports_autosuspend}==&amp;quot;1&amp;quot;&#xA;&#xA;looking at parent device &#39;/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.1&#39;:&#xA;KERNELS==&amp;quot;1-1.1.1&amp;quot;&#xA;SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;DRIVERS==&amp;quot;usb&amp;quot;&#xA;ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;ATTRS{avoid_reset_quirk}==&amp;quot;0&amp;quot;&#xA;ATTRS{bConfigurationValue}==&amp;quot;1&amp;quot;&#xA;ATTRS{bDeviceClass}==&amp;quot;ff&amp;quot;&#xA;ATTRS{bDeviceProtocol}==&amp;quot;ff&amp;quot;&#xA;ATTRS{bDeviceSubClass}==&amp;quot;00&amp;quot;&#xA;ATTRS{bMaxPacketSize0}==&amp;quot;64&amp;quot;&#xA;ATTRS{bMaxPower}==&amp;quot;2mA&amp;quot;&#xA;ATTRS{bNumConfigurations}==&amp;quot;1&amp;quot;&#xA;ATTRS{bNumInterfaces}==&amp;quot; 1&amp;quot;&#xA;ATTRS{bcdDevice}==&amp;quot;0300&amp;quot;&#xA;ATTRS{bmAttributes}==&amp;quot;e0&amp;quot;&#xA;ATTRS{busnum}==&amp;quot;1&amp;quot;&#xA;ATTRS{configuration}==&amp;quot;&amp;quot;&#xA;ATTRS{devnum}==&amp;quot;4&amp;quot;&#xA;ATTRS{devpath}==&amp;quot;1.1.1&amp;quot;&#xA;ATTRS{idProduct}==&amp;quot;7800&amp;quot;&#xA;ATTRS{idVendor}==&amp;quot;0424&amp;quot;&#xA;ATTRS{ltm_capable}==&amp;quot;no&amp;quot;&#xA;ATTRS{maxchild}==&amp;quot;0&amp;quot;&#xA;ATTRS{quirks}==&amp;quot;0x0&amp;quot;&#xA;ATTRS{removable}==&amp;quot;fixed&amp;quot;&#xA;ATTRS{speed}==&amp;quot;480&amp;quot;&#xA;ATTRS{urbnum}==&amp;quot;1332&amp;quot;&#xA;ATTRS{version}==&amp;quot; 2.10&amp;quot;&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// add rndis_host 设备时执行脚本 ...&#xA;&#xA;# /etc/udev/rules.d/90-local.rules &#xA;ACTION==&amp;quot;add&amp;quot;, SUBSYSTEMS==&amp;quot;usb&amp;quot;, DRIVERS==&amp;quot;rndis_host&amp;quot;, RUN+=&amp;quot;/danoo/bin/addnet.sh&amp;quot;&#xA;&#xA;# /danoo/bin/addnet.sh &#xA;#!/bin/bash&#xA;&#xA;for interface in /sys/class/net/*; do&#xA;    if [[ ${interface} == /sys/class/net/eth* ]]; then&#xA;    ok=$(udevadm info ${interface} |grep -v grep |grep rndis_host |wc -l)&#xA;    if [ ${ok} -ne 0 ];then&#xA;         name=$(basename ${interface})&#xA;         echo ${name} &amp;gt; /dev/shm/rndis_host&#xA;         ifconfig ${name} 192.168.0.99 netmask 255.255.255.0&#xA;         ifconfig ${name} mtu 1400&#xA;         route del default; route add default gw 192.168.0.1&#xA;         echo &#39;nameserver 114.114.114.114&#39; &amp;gt; /etc/resolv.conf&#xA;    fi&#xA;    fi&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 指定命名规则&#xA;SUBSYSTEM==&amp;quot;net&amp;quot;,ACTION==&amp;quot;add&amp;quot;,DRIVERS==&amp;quot;?*&amp;quot;,ATTR{address}==&amp;quot;00:00:00:00:00:01&amp;quot;,ATTR{dev_id}==&amp;quot;0x0&amp;quot;,ATTR{type}==&amp;quot;1&amp;quot;,KERNEL==&amp;quot;eth*&amp;quot;,NAME=&amp;quot;eth1&amp;quot;&#xA;SUBSYSTEM==&amp;quot;net&amp;quot;,ACTION==&amp;quot;add&amp;quot;,DRIVERS==&amp;quot;?*&amp;quot;,ATTR{address}==&amp;quot;00:e0:40:68:4b:36&amp;quot;,ATTR{type}==&amp;quot;1&amp;quot;,KERNEL==&amp;quot;eth*&amp;quot;,NAME=&amp;quot;eth0&amp;quot;&#xA;SUBSYSTEM==&amp;quot;net&amp;quot;, ACTION==&amp;quot;add&amp;quot;, ATTR{address}!=&amp;quot;00:00:00:00:00:00&amp;quot;, ATTRS{modalias}==&amp;quot;usb:*&amp;quot;, ATTR{type}==&amp;quot;1&amp;quot;, KERNEL==&amp;quot;eth*&amp;quot;, NAME=&amp;quot;eth1&amp;quot;&#xA;SUBSYSTEM==&amp;quot;net&amp;quot;, ACTION==&amp;quot;add&amp;quot;, ATTR{address}!=&amp;quot;00:00:00:00:00:00&amp;quot;, ATTRS{modalias}==&amp;quot;pci:*&amp;quot;, ATTRS{vendor}==&amp;quot;0x10ec&amp;quot;, ATTR{type}==&amp;quot;1&amp;quot;, KERNEL==&amp;quot;eth*&amp;quot;, NAME=&amp;quot;eth0&amp;quot;&#xA;SUBSYSTEM==&amp;quot;net&amp;quot;, ACTION==&amp;quot;add&amp;quot;, DRIVERS==&amp;quot;?*&amp;quot;, ATTR{address}!=&amp;quot;00:00:00:00:00:01&amp;quot;, ATTR{dev_id}==&amp;quot;0x0&amp;quot;, ATTR{type}==&amp;quot;1&amp;quot;, KERNEL==&amp;quot;wlan*&amp;quot;, NAME=&amp;quot;eth1&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 参考&#xA;&#xA;In an ideal situation? Rewrite that as a udev rule so that it triggers automatically on connection. It will have to be evaluated after other rules so that any interface renaming has already happened by the time it gets evaluated (/etc/udev/rules.d/99-x-local.conf is probably the place to put it), but the basic rule should look similar to this:&#xA;&#xA;SUBSYSTEM==&amp;quot;net&amp;quot;, ENV{ID_BUS}==&amp;quot;usb&amp;quot;, ENV{ID_USB_DRIVER}==&amp;quot;rndis_host&amp;quot;, ACTION==&amp;quot;add&amp;quot;, RUN{program}+=&amp;quot;/bin/sh -c &#39;echo $env{INTERFACE} &amp;gt; /var/tmp/myfile&#39;&amp;quot;&#xA;&#xA;The first four parts match the exact event generated when the device gets connected, more specifically:&#xA;&#xA;SUBSYSTEM==&amp;quot;net&amp;quot; matches networking devices&#xA;ENV{ID_BUS}==&amp;quot;usb&amp;quot; matches only those networking devices that are connected via USB.&#xA;ENV{ID_USB_DRIVER}==&amp;quot;rndis_host&amp;quot; matches only USB devices that use the RNDIS host device driver (the standard one used by Android phones (and I think Windows and Blackberry too) for USB tethering.&#xA;ACTION==&amp;quot;add&amp;quot; matches on the hotplug events only (so this only gets run when the device gets connected, though you could just as easily add a second similar rule matching on the &amp;quot;remove&amp;quot; action to do something when the phone gets unplugged).&#xA;The final item adds a command to the queue of things that udev will invoke when the rule processing is done,. In this case, it&#39;s adding a shell invocation that will write out the interface name to the desired location (udev itself will substitute the $env{INTERFACE} for the actual interface name).&#xA;&#xA;I can&#39;t guarantee that that will work in all cases, but it at least seems to work for my Nexus 6P and should in theory work for most Android phones.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之编译与定制OMXPlayer</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AE%9A%E5%88%B6OMXPlayer/</link>
      <pubDate>2019-04-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之编译与定制OMXPlayer&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;下载源码&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/popcornmix/omxplayer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Build FFmepg&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;make -f Makefile.ffmpeg&#xA;&#xA;如果 git 失败可以&#xA;http://ffmpeg.org/download.html#releases 下载源码替换 ffmepg 目录&#xA;随后注释 Makefile.ffmpeg 中 git 行 ...&#xA;&#xA;ERROR: smbclient not found&#xA;apt-get install smbclient&#xA;apt-get install libsmbclient&#xA;apt-get install libsmbclient-dev&#xA;&#xA;ERROR: libssh not found using pkg-config&#xA;apt-get install libssh-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Build OMXPlayer&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;向 Makefile 中添加 -ldl&#xA;&#xA;OMXSubtitleTagSami.cpp:28:38: fatal error: boost/algorithm/string.hpp: No such file or directory&#xA;apt-get install libboost-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;官方方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Run this script which will install build dependency packages, including g++, and update firmware&#xA;&#xA;    ./prepare-native-raspbian.sh&#xA;&#xA;Build with&#xA;&#xA;    make ffmpeg&#xA;    make -j$(nproc)&#xA;&#xA;Install with&#xA;&#xA;    sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之hello_video循环播放视频</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8Bhello_video%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</link>
      <pubDate>2019-01-09 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之hello_video循环播放视频&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Video deocode demo using OpenMAX IL though the ilcient helper library&#xA;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;&#xA;#include &amp;quot;bcm_host.h&amp;quot;&#xA;#include &amp;quot;ilclient.h&amp;quot;&#xA;&#xA;static int video_decode_test(char *filename)&#xA;{&#xA;   OMX_VIDEO_PARAM_PORTFORMATTYPE format;&#xA;   OMX_TIME_CONFIG_CLOCKSTATETYPE cstate;&#xA;   COMPONENT_T *video_decode = NULL, *video_scheduler = NULL, *video_render = NULL, *clock = NULL;&#xA;   COMPONENT_T *list[5];&#xA;   TUNNEL_T tunnel[4];&#xA;   ILCLIENT_T *client;&#xA;   FILE *in;&#xA;   int status = 0;&#xA;   unsigned int data_len = 0;&#xA;&#xA;   memset(list, 0, sizeof(list));&#xA;   memset(tunnel, 0, sizeof(tunnel));&#xA;&#xA;   if((in = fopen(filename, &amp;quot;rb&amp;quot;)) == NULL)&#xA;      return -2;&#xA;&#xA;   if((client = ilclient_init()) == NULL)&#xA;   {&#xA;      fclose(in);&#xA;      return -3;&#xA;   }&#xA;&#xA;   if(OMX_Init() != OMX_ErrorNone)&#xA;   {&#xA;      ilclient_destroy(client);&#xA;      fclose(in);&#xA;      return -4;&#xA;   }&#xA;&#xA;   // create video_decode&#xA;   if(ilclient_create_component(client, &amp;amp;video_decode, &amp;quot;video_decode&amp;quot;, ILCLIENT_DISABLE_ALL_PORTS | ILCLIENT_ENABLE_INPUT_BUFFERS) != 0)&#xA;      status = -14;&#xA;   list[0] = video_decode;&#xA;&#xA;   // create video_render&#xA;   if(status == 0 &amp;amp;&amp;amp; ilclient_create_component(client, &amp;amp;video_render, &amp;quot;video_render&amp;quot;, ILCLIENT_DISABLE_ALL_PORTS) != 0)&#xA;      status = -14;&#xA;   list[1] = video_render;&#xA;&#xA;   // create clock&#xA;   if(status == 0 &amp;amp;&amp;amp; ilclient_create_component(client, &amp;amp;clock, &amp;quot;clock&amp;quot;, ILCLIENT_DISABLE_ALL_PORTS) != 0)&#xA;      status = -14;&#xA;   list[2] = clock;&#xA;&#xA;   memset(&amp;amp;cstate, 0, sizeof(cstate));&#xA;   cstate.nSize = sizeof(cstate);&#xA;   cstate.nVersion.nVersion = OMX_VERSION;&#xA;   cstate.eState = OMX_TIME_ClockStateWaitingForStartTime;&#xA;   cstate.nWaitMask = 1;&#xA;   if(clock != NULL &amp;amp;&amp;amp; OMX_SetParameter(ILC_GET_HANDLE(clock), OMX_IndexConfigTimeClockState, &amp;amp;cstate) != OMX_ErrorNone)&#xA;      status = -13;&#xA;&#xA;   // create video_scheduler&#xA;   if(status == 0 &amp;amp;&amp;amp; ilclient_create_component(client, &amp;amp;video_scheduler, &amp;quot;video_scheduler&amp;quot;, ILCLIENT_DISABLE_ALL_PORTS) != 0)&#xA;      status = -14;&#xA;   list[3] = video_scheduler;&#xA;&#xA;   set_tunnel(tunnel, video_decode, 131, video_scheduler, 10);&#xA;   set_tunnel(tunnel+1, video_scheduler, 11, video_render, 90);&#xA;   set_tunnel(tunnel+2, clock, 80, video_scheduler, 12);&#xA;&#xA;   // setup clock tunnel first&#xA;   if(status == 0 &amp;amp;&amp;amp; ilclient_setup_tunnel(tunnel+2, 0, 0) != 0)&#xA;      status = -15;&#xA;   else&#xA;      ilclient_change_component_state(clock, OMX_StateExecuting);&#xA;&#xA;   if(status == 0)&#xA;      ilclient_change_component_state(video_decode, OMX_StateIdle);&#xA;&#xA;   memset(&amp;amp;format, 0, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));&#xA;   format.nSize = sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE);&#xA;   format.nVersion.nVersion = OMX_VERSION;&#xA;   format.nPortIndex = 130;&#xA;   format.eCompressionFormat = OMX_VIDEO_CodingAVC;&#xA;&#xA;   if(status == 0 &amp;amp;&amp;amp;&#xA;      OMX_SetParameter(ILC_GET_HANDLE(video_decode), OMX_IndexParamVideoPortFormat, &amp;amp;format) == OMX_ErrorNone &amp;amp;&amp;amp;&#xA;      ilclient_enable_port_buffers(video_decode, 130, NULL, NULL, NULL) == 0)&#xA;   {&#xA;      OMX_BUFFERHEADERTYPE *buf;&#xA;      int port_settings_changed = 0;&#xA;      int first_packet = 1;&#xA;&#xA;      ilclient_change_component_state(video_decode, OMX_StateExecuting);&#xA;&#xA;      while((buf = ilclient_get_input_buffer(video_decode, 130, 1)) != NULL)&#xA;      {&#xA;     // feed data and wait until we get port settings changed&#xA;     unsigned char *dest = buf-&amp;gt;pBuffer;&#xA;&#xA;     // loop if at end&#xA;     if (feof(in))&#xA;         rewind(in);&#xA;&#xA;     data_len += fread(dest, 1, buf-&amp;gt;nAllocLen-data_len, in);&#xA;&#xA;     if(port_settings_changed == 0 &amp;amp;&amp;amp;&#xA;        ((data_len &amp;gt; 0 &amp;amp;&amp;amp; ilclient_remove_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1) == 0) ||&#xA;         (data_len == 0 &amp;amp;&amp;amp; ilclient_wait_for_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1,&#xA;                               ILCLIENT_EVENT_ERROR | ILCLIENT_PARAMETER_CHANGED, 10000) == 0)))&#xA;     {&#xA;        port_settings_changed = 1;&#xA;&#xA;        if(ilclient_setup_tunnel(tunnel, 0, 0) != 0)&#xA;        {&#xA;           status = -7;&#xA;           break;&#xA;        }&#xA;&#xA;        ilclient_change_component_state(video_scheduler, OMX_StateExecuting);&#xA;&#xA;        // now setup tunnel to video_render&#xA;        if(ilclient_setup_tunnel(tunnel+1, 0, 1000) != 0)&#xA;        {&#xA;           status = -12;&#xA;           break;&#xA;        }&#xA;&#xA;        ilclient_change_component_state(video_render, OMX_StateExecuting);&#xA;     }&#xA;     if(!data_len)&#xA;        break;&#xA;&#xA;     buf-&amp;gt;nFilledLen = data_len;&#xA;     data_len = 0;&#xA;&#xA;     buf-&amp;gt;nOffset = 0;&#xA;     if(first_packet)&#xA;     {&#xA;        buf-&amp;gt;nFlags = OMX_BUFFERFLAG_STARTTIME;&#xA;        first_packet = 0;&#xA;     }&#xA;     else&#xA;        buf-&amp;gt;nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;&#xA;&#xA;     if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(video_decode), buf) != OMX_ErrorNone)&#xA;     {&#xA;        status = -6;&#xA;        break;&#xA;     }&#xA;      }&#xA;&#xA;      buf-&amp;gt;nFilledLen = 0;&#xA;      buf-&amp;gt;nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN | OMX_BUFFERFLAG_EOS;&#xA;&#xA;      if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(video_decode), buf) != OMX_ErrorNone)&#xA;     status = -20;&#xA;&#xA;      // wait for EOS from render&#xA;      ilclient_wait_for_event(video_render, OMX_EventBufferFlag, 90, 0, OMX_BUFFERFLAG_EOS, 0,&#xA;                  ILCLIENT_BUFFER_FLAG_EOS, -1);&#xA;&#xA;      // need to flush the renderer to allow video_decode to disable its input port&#xA;      ilclient_flush_tunnels(tunnel, 0);&#xA;&#xA;   }&#xA;&#xA;   fclose(in);&#xA;&#xA;   ilclient_disable_tunnel(tunnel);&#xA;   ilclient_disable_tunnel(tunnel+1);&#xA;   ilclient_disable_tunnel(tunnel+2);&#xA;   ilclient_disable_port_buffers(video_decode, 130, NULL, NULL, NULL);&#xA;   ilclient_teardown_tunnels(tunnel);&#xA;&#xA;   ilclient_state_transition(list, OMX_StateIdle);&#xA;   ilclient_state_transition(list, OMX_StateLoaded);&#xA;&#xA;   ilclient_cleanup_components(list);&#xA;&#xA;   OMX_Deinit();&#xA;&#xA;   ilclient_destroy(client);&#xA;   return status;&#xA;}&#xA;&#xA;int main (int argc, char **argv)&#xA;{&#xA;   if (argc &amp;lt; 2) {&#xA;      printf(&amp;quot;Usage: %s &amp;lt;filename&amp;gt;\n&amp;quot;, argv[0]);&#xA;      exit(1);&#xA;   }&#xA;   bcm_host_init();&#xA;   return video_decode_test(argv[1]);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>SDL2之stb_image代替sdl2_image方法</title>
      <link>http://www.nljb.net/default/SDL2%E4%B9%8Bstb_image%E4%BB%A3%E6%9B%BFsdl2_image%E6%96%B9%E6%B3%95/</link>
      <pubDate>2019-01-09 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;SDL2之stb_image代替sdl2_image方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// https://www.libsdl.org/projects/SDL_image/&#xA;// 常用的 SDL Image 加载图片一般这样 ...&#xA;SDL_Surface * image = IMG_Load(&amp;quot;/home/danoo/aaa.png&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用 stb image 代替 sdl image 不再需要安装三方库&#xA;// 直接把 stb_image.h 文件导入到项目中即可使用 ...&#xA;https://github.com/nulijiabei/stb/blob/master/stb_image.h&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 同时也是官方推荐 ...&#xA;// https://wiki.libsdl.org/SDL_CreateRGBSurfaceFrom&#xA;&#xA;// This example shows how to create a SDL_Surface* with the data loaded from an image&#xA;// file with the stb_image.h library (https://github.com/nothings/stb/)&#xA;&#xA;// the color format you request stb_image to output,&#xA;// use STBI_rgb if you don&#39;t want/need the alpha channel&#xA;int req_format = STBI_rgb_alpha;&#xA;int width, height, orig_format;&#xA;unsigned char* data = stbi_load(&amp;quot;./test.png&amp;quot;, &amp;amp;width, &amp;amp;height, &amp;amp;orig_format, req_format);&#xA;if(data == NULL) {&#xA;  SDL_Log(&amp;quot;Loading image failed: %s&amp;quot;, stbi_failure_reason());&#xA;  exit(1);&#xA;}&#xA;&#xA;// Set up the pixel format color masks for RGB(A) byte arrays.&#xA;// Only STBI_rgb (3) and STBI_rgb_alpha (4) are supported here!&#xA;Uint32 rmask, gmask, bmask, amask;&#xA;#if SDL_BYTEORDER == SDL_BIG_ENDIAN&#xA;  int shift = (req_format == STBI_rgb) ? 8 : 0;&#xA;  rmask = 0xff000000 &amp;gt;&amp;gt; shift;&#xA;  gmask = 0x00ff0000 &amp;gt;&amp;gt; shift;&#xA;  bmask = 0x0000ff00 &amp;gt;&amp;gt; shift;&#xA;  amask = 0x000000ff &amp;gt;&amp;gt; shift;&#xA;#else // little endian, like x86&#xA;  rmask = 0x000000ff;&#xA;  gmask = 0x0000ff00;&#xA;  bmask = 0x00ff0000;&#xA;  amask = (req_format == STBI_rgb) ? 0 : 0xff000000;&#xA;#endif&#xA;&#xA;int depth, pitch;&#xA;if (req_format == STBI_rgb) {&#xA;  depth = 24;&#xA;  pitch = 3*width; // 3 bytes per pixel * pixels per row&#xA;} else { // STBI_rgb_alpha (RGBA)&#xA;  depth = 32;&#xA;  pitch = 4*width;&#xA;}&#xA;&#xA;SDL_Surface* surf = SDL_CreateRGBSurfaceFrom((void*)data, width, height, depth, pitch,&#xA;                         rmask, gmask, bmask, amask);&#xA;&#xA;if (surf == NULL) {&#xA;  SDL_Log(&amp;quot;Creating surface failed: %s&amp;quot;, SDL_GetError());&#xA;  stbi_image_free(data);&#xA;  exit(1);&#xA;}&#xA;&#xA;// ... do something useful with the surface ...&#xA;// ...&#xA;&#xA;// when you don&#39;t need the surface anymore, free it..&#xA;SDL_FreeSurface(surf);&#xA;// .. *and* the data used by the surface!&#xA;stbi_image_free(data);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之自定义开机启动画面</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2/</link>
      <pubDate>2018-12-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之自定义开机启动画面&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 我的系统版本&#xA;root@raspberrypi:~# lsb_release -a&#xA;No LSB modules are available.&#xA;Distributor ID: Raspbian&#xA;Description:    Raspbian GNU/Linux 9.4 (stretch)&#xA;Release:    9.4&#xA;Codename:   stretch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 准备工作&#xA;// 1. 禁用颜色测试&#xA;/boot/config.txt 中添加 disable_splash=1&#xA;// 2. 禁用角落 LOGO&#xA;/boot/cmdline.txt 中添加 logo.nologo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 1. 设置主题风格&#xA;sudo plymouth-set-default-theme details&#xA;// 查看主题风格 ...&#xA;sudo plymouth-set-default-theme -l&#xA;&#xA;// 2. 安装 fbi&#xA;sudo apt-get install fbi&#xA;// 3. 创建 /etc/systemd/system/splashscreen.service&#xA;[Unit]&#xA;Description=Splashscreen&#xA;DefaultDependencies=no&#xA;After=basic.target&#xA;[Service]&#xA;ExecStart=/usr/bin/fbi -d /dev/fb0 --noverbose -a /opt/splash.png&#xA;StandardInput=tty&#xA;StandardOutput=tty&#xA;[Install]&#xA;WantedBy=sysinit.target&#xA;&#xA;// 3.1 放入自定义图片到 /opt/splash.png&#xA;// 3.2 如果不希望图片自动缩放可以去掉 -a&#xA;&#xA;// 4. 启动 splashscreen &#xA;systemctl enable splashscreen // 开启服务&#xA;systemctl start splashscreen // 开启服务&#xA;systemctl status splashscreen // 服务状态&#xA;systemctl stop splashscreen // 停止服务&#xA;&#xA;// 5. 注意 raspi-config 中需要开启 splash screen&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之安装GStreamer与gst-omx教程</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E5%AE%89%E8%A3%85GStreamer%E4%B8%8Egst-omx%E6%95%99%E7%A8%8B/</link>
      <pubDate>2018-11-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之安装GStreamer与gst-omx教程&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在最新的 GStreamer 1.18.x 使用 meson 进行编译&#xA;&#xA;// 下载 GStreamer 提供的 Build 工具&#xA;https://github.com/GStreamer/gst-build&#xA;&#xA;// 下载 Meson 工具&#xA;https://github.com/mesonbuild/meson&#xA;&#xA;// 安装 ninja build ...&#xA;https://github.com/martine/ninja.git&#xA;或：apt-get install ninja-build&#xA;&#xA;// Build  ...&#xA;cd gst-build&#xA;../meson.py build&#xA;ninja -C build&#xA;ninja -C build/ install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 改 gitlab.gnome.org 或 gitlab.freedesktop.org 为 github.com&#xA;../gst-build/subprojects/xxx.wrap &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 默认扩展插件位置 ...&#xA;/usr/local/lib/aarch64-linux-gnu/gstreamer-1.0&#xA;&#xA;// 查询扩展插件 ...&#xA;gst-inspect-1.0 --gst-plugin-path=/usr/local/lib/gstreamer-1.0 | grep mpp&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install -y build-essential autotools-dev automake autoconf \&#xA;            libtool autopoint libxml2-dev zlib1g-dev libglib2.0-dev \&#xA;            pkg-config bison flex python git gtk-doc-tools libasound2-dev \&#xA;            libgudev-1.0-dev libxt-dev libvorbis-dev libcdparanoia-dev \&#xA;            libpango1.0-dev libtheora-dev libvisual-0.4-dev iso-codes \&#xA;            libgtk-3-dev libraw1394-dev libiec61883-dev libavc1394-dev \&#xA;            libv4l-dev libcairo2-dev libcaca-dev libspeex-dev libpng-dev \&#xA;            libshout3-dev libjpeg-dev libaa1-dev libflac-dev libdv4-dev \&#xA;            libtag1-dev libwavpack-dev libpulse-dev libsoup2.4-dev libbz2-dev \&#xA;            libcdaudio-dev libdc1394-22-dev ladspa-sdk libass-dev \&#xA;            libcurl4-gnutls-dev libdca-dev libdvdnav-dev \&#xA;            libexempi-dev libexif-dev libfaad-dev libgme-dev libgsm1-dev \&#xA;            libiptcdata0-dev libkate-dev libmimic-dev libmms-dev \&#xA;            libmodplug-dev libmpcdec-dev libofa0-dev libopus-dev \&#xA;            librsvg2-dev librtmp-dev \&#xA;            libsndfile1-dev libsoundtouch-dev libspandsp-dev libx11-dev \&#xA;            libxvidcore-dev libzbar-dev libzvbi-dev liba52-0.7.4-dev \&#xA;            libcdio-dev libdvdread-dev libmad0-dev libmp3lame-dev \&#xA;            libmpeg2-4-dev libopencore-amrnb-dev libopencore-amrwb-dev \&#xA;            libsidplay1-dev libtwolame-dev libx264-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Distributor ID: Raspbian&#xA;Description:    Raspbian GNU/Linux 9.4 (stretch)&#xA;Release:    9.4&#xA;Codename:   stretch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# /etc/apt/sources.list&#xA;deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi&#xA;# Uncomment line below then &#39;apt-get update&#39; to enable &#39;apt-get source&#39;&#xA;deb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;################# COMPILE GSTREAMER 1.10 ############&#xA;&#xA;&#xA;# Update and Upgrade the Pi, otherwise the build may fail due to inconsistencies&#xA;&#xA;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade -y&#xA;&#xA;# Get the required libraries&#xA;sudo apt-get install -y build-essential autotools-dev automake autoconf \&#xA;            libtool autopoint libxml2-dev zlib1g-dev libglib2.0-dev \&#xA;            pkg-config bison flex python git gtk-doc-tools libasound2-dev \&#xA;            libgudev-1.0-dev libxt-dev libvorbis-dev libcdparanoia-dev \&#xA;            libpango1.0-dev libtheora-dev libvisual-0.4-dev iso-codes \&#xA;            libgtk-3-dev libraw1394-dev libiec61883-dev libavc1394-dev \&#xA;            libv4l-dev libcairo2-dev libcaca-dev libspeex-dev libpng-dev \&#xA;            libshout3-dev libjpeg-dev libaa1-dev libflac-dev libdv4-dev \&#xA;            libtag1-dev libwavpack-dev libpulse-dev libsoup2.4-dev libbz2-dev \&#xA;            libcdaudio-dev libdc1394-22-dev ladspa-sdk libass-dev \&#xA;            libcurl4-gnutls-dev libdca-dev libdirac-dev libdvdnav-dev \&#xA;            libexempi-dev libexif-dev libfaad-dev libgme-dev libgsm1-dev \&#xA;            libiptcdata0-dev libkate-dev libmimic-dev libmms-dev \&#xA;            libmodplug-dev libmpcdec-dev libofa0-dev libopus-dev \&#xA;            librsvg2-dev librtmp-dev libschroedinger-dev libslv2-dev \&#xA;            libsndfile1-dev libsoundtouch-dev libspandsp-dev libx11-dev \&#xA;            libxvidcore-dev libzbar-dev libzvbi-dev liba52-0.7.4-dev \&#xA;            libcdio-dev libdvdread-dev libmad0-dev libmp3lame-dev \&#xA;            libmpeg2-4-dev libopencore-amrnb-dev libopencore-amrwb-dev \&#xA;            libsidplay1-dev libtwolame-dev libx264-dev&#xA;&#xA;cd $HOME&#xA;mkdir packages&#xA;cd packages/&#xA;mkdir gstreamer-1.10&#xA;cd gstreamer-1.10&#xA;&#xA;&#xA;git clone https://github.com/GStreamer/gstreamer&#xA;cd gstreamer&#xA;git checkout -t origin/1.10&#xA;./autogen.sh&#xA;make&#xA;sudo make install&#xA;cd ..&#xA;&#xA;&#xA;git clone https://github.com/GStreamer/gst-plugins-base&#xA;cd gst-plugins-base&#xA;git checkout -t origin/1.10&#xA;./autogen.sh&#xA;make&#xA;sudo make install&#xA;cd ..&#xA;&#xA;&#xA;git clone https://github.com/GStreamer/gst-plugins-good&#xA;cd gst-plugins-good&#xA;git checkout -t origin/1.10&#xA;./autogen.sh&#xA;make&#xA;sudo make install&#xA;cd ..&#xA;&#xA;&#xA;git clone https://github.com/GStreamer/gst-plugins-ugly&#xA;cd gst-plugins-ugly&#xA;git checkout -t origin/1.10&#xA;./autogen.sh&#xA;make&#xA;sudo make install&#xA;cd ..&#xA;&#xA;&#xA;git clone https://github.com/GStreamer/gst-libav&#xA;cd gst-libav&#xA;git checkout -t origin/1.10&#xA;./autogen.sh&#xA;make&#xA;sudo make install&#xA;cd ..&#xA;&#xA;&#xA;git clone https://github.com/GStreamer/gst-plugins-bad&#xA;&#xA;# Install libusb-1.0 to enable  uvch264src&#xA;sudo apt-get install libusb-1.0&#xA;&#xA;cd gst-plugins-bad&#xA;git checkout -t origin/1.10&#xA;export LD_LIBRARY_PATH=/usr/local/lib/ path&#xA;LDFLAGS=&#39;-L/opt/vc/lib&#39; CPPFLAGS=&#39;-I/opt/vc/include -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux&#39; ./autogen.sh&#xA;make CFLAGS+=&amp;quot;-Wno-error&amp;quot;&#xA;sudo make install&#xA;cd ..&#xA;&#xA;################# COMPILE GST-OMX ##########&#xA;&#xA;&#xA;git clone https://github.com/GStreamer/gst-omx&#xA;cd gst-omx&#xA;git checkout -t origin/1.10&#xA;LDFLAGS=&#39;-L/opt/vc/lib&#39; CPPFLAGS=&#39;-I/opt/vc/include -I/opt/vc/include/IL -I/opt/vc/include/interface/vcos/pthreads -I/opt/vc/include/interface/vmcs_host/linux&#39; ./autogen.sh --with-omx-target=rpi&#xA;make CFLAGS+=&amp;quot;-Wno-error&amp;quot;&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Hardware-accelerated video playback on the Raspberry Pi&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://wiki.matthiasbock.net/index.php/Hardware-accelerated_video_playback_on_the_Raspberry_Pi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// add the following line to /etc/apt/sources.list&#xA;deb http://vontaene.de/raspbian-updates/ . main&#xA;&#xA;apt-get update&#xA;apt-get install libgstreamer1.0-0-dbg gstreamer1.0-tools libgstreamer-plugins-base1.0-0 \&#xA;  gstreamer1.0-plugins-good gstreamer1.0-plugins-bad-dbg gstreamer1.0-omx gstreamer1.0-alsa&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gst-launch-1.0 playbin uri=big_buck_bunny.avi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派中手动编译sdl_image无法加载jpeg解决方案</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%AD%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91sdl_image%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDjpeg%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>2018-11-01 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派中手动编译sdl_image无法加载jpeg解决方案&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如果你是因为忘记安装 libjpeg 造成 sdl2 image 无法加载 jpg 请离开 ....&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如果你不准备使用 opengl es 版本的 sdl2&#xA;或者你仅仅只是单独使用 sdl2 image 的&#xA;一条命令解决你的烦恼&#xA;apt-get install libsdl2-2.0-0 libsdl2-dev libsdl2-image-2.0-0 libsdl2-image-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如果你准备手动编译 opengl es 版本的 sdl2 和 sdl2 image 却发现 image 无法接在 jpg 或者 png ...&#xA;先自动安装 ...&#xA;apt-get install libsdl2-2.0-0 libsdl2-dev libsdl2-image-2.0-0 libsdl2-image-dev&#xA;然后手动编译 sdl2 .... ./configure ; make ; make install .... 等&#xA;&#xA;./configure --prefix=/usr/local \&#xA;   --disable-video-x11 \&#xA;   --disable-pulseaudio \&#xA;   --disable-esd \&#xA;   --disable-video-opengl&#xA;&#xA;安装完成后 ... &#xA;&#xA;通过 ldconfig 来控制使用 手动编译的 sdl2 和自动安装的 sdl2 image ...&#xA;&#xA;echo &amp;quot;/usr/local/lib&amp;quot; &amp;gt; /etc/ld.so.conf.d/00-sdl.conf &#xA;ldconfig &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;可能你觉得这并没有从根本解决问题，但是 ...&#xA;第一：我确定我安装了 libjpeg-dev（libjpeg8） &#xA;    /usr/include/jpeglib.h 和 /usr/lib/arm-linux-gnueabihf/libjpeg.so.8.4.0 也都存在 ...&#xA;第二：sdl image configure 也提示 libjpeg OK ...&#xA;    checking jpeglib.h usability... yes&#xA;    checking jpeglib.h presence... yes&#xA;    checking for jpeglib.h... yes&#xA;    checking for jpeg_CreateDecompress in -ljpeg... yes&#xA;    checking for LIBPNG... yes&#xA;第三：IMG_Init(IMG_INIT_JPG | IMG_INIT_PNG) 初始化成功 ...&#xA;    但是 IMG_Load 却报错 ... JPEG loading error&#xA;... 我还能做什么 ... 当然想办法找个现成能用的 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;就这么简单，就这么不走寻常路 ... &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之SDL2.0_OpenGLES_FFmpeg硬解视频播放</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8BSDL2.0_OpenGLES_FFmpeg%E7%A1%AC%E8%A7%A3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/</link>
      <pubDate>2018-10-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之SDL2.0_OpenGLES_FFmpeg硬解视频播放&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如何编译 FFmpeg h264_mmal 请看本博客对应博文&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开启声音需要提前安装 &#xA;apt-get install libasound2-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 首先下载好 SDL 2.0 源码等待编译&#xA;http://www.libsdl.org/download-2.0.php&#xA;&#xA;// 编译一版 OpenGL ES 的 SDL ...&#xA;./configure --prefix=/usr/local \&#xA;   --disable-video-x11 \&#xA;   --disable-pulseaudio \&#xA;   --disable-esd \&#xA;   --disable-video-opengl&#xA;&#xA;Enabled modules : atomic audio video render events joystick &#xA;            haptic sensor power filesystem threads &#xA;            timers file loadso cpuinfo assembly&#xA;Assembly Math   :&#xA;Audio drivers   : disk dummy oss alsa(dynamic)&#xA;Video drivers   : dummy rpi opengl_es1 opengl_es2 vulkan&#xA;Input drivers   : linuxev linuxkd&#xA;Using libsamplerate : NO&#xA;Using libudev       : NO&#xA;Using dbus          : NO&#xA;Using ime           : YES&#xA;Using ibus          : NO&#xA;Using fcitx         : NO&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install libgbm-dev&#xA;apt-get install libdrm-dev&#xA;apt-get install libasound2-dev&#xA;&#xA;./configure --prefix=/usr/local --disable-rpath --disable-video-directfb --disable-nas --disable-esd --disable-arts --disable-alsa-shared --disable-pulseaudio --disable-video-x11 --disable-video-opengl --disable-video-rpi --enable-video-kmsdrm&#xA;&#xA;Audio drivers   : disk dummy oss alsa&#xA;Video drivers   : dummy kmsdrm(dynamic) opengl_es2 vulkan&#xA;Input drivers   : linuxev linuxkd&#xA;Using libsamplerate : NO&#xA;Using libudev       : NO&#xA;Using dbus          : NO&#xA;Using ime           : YES&#xA;Using ibus          : NO&#xA;Using fcitx         : NO&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Windows 系统&#xA;// Qt FFmepg 与 SDL 导入到项目 ...&#xA;INCLUDEPATH += D:/FFmepg/dev/include&#xA;INCLUDEPATH += D:/FFmepg/SDL2/i686-w64-mingw32/include&#xA;LIBS += -lws2_32 -lopengl32 -lole32 -ldxguid -lglut32 -lglu32&#xA;LIBS += D:/FFmepg/dev/lib/libavcodec.dll.a \&#xA;  D:/FFmepg/dev/lib/libavdevice.dll.a \&#xA;  D:/FFmepg/dev/lib/libavfilter.dll.a \&#xA;  D:/FFmepg/dev/lib/libavformat.dll.a \&#xA;  D:/FFmepg/dev/lib/libavutil.dll.a \&#xA;  D:/FFmepg/dev/lib/libswresample.dll.a \&#xA;  D:/FFmepg/dev/lib/libswscale.dll.a \&#xA;  D:/FFmepg/dev/lib/libpostproc.dll.a&#xA;LIBS += D:/FFmepg/SDL2/i686-w64-mingw32/lib/libSDL2.dll.a \&#xA;D:/FFmepg/SDL2/i686-w64-mingw32/lib/libSDL2main.a&#xA;&#xA;// 树莓派 ...&#xA;INCLUDEPATH += /usr/local/include&#xA;LIBS += -lpthread -lm -ldl -lfreetype -lz -lrt&#xA;LIBS += -L/usr/local/lib -lavformat -lavcodec -lavutil -lswscale -lx264 -lSDL2 -lSDL2_image&#xA;LIBS += -L/opt/vc/lib -lmmal_core -lmmal_util -lmmal_vc_client -lbcm_host&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef CORE_H&#xA;#define CORE_H&#xA;&#xA;#include &amp;quot;decoder.h&amp;quot;&#xA;#include &amp;lt;QTime&amp;gt;&#xA;#include &amp;lt;QDebug&amp;gt;&#xA;&#xA;extern &amp;quot;C&amp;quot;&#xA;{&#xA;#include &amp;quot;SDL2/SDL.h&amp;quot;&#xA;}&#xA;&#xA;class Core&#xA;{&#xA;private:&#xA;    int screen_w=0,screen_h=0;&#xA;    SDL_Window *screen;&#xA;    SDL_Renderer* sdlRenderer;&#xA;    SDL_Texture* sdlTexture;&#xA;    SDL_Rect sdlRect;&#xA;    Decoder *m_decoder;&#xA;    int m_t_num = -1;&#xA;    QTime m_t_fps;&#xA;public:&#xA;    Core();&#xA;public:&#xA;    bool init();&#xA;    void show();&#xA;    void decoder(Decoder*);&#xA;};&#xA;&#xA;#endif // CORE_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;core.h&amp;quot;&#xA;&#xA;Core::Core()&#xA;{&#xA;&#xA;}&#xA;&#xA;void Core::decoder(Decoder *_decoder) {&#xA;    this-&amp;gt;m_decoder = _decoder;&#xA;}&#xA;&#xA;bool Core::init() {&#xA;&#xA;    if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {&#xA;    printf( &amp;quot;Could not initialize SDL - %s\n&amp;quot;, SDL_GetError());&#xA;    return -1;&#xA;    }&#xA;&#xA;    screen_w = this-&amp;gt;m_decoder-&amp;gt;pCodecCtx-&amp;gt;width;&#xA;    screen_h = this-&amp;gt;m_decoder-&amp;gt;pCodecCtx-&amp;gt;height;&#xA;    //SDL 2.0 Support for multiple windows&#xA;    screen = SDL_CreateWindow(&amp;quot;Simplest ffmpeg player&#39;s Window&amp;quot;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,&#xA;                  screen_w, screen_h,&#xA;                  SDL_WINDOW_OPENGL);&#xA;&#xA;    if(!screen) {&#xA;    printf(&amp;quot;SDL: could not create window - exiting:%s\n&amp;quot;,SDL_GetError());&#xA;    return -1;&#xA;    }&#xA;&#xA;    sdlRenderer = SDL_CreateRenderer(screen, -1, 0);&#xA;    //IYUV: Y + U + V  (3 planes)&#xA;    //YV12: Y + V + U  (3 planes)&#xA;    sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING,this-&amp;gt;m_decoder-&amp;gt;pCodecCtx-&amp;gt;width,this-&amp;gt;m_decoder-&amp;gt;pCodecCtx-&amp;gt;height);&#xA;&#xA;    sdlRect.x=0;&#xA;    sdlRect.y=0;&#xA;    sdlRect.w=screen_w;&#xA;    sdlRect.h=screen_h;&#xA;&#xA;    // Done ...&#xA;    return true;&#xA;&#xA;}&#xA;&#xA;void Core::show() {&#xA;&#xA;    this-&amp;gt;init();&#xA;&#xA;    while (1) {&#xA;&#xA;    int i = m_decoder-&amp;gt;m_frames-&amp;gt;size();&#xA;    if (i &amp;gt; 0)&#xA;    {&#xA;        Frame front = m_decoder-&amp;gt;m_frames-&amp;gt;front();&#xA;&#xA;#if 0&#xA;        SDL_UpdateTexture( sdlTexture, NULL, front.frame-&amp;gt;data[0], front.frame-&amp;gt;linesize[0] );&#xA;#else&#xA;        SDL_UpdateYUVTexture(sdlTexture, &amp;amp;sdlRect,&#xA;                 front.frame-&amp;gt;data[0], front.frame-&amp;gt;linesize[0],&#xA;            front.frame-&amp;gt;data[1], front.frame-&amp;gt;linesize[1],&#xA;            front.frame-&amp;gt;data[2], front.frame-&amp;gt;linesize[2]);&#xA;#endif&#xA;&#xA;        SDL_RenderClear( sdlRenderer );&#xA;        SDL_RenderCopy( sdlRenderer, sdlTexture,  NULL, &amp;amp;sdlRect);&#xA;        SDL_RenderPresent( sdlRenderer );&#xA;&#xA;    }&#xA;    if (i &amp;gt; 1)&#xA;    {&#xA;        m_decoder-&amp;gt;m_frames-&amp;gt;pop();&#xA;    }&#xA;&#xA;    if (m_t_num == -1 || m_t_fps.elapsed() &amp;gt; 1000) {&#xA;        qreal fps = m_t_num * 1000.0 / m_t_fps.elapsed();&#xA;        // m_log-&amp;gt;debug();&#xA;        qDebug(QString(&amp;quot;-&amp;gt; FPS -&amp;gt; %1&amp;quot;).arg(fps).toStdString().c_str());&#xA;        m_t_fps.start();&#xA;        m_t_num = 0;&#xA;    }&#xA;    m_t_num++;&#xA;&#xA;    //Delay 40ms&#xA;    SDL_Delay(33);&#xA;&#xA;    }&#xA;    SDL_Quit();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef DECODER_H&#xA;#define DECODER_H&#xA;&#xA;#include &amp;lt;QDebug&amp;gt;&#xA;#include &amp;lt;QThread&amp;gt;&#xA;#include &amp;lt;QRunnable&amp;gt;&#xA;#include &amp;lt;QScopedPointer&amp;gt;&#xA;#include &amp;lt;QImage&amp;gt;&#xA;#include &amp;quot;frames.h&amp;quot;&#xA;&#xA;extern &amp;quot;C&amp;quot;&#xA;{&#xA;#include &amp;quot;libavcodec/avcodec.h&amp;quot;&#xA;#include &amp;quot;libavformat/avformat.h&amp;quot;&#xA;#include &amp;quot;libswscale/swscale.h&amp;quot;&#xA;#include &amp;quot;libavutil/imgutils.h&amp;quot;&#xA;}&#xA;&#xA;class Decoder : public QRunnable&#xA;{&#xA;public:&#xA;    Decoder();&#xA;    ~Decoder();&#xA;    void run();&#xA;    bool create();&#xA;public:&#xA;    AVFormatContext *pFormatCtx;&#xA;    AVCodecContext  *pCodecCtx;&#xA;    AVCodec     *pCodec;&#xA;    int videoindex;&#xA;public:&#xA;    QScopedPointer&amp;lt;Frames&amp;gt; m_frames;&#xA;};&#xA;&#xA;#endif // DECODER_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;decoder.h&amp;quot;&#xA;&#xA;Decoder::Decoder()&#xA;{&#xA;    m_frames.reset(new Frames());&#xA;}&#xA;&#xA;Decoder::~Decoder()&#xA;{&#xA;}&#xA;&#xA;bool Decoder::create()&#xA;{&#xA;    av_register_all();&#xA;    avformat_network_init();&#xA;&#xA;    pFormatCtx = avformat_alloc_context();&#xA;&#xA;    if(avformat_open_input(&amp;amp;pFormatCtx, &amp;quot;E:/1111.mp4&amp;quot;, nullptr, nullptr) != 0){&#xA;    printf(&amp;quot;Couldn&#39;t open input stream.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    if(avformat_find_stream_info(pFormatCtx, nullptr) &amp;lt; 0){&#xA;    printf(&amp;quot;Couldn&#39;t find stream information.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    videoindex = -1;&#xA;    for(int i = 0; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; i++) {&#xA;    if(pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) {&#xA;        videoindex = i;&#xA;        break;&#xA;    }&#xA;    }&#xA;    if(videoindex == -1) {&#xA;    printf(&amp;quot;Didn&#39;t find a video stream.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // --------------------------------- //&#xA;    AVCodec* currentCodec = nullptr;&#xA;    currentCodec = av_codec_next(currentCodec);&#xA;    while (currentCodec != nullptr) {&#xA;    if (av_codec_is_encoder(currentCodec)) {&#xA;        // m_log-&amp;gt;debug(QString(&amp;quot;Encoder -&amp;gt; %1 %2&amp;quot;).arg(currentCodec-&amp;gt;name).arg(currentCodec-&amp;gt;long_name));&#xA;    }&#xA;    if (av_codec_is_decoder(currentCodec)) {&#xA;        // m_log-&amp;gt;debug(QString(&amp;quot;Decoder -&amp;gt; %1 %2&amp;quot;).arg(currentCodec-&amp;gt;name).arg(currentCodec-&amp;gt;long_name));&#xA;    }&#xA;    currentCodec = av_codec_next(currentCodec);&#xA;    }&#xA;    // --------------------------------- //&#xA;&#xA;    pCodecCtx = pFormatCtx-&amp;gt;streams[videoindex]-&amp;gt;codec;&#xA;&#xA;#ifdef Q_OS_LINUX&#xA;    pCodec = avcodec_find_decoder_by_name(&amp;quot;h264_mmal&amp;quot;);&#xA;#endif&#xA;&#xA;#ifdef Q_OS_WIN&#xA;    pCodec = avcodec_find_decoder(pCodecCtx-&amp;gt;codec_id);&#xA;#endif&#xA;&#xA;    if(pCodec == nullptr) {&#xA;    printf(&amp;quot;Codec not found.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    if(avcodec_open2(pCodecCtx, pCodec, nullptr) &amp;lt; 0) {&#xA;    printf(&amp;quot;Could not open codec.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // printf(&amp;quot;--------------- File Information ----------------\n&amp;quot;);&#xA;    // av_dump_format(pFormatCtx, 0, &amp;quot;PICT0023.AVI&amp;quot;, 0);&#xA;    // printf(&amp;quot;-------------------------------------------------\n&amp;quot;);&#xA;&#xA;    return true;&#xA;}&#xA;&#xA;void Decoder::run()&#xA;{&#xA;&#xA;    this-&amp;gt;create();&#xA;&#xA;    AVFrame *pFrame = av_frame_alloc();&#xA;    // AVFrame *pFrameYUV = av_frame_alloc();&#xA;    // AVFrame *pFrameRGB = av_frame_alloc();&#xA;&#xA;    // int numBytes = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1);&#xA;    // unsigned char *out_buffer = (unsigned char *)av_malloc(numBytes);&#xA;    // unsigned char *rgb_buffer = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_RGB32, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1));&#xA;    // av_image_fill_arrays(pFrameYUV-&amp;gt;data, pFrameYUV-&amp;gt;linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1);&#xA;    // av_image_fill_arrays(pFrameRGB-&amp;gt;data, pFrameRGB-&amp;gt;linesize, rgb_buffer, AV_PIX_FMT_RGB32, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1);&#xA;    // static struct SwsContext *img_convert_ctx_yuv = sws_getContext(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, pCodecCtx-&amp;gt;pix_fmt, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, nullptr, nullptr, nullptr);&#xA;    // static struct SwsContext *img_convert_ctx_rgb = sws_getContext(pCodecCtx-&amp;gt;width,pCodecCtx-&amp;gt;height, AV_PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, AV_PIX_FMT_RGB32, SWS_BICUBIC, nullptr, nullptr, nullptr);&#xA;&#xA;    AVPacket *packet = (AVPacket *)av_malloc(sizeof(AVPacket));&#xA;&#xA;    int count = 0;&#xA;    while (av_read_frame(pFormatCtx, packet) &amp;gt;= 0) {&#xA;    if(packet-&amp;gt;stream_index == videoindex) {&#xA;        for(;;)&#xA;        {&#xA;        int size = m_frames-&amp;gt;size();&#xA;        if (size &amp;lt; 10) {&#xA;            break;&#xA;        }&#xA;        QThread::msleep(10);&#xA;        }&#xA;        // For decoding, call avcodec_send_packet() to give the decoder raw compressed data in an AVPacket.&#xA;        int frameFinished = avcodec_send_packet(pCodecCtx, packet);&#xA;        while (!frameFinished) {&#xA;        // For decoding, call avcodec_receive_frame(). On success, it will return an AVFrame containing uncompressed audio or video data.&#xA;        frameFinished = avcodec_receive_frame(pCodecCtx, pFrame);&#xA;        if (!frameFinished) {&#xA;            // m_log-&amp;gt;debug(QString(&amp;quot;%1 %2&amp;quot;).arg(pFrame-&amp;gt;format == AV_PIX_FMT_YUV420P ? &amp;quot;OK&amp;quot; : &amp;quot;NO&amp;quot;).arg(count));&#xA;            // -----------------------------------------------&#xA;            // sws_scale(img_convert_ctx_yuv, (const uint8_t* const*)pFrame-&amp;gt;data, pFrame-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height, pFrameYUV-&amp;gt;data, pFrameYUV-&amp;gt;linesize);&#xA;            // sws_scale(img_convert_ctx_rgb, pFrameYUV-&amp;gt;data, pFrameYUV-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height, pFrameRGB-&amp;gt;data, pFrameRGB-&amp;gt;linesize);&#xA;            // QImage img((uchar *)pFrameRGB-&amp;gt;data[0], pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, QImage::Format_ARGB32);&#xA;            m_frames-&amp;gt;push(Frame(av_frame_clone(pFrame), count));&#xA;            count++;&#xA;            // -----------------------------------------------&#xA;            av_frame_unref(pFrame);&#xA;        }&#xA;        }&#xA;    }&#xA;    av_packet_unref(packet);&#xA;    }&#xA;&#xA;    // av_free(rgb_buffer);&#xA;    // sws_freeContext(img_convert_ctx_rgb);&#xA;    // av_frame_free(&amp;amp;pFrameRGB);&#xA;    // av_free(out_buffer);&#xA;    // sws_freeContext(img_convert_ctx_yuv);&#xA;    // av_frame_free(&amp;amp;pFrameYUV);&#xA;    av_frame_free(&amp;amp;pFrame);&#xA;    avcodec_close(pCodecCtx);&#xA;    avformat_close_input(&amp;amp;pFormatCtx);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之QOpenGLWidget使用QPainter绘制FFmpeg解码的YUV420P帧</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8BQOpenGLWidget%E4%BD%BF%E7%94%A8QPainter%E7%BB%98%E5%88%B6FFmpeg%E8%A7%A3%E7%A0%81%E7%9A%84YUV420P%E5%B8%A7/</link>
      <pubDate>2018-10-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qt之QOpenGLWidget使用QPainter绘制FFmpeg解码的YUV420P帧&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef GLWIDGET_H&#xA;#define GLWIDGET_H&#xA;&#xA;#include &amp;lt;QOpenGLWidget&amp;gt;&#xA;#include &amp;lt;QPainter&amp;gt;&#xA;#include &amp;lt;QDebug&amp;gt;&#xA;#include &amp;lt;QTimer&amp;gt;&#xA;#include &amp;lt;QTime&amp;gt;&#xA;#include &amp;lt;QString&amp;gt;&#xA;#include &amp;lt;QtDebug&amp;gt;&#xA;#include &amp;quot;decoder.h&amp;quot;&#xA;&#xA;class GLWidget : public QOpenGLWidget&#xA;{&#xA;    Q_OBJECT&#xA;public:&#xA;    GLWidget();&#xA;    ~GLWidget() override;&#xA;    void decoder(Decoder*);&#xA;private:&#xA;    QTimer *m_t_update = nullptr;&#xA;    Decoder *m_decoder = nullptr;&#xA;    int m_t_num = -1;&#xA;    QTime m_t_fps;&#xA;public slots:&#xA;    void uuu();&#xA;&#xA;protected:&#xA;    void paintEvent(QPaintEvent *event) override;&#xA;};&#xA;&#xA;#endif // GLWIDGET_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;glwidget.h&amp;quot;&#xA;&#xA;GLWidget::GLWidget()&#xA;{&#xA;    this-&amp;gt;m_t_update = new QTimer(this);&#xA;    connect(m_t_update, SIGNAL(timeout()), this, SLOT(uuu()));&#xA;    m_t_update-&amp;gt;start(10);&#xA;}&#xA;&#xA;GLWidget::~GLWidget()&#xA;{&#xA;}&#xA;&#xA;void GLWidget::uuu()&#xA;{&#xA;    update();&#xA;}&#xA;&#xA;void GLWidget::decoder(Decoder* _decoder)&#xA;{&#xA;    this-&amp;gt;m_decoder = _decoder;&#xA;}&#xA;&#xA;void GLWidget::paintEvent(QPaintEvent *event)&#xA;{&#xA;    int i = m_decoder-&amp;gt;m_frames-&amp;gt;size();&#xA;    if (i &amp;gt; 0)&#xA;    {&#xA;    Frame frame = m_decoder-&amp;gt;m_frames-&amp;gt;front();&#xA;    QPainter painter;&#xA;    painter.begin(this);&#xA;    painter.setRenderHint(QPainter::Antialiasing);&#xA;    painter.drawImage(QRect(0,0, 1920,1080), frame.frame);&#xA;    painter.end();&#xA;    }&#xA;    if (i &amp;gt; 0)&#xA;    {&#xA;    m_decoder-&amp;gt;m_frames-&amp;gt;pop();&#xA;    }&#xA;    if (m_t_num == -1 || m_t_fps.elapsed() &amp;gt; 1000) {&#xA;    qreal fps = m_t_num * 1000.0 / m_t_fps.elapsed();&#xA;    qDebug(QString(&amp;quot;-&amp;gt; FPS -&amp;gt; %1&amp;quot;).arg(fps).toStdString().c_str());&#xA;    m_t_fps.start();&#xA;    m_t_num = 0;&#xA;    }&#xA;    m_t_num++;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef DECODER_H&#xA;#define DECODER_H&#xA;&#xA;#include &amp;lt;QDebug&amp;gt;&#xA;#include &amp;lt;QThread&amp;gt;&#xA;#include &amp;lt;QRunnable&amp;gt;&#xA;#include &amp;lt;QScopedPointer&amp;gt;&#xA;#include &amp;lt;QImage&amp;gt;&#xA;#include &amp;quot;frames.h&amp;quot;&#xA;&#xA;extern &amp;quot;C&amp;quot;&#xA;{&#xA;#include &amp;quot;libavcodec/avcodec.h&amp;quot;&#xA;#include &amp;quot;libavformat/avformat.h&amp;quot;&#xA;#include &amp;quot;libswscale/swscale.h&amp;quot;&#xA;#include &amp;quot;libavutil/imgutils.h&amp;quot;&#xA;}&#xA;&#xA;class Decoder : public QRunnable&#xA;{&#xA;public:&#xA;    Decoder();&#xA;    ~Decoder();&#xA;    void run();&#xA;    bool create();&#xA;public:&#xA;    AVFormatContext *pFormatCtx;&#xA;    AVCodecContext  *pCodecCtx;&#xA;    AVCodec     *pCodec;&#xA;    int videoindex;&#xA;public:&#xA;    QScopedPointer&amp;lt;Frames&amp;gt; m_frames;&#xA;};&#xA;&#xA;#endif // DECODER_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;decoder.h&amp;quot;&#xA;&#xA;Decoder::Decoder()&#xA;{&#xA;    m_frames.reset(new Frames());&#xA;}&#xA;&#xA;Decoder::~Decoder()&#xA;{&#xA;}&#xA;&#xA;bool Decoder::create()&#xA;{&#xA;    av_register_all();&#xA;    avformat_network_init();&#xA;&#xA;    pFormatCtx = avformat_alloc_context();&#xA;&#xA;    if(avformat_open_input(&amp;amp;pFormatCtx, &amp;quot;E:/1111.mp4&amp;quot;, nullptr, nullptr) != 0){&#xA;    printf(&amp;quot;Couldn&#39;t open input stream.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    if(avformat_find_stream_info(pFormatCtx, nullptr) &amp;lt; 0){&#xA;    printf(&amp;quot;Couldn&#39;t find stream information.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    videoindex = -1;&#xA;    for(int i = 0; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; i++) {&#xA;    if(pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) {&#xA;        videoindex = i;&#xA;        break;&#xA;    }&#xA;    }&#xA;    if(videoindex == -1) {&#xA;    printf(&amp;quot;Didn&#39;t find a video stream.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // --------------------------------- //&#xA;    AVCodec* currentCodec = nullptr;&#xA;    currentCodec = av_codec_next(currentCodec);&#xA;    while (currentCodec != nullptr) {&#xA;    if (av_codec_is_encoder(currentCodec)) {&#xA;        // m_log-&amp;gt;debug(QString(&amp;quot;Encoder -&amp;gt; %1 %2&amp;quot;).arg(currentCodec-&amp;gt;name).arg(currentCodec-&amp;gt;long_name));&#xA;    }&#xA;    if (av_codec_is_decoder(currentCodec)) {&#xA;        // m_log-&amp;gt;debug(QString(&amp;quot;Decoder -&amp;gt; %1 %2&amp;quot;).arg(currentCodec-&amp;gt;name).arg(currentCodec-&amp;gt;long_name));&#xA;    }&#xA;    currentCodec = av_codec_next(currentCodec);&#xA;    }&#xA;    // --------------------------------- //&#xA;&#xA;    pCodecCtx = pFormatCtx-&amp;gt;streams[videoindex]-&amp;gt;codec;&#xA;    pCodec = avcodec_find_decoder(pCodecCtx-&amp;gt;codec_id);&#xA;    if(pCodec == nullptr) {&#xA;    printf(&amp;quot;Codec not found.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    if(avcodec_open2(pCodecCtx, pCodec, nullptr) &amp;lt; 0) {&#xA;    printf(&amp;quot;Could not open codec.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // printf(&amp;quot;--------------- File Information ----------------\n&amp;quot;);&#xA;    // av_dump_format(pFormatCtx, 0, &amp;quot;PICT0023.AVI&amp;quot;, 0);&#xA;    // printf(&amp;quot;-------------------------------------------------\n&amp;quot;);&#xA;&#xA;    return true;&#xA;}&#xA;&#xA;void Decoder::run()&#xA;{&#xA;&#xA;    this-&amp;gt;create();&#xA;&#xA;    AVFrame *pFrame = av_frame_alloc();&#xA;    AVFrame *pFrameYUV = av_frame_alloc();&#xA;    AVFrame *pFrameRGB = av_frame_alloc();&#xA;&#xA;    int numBytes = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1);&#xA;    unsigned char *out_buffer = (unsigned char *)av_malloc(numBytes);&#xA;    unsigned char *rgb_buffer = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_RGB32, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1));&#xA;    av_image_fill_arrays(pFrameYUV-&amp;gt;data, pFrameYUV-&amp;gt;linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1);&#xA;    av_image_fill_arrays(pFrameRGB-&amp;gt;data, pFrameRGB-&amp;gt;linesize, rgb_buffer, AV_PIX_FMT_RGB32, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 1);&#xA;    static struct SwsContext *img_convert_ctx_yuv = sws_getContext(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, pCodecCtx-&amp;gt;pix_fmt, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, nullptr, nullptr, nullptr);&#xA;    static struct SwsContext *img_convert_ctx_rgb = sws_getContext(pCodecCtx-&amp;gt;width,pCodecCtx-&amp;gt;height, AV_PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, AV_PIX_FMT_RGB32, SWS_BICUBIC, nullptr, nullptr, nullptr);&#xA;&#xA;    AVPacket *packet = (AVPacket *)av_malloc(sizeof(AVPacket));&#xA;&#xA;    int count = 0;&#xA;    while (av_read_frame(pFormatCtx, packet) &amp;gt;= 0) {&#xA;    if(packet-&amp;gt;stream_index == videoindex) {&#xA;        for(;;)&#xA;        {&#xA;        int size = m_frames-&amp;gt;size();&#xA;        if (size &amp;lt; 10) {&#xA;            break;&#xA;        }&#xA;        QThread::msleep(10);&#xA;        }&#xA;        // For decoding, call avcodec_send_packet() to give the decoder raw compressed data in an AVPacket.&#xA;        int frameFinished = avcodec_send_packet(pCodecCtx, packet);&#xA;        while (!frameFinished) {&#xA;        // For decoding, call avcodec_receive_frame(). On success, it will return an AVFrame containing uncompressed audio or video data.&#xA;        frameFinished = avcodec_receive_frame(pCodecCtx, pFrame);&#xA;        if (!frameFinished) {&#xA;            // m_log-&amp;gt;debug(QString(&amp;quot;%1 %2&amp;quot;).arg(pFrame-&amp;gt;format == AV_PIX_FMT_YUV420P ? &amp;quot;OK&amp;quot; : &amp;quot;NO&amp;quot;).arg(count));&#xA;            // -----------------------------------------------&#xA;            sws_scale(img_convert_ctx_yuv, (const uint8_t* const*)pFrame-&amp;gt;data, pFrame-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height, pFrameYUV-&amp;gt;data, pFrameYUV-&amp;gt;linesize);&#xA;            sws_scale(img_convert_ctx_rgb, pFrameYUV-&amp;gt;data, pFrameYUV-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height, pFrameRGB-&amp;gt;data, pFrameRGB-&amp;gt;linesize);&#xA;            QImage img((uchar *)pFrameRGB-&amp;gt;data[0], pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, QImage::Format_ARGB32);&#xA;            m_frames-&amp;gt;push(Frame(img.copy(), count));&#xA;            count++;&#xA;            // -----------------------------------------------&#xA;            av_frame_unref(pFrame);&#xA;        }&#xA;        }&#xA;    }&#xA;    av_packet_unref(packet);&#xA;    }&#xA;&#xA;    av_free(out_buffer);&#xA;    av_free(rgb_buffer);&#xA;    sws_freeContext(img_convert_ctx_yuv);&#xA;    sws_freeContext(img_convert_ctx_rgb);&#xA;    av_frame_free(&amp;amp;pFrameYUV);&#xA;    av_frame_free(&amp;amp;pFrameRGB);&#xA;    av_frame_free(&amp;amp;pFrame);&#xA;    avcodec_close(pCodecCtx);&#xA;    avformat_close_input(&amp;amp;pFormatCtx);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>FFmpeg之从MP4提取H264裸流</title>
      <link>http://www.nljb.net/default/FFmpeg%E4%B9%8B%E4%BB%8EMP4%E6%8F%90%E5%8F%96H264%E8%A3%B8%E6%B5%81/</link>
      <pubDate>2018-09-27 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FFmpeg之从MP4提取H264裸流&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// mp4 转 h264 裸码流&#xA;ffmpeg -i input.mp4 -vcodec h264 output.h264&#xA;// Video: h264, yuv420p(tv, bt709, progressive)&#xA;ffmpeg.exe -i input.mp4 -color_primaries bt709 -color_trc bt709 -colorspace bt709 output.h264&#xA;// Video: h264, yuv420p(progressive)&#xA;ffmpeg -i input_file.avi -vcodec copy -an -bsf:v h264_mp4toannexb output_file.h264&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef DECODER_H&#xA;#define DECODER_H&#xA;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;QDebug&amp;gt;&#xA;#include &amp;lt;QRunnable&amp;gt;&#xA;#include &amp;lt;QThread&amp;gt;&#xA;&#xA;extern &amp;quot;C&amp;quot;&#xA;{&#xA;#include &amp;quot;libavcodec/avcodec.h&amp;quot;&#xA;#include &amp;quot;libavformat/avformat.h&amp;quot;&#xA;#include &amp;quot;libswscale/swscale.h&amp;quot;&#xA;#include &amp;quot;libavutil/imgutils.h&amp;quot;&#xA;}&#xA;&#xA;class Decoder : public QRunnable&#xA;{&#xA;public:&#xA;    Decoder();&#xA;    ~Decoder();&#xA;    void run();&#xA;    bool create();&#xA;private:&#xA;    Log4Qt::Logger *m_log;&#xA;    AVFormatContext *pFormatCtx;&#xA;    AVBitStreamFilterContext* h264bsfc;&#xA;    int videoindex;&#xA;};&#xA;#endif // DECODER_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;decoder.h&amp;quot;&#xA;&#xA;Decoder::Decoder()&#xA;{&#xA;}&#xA;&#xA;Decoder::~Decoder()&#xA;{&#xA;}&#xA;&#xA;bool Decoder::create()&#xA;{&#xA;    // qDebug() &amp;lt;&amp;lt; avcodec_configuration();&#xA;    Runtime::m_decoder_mutex.lock();&#xA;&#xA;    av_register_all();&#xA;    avformat_network_init();&#xA;&#xA;    pFormatCtx = avformat_alloc_context();&#xA;&#xA;    if(avformat_open_input(&amp;amp;pFormatCtx, &amp;quot;E:/1111.mp4&amp;quot;, NULL, NULL) != 0){&#xA;    printf(&amp;quot;Couldn&#39;t open input stream.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    if(avformat_find_stream_info(pFormatCtx, NULL) &amp;lt; 0){&#xA;    printf(&amp;quot;Couldn&#39;t find stream information.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    videoindex = -1;&#xA;    for(int i = 0; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; i++) {&#xA;    if(pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) {&#xA;        videoindex = i;&#xA;        break;&#xA;    }&#xA;    }&#xA;    if(videoindex == -1) {&#xA;    printf(&amp;quot;Didn&#39;t find a video stream.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    h264bsfc = av_bitstream_filter_init(&amp;quot;h264_mp4toannexb&amp;quot;);&#xA;    if(h264bsfc == NULL) {&#xA;    printf(&amp;quot;h264bsfc not found.\n&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // --------------------------------- //&#xA;    AVCodec* currentCodec = NULL;&#xA;    currentCodec = av_codec_next(currentCodec);&#xA;    while (currentCodec != NULL) {&#xA;    if (av_codec_is_encoder(currentCodec)) {&#xA;        cout &amp;lt;&amp;lt; currentCodec-&amp;gt;name &amp;lt;&amp;lt; &amp;quot;\t&amp;quot; &amp;lt;&amp;lt; currentCodec-&amp;gt;long_name &amp;lt;&amp;lt; endl;&#xA;    }&#xA;    currentCodec = av_codec_next(currentCodec);&#xA;    }&#xA;    // --------------------------------- //&#xA;&#xA;    Runtime::m_decoder_mutex.unlock();&#xA;    return true;&#xA;}&#xA;&#xA;#ifdef Q_OS_LINUX // Linux&#xA;&#xA;#endif&#xA;&#xA;#ifdef Q_OS_WIN // Windows 10&#xA;&#xA;void Decoder::run()&#xA;{&#xA;&#xA;    this-&amp;gt;create();&#xA;&#xA;    AVPacket *packet = (AVPacket *)av_malloc(sizeof(AVPacket));&#xA;&#xA;    FILE *fp=fopen(&amp;quot;test.264&amp;quot;,&amp;quot;ab&amp;quot;);&#xA;&#xA;    int count = 0;&#xA;    while(av_read_frame(pFormatCtx, packet) &amp;gt;= 0)&#xA;    {&#xA;    av_bitstream_filter_filter(h264bsfc, pFormatCtx-&amp;gt;streams[videoindex]-&amp;gt;codec, NULL, &amp;amp;packet-&amp;gt;data, &amp;amp;packet-&amp;gt;size, packet-&amp;gt;data, packet-&amp;gt;size, 0);&#xA;    fwrite(packet-&amp;gt;data, 1, packet-&amp;gt;size, fp);&#xA;    count++;&#xA;    av_free_packet(packet);&#xA;    }&#xA;&#xA;    av_bitstream_filter_close(h264bsfc);&#xA;    avformat_close_input(&amp;amp;pFormatCtx);&#xA;&#xA;}&#xA;&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之部署QT与FFmpeg硬解开发环境</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E9%83%A8%E7%BD%B2QT%E4%B8%8EFFmpeg%E7%A1%AC%E8%A7%A3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>2018-09-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;树莓派之部署QT与FFmpeg硬解开发环境&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装 QT&#xA;sudo apt-get update&#xA;sudo apt-get install qt5-default&#xA;sudo apt-get install qtcreator&#xA;sudo apt-get install qtdeclarative5-dev // QML&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 需要自己手动配置构建套件，配置qmake，gcc，g++，gdb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FFmpeg 编译 及 支持 x264 &amp;hellip;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装 GIT&#xA;sudo apt-get update&#xA;sudo apt-get install git&#xA;&#xA;// 创建 config_x264_rpi.sh&#xA;#!/bin/sh&#xA;./configure \&#xA;--enable-shared \&#xA;--enable-static \&#xA;--enable-strip \&#xA;--disable-cli&#xA;&#xA;git clone git://git.videolan.org/x264.git&#xA;cd x264&#xA;mv ../config_x264_rpi.sh ./&#xA;chmod +x config_x264_rpi.sh&#xA;./config_x264_rpi.sh&#xA;make -j4&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试&#xA;./configure --prefix=/usr/local --enable-shared --disable-static --enable-strip --disable-cli&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载 http://ffmpeg.org/releases/ -&amp;gt; 3.4.4&#xA;sudo apt-get install libomxil-bellagio-dev &#xA;&#xA;// 解压后进入 ffmepg 目录 ...&#xA;// 创建 config_ffmepg_rpi.sh&#xA;#!/bin/sh&#xA;PREFIX=/usr/local&#xA;./configure \&#xA;--enable-gpl    --enable-version3 --enable-nonfree \&#xA;--enable-static --disable-shared \&#xA;\&#xA;--prefix=$PREFIX \&#xA;\&#xA;--disable-opencl \&#xA;--disable-thumb \&#xA;--disable-pic \&#xA;--disable-stripping \&#xA;\&#xA;--enable-small \&#xA;\&#xA;--enable-ffmpeg \&#xA;--enable-ffplay \&#xA;--enable-ffserver \&#xA;--enable-ffprobe \&#xA;\&#xA;--disable-doc \&#xA;--disable-htmlpages \&#xA;--disable-podpages \&#xA;--disable-txtpages \&#xA;--disable-manpages \&#xA;\&#xA;--disable-everything \&#xA;\&#xA;--enable-libx264 \&#xA;--enable-encoder=libx264 \&#xA;--enable-decoder=h264 \&#xA;--enable-encoder=aac \&#xA;--enable-decoder=aac \&#xA;--enable-encoder=ac3 \&#xA;--enable-decoder=ac3 \&#xA;--enable-encoder=rawvideo \&#xA;--enable-decoder=rawvideo \&#xA;--enable-encoder=mjpeg \&#xA;--enable-decoder=mjpeg \&#xA;\&#xA;--enable-demuxer=concat \&#xA;--enable-muxer=flv \&#xA;--enable-demuxer=flv \&#xA;--enable-demuxer=live_flv \&#xA;--enable-muxer=hls \&#xA;--enable-muxer=segment \&#xA;--enable-muxer=stream_segment \&#xA;--enable-muxer=mov \&#xA;--enable-demuxer=mov \&#xA;--enable-muxer=mp4 \&#xA;--enable-muxer=mpegts \&#xA;--enable-demuxer=mpegts \&#xA;--enable-demuxer=mpegvideo \&#xA;--enable-muxer=matroska \&#xA;--enable-demuxer=matroska \&#xA;--enable-muxer=wav \&#xA;--enable-demuxer=wav \&#xA;--enable-muxer=pcm* \&#xA;--enable-demuxer=pcm* \&#xA;--enable-muxer=rawvideo \&#xA;--enable-demuxer=rawvideo \&#xA;--enable-muxer=rtsp \&#xA;--enable-demuxer=rtsp \&#xA;--enable-muxer=rtsp \&#xA;--enable-demuxer=sdp \&#xA;--enable-muxer=fifo \&#xA;--enable-muxer=tee \&#xA;\&#xA;--enable-parser=h264 \&#xA;--enable-parser=aac \&#xA;\&#xA;--enable-protocol=file \&#xA;--enable-protocol=tcp \&#xA;--enable-protocol=rtmp \&#xA;--enable-protocol=cache \&#xA;--enable-protocol=pipe \&#xA;\&#xA;--enable-filter=aresample \&#xA;--enable-filter=allyuv \&#xA;--enable-filter=scale \&#xA;--enable-libfreetype \&#xA;\&#xA;--enable-indev=v4l2 \&#xA;--enable-indev=alsa \&#xA;\&#xA;--enable-omx \&#xA;--enable-omx-rpi \&#xA;--enable-encoder=h264_omx \&#xA;\&#xA;--enable-mmal \&#xA;--enable-hwaccel=h264_mmal \&#xA;--enable-decoder=h264_mmal \&#xA;\&#xA;&#xA;// 编译 ..&#xA;chmod +x config_ffmpeg_rpi.sh&#xA;./config_ffmpeg_rpi.sh&#xA;make -j4&#xA;sudo make install&#xA;&#xA;// 输入ffmpeg并回车其中有h264_omx和h264_mmal字样&#xA;// 说明ffmpeg已支持树莓派的H.264硬件编解码器。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 补充：如果需要 avformat_open_input .264 格式流需要增加&#xA;--enable-demuxer=h264&#xA;--enable-demuxer=aac // open input aac&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试&#xA;./configure --prefix=/usr/local --enable-version3 --enable-nonfree --enable-gpl --disable-static --enable-shared --enable-libx264 --enable-encoder=libx264 --enable-decoder=h264 --enable-encoder=aac --enable-decoder=aac --enable-omx --enable-omx-rpi --enable-encoder=h264_omx --enable-mmal --enable-hwaccel=h264_mmal --enable-decoder=h264_mmal &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// FFmpeg License and Legal Considerations&#xA;./configure --prefix=/usr/local --enable-version3 --disable-static --enable-shared --enable-decoder=h264 --enable-encoder=aac --enable-decoder=aac --enable-omx --enable-omx-rpi --enable-encoder=h264_omx --enable-mmal --enable-hwaccel=h264_mmal --enable-decoder=h264_mmal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ffmpeg 3.4.7&#xA;&#xA;./configure \&#xA;    --prefix=/usr/local \&#xA;    --enable-version3 \&#xA;    --disable-static \&#xA;    --enable-shared \&#xA;    \&#xA;    --enable-demuxer=mov \&#xA;    --enable-demuxer=rtsp \&#xA;    --enable-demuxer=sdp \&#xA;    \&#xA;    --enable-decoder=h264 \&#xA;    --enable-decoder=aac \&#xA;    \&#xA;    --enable-omx \&#xA;    --enable-omx-rpi \&#xA;    --enable-encoder=h264_omx \&#xA;    \&#xA;    --enable-mmal \&#xA;    --enable-hwaccel=h264_mmal \&#xA;    --enable-decoder=h264_mmal \&#xA;    --enable-hwaccel=mpeg4_mmal \&#xA;    --enable-decoder=mpeg4_mmal \&#xA;    \&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 引用 FFmepg 库 -&amp;gt; xxx.pro&#xA;LIBS+=-L/usr/local/lib -lavformat -lavcodec -lavutil -lx264 &#xA;LIBS+=-lpthread -lm -ldl -lfreetype -lz &#xA;LIBS+=-L/opt/vc/lib -lmmal_core -lmmal_util -lmmal_vc_client -lbcm_host &#xA;INCLUDEPATH+=/usr/local/include &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试&#xA;extern &amp;quot;C&amp;quot;&#xA;{&#xA;    #include &amp;quot;libavcodec/avcodec.h&amp;quot;&#xA;    #include &amp;quot;libavformat/avformat.h&amp;quot;&#xA;    #include &amp;quot;libswscale/swscale.h&amp;quot;&#xA;}&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QApplication a(argc, argv);&#xA;    qDebug() &amp;lt;&amp;lt; avcodec_configuration();&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/popcornmix/FFmpeg/tree/2711&#xA;&#xA;RPI_TOOLROOT=/usr&#xA;RPI_OPT_VC=/opt/vc&#xA;&#xA;RPI_INCLUDES=&amp;quot;-I$RPI_OPT_VC/include -I$RPI_OPT_VC/include/interface/vcos/pthreads -I$RPI_OPT_VC/include/interface/vmcs_host/linux&amp;quot;&#xA;RPI_DEFS=&amp;quot;-D__VCCOREVER__=0x04000000 -DRPI_DISPLAY=1&amp;quot;&#xA;RPI_LIBDIRS=&amp;quot;-L$RPI_TOOLROOT/lib -L$RPI_OPT_VC/lib&amp;quot;&#xA;#RPI_KEEPS=&amp;quot;-save-temps=obj&amp;quot;&#xA;RPI_KEEPS=&amp;quot;&amp;quot;&#xA;&#xA;./configure --enable-cross-compile\&#xA; --arch=armv6t2\&#xA; --cpu=cortex-a7\&#xA; --target-os=linux\&#xA; --disable-stripping\&#xA; --disable-thumb\&#xA; --enable-mmal\&#xA; --enable-rpi\&#xA; --extra-cflags=&amp;quot;-g $RPI_KEEPS $RPI_DEFS $RPI_INCLUDES&amp;quot;\&#xA; --extra-cxxflags=&amp;quot;$RPI_DEFS $RPI_INCLUDES&amp;quot;\&#xA; --extra-ldflags=&amp;quot;$RPI_LIBDIRS -Wl,-rpath=/opt/vc/lib,-rpath-link=$RPI_OPT_VC/lib,-rpath=/lib,-rpath=/usr/lib,-rpath-link=$RPI_TOOLROOT/lib,-rpath-link=$RPI_TOOLROOT/lib&amp;quot;\&#xA; --extra-libs=&amp;quot;-Wl,--start-group -lbcm_host -lmmal -lmmal_util -lmmal_core -lvcos -lvcsm -lvchostif -lvchiq_arm&amp;quot;\&#xA; --cross-prefix=$RPI_TOOLROOT/bin/arm-linux-gnueabihf- \&#xA; --prefix=/usr/local \&#xA; --extra-libs=&amp;quot;-ldl&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派之系统安装与网络配置</title>
      <link>http://www.nljb.net/default/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%B8%8E%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>2018-09-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;树莓派之系统安装与网络配置&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;硬件:&#xA;    树莓派zero(w)&#xA;    PC一台(这里用的win10)&#xA;    普通micro数据线&#xA;    读卡器和8G容量以上的TF卡&#xA;&#xA;软件:&#xA;    win32diskimager&#xA;    树莓派官方固件 (https://www.raspberrypi.org/downloads/raspbian/)&#xA;    Linux (虚拟机实体机都可以)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 windows 系统下运行 win32diskimager 程序&#xA;// 选择系统u盘，并选择 raspbian 镜像 ... 开始安装 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在安装完系统之后先不要着急将存储卡放回到树莓派上 ...&#xA;// 将存储卡挂载到 Linux 系统或虚拟机中 ... 会看到两个分区 ...&#xA;// 一般来说 sda1（boot分区）、sda2（root分区）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开启SSH&#xA;// 挂载 boot 分区，在分区根目录创建名字为 ssh 的文件&#xA;touch ssh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开放树莓派虚拟网卡功能实现数据线互联 ...&#xA;// 在 boot 分区中修改 config.txt 文件 ... 末行加入 ...&#xA;dtoverlay=dwc2&#xA;&#xA;// 在 boot 分区中修改 cmdline.txt 文件 ... 找到 rootwite &#xA;// 在 rootwite 后边加入 modules-load=dwc2,g_ether 注意空格&#xA;modules-load=dwc2,g_ether&#xA;&#xA;// 配置有线及WIFI ...&#xA;// 挂载 root 分区，在分区内修改 /etc/network/interfaces 文件&#xA;&#xA;// 有线部分 ...&#xA;allow-hotplug usb0&#xA;auto usb0&#xA;iface usb0 inet static&#xA;address 192.168.137.2&#xA;netmask 255.255.255.0&#xA;# gateway 192.168.137.1 // 这里说明一下，如果WIFI就把有线网关禁用&#xA;dns-nameservers 114.114.114.114&#xA;&#xA;// WIFI 部分 ...&#xA;auto wlan0 &#xA;iface wlan0 inet dhcp&#xA;wpa_conf /etc/wpa_supplicant/wpa_supplicant.conf&#xA;&#xA;# 配置 /etc/wpa_supplicant/wpa_supplicant.conf&#xA;network={&#xA;    ssid=&amp;quot;wifiname&amp;quot;&#xA;    psk=&amp;quot;password&amp;quot;&#xA;}&#xA;&#xA;// 如果是开放网络把 psk 那行改成 key_mgmt=NONE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 配置完成后将USB数据线接入到电脑(Linux虚拟机)&#xA;// 注意：虚拟机需要选择加载的USB设备 ...&#xA;// 此时在 Linux 虚拟机中会看到新设备 ifconfig usb0&#xA;ifconfig usb0 192.168.137.1&#xA;// 我们在配置网络的时候已经为树莓派配置了 IP(192.168.137.2)&#xA;ping 192.168.137.2&#xA;ssh pi@192.168.137.2&#xA;&#xA;// 注意：发现有时在配置虚拟机IP后网络依然无法PING通 ...&#xA;// 尝试后发现重新加载 Linux 虚拟机 USB 设备后正常 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 以上，SSH与网络均配置完毕 ...&#xA;// 开机后通过 ifconfig 检查网络是否连接 ...&#xA;// 通过 SSH 登录即可 ...&#xA;// 注意：默认用户名 pi  密码 raspberry&#xA;&#xA;// 查看 wifi 的一些命令 &#xA;iwconfig &#xA;iwlist scan ... 等等 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过树莓派配置工具开启相关功能 ...&#xA;// 可以配置 SSH 、VNC、等 ...&#xA;sudo raspi-config&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 更换科大源&#xA;sudo sed -i &#39;s|mirrordirector.raspbian.org|mirrors.ustc.edu.cn/raspbian|g&#39; /etc/apt/sources.list&#xA;sudo sed -i &#39;s|archive.raspbian.org|mirrors.ustc.edu.cn/raspbian|g&#39; /etc/apt/sources.list&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 感谢&#xA;https://www.cnblogs.com/systemVITO/p/8046643.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>使用nmcli-network-manager管理wifi网络</title>
      <link>http://www.nljb.net/default/%E4%BD%BF%E7%94%A8nmcli-network-manager%E7%AE%A1%E7%90%86wifi%E7%BD%91%E7%BB%9C/</link>
      <pubDate>2018-08-11 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;使用nmcli-network-manager管理wifi网络&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用 nmtui 可以在命令行界面进行网络配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 配置文件：/etc/NetworkManager/NetworkManager.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意：OBJECT和COMMAND可以用全程也可以用简称，最少可以只用一个字母，但我们一般用头三个字母，这样不容易搞错&#xA;&#xA;root@desktop:~# nmcli -help&#xA;Usage: nmcli [OPTIONS] OBJECT { COMMAND | help }&#xA;&#xA;OPTIONS&#xA;  -t[erse]                                   terse output&#xA;  -p[retty]                                  pretty output&#xA;  -m[ode] tabular|multiline                  output mode&#xA;  -c[olors] auto|yes|no                      whether to use colors in output&#xA;  -f[ields] &amp;lt;field1,field2,...&amp;gt;|all|common   specify fields to output&#xA;  -e[scape] yes|no                           escape columns separators in values&#xA;  -n[ocheck]                                 don&#39;t check nmcli and NetworkManager versions&#xA;  -a[sk]                                     ask for missing parameters&#xA;  -s[how-secrets]                            allow displaying passwords&#xA;  -w[ait] &amp;lt;seconds&amp;gt;                          set timeout waiting for finishing operations&#xA;  -v[ersion]                                 show program version&#xA;  -h[elp]                                    print this help&#xA;&#xA;OBJECT&#xA;  g[eneral]       NetworkManager&#39;s general status and operations&#xA;  n[etworking]    overall networking control&#xA;  r[adio]         NetworkManager radio switches&#xA;  c[onnection]    NetworkManager&#39;s connections&#xA;  d[evice]        devices managed by NetworkManager&#xA;  a[gent]         NetworkManager secret agent or polkit agent&#xA;  m[onitor]       monitor NetworkManager changes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// WIFI 相关 ...&#xA;nmcli device wifi // 扫描&#xA;&#xA;root@desktop:~# nmcli device wifi &#xA;*  SSID                 MODE   CHAN  RATE       SIGNAL  BARS  SECURITY  &#xA;   --                   Infra  1     54 Mbit/s  100     ▂▄▆█            &#xA;   dnet                 Infra  11    54 Mbit/s  100     ▂▄▆█  WPA2      &#xA;   danoo-007            Infra  11    54 Mbit/s  84      ▂▄▆█  WPA1 WPA2 &#xA;   danoo100             Infra  3     54 Mbit/s  74      ▂▄▆_  WPA1 WPA2 &#xA;&#xA;// 使用方法:&#xA;connect &amp;lt;(B)SSID&amp;gt; [password &amp;lt;password&amp;gt;] [wep-key-type key|phrase] [ifname &amp;lt;ifname&amp;gt;]&#xA;                [bssid &amp;lt;BSSID&amp;gt;] [name &amp;lt;name&amp;gt;] [private yes|no] [hidden yes|no]&#xA;&#xA;// 关闭/打开 所有无线网卡&#xA;nmcli r wifi off&#xA;nmcli r wifi on&#xA;&#xA;// 禁用网卡&#xA;nmcli device disconnect ifname wlan0&#xA;&#xA;// 停用 wlan0 某一个活动的连接&#xA;nmcli con to check&#xA;nmcli con down &amp;lt;wifi name&amp;gt; to disconnect&#xA;&#xA;// 连接 WIFI 网络&#xA;nmcli dev wifi con &amp;quot;wifi name&amp;quot; password &amp;quot;wifi password&amp;quot;&#xA;&#xA;// 启用连接 WIFI &#xA;nmcli con up &amp;lt;wifi name&amp;gt;&#xA;&#xA;// 删除WIFI连接 - 配置&#xA;nmcli con delete &amp;lt;wifi name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 同样支持 hotspot 热点 ...&#xA;&#xA;ARGUMENTS := wifi hotspot [ifname &amp;lt;ifname&amp;gt;] [con-name &amp;lt;name&amp;gt;] [ssid &amp;lt;SSID&amp;gt;]&#xA;              [band a|bg] [channel &amp;lt;channel&amp;gt;] [password &amp;lt;password&amp;gt;]&#xA;&#xA;Create a Wi-Fi hotspot. Use &#39;connection down&#39; or &#39;device disconnect&#39;&#xA;to stop the hotspot.&#xA;Parameters of the hotspot can be influenced by the optional parameters:&#xA;ifname - Wi-Fi device to use&#xA;con-name - name of the created hotspot connection profile&#xA;ssid - SSID of the hotspot&#xA;band - Wi-Fi band to use&#xA;channel - Wi-Fi channel to use&#xA;password - password to use for the hotspot&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 启用/禁用所有网络连接&#xA;nmcli net on/off&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看网卡信息&#xA;nmcli device show // 所有&#xA;nmcli device show eth0&#xA;nmcli device show wlan0&#xA;&#xA;root@desktop:~# nmcli device show eth0&#xA;GENERAL.DEVICE:                         eth0&#xA;GENERAL.TYPE:                           ethernet&#xA;GENERAL.HWADDR:                         00:30:18:57:3D:23&#xA;GENERAL.MTU:                            1400&#xA;GENERAL.STATE:                          10 (unmanaged)&#xA;GENERAL.CONNECTION:                     --&#xA;GENERAL.CON-PATH:                       --&#xA;WIRED-PROPERTIES.CARRIER:               off&#xA;IP4.ADDRESS[1]:                         169.254.4.9/16&#xA;IP4.GATEWAY:                            0.0.0.0&#xA;IP6.ADDRESS[1]:                         fe80::230:18ff:fe57:3d23/64&#xA;IP6.GATEWAY:   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看设备状态&#xA;nmcli device status&#xA;&#xA;root@desktop:~# nmcli device status&#xA;DEVICE  TYPE      STATE         CONNECTION &#xA;tun0    tun       connected     tun0       &#xA;wlan0   wifi      disconnected  --         &#xA;eth0    ethernet  unmanaged     --         &#xA;lo      loopback  unmanaged     --         &#xA;ppp0    unknown   unmanaged     --   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 禁用设备 ... 活跃设备&#xA;nmcli device dis wlan0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开关连接&#xA;nmcli con up tun0&#xA;nmcli con down tun0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看所有状态&#xA;nmcli general status&#xA;&#xA;root@desktop:~# nmcli general status&#xA;STATE      CONNECTIVITY  WIFI-HW  WIFI     WWAN-HW  WWAN    &#xA;connected  full          enabled  enabled  enabled  enabled &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看所有连接&#xA;// nmcli con show // 查看所有连接&#xA;// nmcli con show -a // 活动的连接 --active&#xA;// nmcli con show tun0 // 详细信息&#xA;&#xA;root@aaa:~# nmcli con show&#xA;NAME                UUID                                  TYPE            DEVICE &#xA;Wired connection 1  68fccaf2-58cc-3ba1-86a4-aa5cb026c836  802-3-ethernet  eth1   &#xA;tap0                d6dda4d5-b457-4fd7-ac84-e46b82cf4850  tun             tap0   &#xA;tun0                05d6d9f7-9eab-4541-b110-7ea0dd4ac8b3  tun             tun0  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之pppd拨号成功后后自动挂断</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8Bpppd%E6%8B%A8%E5%8F%B7%E6%88%90%E5%8A%9F%E5%90%8E%E5%90%8E%E8%87%AA%E5%8A%A8%E6%8C%82%E6%96%AD/</link>
      <pubDate>2018-08-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Linux之pppd拨号成功后自动挂断&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Ubuntu 16.04 系统 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 手动 PPPD 拨号 ...&#xA;&#xA;&#xA;OK&#xA;&#xA;+CSQ: 23,99&#xA;&#xA;OK&#xA;ATQ0 V1 E1 S0=0 &amp;amp;C1 &amp;amp;D2 +FCLASS=0&#xA;OK&#xA;AT+CRSM=176,12258,0,0,10&#xA;+CRSM: 144,0,&amp;quot;98681011180171850491&amp;quot;&#xA;23:44:16.054558 dial.go:103: ICCID &amp;gt;&amp;gt;&amp;gt; /dev/shm/3g_iccid&#xA;&#xA;OK&#xA;AT+CFUN=1&#xA;OK&#xA;AT+CGDCONT=1,&amp;quot;IP&amp;quot;,&amp;quot;UNINET&amp;quot;,,0,0&#xA;OK&#xA;ATDT*99#&#xA;CONNECT&#xA;Serial connection established.&#xA;Using interface ppp0&#xA;Connect: ppp0 &amp;lt;--&amp;gt; /dev/ttyUSB2&#xA;PAP authentication succeeded&#xA;Could not determine remote IP address: defaulting to 10.64.64.64&#xA;local  IP address 10.112.218.220&#xA;remote IP address 10.64.64.64&#xA;primary   DNS address 202.106.195.68&#xA;secondary DNS address 202.106.46.151&#xA;Modem hangup // 自动挂断 .... &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&#xA;Connect time 0.5 minutes.&#xA;Sent 846 bytes, received 532 bytes.&#xA;Connection terminated.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// syslog 日志&#xA;Aug  3 23:44:14 danoo-desktop pppd[3294]: pppd 2.4.7 started by root, uid 0&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: abort on (NO CARRIER)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: abort on (NO DIALTONE)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: abort on (ERROR)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: abort on (NO ANSWER)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: abort on (BUSY)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: send (AT^M)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: expect (OK)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: OK&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]:  -- got it&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: send (ATZ+CSQ^M)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: expect (OK)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: +CSQ: 23,99^M&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: OK&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]:  -- got it&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: send (ATQ0 V1 E1 S0=0 &amp;amp;C1 &amp;amp;D2 +FCLASS=0^M)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: expect (OK)&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: ATQ0 V1 E1 S0=0 &amp;amp;C1 &amp;amp;D2 +FCLASS=0^M^M&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: OK&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]:  -- got it&#xA;Aug  3 23:44:15 danoo-desktop chat[3297]: send (AT+CRSM=176,12258,0,0,10^M)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: expect (OK)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: AT+CRSM=176,12258,0,0,10^M^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: +CRSM: 144,0,&amp;quot;98681011180171850491&amp;quot;^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: OK&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]:  -- got it&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: send (AT+CFUN=1^M)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: expect (OK)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: AT+CFUN=1^M^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: OK&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]:  -- got it&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: send (AT+CGDCONT=1,&amp;quot;IP&amp;quot;,&amp;quot;UNINET&amp;quot;,,0,0^M)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: expect (OK)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: AT+CGDCONT=1,&amp;quot;IP&amp;quot;,&amp;quot;UNINET&amp;quot;,,0,0^M^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: OK&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]:  -- got it&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: send (ATDT*99#^M)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: expect (CONNECT)&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: ^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: ATDT*99#^M^M&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]: CONNECT&#xA;Aug  3 23:44:16 danoo-desktop chat[3297]:  -- got it&#xA;Aug  3 23:44:16 danoo-desktop pppd[3294]: Serial connection established.&#xA;Aug  3 23:44:16 danoo-desktop pppd[3294]: Using interface ppp0&#xA;Aug  3 23:44:16 danoo-desktop pppd[3294]: Connect: ppp0 &amp;lt;--&amp;gt; /dev/ttyUSB2&#xA;Aug  3 23:44:16 danoo-desktop NetworkManager[706]: nm_device_get_device_type: assertion &#39;NM_IS_DEVICE (self)&#39; failed&#xA;Aug  3 23:44:16 danoo-desktop NetworkManager[706]: &amp;lt;info&amp;gt;  [1533311056.6215] manager: (ppp0): new Generic device (/org/freedesktop/NetworkManager/Devices/6)&#xA;Aug  3 23:44:16 danoo-desktop NetworkManager[706]: &amp;lt;info&amp;gt;  [1533311056.6410] devices added (path: /sys/devices/virtual/net/ppp0, iface: ppp0)&#xA;Aug  3 23:44:16 danoo-desktop NetworkManager[706]: &amp;lt;info&amp;gt;  [1533311056.6411] device added (path: /sys/devices/virtual/net/ppp0, iface: ppp0): no ifupdown configuration found.&#xA;Aug  3 23:44:17 danoo-desktop pppd[3294]: PAP authentication succeeded&#xA;Aug  3 23:44:20 danoo-desktop pppd[3294]: Could not determine remote IP address: defaulting to 10.64.64.64&#xA;Aug  3 23:44:20 danoo-desktop pppd[3294]: local  IP address 10.112.218.220&#xA;Aug  3 23:44:20 danoo-desktop pppd[3294]: remote IP address 10.64.64.64&#xA;Aug  3 23:44:20 danoo-desktop pppd[3294]: primary   DNS address 202.106.195.68&#xA;Aug  3 23:44:20 danoo-desktop pppd[3294]: secondary DNS address 202.106.46.151&#xA;Aug  3 23:44:22 danoo-desktop ntpd[1755]: Listen normally on 9 ppp0 10.112.218.220:123&#xA;Aug  3 23:44:22 danoo-desktop ntpd[1755]: new interface(s) found: waking up resolver&#xA;Aug  3 23:44:44 danoo-desktop ModemManager[683]: &amp;lt;warn&amp;gt;  (ttyUSB0): close blocked by driver for more than 7 seconds!&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.578029] usb 1-3: USB disconnect, device number 15&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.578867] generic ttyUSB0: generic converter now disconnected from ttyUSB0&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.578906] usbserial_generic 1-3:1.0: device disconnected&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.579319] generic ttyUSB2: generic converter now disconnected from ttyUSB2&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.579340] usbserial_generic 1-3:1.1: device disconnected&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.590752] generic ttyUSB3: generic converter now disconnected from ttyUSB3&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.590782] usbserial_generic 1-3:1.2: device disconnected&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.591157] generic ttyUSB4: generic converter now disconnected from ttyUSB4&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.591186] usbserial_generic 1-3:1.3: device disconnected&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.591619] generic ttyUSB5: generic converter now disconnected from ttyUSB5&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.591637] usbserial_generic 1-3:1.4: device disconnected&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.593423] generic ttyUSB6: generic converter now disconnected from ttyUSB6&#xA;Aug  3 23:44:45 danoo-desktop kernel: [  383.593457] usbserial_generic 1-3:1.5: device disconnected&#xA;Aug  3 23:44:45 danoo-desktop NetworkManager[706]: &amp;lt;error&amp;gt; [1533311085.5562] platform-linux: do-change-link[7]: failure changing link: failure 19 (No such device)&#xA;Aug  3 23:44:45 danoo-desktop pppd[3294]: Modem hangup&#xA;Aug  3 23:44:45 danoo-desktop NetworkManager[706]: &amp;lt;warn&amp;gt;  [1533311085.5562] device (ppp0): failed to disable userspace IPv6LL address handling&#xA;Aug  3 23:44:45 danoo-desktop pppd[3294]: Connect time 0.5 minutes.&#xA;Aug  3 23:44:45 danoo-desktop pppd[3294]: Sent 846 bytes, received 532 bytes.&#xA;Aug  3 23:44:45 danoo-desktop pppd[3294]: Connection terminated.&#xA;Aug  3 23:44:45 danoo-desktop ModemManager[683]: &amp;lt;info&amp;gt;  (tty/ttyUSB2): released by modem /sys/devices/pci0000:00/0000:00:14.0/usb1/1-3&#xA;Aug  3 23:44:45 danoo-desktop ModemManager[683]: &amp;lt;warn&amp;gt;  (ttyUSB2) could not open serial device (2)&#xA;Aug  3 23:44:45 danoo-desktop ModemManager[683]: &amp;lt;warn&amp;gt;  (ttyUSB3) could not open serial device (2)&#xA;Aug  3 23:44:45 danoo-desktop ModemManager[683]: &amp;lt;warn&amp;gt;  (ttyUSB4) could not open serial device (2)&#xA;Aug  3 23:44:45 danoo-desktop ModemManager[683]: &amp;lt;info&amp;gt;  (tty/ttyUSB0): released by modem /sys/devices/pci0000:00/0000:00:14.0/usb1/1-3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 发现断开都是由 ModemManager -&amp;gt; close blocked by driver for more than 7 seconds! 之后断开 ...&#xA;// 所以尝试卸掉该软件后解决 sudo apt-get remove modemmanager&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;What is ModemManager?&#xA;ModemManager is a DBus-activated daemon which controls mobile broadband (2G/3G/4G) devices and connections. Whether built-in devices, USB dongles, bluetooth-paired telephones, or professional RS232/USB devices with external power supplies, ModemManager is able to prepare and configure the modems and setup connections with them.&#xA;&#xA;1.x is the stable series of ModemManager using the improved /org/freedesktop/ModemManager1 interface.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 就是说这个一个管理守护程序，负责2g/3g/4g, RS232/USB等，如果手动执行pppd标号貌似没有得到它的授权 ... 给你干掉了 ... 猜的 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>修改Ubuntu启动画面中的Logo</title>
      <link>http://www.nljb.net/default/%E4%BF%AE%E6%94%B9Ubuntu%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2%E4%B8%AD%E7%9A%84Logo/</link>
      <pubDate>2018-07-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;修改Ubuntu启动画面中的Logo&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在grub文件中可以设置使用splash或text模式启动&#xA;/etc/default/grub -&amp;gt; GRUB_CMDLINE_LINUX_DEFAULT&#xA;更新 update-grub&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;修改 /usr/share/plymouth/themes/ubuntu-logo/ubuntu-logo.png&#xA;修改 /usr/share/plymouth/themes/ubuntu-logo/ubuntu-logo16.png&#xA;修改 /usr/share/plymouth/themes/ubuntu-text/ubuntu-text.plymouth&#xA;修改 /usr/share/plymouth/themes/ubuntu-text/ubuntu-text.plymouth.in&#xA;更新 update-initramfs -u&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>强制重启Linux系统的几种方法</title>
      <link>http://www.nljb.net/default/%E5%BC%BA%E5%88%B6%E9%87%8D%E5%90%AFLinux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>2018-06-28 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;强制重启Linux系统的几种方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;实际生产环境中某些情况下 Linux 服务器系统在出现致命错误需要远程进行重启，通过常规的 reboot、init 6 等方法无法正常重启（例如重启时卡在驱动程序里等情况），这时就需要通过下面介绍的几种特殊的方法进行强制重启。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;注意&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;下面这些强制重启 Linux 的方法都是直接跳过 umount 文件系统及 sync 等操作，可能导致数据损坏，不在特殊情况下请勿使用。&#xA;另外当然这些都是需要 root 超级用户权限的哦。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;reboot 命令&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;直接通过运行 reboot -nf 命令，这样重启时可以指定跳过 init 的处理和 sync 操作，这样可以避免大多数情况下的问题。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;magic SysRq key 方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;magic SysRq key 通过 proc 接口提供用户直接发底层命令给 kernel 的功能，可以实现关机、重启、宕机等操作&#xA;Linux kernel 需要开启 CONFIG_MAGIC_SYSRQ 才可以支持 magic SysRq key。&#xA;&#xA;运行下面两条命令就可以直接强制重启系统：&#xA;&#xA;[root@localhost ~]# echo 1 &amp;gt; /proc/sys/kernel/sysrq&#xA;[root@localhost ~]# echo b &amp;gt; /proc/sysrq-trigger&#xA;&#xA;相应的直接强制关机的命令：&#xA;&#xA;[root@localhost ~]# echo 1 &amp;gt; /proc/sys/kernel/sysrq&#xA;[root@localhost ~]# echo o &amp;gt; /proc/sysrq-trigger&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;watchdog 方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如果 Linux kernel 未开启 magic SysRq key 或者不起作用，可以尝试使用 watchdog 重启方法。watchdog 通过监控数据输入是否正常可以实现在系统出现异常时自动重启系统，这里我们刚好可以借用的。&#xA;&#xA;首先需要加载 watchdog 支持，这个和主板硬件设备有关，如果只需要软件模拟的，可以运行：&#xA;&#xA;[root@localhost ~]# modprobe softdog&#xA;命令加载软件 watchdog 支持，接着再运行：&#xA;&#xA;[root@localhost ~]# cat /dev/watchdog&#xA;命令，该命令会马上退出并报错，同时系统日志中就会提示：&#xA;&#xA;softdog: Unexpected close, not stopping watchdog!&#xA;这就表示 watchdog 设备是被意外关闭的而不是正常停止的，大约等待 60 秒之后你就会发现 Linux 系统自动重启了。&#xA;Linux watchdog 的异常等待时间是通过 /proc/sys/kernel/watchdog_thresh 设置的，一般默认为 60 秒。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;IPMI 方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;上面几种方法都不能用？如果你的主板刚好支持 IPMI 管理接口的话&#xA;那可以直接通过 IPMI 实现硬件上的强制关机或重启。&#xA;&#xA;首先加载 IPMI 支持：&#xA;&#xA;[root@localhost ~]# modprobe ipmi_msghandler ipmi_devintf ipmi_si&#xA;确认 IPMI 设备是否已找到：&#xA;&#xA;[root@localhost ~]# ls -l /dev/ipmi*&#xA;如果输出正常的话表示 IPMI 被正确加载了，接着安装 ipmitool 管理工具。&#xA;ipmitool 可以通过 IPMI 接口完成对本机或远程主机的一系列管理操作。&#xA;&#xA;这里我们就用直接电源管理的，重启系统：&#xA;&#xA;[root@localhost ~]# ipmitool power reset&#xA;运行完成后主机就会马上重启，相应的关闭主机可以运行命令：&#xA;&#xA;[root@localhost ~]# ipmitool power off&#xA;ipmitool 还可以实现在系统未启动时远程查看监控主板硬件状态等功能&#xA;在 IPMI 可用的情况下 ipmitool 还是比较方便好用的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt中实现图片透明度设置与显示</title>
      <link>http://www.nljb.net/default/Qt%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E9%80%8F%E6%98%8E%E5%BA%A6%E8%AE%BE%E7%BD%AE%E4%B8%8E%E6%98%BE%E7%A4%BA/</link>
      <pubDate>2018-06-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qt中实现图片透明度设置与显示&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;drawForeground(QPainter *painter, const QRectF &amp;amp;rect)  &#xA;{  &#xA;    QPixmap foreImg;  &#xA;    foreImg.load(&amp;quot;C:/Users/Desktop/fengjing1.jpg&amp;quot;);  &#xA;    if (!foreImg.isNull())  &#xA;    {  &#xA;    painter-&amp;gt;setOpacity(0.4);//透明度设置  &#xA;    painter-&amp;gt;drawPixmap(int(sceneRect().left()), int(sceneRect().top()), foreImg);     &#xA;    }  &#xA;&#xA;}  &#xA;drawBackground(QPainter *painter, const QRectF &amp;amp;rect)  &#xA;{  &#xA;    QPixmap foreImg;  &#xA;    foreImg.load(&amp;quot;C:/Users/Desktop/fengjing2.jpg&amp;quot;);  &#xA;    if (!foreImg.isNull())  &#xA;    {  &#xA;    painter-&amp;gt;setOpacity(0.9);//透明度设置  &#xA;    painter-&amp;gt;drawPixmap(int(sceneRect().left()), int(sceneRect().top()), foreImg);     &#xA;    }  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux音频配置文件asound.conf的使用</title>
      <link>http://www.nljb.net/default/Linux%E9%9F%B3%E9%A2%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6asound.conf%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2018-06-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Linux音频配置文件asound.conf的使用&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;asound.conf文件作用：主要用来做Android/Linux音频的路由控制，不同路由可以设置多个寄存器的不同配置组合，形成不同的音频通道，从而当路由改变时，底层codec通道随之改变。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如何获取当前的声卡卡号与设备号呢 ...&#xA;&#xA;&#xA;// aplay -l&#xA;**** List of PLAYBACK Hardware Devices ****&#xA;card 0: PCH [HDA Intel PCH], device 0: ALC662 rev3 Analog [ALC662 rev3 Analog]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 0: PCH [HDA Intel PCH], device 3: HDMI 0 [HDMI 0]&#xA;  Subdevices: 0/1&#xA;  Subdevice #0: subdevice #0&#xA;card 0: PCH [HDA Intel PCH], device 7: HDMI 1 [HDMI 1]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 0: PCH [HDA Intel PCH], device 8: HDMI 2 [HDMI 2]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;&#xA;// 以上信息可以直接看到 Card 声卡编号为 0&#xA;// 以上信息可以看到设备 Device 0, 3, 7, 8&#xA;// 以上信息可以看到 0 为 ALC662(模拟), 3,7,8为HDMI&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 但是如果使用HDMI设备，结果看到三个Device怎么才能知道哪个是当前的设备呢 ...&#xA;// 可以使用 aplay 来测试, 哪个出声音就是哪个了 ...&#xA;aplay -D hw:0,3 /usr/share/sounds/alsa/test.wav&#xA;aplay -D hw:0,7 /usr/share/sounds/alsa/test.wav&#xA;aplay -D hw:0,8 /usr/share/sounds/alsa/test.wav&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/asound.conf(简易配置) :&#xA;&#xA;    {&#xA;      pcm.!default{&#xA;          type hw&#xA;          card 1&#xA;          device 7&#xA;        }  &#xA;&#xA;      ctl.!default{&#xA;          type hw&#xA;          card 1&#xA;          device 7&#xA;         }  &#xA;    }}}&#xA;// 其中card代表声卡号, device代表设备号。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 更加简易配置&#xA;&#xA;defaults.pcm.card 0   &#xA;defaults.pcm.device 3&#xA;defaults.ctl.card 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 特殊的静音情况 MM&#xA;// 通过 alsamixer 来打开/关闭静音设备，与调节音量等 ...&#xA;alsamixer -c 1&#xA;alsactl store&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt中两个类互相包含与引用</title>
      <link>http://www.nljb.net/default/Qt%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%B1%BB%E4%BA%92%E7%9B%B8%E5%8C%85%E5%90%AB%E4%B8%8E%E5%BC%95%E7%94%A8/</link>
      <pubDate>2018-05-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qt中两个类互相包含与引用&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 案例基础类&#xA;&#xA;// a.h&#xA;class A { }&#xA;&#xA;// b.h&#xA;class B { }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果想在类A中使用类B，在类B中使用类A，应该怎么办&#xA;&#xA;// a.h&#xA;// b.h&#xA;class A&#xA;{&#xA;    B *b&#xA;}&#xA;&#xA;// b.h&#xA;// a.h&#xA;class B &#xA;{&#xA;    A *a&#xA;}&#xA;&#xA;// 上面的方法一定是编译失败的 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 正确方法&#xA;// a.h&#xA;#include &amp;quot;a.h&amp;quot;&#xA;#include &amp;quot;b.h&amp;quot;&#xA;class A &#xA;{&#xA;    B *b = new B();&#xA;    b.a = this;&#xA;    void hello() {};&#xA;}&#xA;&#xA;// b.h&#xA;class A;&#xA;class B&#xA;{&#xA;    A *a;&#xA;}&#xA;&#xA;// b.cpp&#xA;#include &amp;quot;b.h&amp;quot;&#xA;#include &amp;quot;a.h&amp;quot; // 只能在 b.cpp 里面 include a.h&#xA;B::B()&#xA;{&#xA;    a.hello();&#xA;}&#xA;&#xA;&#xA;// 注意：&#xA;// 重点在哪里，重点就在 .h 文件里面用 class A 而不要 include a.h&#xA;// 那在哪里 include a.h 呢，然后是在 .cpp 里面 ... 就这么简单 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>QGraphicsItem如何使用信号与槽</title>
      <link>http://www.nljb.net/default/QGraphicsItem%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</link>
      <pubDate>2018-05-19 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;QGraphicsItem如何使用信号/槽&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;对于 QGraphicsItem 来说，信号/槽和属性机制不是它的一部分，因为它不继承自 QObject。这是一个出于性能考虑的设计决策，允许比较大的场景以及快速的交互。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;特殊情况下，如果真的需要使用信号/槽，可以使用 QObject 的信号/槽和属性机制来扩展 QGraphicsItem。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;继承自 QObject 和 QGraphicsItem&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class CustomItem : public QObject, public QGraphicsItem&#xA;{&#xA;    Q_OBJECT&#xA;&#xA;public:&#xA;    explicit CustomItem(QGraphicsItem *parent = 0);&#xA;    virtual QRectF boundingRect() const;&#xA;    virtual void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);&#xA;&#xA;Q_SIGNALS:&#xA;    void mySignal();&#xA;&#xA;public Q_SLOTS:&#xA;    void mySlot();&#xA;    ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;继承自 QGraphicsObject&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;QGraphicsObject 类为需要信号/槽和属性的所有 items 提供一个基类，将 QGraphicsItem 的许多基本 setters 和 getters 映射到属性，并为其中的许多添加了通知信号。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于 QGraphicsObject 继承自 QObject 和 QGraphicsItem，所以，上述的自定义 item 可以变成这样：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class CustomItem : public QGraphicsObject&#xA;{&#xA;    Q_OBJECT&#xA;&#xA;public:&#xA;    explicit CustomItem(QGraphicsItem *parent = 0);&#xA;    virtual QRectF boundingRect() const;&#xA;    virtual void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);&#xA;&#xA;Q_SIGNALS:&#xA;    void mySignal();&#xA;&#xA;public Q_SLOTS:&#xA;    void mySlot();&#xA;    ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// .h&#xA;#ifndef CUSTOMITEM_H&#xA;#define CUSTOMITEM_H&#xA;&#xA;#include &amp;lt;QObject&amp;gt;&#xA;#include &amp;lt;QGraphicsItem&amp;gt;&#xA;&#xA;class CustomItem : public QObject, public QGraphicsItem&#xA;{&#xA;    Q_OBJECT&#xA;public:&#xA;    CustomItem(QGraphicsItem *parent = 0);&#xA;    ~CustomItem();&#xA;public slots:&#xA;    virtual void hello();&#xA;};&#xA;&#xA;#endif // CUSTOMITEM_H&#xA;&#xA;&#xA;// .cpp&#xA;#include &amp;quot;include/customitem.h&amp;quot;&#xA;&#xA;CustomItem::CustomItem(QGraphicsItem *parent)&#xA;{&#xA;}&#xA;&#xA;CustomItem::~CustomItem()&#xA;{&#xA;&#xA;}&#xA;&#xA;void CustomItem::hello()&#xA;{&#xA;&#xA;}&#xA;&#xA;// 继承&#xA;class DemoItem : public CustomItem&#xA;{&#xA;&#xA;}&#xA;&#xA;DemoItem::DemoItem()&#xA;{&#xA;    QTimer *m_timer = new QTimer(this);&#xA;    // 这里的 hello 必须在父类定义好 ... &#xA;    connect(m_timer, SIGNAL(timeout()), this, SLOT(hello()));&#xA;    m_timer-&amp;gt;start(1000);&#xA;}&#xA;&#xA;void DemoItem::hello()&#xA;{&#xA;    cout &amp;lt;&amp;lt; &amp;quot;www.nljb.net&amp;quot; &amp;lt;&amp;lt; endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;部分摘自：&lt;a href=&#34;https://blog.csdn.net/liang19890820/article/details/53643700&#34;&gt;https://blog.csdn.net/liang19890820/article/details/53643700&lt;/a&gt; 感谢&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenCV之BackgroundSubtractorMOG2动态目标检测</title>
      <link>http://www.nljb.net/default/OpenCV%E4%B9%8BBackgroundSubtractorMOG2%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</link>
      <pubDate>2018-05-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;OpenCV之BackgroundSubtractorMOG2动态目标检测&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OpenCV3 与 OpenCV2 一些区别 ...&#xA;Ptr&amp;lt;BackgroundSubtractor&amp;gt; bg_model = createBackgroundSubtractorMOG2();&#xA;bg_model-&amp;gt;apply(img, fgmask);&#xA;&#xA;// ------------------------------------ //&#xA;//  params.minThreshold = 20;//二值化的起始阈值&#xA;//  params.maxThreshold = 180;//二值化的终止阈值&#xA;//  params.thresholdStep = 10;//二值化的阈值步长&#xA;//  params.minConvexity = 0.5f;//斑点的最小凸度 默认0.95f&#xA;//  params.minInertiaRatio = 0.03f;//斑点的最小惯性率 默认0.1f&#xA;//  params.minArea = 120;//斑点的最小面积&#xA;//  params.maxArea = 5000;//斑点的最大面积&#xA;//  params.blobColor = 255;//检测白色&#xA;//  重复的最小次数，只有属于灰度图像斑点的那些二值图像斑点数量大于该值时，该灰度图像斑点才被认为是特征点&#xA;//  params.minRepeatability = 2;&#xA;//  最小的斑点距离，不同二值图像的斑点间距离小于该值时，被认为是同一个位置的斑点，否则是不同位置上的斑点&#xA;//  params.minDistBetweenBlobs = 10;&#xA;// ------------------------------------ //&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OpenCV2使用BackgroundSubtractorMOG2动态目标检测&#xA;#include &amp;lt;opencv2/opencv.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/core/core.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;&#xA;&#xA;using namespace cv;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    // --------------------------------------------------&#xA;    namedWindow(&amp;quot;image&amp;quot;, WINDOW_AUTOSIZE);&#xA;    namedWindow(&amp;quot;foreground&amp;quot;, WINDOW_AUTOSIZE);&#xA;    namedWindow(&amp;quot;background&amp;quot;, WINDOW_AUTOSIZE);&#xA;    // --------------------------------------------------&#xA;    VideoCapture m_cap(&amp;quot;/home/danoo/xxx.avi&amp;quot;);&#xA;    // --------------------------------------------------&#xA;    BackgroundSubtractorMOG2 m_mog;&#xA;    SimpleBlobDetector::Params m_params;&#xA;    m_params.filterByArea = true;&#xA;    m_params.minArea = 1;&#xA;    m_params.blobColor = 255;&#xA;    SimpleBlobDetector m_detector(m_params);&#xA;    Ptr&amp;lt;SimpleBlobDetector&amp;gt; m_blob = m_detector.create(&amp;quot;SimpleBlob&amp;quot;);&#xA;    // --------------------------------------------------&#xA;    Mat frame;&#xA;    Mat foreground;&#xA;    // Mat background;&#xA;    while(m_cap.read(frame))&#xA;    {&#xA;    // 运动前景检测&#xA;    m_mog(frame, foreground, 0.001);&#xA;    // 腐蚀&#xA;    cv::erode(foreground, foreground, cv::Mat());&#xA;    // 膨胀&#xA;    cv::dilate(foreground, foreground, cv::Mat());&#xA;    // 返回当前背景图像&#xA;    // m_mog.getBackgroundImage(background);&#xA;    // -------------------------------------------------------------- //&#xA;    // 特征点检测&#xA;    vector&amp;lt;KeyPoint&amp;gt; key_points;&#xA;    m_blob-&amp;gt;detect(foreground, key_points);&#xA;    // -------------------------------------------------------------- //&#xA;    // 检测到特征点 ...&#xA;    // key_points.size()&#xA;    // -------------------------------------------------------------- //&#xA;    imshow(&amp;quot;image&amp;quot;, frame);&#xA;    imshow(&amp;quot;foreground&amp;quot;, foreground);&#xA;    // -------------------------------------------------------------- //&#xA;    cv::waitKey(20);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;整合foreground到frame图像&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 初始化 Mat - 识别区域尺寸&#xA;Mat channel = Mat::zeros(foreground.rows, foreground.cols, CV_8UC3);&#xA;// 通道数组 ...&#xA;vector&amp;lt;cv::Mat&amp;gt; channels;&#xA;channels.push_back(foreground);&#xA;channels.push_back(foreground);&#xA;channels.push_back(foreground);&#xA;// 将多个数组组合合并成一个多通道的数组&#xA;cv::merge(channels, channel);&#xA;// 重定义尺寸 ...&#xA;// cv::resize(channel, channel, Size(frame.cols, frame.rows), 0, 0, cv::INTER_LINEAR);&#xA;Mat roi = frame(rect);&#xA;// 实现图片的线性融合 - 数组有相同的尺寸和相同的信道数&#xA;addWeighted(channel, 0.5, roi, 0.5, 0, roi);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/core/core.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;&#xA;&#xA;using namespace cv;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    // --------------------------------------------------&#xA;    namedWindow(&amp;quot;foreground&amp;quot;, WINDOW_AUTOSIZE);&#xA;    // --------------------------------------------------&#xA;    VideoCapture m_cap(&amp;quot;/home/danoo/xxx.avi&amp;quot;);&#xA;    // --------------------------------------------------&#xA;    BackgroundSubtractorMOG2 m_mog;&#xA;    SimpleBlobDetector::Params m_params;&#xA;    m_params.filterByArea = true;&#xA;    m_params.minArea = 1;&#xA;    m_params.blobColor = 255;&#xA;    SimpleBlobDetector m_detector(m_params);&#xA;    Ptr&amp;lt;SimpleBlobDetector&amp;gt; m_blob = m_detector.create(&amp;quot;SimpleBlob&amp;quot;);&#xA;    // --------------------------------------------------&#xA;    Mat frame;&#xA;    Mat foreground;&#xA;    // Mat background;&#xA;    while(m_cap.read(frame))&#xA;    {&#xA;    // 运动前景检测&#xA;    m_mog(frame, foreground, 0.001);&#xA;    // 腐蚀&#xA;    cv::erode(foreground, foreground, cv::Mat());&#xA;    // 膨胀&#xA;    cv::dilate(foreground, foreground, cv::Mat());&#xA;    // 返回当前背景图像&#xA;    // m_mog.getBackgroundImage(background);&#xA;    // -------------------------------------------------------------- //&#xA;    // 特征点检测&#xA;    vector&amp;lt;KeyPoint&amp;gt; key_points;&#xA;    m_blob-&amp;gt;detect(foreground, key_points);&#xA;    // -------------------------------------------------------------- //&#xA;    // 检测到特征点 ...&#xA;    // key_points.size()&#xA;    // -------------------------------------------------------------- //&#xA;    // 初始化 Mat - 识别区域尺寸&#xA;    Mat channel = Mat::zeros(foreground.rows, foreground.cols, CV_8UC3);&#xA;    // 通道数组 ...&#xA;    vector&amp;lt;cv::Mat&amp;gt; channels;&#xA;    channels.push_back(foreground);&#xA;    channels.push_back(foreground);&#xA;    channels.push_back(foreground);&#xA;    // 将多个数组组合合并成一个多通道的数组&#xA;    cv::merge(channels, channel);&#xA;    // 重定义尺寸 ...&#xA;    // cv::resize(channel, channel, Size(frame.cols, frame.rows), 0, 0, cv::INTER_LINEAR);&#xA;    Mat roi = frame;&#xA;    // 实现图片的线性融合 - 数组有相同的尺寸和相同的信道数&#xA;    addWeighted(channel, 0.5, roi, 0.5, 0, roi);&#xA;    // -------------------------------------------------------------- //&#xA;    imshow(&amp;quot;foreground&amp;quot;, frame);&#xA;    // -------------------------------------------------------------- //&#xA;    cv::waitKey(20);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang中的Race检测</title>
      <link>http://www.nljb.net/default/Golang%E4%B8%AD%E7%9A%84Race%E6%A3%80%E6%B5%8B/</link>
      <pubDate>2018-04-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Golang中的Race检测&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;由于golang中的go是非常方便的，加上函数又非常容易隐藏go。&lt;/em&gt;&#xA;&lt;em&gt;所以很多时候，当我们写出一个程序的时候，我们并不知道这个程序在并发情况下会不会出现什么问题。&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;所以在本质上说，goroutine的使用增加了函数的危险系数论go语言中goroutine的使用。比如一个全局变量，如果没有加上锁，我们写一个比较庞大的项目下来，就根本不知道这个变量是不是会引起多个goroutine竞争。&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Rect主要做的就是检测线程间对某一个对象产生了竞争使用&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 未加锁版&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;type A struct {&#xA;    name string&#xA;}&#xA;&#xA;func NewA() *A {&#xA;    a := new(A)&#xA;    return a&#xA;}&#xA;&#xA;func main() {&#xA;    a := NewA()&#xA;    go func() {&#xA;        a.name = &amp;quot;www.nljb.net&amp;quot;&#xA;    }()&#xA;    a.name = &amp;quot;www.nljb.net&amp;quot;&#xA;    fmt.Println(&amp;quot;a is &amp;quot;, a.name)&#xA;&#xA;    time.Sleep(2 * time.Second)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 未加锁版&#xA;go run -race a.go&#xA;a is  www.nljb.net&#xA;==================&#xA;WARNING: DATA RACE&#xA;Write at 0x00c04204e1c0 by goroutine 6:&#xA;  main.main.func1()&#xA;      C:/Users/a/Desktop/a.go:20 +0x3f&#xA;&#xA;Previous write at 0x00c04204e1c0 by main goroutine:&#xA;  main.main()&#xA;      C:/Users/a/Desktop/a.go:22 +0x7a&#xA;&#xA;Goroutine 6 (running) created at:&#xA;  main.main()&#xA;      C:/Users/a/Desktop/a.go:19 +0x6c&#xA;==================&#xA;Found 1 data race(s)&#xA;exit status 66&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 加锁版&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;sync&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;type A struct {&#xA;    name string&#xA;    lock *sync.RWMutex&#xA;}&#xA;&#xA;func NewA() *A {&#xA;    a := new(A)&#xA;    a.lock = new(sync.RWMutex)&#xA;    return a&#xA;}&#xA;&#xA;func (this *A) Set() {&#xA;    this.lock.Lock()&#xA;    this.name = &amp;quot;www.nljb.net&amp;quot;&#xA;    this.lock.Unlock()&#xA;}&#xA;&#xA;func (this *A) Get() string {&#xA;    this.lock.Lock()&#xA;    name := this.name&#xA;    this.lock.Unlock()&#xA;    return name&#xA;}&#xA;&#xA;func main() {&#xA;    a := NewA()&#xA;    go func() {&#xA;        a.Set()&#xA;    }()&#xA;    a.Set()&#xA;    fmt.Println(&amp;quot;a is &amp;quot;, a.Get())&#xA;&#xA;    time.Sleep(2 * time.Second)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 加锁后进行竞争检测&#xA;go run -race a.go&#xA;a is  www.nljb.net&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 样例&#xA;package main&#xA;&#xA;import(&#xA;    &amp;quot;time&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    a := 1&#xA;    go func(){&#xA;    a = 2&#xA;    }()&#xA;    a = 3&#xA;    fmt.Println(&amp;quot;a is &amp;quot;, a)&#xA;&#xA;    time.Sleep(2 * time.Second)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go run -race a.go&#xA;a is  3&#xA;==================&#xA;WARNING: DATA RACE&#xA;Write at 0x00c04205a058 by goroutine 6:&#xA;  main.main.func1()&#xA;      C:/Users/a/Desktop/a.go:11 +0x3f&#xA;&#xA;Previous write at 0x00c04205a058 by main goroutine:&#xA;  main.main()&#xA;      C:/Users/a/Desktop/a.go:13 +0x8f&#xA;&#xA;Goroutine 6 (running) created at:&#xA;  main.main()&#xA;      C:/Users/a/Desktop/a.go:10 +0x81&#xA;==================&#xA;Found 1 data race(s)&#xA;exit status 66&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这个命令输出了Warning，告诉我们，goroutine5运行到第11行和main goroutine运行到13行的时候触发竞争了。&#xA;而且goroutine5是在第12行的时候产生的。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;部分转自：&lt;a href=&#34;http://www.cnblogs.com/yjf512/p/5144211.html&#34;&gt;http://www.cnblogs.com/yjf512/p/5144211.html&lt;/a&gt; 感谢&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之获取Struct的Tag</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E8%8E%B7%E5%8F%96Struct%E7%9A%84Tag/</link>
      <pubDate>2018-03-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;获取Struce的Tag&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;)&#xA;&#xA;type Foo struct {&#xA;    FirstName string `tag_name:&amp;quot;tag 1&amp;quot;`&#xA;    LastName  string `tag_name:&amp;quot;tag 2&amp;quot;`&#xA;    Age       int    `tag_name:&amp;quot;tag 3&amp;quot;`&#xA;}&#xA;&#xA;func (f *Foo) reflect() {&#xA;    val := reflect.ValueOf(f).Elem()&#xA;&#xA;    for i := 0; i &amp;lt; val.NumField(); i++ {&#xA;        valueField := val.Field(i)&#xA;        typeField := val.Type().Field(i)&#xA;        tag := typeField.Tag&#xA;&#xA;        fmt.Printf(&amp;quot;Field Name: %s,\t Field Value: %v,\t Tag Value: %s\n&amp;quot;, typeField.Name, valueField.Interface(), tag.Get(&amp;quot;tag_name&amp;quot;))&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    f := &amp;amp;Foo{&#xA;        FirstName: &amp;quot;Drew&amp;quot;,&#xA;        LastName:  &amp;quot;Olson&amp;quot;,&#xA;        Age:       30,&#xA;    }&#xA;&#xA;    f.reflect()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot; // 这里引入reflect模块&#xA;)&#xA;type User struct {&#xA;    Name   string &amp;quot;user name&amp;quot; //这引号里面的就是tag&#xA;    Passwd string &amp;quot;user passsword&amp;quot;&#xA;}&#xA;func main() {&#xA;    user := &amp;amp;User{&amp;quot;chronos&amp;quot;, &amp;quot;pass&amp;quot;}&#xA;    s := reflect.TypeOf(user).Elem() //通过反射获取type定义&#xA;    for i := 0; i &amp;lt; s.NumField(); i++ {&#xA;        fmt.Println(s.Field(i).Tag) //将tag输出出来&#xA;    }&#xA;}&#xA;&#xA;// Golang.org中reflect的示例代码&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    type S struct {&#xA;    F string `species:&amp;quot;gopher&amp;quot; color:&amp;quot;blue&amp;quot;`&#xA;}&#xA;&#xA;s := S{}&#xA;    st := reflect.TypeOf(s)&#xA;    field := st.Field(0)&#xA;    fmt.Println(field.Tag.Get(&amp;quot;color&amp;quot;), field.Tag.Get(&amp;quot;species&amp;quot;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之一个有趣的闭包问题</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>2018-03-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Golang之一个有趣的闭包问题&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在论坛上看到一个有趣的闭包例子, 下面这两个例子输出结果截然不同 ... &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 未达到目的&#xA;package main&#xA;&#xA;import (  &#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;type field struct {  &#xA;    name string&#xA;}&#xA;&#xA;func (p *field) print() {  &#xA;    fmt.Println(p.name)&#xA;}&#xA;&#xA;func main() {  &#xA;    data := []field/{/{&amp;quot;one&amp;quot;/},/{&amp;quot;two&amp;quot;/},/{&amp;quot;three&amp;quot;/}/}&#xA;    for _,v := range data {&#xA;    go v.print()&#xA;    }&#xA;    time.Sleep(3 * time.Second)&#xA;}&#xA;//goroutines print: three, three, three&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 正确例子&#xA;package main&#xA;&#xA;import (  &#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;type field struct {  &#xA;    name string&#xA;}&#xA;&#xA;func (p *field) print() {  &#xA;    fmt.Println(p.name)&#xA;}&#xA;&#xA;func main() {  &#xA;    data := []*field/{/{&amp;quot;one&amp;quot;/},/{&amp;quot;two&amp;quot;/},/{&amp;quot;three&amp;quot;/}/}&#xA;    for _,v := range data {&#xA;    go v.print()&#xA;    }&#xA;    time.Sleep(3 * time.Second)&#xA;}&#xA;//goroutines print: one, two, three&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 还有第三个例子&#xA;func TestClosure2() {&#xA;&#xA;    data := []*field/{/{&amp;quot;one&amp;quot;/}, /{&amp;quot;two&amp;quot;/}, /{&amp;quot;three&amp;quot;/}/}&#xA;&#xA;    for _, v := range data {&#xA;        go func() {&#xA;            v.print()&#xA;        }()&#xA;    }&#xA;    //goroutines print: three, three, three&#xA;&#xA;    // ---------------------------------&#xA;    // 解决方案 ... &#xA;    // for _, v := range data {&#xA;    //  go func(x *field) {&#xA;    //      x.print()&#xA;    //  }(v)&#xA;    // }&#xA;    // ---------------------------------&#xA;    //goroutines print: one, two, three&#xA;&#xA;    time.Sleep(3 * time.Second)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;What you’ve discovered is another piece of syntactic sugar, whereby if you call a method that takes a pointer receiver on a value, then Go will automatically take the address of the value and use that as the receiver.&#xA;&#xA;This has a subtle effect on your program. When the go statement evaluates v.print() if it needs a pointer receiver but does not have one, it takes the address of v, which as we saw before causes all of the go routines to work with the same copy of v.&#xA;&#xA;If the go statement finds that it already has a pointer receiver, then it can use it directly as the receiver.&#xA;&#xA;You can see this here with a modified version of your program that prints the address of field&#39;s receiver.&#xA;&#xA;https://play.golang.org/p/wUXsuzdeI44&#xA;&#xA;You can see that in TestClosure the address is different for the three invocations, it is in fact the address of the elements of []*field.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Go之runtime.Caller与runtime.FuncForPC使用</title>
      <link>http://www.nljb.net/default/Go%E4%B9%8Bruntime.Caller%E4%B8%8Eruntime.FuncForPC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2018-03-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;runtime.Caller与runtime.FuncForPC&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Caller(skip int) (pc uintptr, file string, line int, ok bool)&#xA;// skip如果是0，返回当前调用Caller函数的函数名、文件、程序指针PC，1是上一层函数，以此类推&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;runtime&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    test()&#xA;}&#xA;&#xA;func test() {&#xA;    test2()&#xA;}&#xA;&#xA;func test2() {&#xA;&#xA;    // 上2层函数信息&#xA;    pc, file, line, ok := runtime.Caller(2)&#xA;    // 是否获取成功&#xA;    log.Println(ok)&#xA;    // 函数指针&#xA;    log.Println(pc)&#xA;    // 所属文件&#xA;    log.Println(file)&#xA;    // 所属行&#xA;    log.Println(line)&#xA;    // 获取函数信息&#xA;    f := runtime.FuncForPC(pc)&#xA;    // 函数名&#xA;    log.Println(f.Name())&#xA;&#xA;    // 当前函数信息&#xA;    pc, file, line, ok = runtime.Caller(0)&#xA;    log.Println(pc)&#xA;    log.Println(file)&#xA;    log.Println(line)&#xA;    log.Println(ok)&#xA;    f = runtime.FuncForPC(pc)&#xA;    log.Println(f.Name())&#xA;&#xA;    // 上一层函数信息&#xA;    pc, file, line, ok = runtime.Caller(1)&#xA;    log.Println(pc)&#xA;    log.Println(file)&#xA;    log.Println(line)&#xA;    log.Println(ok)&#xA;    f = runtime.FuncForPC(pc)&#xA;    log.Println(f.Name())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;直接从函数指针获取函数名称所属文件&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;    &amp;quot;runtime&amp;quot;&#xA;)&#xA;&#xA;type Demo struct {&#xA;}&#xA;&#xA;func (this *Demo) Hello() {&#xA;&#xA;}&#xA;&#xA;func main() {&#xA;    demo := new(Demo)&#xA;    pc := reflect.ValueOf(demo.Hello).Pointer()&#xA;    f := runtime.FuncForPC(pc)&#xA;    log.Println(f.Name())&#xA;    log.Println(f.FileLine(pc))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenCV之-两幅相同与不同尺寸图像融合</title>
      <link>http://www.nljb.net/default/OpenCV%E4%B9%8B-%E4%B8%A4%E5%B9%85%E7%9B%B8%E5%90%8C%E4%B8%8E%E4%B8%8D%E5%90%8C%E5%B0%BA%E5%AF%B8%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88/</link>
      <pubDate>2018-02-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;两幅相同与不同尺寸图像融合&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2018-02-23-OpenCV之-两幅相同与不同尺寸图像融合/1.png&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/core/core.hpp&amp;gt;  &#xA;#include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;  &#xA;#include &amp;lt;opencv2/imgproc/imgproc.hpp&amp;gt;   &#xA;#include &amp;lt;iostream&amp;gt;   &#xA;using namespace cv;  &#xA;using namespace std;  &#xA;&#xA;int main()  &#xA;{  &#xA;    //【0】定义相关变量   &#xA;    Mat ac, ahand;  &#xA;    //【1】读取原始图像并检查图像是否读取成功    &#xA;    ac = imread(&amp;quot;D:\\OutPutResult\\ImageTest\\ac.jpg&amp;quot;);  &#xA;    ahand = imread(&amp;quot;D:\\OutPutResult\\ImageTest\\ahand.jpg&amp;quot;);  &#xA;    if (ahand.empty() &amp;amp;&amp;amp; ac.empty())        //检验两幅图像是否同时存在  &#xA;    {  &#xA;    cout &amp;lt;&amp;lt; &amp;quot;读取图像有误，请重新输入正确路径！\n&amp;quot;;  &#xA;    return -1;  &#xA;    }  &#xA;    //【3】显示原始图像  &#xA;    namedWindow(&amp;quot;图像1ac&amp;quot;);   //创建窗口  &#xA;    imshow(&amp;quot;图像1ac&amp;quot;, ac);    //显示窗口  &#xA;    namedWindow(&amp;quot;图像2ahand&amp;quot;);  &#xA;    imshow(&amp;quot;图像2ahand&amp;quot;, ahand);  &#xA;    //【4】调整ahand的大小与ac的大小一致，融合函数addWeighted()要求输入的两个图形尺寸必须相同    &#xA;    resize(ahand, ahand, Size(ac.cols, ac.rows));  &#xA;    //【5】利用addWeighted()函数对两幅图像进行融合  &#xA;    addWeighted(ac, 0.6, ahand, 0.4, 0., ac); //最后融合效果显示在ac图像上  &#xA;    /* &#xA;    若不想毁坏原始ac图像，也可建立一个与ac图像类型尺寸一样的新图像，将融合后的图像保存到上面。 &#xA;    建立方法： &#xA;    Mat newImage(ac.size(), ac.type()); //newImage与ac类型尺寸相同 &#xA;    */  &#xA;    namedWindow(&amp;quot;图像1与图像2融合效果图&amp;quot;);  &#xA;    imshow(&amp;quot;图像1与图像2融合效果图&amp;quot;, ac);  &#xA;    //【6】保持等待状态   &#xA;    waitKey();  &#xA;    return 0;  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2018-02-23-OpenCV之-两幅相同与不同尺寸图像融合/2.png&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/core/core.hpp&amp;gt;  &#xA;#include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;  &#xA;#include &amp;lt;opencv2/imgproc/imgproc.hpp&amp;gt;   &#xA;#include &amp;lt;iostream&amp;gt;   &#xA;using namespace cv;  &#xA;using namespace std;  &#xA;&#xA;int main()  &#xA;{  &#xA;    //【0】定义相关变量   &#xA;    Mat ac, ahand;  &#xA;    //【1】读取原始图像并检查图像是否读取成功    &#xA;    ac = imread(&amp;quot;D:\\OutPutResult\\ImageTest\\ac.jpg&amp;quot;);  &#xA;    ahand = imread(&amp;quot;D:\\OutPutResult\\ImageTest\\ahand.jpg&amp;quot;);  &#xA;    if (ahand.empty() &amp;amp;&amp;amp; ac.empty())        //检验两幅图像是否同时存在  &#xA;    {  &#xA;    cout &amp;lt;&amp;lt; &amp;quot;读取图像有误，请重新输入正确路径！\n&amp;quot;;  &#xA;    return -1;  &#xA;    }  &#xA;    //【3】显示原始图像  &#xA;    namedWindow(&amp;quot;图像1ac&amp;quot;);   //创建窗口  &#xA;    imshow(&amp;quot;图像1ac&amp;quot;, ac);    //显示窗口  &#xA;    namedWindow(&amp;quot;图像2ahand&amp;quot;);  &#xA;    imshow(&amp;quot;图像2ahand&amp;quot;, ahand);  &#xA;    //【4】利用ROI，获取将要理图像的矩形大小  &#xA;    Mat imageROI;  &#xA;    imageROI = ac(Rect(20, 40, ahand.cols, ahand.rows));//在ac图像左上角(20,40)处(即起点位置)，获取同ahand图像尺寸一致的区域  &#xA;    //【5】利用addWeighted()函数对两幅图像进行融合  &#xA;    addWeighted(ahand, 0.6, imageROI, 0.4, 0., imageROI);   &#xA;    namedWindow(&amp;quot;图像1与图像2融合效果图&amp;quot;);  &#xA;    imshow(&amp;quot;图像1与图像2融合效果图&amp;quot;, ac);  &#xA;    //【6】保持等待状态   &#xA;    waitKey();  &#xA;    return 0;  &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;官方解释：&lt;a href=&#34;https://docs.opencv.org/master/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19&#34;&gt;https://docs.opencv.org/master/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;文档摘自：&lt;a href=&#34;http://blog.csdn.net/sinat_36264666/article/details/77102735&#34;&gt;http://blog.csdn.net/sinat_36264666/article/details/77102735&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>RESTful API</title>
      <link>http://www.nljb.net/default/RESTful-API/</link>
      <pubDate>2017-12-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;RESTful API 简单了解&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;首先为什么要用RESTful结构呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;早先页是前端后端融在一起的，比如之前的PHP，JSP等。&#xA;在之前的桌面时代问题不大，但是近年来移动互联网的发展，各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务。&#xA;另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;在RESTful架构下：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2017-12-29-RESTful-API/1.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Server的API如何设计才满足RESTful要求?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过http协议的GET,POST,DELETE,PUT方法实现对url资源的CRUD（创建、读取、更新和删除）操作&#xA;// 当然 RESTful 还能做很多 ... 但是这里只说最常用的 ...&#xA;&#xA;// Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。&#xA;// 当然还可以压缩HTTP传输时的数据（on-wire data compression）。&#xA;// 用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。&#xA;&#xA;// 关于安全：自己的接口就用https，加上一个key做一次hash放在最后即可&#xA;// 如果是平台的API，可以用成熟但是复杂的OAuth2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GET       用来获取资源&lt;/li&gt;&#xA;&lt;li&gt;POST      用来新建资源（更新资源）&lt;/li&gt;&#xA;&lt;li&gt;PUT       用来更新资源&lt;/li&gt;&#xA;&lt;li&gt;DELETE    用来删除资源&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DELETE &lt;a href=&#34;http://api.qc.com/v1/friends&#34;&gt;http://api.qc.com/v1/friends&lt;/a&gt;   删除某人的好友&lt;/li&gt;&#xA;&lt;li&gt;POST &lt;a href=&#34;http://api.qc.com/v1/friends&#34;&gt;http://api.qc.com/v1/friends&lt;/a&gt; 添加好友&lt;/li&gt;&#xA;&lt;li&gt;UPDATE &lt;a href=&#34;http://api.qc.com/v1/profile&#34;&gt;http://api.qc.com/v1/profile&lt;/a&gt;   更新个人资料&lt;/li&gt;&#xA;&lt;li&gt;GET &lt;a href=&#34;http://api.qc.com/v1/id&#34;&gt;http://api.qc.com/v1/id&lt;/a&gt;       获取个人资料&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2017-12-29-RESTful-API/2.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>通过Screen进行远程会话管理</title>
      <link>http://www.nljb.net/default/%E9%80%9A%E8%BF%87Screen%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</link>
      <pubDate>2017-11-10 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Screen是Linux下的一款远程会话管理工具&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;为什么关掉窗口/断开连接会使得正在运行的程序死掉, 挂断信号（SIGHUP）默认的动作是终止程序&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建一个新的窗口:&#xA;[root@nljb ~]# screen&#xA;[root@nljb ~]# screen vi nljb.c&#xA;&#xA;// 键入C-a d，Screen会给出detached提示&#xA;... 分离会话, 再也不用担心我们关掉terminal程序就不运行了&#xA;&#xA;// 查看会话&#xA;[root@nljb ~]# screen -ls&#xA;There is a screen on:&#xA;    6582.pts-1.tivf06      (Detached)&#xA;1 Socket in /tmp/screens/S-root.&#xA;&#xA;// 重新连接会话：&#xA;[root@nljb ~]# screen -r 6582&#xA;&#xA;// 清除死去的窗口&#xA;[root@nljb ~]# screen -wipe &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;C-a ?   显示所有键绑定信息&#xA;C-a w   显示所有窗口列表&#xA;C-a C-a 切换到之前显示的窗口&#xA;C-a c   创建一个新的运行shell的窗口并切换到该窗口&#xA;C-a n   切换到下一个窗口&#xA;C-a p   切换到前一个窗口(与C-a n相对)&#xA;C-a 0..9切换到窗口0..9&#xA;C-a a   发送 C-a到当前窗口&#xA;C-a d   暂时断开screen会话&#xA;C-a k   杀掉当前窗口与程序&#xA;C-a [   进入拷贝/回滚模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之v1.9中线程安全的sync.Map</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8Bv1.9%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84sync.Map/</link>
      <pubDate>2017-10-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Golang 1.9 sync.Map 使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Store&lt;/li&gt;&#xA;&lt;li&gt;LoadOrStore&lt;/li&gt;&#xA;&lt;li&gt;Load&lt;/li&gt;&#xA;&lt;li&gt;Delete&lt;/li&gt;&#xA;&lt;li&gt;Range&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 说明： 存储一个设置的键值。&#xA;Store(key, value interface{})&#xA;&#xA;// 说明： 返回键的现有值(如果存在)，否则存储并返回给定的值，如果是读取则返回true，如果是存储返回false。&#xA;LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)&#xA;&#xA;// 说明： 读取存储在map中的值，如果没有值，则返回nil。OK的结果表示是否在map中找到值。&#xA;Load(key interface{}) (value interface{}, ok bool)&#xA;&#xA;// 说明： 删除键对应的值。&#xA;Delete(key interface{})&#xA;&#xA;// 说明： 循环读取map中的值。&#xA;Range(f func(key, value interface{}) bool)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;sync&amp;quot;&#xA;)&#xA;&#xA;type userInfo struct {&#xA;    Name string&#xA;    Age  int&#xA;}&#xA;&#xA;var m sync.Map&#xA;&#xA;func main() {&#xA;&#xA;    vv, ok := m.LoadOrStore(&amp;quot;1&amp;quot;, &amp;quot;one&amp;quot;)&#xA;    fmt.Println(vv, ok) //one false&#xA;&#xA;    vv, ok = m.Load(&amp;quot;1&amp;quot;)&#xA;    fmt.Println(vv, ok) //one true&#xA;&#xA;    vv, ok = m.LoadOrStore(&amp;quot;1&amp;quot;, &amp;quot;oneone&amp;quot;)&#xA;    fmt.Println(vv, ok) //one true&#xA;&#xA;    vv, ok = m.Load(&amp;quot;1&amp;quot;)&#xA;    fmt.Println(vv, ok) //one true&#xA;&#xA;    m.Store(&amp;quot;1&amp;quot;, &amp;quot;oneone&amp;quot;)&#xA;    vv, ok = m.Load(&amp;quot;1&amp;quot;)&#xA;    fmt.Println(vv, ok) // oneone true&#xA;&#xA;    m.Store(&amp;quot;2&amp;quot;, &amp;quot;two&amp;quot;)&#xA;    m.Range(func(k, v interface{}) bool {&#xA;    fmt.Println(k, v)&#xA;    return true&#xA;    })&#xA;&#xA;    m.Delete(&amp;quot;1&amp;quot;)&#xA;    m.Range(func(k, v interface{}) bool {&#xA;    fmt.Println(k, v)&#xA;    return true&#xA;    })&#xA;&#xA;    map1 := make(map[string]userInfo)&#xA;    var user1 userInfo&#xA;    user1.Name = &amp;quot;ChamPly&amp;quot;&#xA;    user1.Age = 24&#xA;    map1[&amp;quot;user1&amp;quot;] = user1&#xA;&#xA;    var user2 userInfo&#xA;    user2.Name = &amp;quot;Tom&amp;quot;&#xA;    user2.Age = 18&#xA;    m.Store(&amp;quot;map_test&amp;quot;, map1)&#xA;&#xA;    mapValue, _ := m.Load(&amp;quot;map_test&amp;quot;)&#xA;&#xA;    for k, v := range mapValue.(interface{}).(map[string]userInfo) {&#xA;    fmt.Println(k, v)&#xA;    fmt.Println(&amp;quot;name:&amp;quot;, v.Name)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenCV之基于混合高斯模型GMM的运动目标检测</title>
      <link>http://www.nljb.net/default/OpenCV%E4%B9%8B%E5%9F%BA%E4%BA%8E%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8BGMM%E7%9A%84%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</link>
      <pubDate>2017-10-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;基于混合高斯模型GMM的运动目标检测&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;  &#xA;#include &amp;lt;string&amp;gt;  &#xA;&#xA;#include &amp;lt;opencv2/opencv.hpp&amp;gt;  &#xA;&#xA;&#xA;int main(int argc, char** argv)  &#xA;{  &#xA;    std::string videoFile = &amp;quot;../test.avi&amp;quot;;  &#xA;&#xA;    cv::VideoCapture capture;  &#xA;    capture.open(videoFile);  &#xA;&#xA;    if (!capture.isOpened())  &#xA;    {  &#xA;    std::cout&amp;lt;&amp;lt;&amp;quot;read video failure&amp;quot;&amp;lt;&amp;lt;std::endl;  &#xA;    return -1;  &#xA;    }  &#xA;&#xA;&#xA;    cv::BackgroundSubtractorMOG2 mog;  &#xA;&#xA;    cv::Mat foreground;  &#xA;    cv::Mat background;  &#xA;&#xA;    cv::Mat frame;  &#xA;    long frameNo = 0;  &#xA;    while (capture.read(frame))  &#xA;    {  &#xA;    ++frameNo;  &#xA;&#xA;    std::cout&amp;lt;&amp;lt;frameNo&amp;lt;&amp;lt;std::endl;  &#xA;&#xA;    // 运动前景检测，并更新背景  &#xA;    mog(frame, foreground, 0.001);         &#xA;&#xA;    // 腐蚀  &#xA;    cv::erode(foreground, foreground, cv::Mat());  &#xA;&#xA;    // 膨胀  &#xA;    cv::dilate(foreground, foreground, cv::Mat());  &#xA;&#xA;    mog.getBackgroundImage(background);   // 返回当前背景图像  &#xA;&#xA;    cv::imshow(&amp;quot;video&amp;quot;, foreground);  &#xA;    cv::imshow(&amp;quot;background&amp;quot;, background);  &#xA;&#xA;&#xA;    if (cv::waitKey(25) &amp;gt; 0)  &#xA;    {  &#xA;        break;  &#xA;    }  &#xA;    }  &#xA;&#xA;    return 0;  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OpenCV2&#xA;// --------------------------------------------------&#xA;BackgroundSubtractorMOG2 m_mog;&#xA;SimpleBlobDetector::Params m_params;&#xA;m_params.blobColor = 255;&#xA;SimpleBlobDetector m_detector(m_params);&#xA;Ptr&amp;lt;SimpleBlobDetector&amp;gt; m_blob = m_detector.create(&amp;quot;SimpleBlob&amp;quot;);&#xA;// --------------------------------------------------&#xA;int count = 0;&#xA;// -----------------------&#xA;Rect rect = cv::Rect(150, 50, 350, 250);&#xA;Mat frame;&#xA;Mat foreground;&#xA;while(m_cap.read(frame))&#xA;{&#xA;    // ------------------------------&#xA;    // 运动前景检测&#xA;    // m_mog-&amp;gt;apply(frame(rect), foreground, 0.001);&#xA;    m_mog(frame(rect), foreground, 0.001);&#xA;    // 腐蚀&#xA;    cv::erode(foreground, foreground, cv::Mat());&#xA;    // 膨胀&#xA;    cv::dilate(foreground, foreground, cv::Mat());&#xA;    // getBackgroundImage&#xA;    // m_mog-&amp;gt;getBackgroundImage(background);&#xA;    // -------------------------------------------------------------- //&#xA;    // 特征点检测&#xA;    vector&amp;lt;KeyPoint&amp;gt; key_points;&#xA;    m_blob-&amp;gt;detect(foreground, key_points);&#xA;    // -------------------------------------------------------------- //&#xA;    // Debug&#xA;    if (Runtime::m_configure-&amp;gt;m_parcel_debug)&#xA;    {&#xA;        Mat channel = Mat::zeros(foreground.rows, foreground.cols, CV_8UC3);&#xA;        vector&amp;lt;cv::Mat&amp;gt; channels;&#xA;        channels.push_back(foreground);&#xA;        channels.push_back(foreground);&#xA;        channels.push_back(foreground);&#xA;        cv::merge(channels, channel);&#xA;        cv::resize(channel, channel,Size(frame.cols, frame.rows), 0, 0, cv::INTER_LINEAR);&#xA;        addWeighted(frame, 0.5, channel, 0.5, 0, frame);&#xA;        m_frames-&amp;gt;push(Frame(frame.clone(), count));&#xA;    }&#xA;    // -------------------------------------------------------------- //&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OpenCV3&#xA;#include &amp;lt;opencv2/features2d/features2d.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/core.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/core/utility.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/imgproc.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/video/background_segm.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/videoio.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/highgui.hpp&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;QDateTime&amp;gt;&#xA;&#xA;using namespace std;&#xA;using namespace cv;&#xA;&#xA;int main(int argc, char** argv)&#xA;{&#xA;&#xA;    std::string videoFile = &amp;quot;/home/danoo/x.avi&amp;quot;;&#xA;&#xA;    cv::VideoCapture m_cap;&#xA;    m_cap.open(videoFile);&#xA;    if (!m_cap.isOpened())&#xA;    {&#xA;    std::cout&amp;lt;&amp;lt;&amp;quot;read video failure&amp;quot;&amp;lt;&amp;lt;std::endl;&#xA;    return -1;&#xA;    }&#xA;&#xA;    m_cap.set(CV_CAP_PROP_FRAME_WIDTH, 640);&#xA;    m_cap.set(CV_CAP_PROP_FRAME_HEIGHT, 480);&#xA;    // m_cap.set(CV_CAP_PROP_FPS, Runtime::m_configure-&amp;gt;m_render_fps);&#xA;    // m_cap.set(CV_CAP_PROP_FOURCC, CV_FOURCC(&#39;M&#39;,&#39;G&#39;,&#39;P&#39;,&#39;G&#39;));&#xA;    // ------------------------------------ //&#xA;    Ptr&amp;lt;cv::BackgroundSubtractor&amp;gt; m_mog;&#xA;    m_mog = createBackgroundSubtractorMOG2();&#xA;    // ------------------------------------ //&#xA;    SimpleBlobDetector::Params m_params;&#xA;    //        params.minThreshold = 20;//二值化的起始阈值&#xA;    //        params.maxThreshold = 180;//二值化的终止阈值&#xA;    //        params.thresholdStep = 10;//二值化的阈值步长&#xA;    //        params.minConvexity = 0.5f;//斑点的最小凸度 默认0.95f&#xA;    //        params.minInertiaRatio = 0.03f;//斑点的最小惯性率 默认0.1f&#xA;    //        params.minArea = 120;//斑点的最小面积&#xA;    //        params.maxArea = 5000;//斑点的最大面积&#xA;    m_params.blobColor = 255;//检测白色&#xA;    //   重复的最小次数，只有属于灰度图像斑点的那些二值图像斑点数量大于该值时，该灰度图像斑点才被认为是特征点&#xA;    //   params.minRepeatability = 2;&#xA;    //   最小的斑点距离，不同二值图像的斑点间距离小于该值时，被认为是同一个位置的斑点，否则是不同位置上的斑点&#xA;    //   params.minDistBetweenBlobs = 10;&#xA;    Ptr&amp;lt;SimpleBlobDetector&amp;gt; m_detector;&#xA;    m_detector = SimpleBlobDetector::create(m_params);&#xA;    // -----------------------------------------------------------------------------&#xA;&#xA;    namedWindow(&amp;quot;video&amp;quot;, WINDOW_NORMAL);&#xA;    //    namedWindow(&amp;quot;background&amp;quot;, WINDOW_NORMAL);&#xA;    namedWindow(&amp;quot;SimpleBlobDetector&amp;quot;);&#xA;&#xA;    int m_before_size;&#xA;    Mat frame;&#xA;    Mat foreground;&#xA;    //    Mat background;&#xA;    while(m_cap.read(frame))&#xA;    {&#xA;    // ------------------------------ //&#xA;    // 运动前景检测&#xA;    m_mog-&amp;gt;apply(frame(cv::Rect(150, 50, 350, 250)), foreground, 0.001);&#xA;    // 腐蚀&#xA;    cv::erode(foreground, foreground, cv::Mat());&#xA;    // 膨胀&#xA;    cv::dilate(foreground, foreground, cv::Mat());&#xA;    // getBackgroundImage&#xA;    //        m_mog-&amp;gt;getBackgroundImage(background);&#xA;    // 特征点检测&#xA;    vector&amp;lt;KeyPoint&amp;gt; key_points;&#xA;    m_detector-&amp;gt;detect(foreground, key_points);&#xA;    if (m_before_size != -1 &amp;amp;&amp;amp; m_before_size &amp;gt;= 3 &amp;amp;&amp;amp; m_before_size &amp;gt; key_points.size()) {&#xA;        // m_log-&amp;gt;debug(QString().sprintf(&amp;quot;Parcel Point Size -&amp;gt; %d&amp;quot;, m_before_size));&#xA;        cv::rectangle(frame, cv::Rect(150, 50, 350, 250), CV_RGB(255, 0, 0), 4, 8, 0);&#xA;        // --------------------------------------------------------------------------------&#xA;        // m_frames-&amp;gt;push(Frame(frame.clone(), count));&#xA;    }&#xA;    printf(&amp;quot;%d(%d)\n&amp;quot;, key_points.size(), m_before_size);&#xA;    m_before_size = key_points.size();&#xA;    // -------------------------------&#xA;    cv::imshow(&amp;quot;video&amp;quot;, frame);&#xA;    //        cv::imshow(&amp;quot;background&amp;quot;, background);&#xA;    cv::imshow(&amp;quot;SimpleBlobDetector&amp;quot;, foreground);&#xA;    if (cv::waitKey(25) &amp;gt; 0)&#xA;        break;&#xA;    }&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之制作镜像文件</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8B%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/</link>
      <pubDate>2017-09-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;制作ISO镜像的方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 把/dev/cdrom目录制作为镜像&#xA;dd if=/dev/cdrom of=/root/myiso.iso&#xA;mkisofs -r -o myiso.iso /dev/cdrom&#xA;cp -r /home/user myiso.iso&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之Huawei设备不能正常识别ttyUSB解决办法</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8BHuawei%E8%AE%BE%E5%A4%87%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E8%AF%86%E5%88%ABttyUSB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>2017-09-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;未识别ttyUSB设备&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;usb_modeswitch -v 12d1 -p 1446 -W -J&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;解决 12d1:1446 -&amp;gt; 12d1:1436&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;主要原因还是因为当前Huawei设备模式不对，一般如果处于存储模式就不会初始化ttyUSB设备等&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install usb-modeswitch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;DefaultVendor = 0x12d1&#xA;DefaultProduct = 0x1446&#xA;&#xA;TargetVendor = 0x12d1&#xA;TargetProductList = “1001,1406,140b，140C，1412,141b，14ac”&#xA;&#xA;CheckSuccess = 20&#xA;&#xA;在messageContent = “55534243123456780000000000000011062000000100000000000000000000”&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 手动切换&#xA;usb_modeswitch -c /etc/usb_modeswitch.d/12d1:1446&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;解决 12d1:1f01 -&amp;gt; 12d1:14dc&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# /lib/udev/rules.d/40-usb_modeswitch.rules&#xA;ATTR{idVendor}==&amp;quot;12d1&amp;quot;, ATTR{idProduct}==&amp;quot;1f01&amp;quot;, RUN+=&amp;quot;usb_modeswitch &#39;%b/%k&#39;&amp;quot;&#xA;ATTRS{idVendor}==&amp;quot;12d1&amp;quot;, ATTRS{idProduct}==&amp;quot;1f01&amp;quot;, RUN+=&amp;quot;usb_modeswitch &#39;%b/%k&#39;&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# /etc/usb_modeswitch.d/12d1\:1f01&#xA;DefaultVendor=0x12d1&#xA;DefaultProduct=0x1f01&#xA;TargetVendor=0x12d1&#xA;TargetProductList=&amp;quot;14db,14dc&amp;quot;&#xA;HuaweiNewMode=1&#xA;NoDriverLoading=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# 测试&#xA;usb_modeswitch -W -c /etc/12d1:1f01&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Huawei E1750&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;DefaultVendor= 0x12d1&#xA;DefaultProduct= 0x1446&#xA;&#xA;TargetVendor= 0x12d1&#xA;TargetProduct= 0x1001&#xA;&#xA;&#xA;# only for reference and 0.x versions&#xA;&#xA;MessageEndpoint=0x01&#xA;MessageContent=&amp;quot;55534243123456780000000000000011060000000000000000000000000000&amp;quot;&#xA;HuaweiMode=0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenCV之三帧差分法运动检测</title>
      <link>http://www.nljb.net/default/OpenCV%E4%B9%8B%E4%B8%89%E5%B8%A7%E5%B7%AE%E5%88%86%E6%B3%95%E8%BF%90%E5%8A%A8%E6%A3%80%E6%B5%8B/</link>
      <pubDate>2017-09-21 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;opencv2/core/core.hpp&amp;quot;&#xA;#include &amp;quot;opencv2/highgui/highgui.hpp&amp;quot;&#xA;#include &amp;quot;opencv2/imgproc/imgproc.hpp&amp;quot;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;#define threshold_diff1 25 //设置简单帧差法阈值&#xA;#define threshold_diff2 25 //设置简单帧差法阈值&#xA;&#xA;using namespace cv;&#xA;using namespace std;&#xA;&#xA;int main(int argc,unsigned char* argv[])&#xA;{&#xA;    Mat img_src1,img_src2,img_src3;//3帧法需要3帧图片&#xA;    Mat img_dst,gray1,gray2,gray3;&#xA;    Mat gray_diff1,gray_diff2;//存储2次相减的图片&#xA;    Mat gray_diff11,gray_diff12;&#xA;    Mat gray_diff21,gray_diff22;&#xA;    Mat gray;//用来显示前景的&#xA;    bool pause=false;&#xA;&#xA;    VideoCapture vido_file(&amp;quot;/home/danoo/b60.avi&amp;quot;);//在这里改相应的文件名&#xA;    namedWindow(&amp;quot;foreground&amp;quot;,0);&#xA;    for (;;)&#xA;    {&#xA;    if(!false)&#xA;    {&#xA;        vido_file &amp;gt;&amp;gt;img_src1;&#xA;        cvtColor(img_src1,gray1,CV_BGR2GRAY);&#xA;&#xA;        waitKey(33);&#xA;        vido_file &amp;gt;&amp;gt;img_src2;&#xA;        cvtColor(img_src2,gray2,CV_BGR2GRAY);&#xA;        imshow(&amp;quot;video_src&amp;quot;,img_src2);//&#xA;&#xA;        waitKey(33);&#xA;        vido_file &amp;gt;&amp;gt;img_src3;&#xA;        cvtColor(img_src3,gray3,CV_BGR2GRAY);&#xA;&#xA;        Sobel(gray1,gray1,  CV_8U,1,0,3,0.4,128);&#xA;        Sobel(gray2,gray2,  CV_8U,1,0,3,0.4,128);&#xA;        Sobel(gray3,gray3,  CV_8U,1,0,3,0.4,128);&#xA;&#xA;        subtract(gray2,gray1,gray_diff11);//第二帧减第一帧&#xA;        subtract(gray1,gray2,gray_diff12);&#xA;        add(gray_diff11,gray_diff12,gray_diff1);&#xA;        subtract(gray3,gray2,gray_diff21);//第三帧减第二帧&#xA;        subtract(gray2,gray3,gray_diff22);&#xA;        add(gray_diff21,gray_diff22,gray_diff2);&#xA;&#xA;        for(int i=0;i&amp;lt;gray_diff1.rows;i++)&#xA;        for(int j=0;j&amp;lt;gray_diff1.cols;j++)&#xA;        {&#xA;            if(abs(gray_diff1.at&amp;lt;unsigned char&amp;gt;(i,j))&amp;gt;=threshold_diff1)//这里模板参数一定要用unsigned char，否则就一直报错&#xA;            gray_diff1.at&amp;lt;unsigned char&amp;gt;(i,j)=255;            //第一次相减阈值处理&#xA;            else gray_diff1.at&amp;lt;unsigned char&amp;gt;(i,j)=0;&#xA;&#xA;            if(abs(gray_diff2.at&amp;lt;unsigned char&amp;gt;(i,j))&amp;gt;=threshold_diff2)//第二次相减阈值处理&#xA;            gray_diff2.at&amp;lt;unsigned char&amp;gt;(i,j)=255;&#xA;            else gray_diff2.at&amp;lt;unsigned char&amp;gt;(i,j)=0;&#xA;        }&#xA;        bitwise_and(gray_diff1,gray_diff2,gray);&#xA;&#xA;        dilate(gray,gray,Mat());erode(gray,gray,Mat());&#xA;&#xA;        imshow(&amp;quot;foreground&amp;quot;,gray);&#xA;    }&#xA;    if( cvWaitKey(33) &amp;gt;= 0 )&#xA;        break;&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 帧差法&#xA;&#xA;// 帧间差分法的原理简单，计算量小，能够快速检测出场景中的运动目标&#xA;// 采用两帧差分法检测出的目标会出现重影的现象，采用三帧差分法，可以检测出较为完整的运动目标&#xA;// 帧间差分法的局限性是仅能在三帧中进行差异运算 ... 差异大效果好 ...&#xA;// 对于摄像头的画面进行帧差法检测可以通过控制画面采集的时间来实现更好的检测效果 ...&#xA;// 可以尝试通过刚性位移检测该运动移动方向 ...&#xA;&#xA;Mat a1, a2, a3;&#xA;Mat g1, g2, g3;&#xA;Mat d1, d2, d3;&#xA;Mat frame;&#xA;VideoCapture m_cap = VideoCapture(&amp;quot;E:/bbb.mp4&amp;quot;);&#xA;while(true)&#xA;{&#xA;&#xA;    // 连续三帧对于高速移动的物体有着较好的检测效果 ...&#xA;    m_cap &amp;gt;&amp;gt; a1;&#xA;    m_cap &amp;gt;&amp;gt; a2;&#xA;    m_cap &amp;gt;&amp;gt; a3;&#xA;&#xA;    cvtColor(a1, g1, COLOR_BGR2GRAY); // 转换颜色空间 ...&#xA;    cvtColor(a2, g2, COLOR_BGR2GRAY); // 转换颜色空间 ...&#xA;    cvtColor(a3, g3, COLOR_BGR2GRAY); // 转换颜色空间 ...&#xA;&#xA;    absdiff(g1, g2, d1); // 做差求绝对值 ...&#xA;    absdiff(g2, g3, d2); // 做差求绝对值 ...&#xA;    bitwise_and(d1, d2, d3); // 与运算 ...&#xA;&#xA;    // 图像上的像素点的灰度值设置为0或255, 这样将使整个图像呈现出明显的黑白效果&#xA;    threshold(d3, frame, 20, 255.0, THRESH_BINARY); // 二值化&#xA;&#xA;    dilate(frame, frame, Mat()); // 膨胀(膨胀是将白色区域扩大)&#xA;    // erode(frame, frame, Mat()); // 腐蚀(腐蚀是将黑色区域扩大)&#xA;&#xA;    int count = 0;&#xA;    Mat_&amp;lt;uchar&amp;gt;::iterator it = frame.begin&amp;lt;uchar&amp;gt;();&#xA;    Mat_&amp;lt;uchar&amp;gt;::iterator itend = frame.end&amp;lt;uchar&amp;gt;();&#xA;    for (; it != itend; ++it) {&#xA;        if ((*it)&amp;gt;0) count+=1; // 二值化后，像素点是0或者255&#xA;    }&#xA;    m_log-&amp;gt;debug(QString(&amp;quot;&amp;gt;&amp;gt; %1&amp;quot;).arg(count));&#xA;&#xA;    imshow(&amp;quot;windows&amp;quot;, frame);&#xA;    waitKey(1000/30);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenCV之从video设备录制视频</title>
      <link>http://www.nljb.net/default/OpenCV%E4%B9%8B%E4%BB%8Evideo%E8%AE%BE%E5%A4%87%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/</link>
      <pubDate>2017-09-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OpenCV之从video设备录制视频&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/core/core.hpp&amp;gt;&#xA;#include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;&#xA;#include &amp;lt;QLatin1String&amp;gt;&#xA;#include &amp;lt;QQueue&amp;gt;&#xA;#include &amp;lt;QDateTime&amp;gt;&#xA;&#xA;using namespace cv;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;&#xA;    int id = QString(QLatin1String(argv[1])).toInt();&#xA;    int fps = QString(QLatin1String(argv[2])).toInt();&#xA;    int len = QString(QLatin1String(argv[3])).toInt();&#xA;    QString nm = QString(QLatin1String(argv[4]));&#xA;    CvCapture* capture = cvCreateCameraCapture(id);&#xA;    cvSetCaptureProperty(capture, CV_CAP_PROP_FRAME_WIDTH, 1280);&#xA;    cvSetCaptureProperty(capture, CV_CAP_PROP_FRAME_HEIGHT, 1024);&#xA;    cvSetCaptureProperty(capture, CV_CAP_PROP_FPS, fps);&#xA;&#xA;    IplImage* frame = cvQueryFrame(capture);&#xA;    CvVideoWriter* video = cvCreateVideoWriter(nm.toStdString().c_str(), CV_FOURCC(&#39;D&#39;, &#39;I&#39;, &#39;V&#39;, &#39;X&#39;) , fps, cvSize(frame-&amp;gt;width, frame-&amp;gt;height));&#xA;&#xA;    int count = 0;&#xA;    QQueue&amp;lt;qint64&amp;gt; t;&#xA;    qint64 t0 = QDateTime::currentMSecsSinceEpoch();&#xA;    while (count &amp;lt;= len)&#xA;    {&#xA;    frame = cvQueryFrame(capture);&#xA;    if(!frame)&#xA;    {&#xA;        cout&amp;lt;&amp;lt;&amp;quot;Can not get frame from the capture.&amp;quot;&amp;lt;&amp;lt;endl;&#xA;        break;&#xA;    }&#xA;    cvWriteFrame(video, frame);&#xA;    count++;&#xA;    const qint64 now = QDateTime::currentMSecsSinceEpoch();&#xA;    const qint64 dt = now - t0;&#xA;    t.enqueue(now);&#xA;    if (count % 10 == 0) {&#xA;        cout &amp;lt;&amp;lt; QString().sprintf(&amp;quot;COUNT %d - FPS(%.1f/%.1f)&amp;quot;, count,  (count  *1000.0 / dt), (t.size() * 1000.0 / (now - t.first()))).toStdString().c_str() &amp;lt;&amp;lt; endl;;&#xA;    }&#xA;    if (t.size() &amp;gt; 10)&#xA;        t.dequeue();&#xA;    }&#xA;    cvReleaseVideoWriter(&amp;amp;video);&#xA;    cvReleaseCapture(&amp;amp;capture);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之QMultiMap一键多值</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8BQMultiMap%E4%B8%80%E9%94%AE%E5%A4%9A%E5%80%BC/</link>
      <pubDate>2017-09-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Qt之QMultiMap一键多值&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;在QT中常用的键值对QMap，当遇到一键多值需要存储时往往QMap中vector这样存储, 但是QT提供了QMultiMap来解决这个问题&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://doc.qt.io/qt-4.8/qmultimap.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QMultiMap&amp;lt;QString, int&amp;gt; map1, map2, map3;&#xA;&#xA;map1.insert(&amp;quot;plenty&amp;quot;, 100);&#xA;map1.insert(&amp;quot;plenty&amp;quot;, 2000);&#xA;// map1.size() == 2&#xA;&#xA;map2.insert(&amp;quot;plenty&amp;quot;, 5000);&#xA;// map2.size() == 1&#xA;&#xA;map3 = map1 + map2;&#xA;// map3.size() == 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QList&amp;lt;int&amp;gt; values = map.values(&amp;quot;plenty&amp;quot;);&#xA;for (int i = 0; i &amp;lt; values.size(); ++i)&#xA;    cout &amp;lt;&amp;lt; values.at(i) &amp;lt;&amp;lt; endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QMultiMap&amp;lt;QString, int&amp;gt;::iterator i = map.find(&amp;quot;plenty&amp;quot;);&#xA;while (i != map.end() &amp;amp;&amp;amp; i.key() == &amp;quot;plenty&amp;quot;) {&#xA;    cout &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; endl;&#xA;    ++i;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之线程与数据传递的使用</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2017-08-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Qt之线程与数据传递的使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// .h&#xA;class Demo : public QObject&#xA;{&#xA;    Q_OBJECT&#xA;public:&#xA;    Demo();&#xA;    void start();&#xA;public slots:&#xA;    void run() {&#xA;    start();&#xA;    }&#xA;signals:&#xA;    void send(QJsonObject);&#xA;};&#xA;&#xA;// .cpp&#xA;Demo::Demo()&#xA;{&#xA;}&#xA;&#xA;void Demo::start()&#xA;{&#xA;    QJsonObject a = readJson(&amp;quot;/demo.json&amp;quot;);&#xA;    if (a.isEmpty()) {&#xA;    return;&#xA;    }&#xA;    emit control(a);&#xA;}&#xA;&#xA;// QtWindow.cpp&#xA;void QtWindow::recv(QJsonObject _json) &#xA;{&#xA;    // ...&#xA;}&#xA;&#xA;// 启动线程(当前是在QtWindow)&#xA;Demo *demo = new Demo();&#xA;QObject::connect(demo, SIGNAL(send(QJsonObject)), this, SLOT(recv(QJsonObject)));&#xA;QThread *thread = new QThread();&#xA;demo-&amp;gt;moveToThread(thread);&#xA;thread-&amp;gt;start();&#xA;QObject::connect(thread, SIGNAL(started()), demo, SLOT(run()));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// .h&#xA;class Demo : public QRunnable&#xA;{&#xA;public:&#xA;    Demo();&#xA;    virtual ~Demo();&#xA;    void run();&#xA;    void setWindow(QtWindow*);&#xA;    QtWindow *m_window;&#xA;};&#xA;&#xA;// .cpp&#xA;Demo::Demo()&#xA;{&#xA;}&#xA;&#xA;Demo::~Demo()&#xA;{&#xA;&#xA;}&#xA;&#xA;void Demo::setWindow(QtWindow *_m_window)&#xA;{&#xA;    m_window = _m_window;&#xA;}&#xA;&#xA;void Demo::run()&#xA;{&#xA;    /* 发送指令 ... */&#xA;    QMetaObject::invokeMethod(m_window, &amp;quot;recv&amp;quot;, Q_ARG(QJsonObject, m_json));&#xA;}&#xA;&#xA;// QtWindow.cpp&#xA;void QtWindow::recv(QJsonObject _m_json) &#xA;{&#xA;    // ...&#xA;}&#xA;&#xA;// 启动线程(当前是在QtWindow)&#xA;Demo *demo = new Demo();&#xA;demo.setWindow(this);&#xA;QThreadPool::globalInstance()-&amp;gt;start(demo);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Ubuntu之Firefox开机自启及全屏</title>
      <link>http://www.nljb.net/default/Ubuntu%E4%B9%8BFirefox%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8F%8A%E5%85%A8%E5%B1%8F/</link>
      <pubDate>2017-08-22 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Ubuntu之Firefox开机自启及全屏&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# 安装全屏插件 Firefox FullScreen&#xA;https://addons.mozilla.org/zh-CN/firefox/addon/mwfullscreen/?src=search&#xA;&#xA;# 方法一：设置开机自动启动&#xA;# vi ~/.config/upstart/firefox.conf&#xA;start on desktop-start  &#xA;stop on desktop-end  &#xA;exec /usr/bin/firefox&#xA;&#xA;# 方法二：设置开机自动启动&#xA;mkdir -p ~/.config/autostart&#xA;cp /usr/share/applications/firefox.desktop ~/.config/autostart/firefox.desktop&#xA;chmod +x ~/.config/autostart/firefox.desktop&#xA;&#xA;# 方法三：Startup Applications 添加&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Chrome&#xA;--kiosk 即可全屏&#xA;--app=&amp;lt;URL&amp;gt; 自动打开指定的URL&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之通过udev规则指定设备文件名</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8B%E9%80%9A%E8%BF%87udev%E8%A7%84%E5%88%99%E6%8C%87%E5%AE%9A%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E5%90%8D/</link>
      <pubDate>2017-08-01 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Linux之通过udev规则指定设备文件名&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;需求：有三个/dev/video0-3设备，但是每次重启设备的文件名称会改变, 想固定这个设备文件名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当前 /dev/video0 是 PCI 采集卡，1-2是USB摄像头 &amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过 udevinfo (ubuntu：udevadm) 查看设备信息&#xA;// udevadm (udev管理工具)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;udevadm info -a /dev/video0 &#xA;&#xA;    Udevadm info starts with the device specified by the devpath and then&#xA;    walks up the chain of parent devices. It prints for every device&#xA;    found, all possible attributes in the udev rules key format.&#xA;    A rule to match, can be composed by the attributes of the device&#xA;    and the attributes from one single parent device.&#xA;&#xA;    looking at device &#39;/devices/pci0000:00/0000:00:1c.5/0000:02:00.0/0000:03:01.0/0000:04:00.0/video4linux/video0&#39;:&#xA;        KERNEL==&amp;quot;video0&amp;quot;&#xA;        SUBSYSTEM==&amp;quot;video4linux&amp;quot;&#xA;        DRIVER==&amp;quot;&amp;quot;&#xA;        ATTR{dev_debug}==&amp;quot;0&amp;quot;&#xA;        ATTR{index}==&amp;quot;0&amp;quot;&#xA;        ATTR{name}==&amp;quot;PL330B:RAW 00.00 a0011af2&amp;quot;&#xA;&#xA;    looking at parent device &#39;/devices/pci0000:00/0000:00:1c.5/0000:02:00.0/0000:03:01.0/0000:04:00.0&#39;:&#xA;        KERNELS==&amp;quot;0000:04:00.0&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;pci&amp;quot;&#xA;        DRIVERS==&amp;quot;LINUXV4L2330b&amp;quot;&#xA;        ATTRS{broken_parity_status}==&amp;quot;0&amp;quot;&#xA;        ATTRS{class}==&amp;quot;0xff0000&amp;quot;&#xA;        ATTRS{consistent_dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{d3cold_allowed}==&amp;quot;1&amp;quot;&#xA;        ATTRS{device}==&amp;quot;0xa001&amp;quot;&#xA;        ATTRS{dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{driver_override}==&amp;quot;(null)&amp;quot;&#xA;        ATTRS{enable}==&amp;quot;1&amp;quot;&#xA;        ATTRS{irq}==&amp;quot;18&amp;quot;&#xA;        ATTRS{local_cpulist}==&amp;quot;0-7&amp;quot;&#xA;        ATTRS{local_cpus}==&amp;quot;ff&amp;quot;&#xA;        ATTRS{msi_bus}==&amp;quot;1&amp;quot;&#xA;        ATTRS{numa_node}==&amp;quot;-1&amp;quot;&#xA;        ATTRS{revision}==&amp;quot;0x00&amp;quot;&#xA;        ATTRS{subsystem_device}==&amp;quot;0xa001&amp;quot;&#xA;        ATTRS{subsystem_vendor}==&amp;quot;0x1af2&amp;quot;&#xA;        ATTRS{vendor}==&amp;quot;0x1af2&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:1c.5/0000:02:00.0/0000:03:01.0&#39;:&#xA;        KERNELS==&amp;quot;0000:03:01.0&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;pci&amp;quot;&#xA;        DRIVERS==&amp;quot;pcieport&amp;quot;&#xA;        ATTRS{broken_parity_status}==&amp;quot;0&amp;quot;&#xA;        ATTRS{class}==&amp;quot;0x060400&amp;quot;&#xA;        ATTRS{consistent_dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{d3cold_allowed}==&amp;quot;1&amp;quot;&#xA;        ATTRS{device}==&amp;quot;0x2304&amp;quot;&#xA;        ATTRS{dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{driver_override}==&amp;quot;(null)&amp;quot;&#xA;        ATTRS{enable}==&amp;quot;1&amp;quot;&#xA;        ATTRS{irq}==&amp;quot;120&amp;quot;&#xA;        ATTRS{local_cpulist}==&amp;quot;0-7&amp;quot;&#xA;        ATTRS{local_cpus}==&amp;quot;ff&amp;quot;&#xA;        ATTRS{msi_bus}==&amp;quot;1&amp;quot;&#xA;        ATTRS{numa_node}==&amp;quot;-1&amp;quot;&#xA;        ATTRS{revision}==&amp;quot;0x05&amp;quot;&#xA;        ATTRS{subsystem_device}==&amp;quot;0x0000&amp;quot;&#xA;        ATTRS{subsystem_vendor}==&amp;quot;0x0000&amp;quot;&#xA;        ATTRS{vendor}==&amp;quot;0x12d8&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:1c.5/0000:02:00.0&#39;:&#xA;        KERNELS==&amp;quot;0000:02:00.0&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;pci&amp;quot;&#xA;        DRIVERS==&amp;quot;pcieport&amp;quot;&#xA;        ATTRS{broken_parity_status}==&amp;quot;0&amp;quot;&#xA;        ATTRS{class}==&amp;quot;0x060400&amp;quot;&#xA;        ATTRS{consistent_dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{d3cold_allowed}==&amp;quot;1&amp;quot;&#xA;        ATTRS{device}==&amp;quot;0x2304&amp;quot;&#xA;        ATTRS{dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{driver_override}==&amp;quot;(null)&amp;quot;&#xA;        ATTRS{enable}==&amp;quot;1&amp;quot;&#xA;        ATTRS{irq}==&amp;quot;0&amp;quot;&#xA;        ATTRS{local_cpulist}==&amp;quot;0-7&amp;quot;&#xA;        ATTRS{local_cpus}==&amp;quot;ff&amp;quot;&#xA;        ATTRS{msi_bus}==&amp;quot;1&amp;quot;&#xA;        ATTRS{numa_node}==&amp;quot;-1&amp;quot;&#xA;        ATTRS{revision}==&amp;quot;0x05&amp;quot;&#xA;        ATTRS{subsystem_device}==&amp;quot;0x0000&amp;quot;&#xA;        ATTRS{subsystem_vendor}==&amp;quot;0x0000&amp;quot;&#xA;        ATTRS{vendor}==&amp;quot;0x12d8&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:1c.5&#39;:&#xA;        KERNELS==&amp;quot;0000:00:1c.5&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;pci&amp;quot;&#xA;        DRIVERS==&amp;quot;pcieport&amp;quot;&#xA;        ATTRS{broken_parity_status}==&amp;quot;0&amp;quot;&#xA;        ATTRS{class}==&amp;quot;0x060400&amp;quot;&#xA;        ATTRS{consistent_dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{d3cold_allowed}==&amp;quot;1&amp;quot;&#xA;        ATTRS{device}==&amp;quot;0xa295&amp;quot;&#xA;        ATTRS{dma_mask_bits}==&amp;quot;32&amp;quot;&#xA;        ATTRS{driver_override}==&amp;quot;(null)&amp;quot;&#xA;        ATTRS{enable}==&amp;quot;1&amp;quot;&#xA;        ATTRS{irq}==&amp;quot;17&amp;quot;&#xA;        ATTRS{local_cpulist}==&amp;quot;0-7&amp;quot;&#xA;        ATTRS{local_cpus}==&amp;quot;ff&amp;quot;&#xA;        ATTRS{msi_bus}==&amp;quot;1&amp;quot;&#xA;        ATTRS{numa_node}==&amp;quot;-1&amp;quot;&#xA;        ATTRS{revision}==&amp;quot;0xf0&amp;quot;&#xA;        ATTRS{subsystem_device}==&amp;quot;0x8694&amp;quot;&#xA;        ATTRS{subsystem_vendor}==&amp;quot;0x1043&amp;quot;&#xA;        ATTRS{vendor}==&amp;quot;0x8086&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00&#39;:&#xA;        KERNELS==&amp;quot;pci0000:00&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;&amp;quot;&#xA;        DRIVERS==&amp;quot;&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;udevadm info -a /dev/video1 &#xA;&#xA;    Udevadm info starts with the device specified by the devpath and then&#xA;    walks up the chain of parent devices. It prints for every device&#xA;    found, all possible attributes in the udev rules key format.&#xA;    A rule to match, can be composed by the attributes of the device&#xA;    and the attributes from one single parent device.&#xA;&#xA;      looking at device &#39;/devices/pci0000:00/0000:00:14.0/usb1/1-5/1-5:1.0/video4linux/video1&#39;:&#xA;        KERNEL==&amp;quot;video1&amp;quot;&#xA;        SUBSYSTEM==&amp;quot;video4linux&amp;quot;&#xA;        DRIVER==&amp;quot;&amp;quot;&#xA;        ATTR{dev_debug}==&amp;quot;0&amp;quot;&#xA;        ATTR{index}==&amp;quot;0&amp;quot;&#xA;        ATTR{name}==&amp;quot;USB 2.0 Camera&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0/usb1/1-5/1-5:1.0&#39;:&#xA;        KERNELS==&amp;quot;1-5:1.0&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;        DRIVERS==&amp;quot;uvcvideo&amp;quot;&#xA;        ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bAlternateSetting}==&amp;quot; 0&amp;quot;&#xA;        ATTRS{bInterfaceClass}==&amp;quot;0e&amp;quot;&#xA;        ATTRS{bInterfaceNumber}==&amp;quot;00&amp;quot;&#xA;        ATTRS{bInterfaceProtocol}==&amp;quot;00&amp;quot;&#xA;        ATTRS{bInterfaceSubClass}==&amp;quot;01&amp;quot;&#xA;        ATTRS{bNumEndpoints}==&amp;quot;01&amp;quot;&#xA;        ATTRS{iad_bFirstInterface}==&amp;quot;00&amp;quot;&#xA;        ATTRS{iad_bFunctionClass}==&amp;quot;0e&amp;quot;&#xA;        ATTRS{iad_bFunctionProtocol}==&amp;quot;00&amp;quot;&#xA;        ATTRS{iad_bFunctionSubClass}==&amp;quot;03&amp;quot;&#xA;        ATTRS{iad_bInterfaceCount}==&amp;quot;02&amp;quot;&#xA;        ATTRS{interface}==&amp;quot;HD USB Camera&amp;quot;&#xA;        ATTRS{supports_autosuspend}==&amp;quot;1&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0/usb1/1-5&#39;:&#xA;        KERNELS==&amp;quot;1-5&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;        DRIVERS==&amp;quot;usb&amp;quot;&#xA;        ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;        ATTRS{avoid_reset_quirk}==&amp;quot;0&amp;quot;&#xA;        ATTRS{bConfigurationValue}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bDeviceClass}==&amp;quot;ef&amp;quot;&#xA;        ATTRS{bDeviceProtocol}==&amp;quot;01&amp;quot;&#xA;        ATTRS{bDeviceSubClass}==&amp;quot;02&amp;quot;&#xA;        ATTRS{bMaxPacketSize0}==&amp;quot;64&amp;quot;&#xA;        ATTRS{bMaxPower}==&amp;quot;500mA&amp;quot;&#xA;        ATTRS{bNumConfigurations}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bNumInterfaces}==&amp;quot; 2&amp;quot;&#xA;        ATTRS{bcdDevice}==&amp;quot;0100&amp;quot;&#xA;        ATTRS{bmAttributes}==&amp;quot;80&amp;quot;&#xA;        ATTRS{busnum}==&amp;quot;1&amp;quot;&#xA;        ATTRS{configuration}==&amp;quot;&amp;quot;&#xA;        ATTRS{devnum}==&amp;quot;3&amp;quot;&#xA;        ATTRS{devpath}==&amp;quot;5&amp;quot;&#xA;        ATTRS{idProduct}==&amp;quot;9230&amp;quot;&#xA;        ATTRS{idVendor}==&amp;quot;05a3&amp;quot;&#xA;        ATTRS{ltm_capable}==&amp;quot;no&amp;quot;&#xA;        ATTRS{manufacturer}==&amp;quot;HD Camera Manufacturer&amp;quot;&#xA;        ATTRS{maxchild}==&amp;quot;0&amp;quot;&#xA;        ATTRS{product}==&amp;quot;USB 2.0 Camera&amp;quot;&#xA;        ATTRS{quirks}==&amp;quot;0x0&amp;quot;&#xA;        ATTRS{removable}==&amp;quot;removable&amp;quot;&#xA;        ATTRS{speed}==&amp;quot;480&amp;quot;&#xA;        ATTRS{urbnum}==&amp;quot;7260181&amp;quot;&#xA;        ATTRS{version}==&amp;quot; 2.00&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0/usb1&#39;:&#xA;        KERNELS==&amp;quot;usb1&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;        DRIVERS==&amp;quot;usb&amp;quot;&#xA;        ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;        ATTRS{authorized_default}==&amp;quot;1&amp;quot;&#xA;        ATTRS{avoid_reset_quirk}==&amp;quot;0&amp;quot;&#xA;        ATTRS{bConfigurationValue}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bDeviceClass}==&amp;quot;09&amp;quot;&#xA;        ATTRS{bDeviceProtocol}==&amp;quot;01&amp;quot;&#xA;        ATTRS{bDeviceSubClass}==&amp;quot;00&amp;quot;&#xA;        ATTRS{bMaxPacketSize0}==&amp;quot;64&amp;quot;&#xA;        ATTRS{bMaxPower}==&amp;quot;0mA&amp;quot;&#xA;        ATTRS{bNumConfigurations}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bNumInterfaces}==&amp;quot; 1&amp;quot;&#xA;        ATTRS{bcdDevice}==&amp;quot;0410&amp;quot;&#xA;        ATTRS{bmAttributes}==&amp;quot;e0&amp;quot;&#xA;        ATTRS{busnum}==&amp;quot;1&amp;quot;&#xA;        ATTRS{configuration}==&amp;quot;&amp;quot;&#xA;        ATTRS{devnum}==&amp;quot;1&amp;quot;&#xA;        ATTRS{devpath}==&amp;quot;0&amp;quot;&#xA;        ATTRS{idProduct}==&amp;quot;0002&amp;quot;&#xA;        ATTRS{idVendor}==&amp;quot;1d6b&amp;quot;&#xA;        ATTRS{interface_authorized_default}==&amp;quot;1&amp;quot;&#xA;        ATTRS{ltm_capable}==&amp;quot;no&amp;quot;&#xA;        ATTRS{manufacturer}==&amp;quot;Linux 4.10.0-27-generic xhci-hcd&amp;quot;&#xA;        ATTRS{maxchild}==&amp;quot;12&amp;quot;&#xA;        ATTRS{product}==&amp;quot;xHCI Host Controller&amp;quot;&#xA;        ATTRS{quirks}==&amp;quot;0x0&amp;quot;&#xA;        ATTRS{removable}==&amp;quot;unknown&amp;quot;&#xA;        ATTRS{serial}==&amp;quot;0000:00:14.0&amp;quot;&#xA;        ATTRS{speed}==&amp;quot;480&amp;quot;&#xA;        ATTRS{urbnum}==&amp;quot;60&amp;quot;&#xA;        ATTRS{version}==&amp;quot; 2.00&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0&#39;:&#xA;        KERNELS==&amp;quot;0000:00:14.0&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;pci&amp;quot;&#xA;        DRIVERS==&amp;quot;xhci_hcd&amp;quot;&#xA;        ATTRS{broken_parity_status}==&amp;quot;0&amp;quot;&#xA;        ATTRS{class}==&amp;quot;0x0c0330&amp;quot;&#xA;        ATTRS{consistent_dma_mask_bits}==&amp;quot;64&amp;quot;&#xA;        ATTRS{d3cold_allowed}==&amp;quot;1&amp;quot;&#xA;        ATTRS{device}==&amp;quot;0xa2af&amp;quot;&#xA;        ATTRS{dma_mask_bits}==&amp;quot;64&amp;quot;&#xA;        ATTRS{driver_override}==&amp;quot;(null)&amp;quot;&#xA;        ATTRS{enable}==&amp;quot;1&amp;quot;&#xA;        ATTRS{irq}==&amp;quot;122&amp;quot;&#xA;        ATTRS{local_cpulist}==&amp;quot;0-7&amp;quot;&#xA;        ATTRS{local_cpus}==&amp;quot;ff&amp;quot;&#xA;        ATTRS{msi_bus}==&amp;quot;1&amp;quot;&#xA;        ATTRS{numa_node}==&amp;quot;-1&amp;quot;&#xA;        ATTRS{revision}==&amp;quot;0x00&amp;quot;&#xA;        ATTRS{subsystem_device}==&amp;quot;0x8694&amp;quot;&#xA;        ATTRS{subsystem_vendor}==&amp;quot;0x1043&amp;quot;&#xA;        ATTRS{vendor}==&amp;quot;0x8086&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00&#39;:&#xA;        KERNELS==&amp;quot;pci0000:00&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;&amp;quot;&#xA;        DRIVERS==&amp;quot;&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;udevadm info -a /dev/video2 &#xA;&#xA;    Udevadm info starts with the device specified by the devpath and then&#xA;    walks up the chain of parent devices. It prints for every device&#xA;    found, all possible attributes in the udev rules key format.&#xA;    A rule to match, can be composed by the attributes of the device&#xA;    and the attributes from one single parent device.&#xA;&#xA;      looking at device &#39;/devices/pci0000:00/0000:00:14.0/usb1/1-6/1-6:1.0/video4linux/video2&#39;:&#xA;        KERNEL==&amp;quot;video2&amp;quot;&#xA;        SUBSYSTEM==&amp;quot;video4linux&amp;quot;&#xA;        DRIVER==&amp;quot;&amp;quot;&#xA;        ATTR{dev_debug}==&amp;quot;0&amp;quot;&#xA;        ATTR{index}==&amp;quot;0&amp;quot;&#xA;        ATTR{name}==&amp;quot;USB 2.0 Camera&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0/usb1/1-6/1-6:1.0&#39;:&#xA;        KERNELS==&amp;quot;1-6:1.0&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;        DRIVERS==&amp;quot;uvcvideo&amp;quot;&#xA;        ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bAlternateSetting}==&amp;quot; 0&amp;quot;&#xA;        ATTRS{bInterfaceClass}==&amp;quot;0e&amp;quot;&#xA;        ATTRS{bInterfaceNumber}==&amp;quot;00&amp;quot;&#xA;        ATTRS{bInterfaceProtocol}==&amp;quot;00&amp;quot;&#xA;        ATTRS{bInterfaceSubClass}==&amp;quot;01&amp;quot;&#xA;        ATTRS{bNumEndpoints}==&amp;quot;01&amp;quot;&#xA;        ATTRS{iad_bFirstInterface}==&amp;quot;00&amp;quot;&#xA;        ATTRS{iad_bFunctionClass}==&amp;quot;0e&amp;quot;&#xA;        ATTRS{iad_bFunctionProtocol}==&amp;quot;00&amp;quot;&#xA;        ATTRS{iad_bFunctionSubClass}==&amp;quot;03&amp;quot;&#xA;        ATTRS{iad_bInterfaceCount}==&amp;quot;02&amp;quot;&#xA;        ATTRS{interface}==&amp;quot;HD USB Camera&amp;quot;&#xA;        ATTRS{supports_autosuspend}==&amp;quot;1&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0/usb1/1-6&#39;:&#xA;        KERNELS==&amp;quot;1-6&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;        DRIVERS==&amp;quot;usb&amp;quot;&#xA;        ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;        ATTRS{avoid_reset_quirk}==&amp;quot;0&amp;quot;&#xA;        ATTRS{bConfigurationValue}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bDeviceClass}==&amp;quot;ef&amp;quot;&#xA;        ATTRS{bDeviceProtocol}==&amp;quot;01&amp;quot;&#xA;        ATTRS{bDeviceSubClass}==&amp;quot;02&amp;quot;&#xA;        ATTRS{bMaxPacketSize0}==&amp;quot;64&amp;quot;&#xA;        ATTRS{bMaxPower}==&amp;quot;500mA&amp;quot;&#xA;        ATTRS{bNumConfigurations}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bNumInterfaces}==&amp;quot; 2&amp;quot;&#xA;        ATTRS{bcdDevice}==&amp;quot;0100&amp;quot;&#xA;        ATTRS{bmAttributes}==&amp;quot;80&amp;quot;&#xA;        ATTRS{busnum}==&amp;quot;1&amp;quot;&#xA;        ATTRS{configuration}==&amp;quot;&amp;quot;&#xA;        ATTRS{devnum}==&amp;quot;4&amp;quot;&#xA;        ATTRS{devpath}==&amp;quot;6&amp;quot;&#xA;        ATTRS{idProduct}==&amp;quot;9230&amp;quot;&#xA;        ATTRS{idVendor}==&amp;quot;05a3&amp;quot;&#xA;        ATTRS{ltm_capable}==&amp;quot;no&amp;quot;&#xA;        ATTRS{manufacturer}==&amp;quot;HD Camera Manufacturer&amp;quot;&#xA;        ATTRS{maxchild}==&amp;quot;0&amp;quot;&#xA;        ATTRS{product}==&amp;quot;USB 2.0 Camera&amp;quot;&#xA;        ATTRS{quirks}==&amp;quot;0x0&amp;quot;&#xA;        ATTRS{removable}==&amp;quot;removable&amp;quot;&#xA;        ATTRS{speed}==&amp;quot;480&amp;quot;&#xA;        ATTRS{urbnum}==&amp;quot;7275257&amp;quot;&#xA;        ATTRS{version}==&amp;quot; 2.00&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0/usb1&#39;:&#xA;        KERNELS==&amp;quot;usb1&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;usb&amp;quot;&#xA;        DRIVERS==&amp;quot;usb&amp;quot;&#xA;        ATTRS{authorized}==&amp;quot;1&amp;quot;&#xA;        ATTRS{authorized_default}==&amp;quot;1&amp;quot;&#xA;        ATTRS{avoid_reset_quirk}==&amp;quot;0&amp;quot;&#xA;        ATTRS{bConfigurationValue}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bDeviceClass}==&amp;quot;09&amp;quot;&#xA;        ATTRS{bDeviceProtocol}==&amp;quot;01&amp;quot;&#xA;        ATTRS{bDeviceSubClass}==&amp;quot;00&amp;quot;&#xA;        ATTRS{bMaxPacketSize0}==&amp;quot;64&amp;quot;&#xA;        ATTRS{bMaxPower}==&amp;quot;0mA&amp;quot;&#xA;        ATTRS{bNumConfigurations}==&amp;quot;1&amp;quot;&#xA;        ATTRS{bNumInterfaces}==&amp;quot; 1&amp;quot;&#xA;        ATTRS{bcdDevice}==&amp;quot;0410&amp;quot;&#xA;        ATTRS{bmAttributes}==&amp;quot;e0&amp;quot;&#xA;        ATTRS{busnum}==&amp;quot;1&amp;quot;&#xA;        ATTRS{configuration}==&amp;quot;&amp;quot;&#xA;        ATTRS{devnum}==&amp;quot;1&amp;quot;&#xA;        ATTRS{devpath}==&amp;quot;0&amp;quot;&#xA;        ATTRS{idProduct}==&amp;quot;0002&amp;quot;&#xA;        ATTRS{idVendor}==&amp;quot;1d6b&amp;quot;&#xA;        ATTRS{interface_authorized_default}==&amp;quot;1&amp;quot;&#xA;        ATTRS{ltm_capable}==&amp;quot;no&amp;quot;&#xA;        ATTRS{manufacturer}==&amp;quot;Linux 4.10.0-27-generic xhci-hcd&amp;quot;&#xA;        ATTRS{maxchild}==&amp;quot;12&amp;quot;&#xA;        ATTRS{product}==&amp;quot;xHCI Host Controller&amp;quot;&#xA;        ATTRS{quirks}==&amp;quot;0x0&amp;quot;&#xA;        ATTRS{removable}==&amp;quot;unknown&amp;quot;&#xA;        ATTRS{serial}==&amp;quot;0000:00:14.0&amp;quot;&#xA;        ATTRS{speed}==&amp;quot;480&amp;quot;&#xA;        ATTRS{urbnum}==&amp;quot;60&amp;quot;&#xA;        ATTRS{version}==&amp;quot; 2.00&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00/0000:00:14.0&#39;:&#xA;        KERNELS==&amp;quot;0000:00:14.0&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;pci&amp;quot;&#xA;        DRIVERS==&amp;quot;xhci_hcd&amp;quot;&#xA;        ATTRS{broken_parity_status}==&amp;quot;0&amp;quot;&#xA;        ATTRS{class}==&amp;quot;0x0c0330&amp;quot;&#xA;        ATTRS{consistent_dma_mask_bits}==&amp;quot;64&amp;quot;&#xA;        ATTRS{d3cold_allowed}==&amp;quot;1&amp;quot;&#xA;        ATTRS{device}==&amp;quot;0xa2af&amp;quot;&#xA;        ATTRS{dma_mask_bits}==&amp;quot;64&amp;quot;&#xA;        ATTRS{driver_override}==&amp;quot;(null)&amp;quot;&#xA;        ATTRS{enable}==&amp;quot;1&amp;quot;&#xA;        ATTRS{irq}==&amp;quot;122&amp;quot;&#xA;        ATTRS{local_cpulist}==&amp;quot;0-7&amp;quot;&#xA;        ATTRS{local_cpus}==&amp;quot;ff&amp;quot;&#xA;        ATTRS{msi_bus}==&amp;quot;1&amp;quot;&#xA;        ATTRS{numa_node}==&amp;quot;-1&amp;quot;&#xA;        ATTRS{revision}==&amp;quot;0x00&amp;quot;&#xA;        ATTRS{subsystem_device}==&amp;quot;0x8694&amp;quot;&#xA;        ATTRS{subsystem_vendor}==&amp;quot;0x1043&amp;quot;&#xA;        ATTRS{vendor}==&amp;quot;0x8086&amp;quot;&#xA;&#xA;      looking at parent device &#39;/devices/pci0000:00&#39;:&#xA;        KERNELS==&amp;quot;pci0000:00&amp;quot;&#xA;        SUBSYSTEMS==&amp;quot;&amp;quot;&#xA;        DRIVERS==&amp;quot;&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看设备对应的 KERNELS ...&#xA;root@danoo-System-Product-Name:~# ll /sys/class/video4linux/video0/&#xA;total 0&#xA;drwxr-xr-x 3 root root    0 8月   1 22:16 ./&#xA;drwxr-xr-x 3 root root    0 8月   1 13:58 ../&#xA;-r--r--r-- 1 root root 4096 8月   1 13:58 dev&#xA;-rw-r--r-- 1 root root 4096 8月   1 22:00 dev_debug&#xA;lrwxrwxrwx 1 root root    0 8月   1 13:58 device -&amp;gt; ../../../0000:04:00.0/&#xA;-r--r--r-- 1 root root 4096 8月   1 13:58 index&#xA;-r--r--r-- 1 root root 4096 8月   1 22:00 name&#xA;drwxr-xr-x 2 root root    0 8月   1 22:16 power/&#xA;lrwxrwxrwx 1 root root    0 8月   1 13:58 subsystem -&amp;gt; ../../../../../../../../class/video4linux/&#xA;-rw-r--r-- 1 root root 4096 8月   1 13:58 uevent&#xA;root@danoo-System-Product-Name:~# ll /sys/class/video4linux/video1/&#xA;total 0&#xA;drwxr-xr-x 3 root root    0 8月   1 22:16 ./&#xA;drwxr-xr-x 3 root root    0 8月   1 13:58 ../&#xA;-r--r--r-- 1 root root 4096 8月   1 13:58 dev&#xA;-rw-r--r-- 1 root root 4096 8月   1 22:02 dev_debug&#xA;lrwxrwxrwx 1 root root    0 8月   1 13:58 device -&amp;gt; ../../../1-5:1.0/&#xA;-r--r--r-- 1 root root 4096 8月   1 13:58 index&#xA;-r--r--r-- 1 root root 4096 8月   1 22:02 name&#xA;drwxr-xr-x 2 root root    0 8月   1 22:16 power/&#xA;lrwxrwxrwx 1 root root    0 8月   1 13:58 subsystem -&amp;gt; ../../../../../../../../class/video4linux/&#xA;-rw-r--r-- 1 root root 4096 8月   1 13:58 uevent&#xA;root@danoo-System-Product-Name:~# ll /sys/class/video4linux/video2/&#xA;total 0&#xA;drwxr-xr-x 3 root root    0 8月   1 22:17 ./&#xA;drwxr-xr-x 3 root root    0 8月   1 13:58 ../&#xA;-r--r--r-- 1 root root 4096 8月   1 13:58 dev&#xA;-rw-r--r-- 1 root root 4096 8月   1 22:03 dev_debug&#xA;lrwxrwxrwx 1 root root    0 8月   1 13:58 device -&amp;gt; ../../../1-6:1.0/&#xA;-r--r--r-- 1 root root 4096 8月   1 13:58 index&#xA;-r--r--r-- 1 root root 4096 8月   1 22:03 name&#xA;drwxr-xr-x 2 root root    0 8月   1 22:17 power/&#xA;lrwxrwxrwx 1 root root    0 8月   1 13:58 subsystem -&amp;gt; ../../../../../../../../class/video4linux/&#xA;-rw-r--r-- 1 root root 4096 8月   1 13:58 uevent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 /etc/udev/rules.d 下新建udev规则文件 81-uvccam.rules&#xA;&#xA;// video0 为 PCI 设备，通过 vendor 和 device 与 KERNELS 来指定 NAME 和 SYMLINK 名称&#xA;// video0 的 device -&amp;gt; ../../../0000:04:00.0/ 同时用 0000:03:01.0 也可以 ... &#xA;// 只要包含 vendor 和 device 即可&#xA;KERNEL==&amp;quot;video*&amp;quot;, SUBSYSTEMS==&amp;quot;pci&amp;quot;, ATTRS{vendor}==&amp;quot;0x1af2&amp;quot;, ATTRS{device}==&amp;quot;0xa001&amp;quot;, KERNELS==&amp;quot;0000:04:00.0&amp;quot;,&#xA;    NAME=&amp;quot;video0&amp;quot;, SYMLINK+=&amp;quot;x&amp;quot;&#xA;# KERNEL==&amp;quot;video*&amp;quot;, SUBSYSTEMS==&amp;quot;pci&amp;quot;, ATTRS{vendor}==&amp;quot;0x12d8&amp;quot;, ATTRS{device}==&amp;quot;0x2304&amp;quot;, KERNELS==&amp;quot;0000:03:01.0&amp;quot;,&#xA;    NAME=&amp;quot;video0&amp;quot;, SYMLINK+=&amp;quot;x&amp;quot;&#xA;// video1 为 USB 设备，通过 idVendor 和 idProduct 与 KERNELS 来指定 NAME 和 SYMLINK 名称&#xA;// video1 的 device -&amp;gt; ../../../1-5:1.0/ 此时 KERNELS=&amp;quot;1-5:1.0&amp;quot; 并不包含 idVendor 和 idProduct &#xA;// 但是 KERNELS=&amp;quot;1-5&amp;quot; 包含同样可以使用 ...&#xA;KERNEL==&amp;quot;video*&amp;quot;, SUBSYSTEMS==&amp;quot;usb&amp;quot;, ATTRS{idVendor}==&amp;quot;05a3&amp;quot;, ATTRS{idProduct}==&amp;quot;9230&amp;quot;, KERNELS==&amp;quot;1-5&amp;quot;,&#xA;    NAME=&amp;quot;video1&amp;quot;, SYMLINK+=&amp;quot;res&amp;quot;&#xA;// video2 为 USB 设备，通过 idVendor 和 idProduct 与 KERNELS 来指定 NAME 和 SYMLINK 名称&#xA;// video1 的 device -&amp;gt; ../../../1-6:1.0/ 此时 KERNELS=&amp;quot;1-5:1.0&amp;quot; 并不包含 idVendor 和 idProduct &#xA;// 但是 KERNELS=&amp;quot;1-6&amp;quot; 包含同样可以使用 ...&#xA;KERNEL==&amp;quot;video*&amp;quot;, SUBSYSTEMS==&amp;quot;usb&amp;quot;, ATTRS{idVendor}==&amp;quot;05a3&amp;quot;, ATTRS{idProduct}==&amp;quot;9230&amp;quot;, KERNELS==&amp;quot;1-6&amp;quot;,&#xA;    NAME=&amp;quot;video2&amp;quot;, SYMLINK+=&amp;quot;face&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 重启后，即可看到&#xA;&#xA;lrwxrwxrwx 1 root root 6 8月   1 13:58 /dev/x -&amp;gt; video0&#xA;lrwxrwxrwx 1 root root 6 8月   1 13:58 /dev/res -&amp;gt; video1&#xA;lrwxrwxrwx 1 root root 6 8月   1 13:58 /dev/face -&amp;gt; video2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;声明：此方法通过 &lt;a href=&#34;http://blog.csdn.net/linczone/article/details/48342419&#34;&gt;http://blog.csdn.net/linczone/article/details/48342419&lt;/a&gt; 学习, 内容绝对原创&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;查看自己设备的idVendor和idProduct&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lsusb -vvv&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;udevadm info --attribute-walk --path=/sys/bus/usb-serial/devices/ttyUSB0&#xA;&#xA;    SUBSYSTEMS==&amp;quot;usb&amp;quot;  &#xA;    DRIVERS==&amp;quot;cp210x&amp;quot;  &#xA;    ATTRS{bInterfaceClass}==&amp;quot;ff&amp;quot;  &#xA;    ATTRS{bInterfaceSubClass}==&amp;quot;00&amp;quot;  &#xA;    ATTRS{bInterfaceProtocol}==&amp;quot;00&amp;quot;  &#xA;    ATTRS{bNumEndpoints}==&amp;quot;02&amp;quot;  &#xA;    ATTRS{supports_autosuspend}==&amp;quot;1&amp;quot;  &#xA;    ATTRS{bAlternateSetting}==&amp;quot; 0&amp;quot;  &#xA;    ATTRS{bInterfaceNumber}==&amp;quot;00&amp;quot;  &#xA;    ATTRS{interface}==&amp;quot;CP2102 USB to UART Bridge Controller&amp;quot;  &#xA;    KERNEL==&amp;quot;ttyUSB*&amp;quot;, KERNELS==&amp;quot;1-2.1&amp;quot;, MODE:=&amp;quot;0777&amp;quot;,SYMLINK+=&amp;quot;slamtec_base_&amp;quot;  &#xA;    KERNEL==&amp;quot;ttyUSB*&amp;quot;, KERNELS==&amp;quot;1-2.2&amp;quot;, MODE:=&amp;quot;0777&amp;quot;,SYMLINK+=&amp;quot;slamtec_laser_&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;service udev reload&#xA;service udev restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Nginx反向代理之端口转发</title>
      <link>http://www.nljb.net/default/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</link>
      <pubDate>2017-07-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Nginx反向代理之端口转发&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 格式检查 /etc/nginx/nginx.conf &#xA;nginx -t -c /etc/nginx/nginx.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# /etc/nginx/nginx.conf &#xA;&#xA;http {&#xA;    // 当通过 face.danoolive.com:80 端口访问这个服务器时&#xA;    // 该请求会被转发到 127.0.0.1:9992&#xA;    server {&#xA;        listen 80; &#xA;        server_name face.danoolive.com; &#xA;        // 通过访问的路径来处理转发 ...&#xA;        location / { &#xA;            // 也不一定是内网 127.0.0.1 ，也可以是另外一个服务器的某个端口等 ...&#xA;            proxy_pass http://127.0.0.1:9992;&#xA;        }&#xA;    }&#xA;&#xA;    // 当通过 res.danoolive.com:80 端口访问这个服务器时&#xA;    // 该请求会被转发到 127.0.0.1:9991&#xA;    server {&#xA;        listen 80; &#xA;        server_name res.danoolive.com; &#xA;        location / { &#xA;            proxy_pass http://127.0.0.1:9991;&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 网上案例&#xA;server {&#xA;    listen       80;&#xA;    server_name  www.aaa.com aaa.com;&#xA;    location / {&#xA;       　　proxy_pass   http://www.aaa.com:8087/proj1/;&#xA;    }&#xA;　　　　location /proj1/ {&#xA;       　　proxy_pass   http://www.aaa.com:8087/proj1/;&#xA;　　　　}&#xA;}&#xA;&#xA;server {&#xA;　　listen 80; &#xA;　　server_name www.bbb.com bbb.com; &#xA;　　location / { &#xA;　　　　proxy_pass http://www.aaa.con:8087/proj2/;&#xA;　　}&#xA;　　location /proj2/ {&#xA;　　　　proxy_pass http://www.aaa.con:8087/proj2/;&#xA;　　}&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Ubuntu之 portmapper is not running 解决方案</title>
      <link>http://www.nljb.net/default/Ubuntu%E4%B9%8B-portmapper-is-not-running-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>2017-07-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Not starting: portmapper is not running&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;以前叫portmap现在叫rpcbind, portmap的主要功能是把RPC程序号转化为Internet的端口号&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Stopping NFS kernel daemon                              [ OK ]&lt;/li&gt;&#xA;&lt;li&gt;Unexporting directories for NFS kernel daemon&amp;hellip;        [ OK ]&lt;/li&gt;&#xA;&lt;li&gt;Exporting directories for NFS kernel daemon&amp;hellip;          [ OK ]&lt;/li&gt;&#xA;&lt;li&gt;Starting NFS kernel daemon&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;Not starting: portmapper is not running&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get purge rpcbind  &#xA;$ sudo apt-get install nfs-kernel-server  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/exports  &#xA;/(your_share_name) *(rw,sync,no_subtree_check,no_root_squash)   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo service rpcbind start  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo /etc/init.d/nfs-kernel-server restart  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Ubuntu下使用Hostapd搭建热点</title>
      <link>http://www.nljb.net/default/Ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8Hostapd%E6%90%AD%E5%BB%BA%E7%83%AD%E7%82%B9/</link>
      <pubDate>2017-07-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Ubuntu下使用Hostapd搭建热点&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 二选一(1)：准备工作: 安装 hostap &#xA;wget http://hostap.epitest.fi/releases/hostapd-2.2.tar.gz&#xA;tar -zxf hostapd-2.2.tar.gz&#xA;cd hostapd-2.2&#xA;cd hostapd&#xA;make&#xA;&#xA;// 二选一(2)：安装 hostap&#xA;apt-get install hostapd&#xA;&#xA;// 打补丁&#xA;git clone https://github.com/OpenSecurityResearch/hostapd-wpe&#xA;patch -p1 &amp;lt; ../hostapd-wpe/hostapd-wpe.patch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// /etc/hostapd.conf&#xA;interface=wlan0&#xA;driver=nl80211&#xA;ssid=test&#xA;channel=6&#xA;hw_mode=g&#xA;auth_algs=1&#xA;wpa=3&#xA;wpa_passphrase=12345678&#xA;wpa_key_mgmt=WPA-PSK&#xA;wpa_pairwise=TKIP&#xA;rsn_pairwise=CCMP&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试 &#xA;hostapd /etc/hostapd.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 一般都会出现以下错误&#xA;Configuration file: hostapd.conf&#xA;nl80211: Could not configure driver mode&#xA;nl80211 driver initialization failed.&#xA;hostapd_free_hapd_data: Interface wlan0 wasn&#39;t started&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解决方案: 修改 NetworkManager 相关配置&#xA;// 放弃NetworkManager对无线热点网卡的管理&#xA;// /etc/NetworkManager/NetworkManager.conf&#xA;[main]&#xA;plugins=ifupdown,keyfile,ofono&#xA;dns=dnsmasq&#xA;&#xA;[ifupdown]&#xA;managed=false&#xA;&#xA;[keyfile] // 注意: 这里的MAC地址是 wlan0 的 .&#xA;unmanaged-devices=mac:70:1c:e7:35:06:8d&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 重启 NetworkManager&#xA;sudo service network-manager stop;sudo service network-manager start  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;此时，应该已经可以搜索到ssid为test的wifi了，但是还不能连接&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 安装 dhcp server&#xA;apt-get install isc-dhcp-server&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 配置 DHCP&#xA;// vi /etc/default/isc-dhcp-server&#xA;INTERFACES=&amp;quot;wlan0&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;option domain-name-servers 8.8.8.8, 114.114.114.114;&#xA;default-lease-time 600;&#xA;max-lease-time 7200;&#xA;&#xA;// 192.168.3.0 为网段&#xA;subnet 192.168.3.0 netmask 255.255.255.0 {&#xA;    // range 为 dhcp 的地址池&#xA;    range 192.168.3.100 192.168.3.200;&#xA;    // routers 为 获取的网关 ...&#xA;    // 这里的地址为 wlan0 的 ip 地址 ...&#xA;    option routers 192.168.3.1;&#xA;    // 广播地址&#xA;    option broadcast-address 192.168.3.255;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 配置 wlan0 地址并重启 dhcp server&#xA;ifconfig wlan0 192.168.3.1/24&#xA;service isc-dhcp-server restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开启端口转发 ... 并透明代理 eth0&#xA;echo &amp;quot;1&amp;quot; &amp;gt; /proc/sys/net/ipv4/ip_forward&#xA;iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;完成以上配置，如果没有出错，应该可以了，此时需要写个脚本启动了&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>在Linux中使用lsusb查看USB设备</title>
      <link>http://www.nljb.net/default/%E5%9C%A8Linux%E4%B8%AD%E4%BD%BF%E7%94%A8lsusb%E6%9F%A5%E7%9C%8BUSB%E8%AE%BE%E5%A4%87/</link>
      <pubDate>2017-07-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;在Linux中使用lsusb查看USB设备&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Bus 008 : 指明设备连接到哪（哪条总线）&#xA;Device 002 : 表明这是连接到总线上的第二台设备&#xA;ID : 设备的ID&#xA;Broadcom Corp. Bluetooth Controller :生产商名字和设备名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ lsusb&#xA;Bus 002 Device 002: ID 05e3:0612 Genesys Logic, Inc.&#xA;Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub&#xA;Bus 001 Device 002: ID 05e3:0612 Genesys Logic, Inc.&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;&#xA;// Genesys 是台湾的 USB HUB 芯片厂商，我们可以看到在系统中同时使用了 USB 3.0 root hub 驱动和 USB 2.0 root hub 驱动。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lsusb -v // 列出所有USB的详细&#xA;&#xA;// 可以输出非常详细的信息，包括设备的电流等等&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果没有显示USB x.0 怎么办 Bus 001 Device 006: ID 80ee:0030 VirtualBox &#xA;Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub&#xA;Bus 001 Device 006: ID 80ee:0030 VirtualBox &#xA;Bus 001 Device 002: ID 80ee:0021 VirtualBox USB Tablet&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lsusb -t&#xA;/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/6p, 5000M&#xA;/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/8p, 480M&#xA;    |__ Port 1: Dev 2, If 0, Class=Human Interface Device, Driver=usbhid, 12M&#xA;    |__ Port 2: Dev 6, If 0, Class=Video, Driver=uvcvideo, 12M&#xA;    |__ Port 2: Dev 6, If 1, Class=Video, Driver=uvcvideo, 12M&#xA;&#xA;&#xA;lsusb -t&#xA;/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/8p, 5000M&#xA;/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/16p, 480M&#xA;    |__ Port 8: Dev 2, If 1, Class=Wireless, Driver=btusb, 12M&#xA;    |__ Port 8: Dev 2, If 0, Class=Wireless, Driver=btusb, 12M&#xA;    |__ Port 9: Dev 3, If 0, Class=Video, Driver=uvcvideo, 480M&#xA;    |__ Port 9: Dev 3, If 1, Class=Video, Driver=uvcvideo, 480M&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 是指USB类型的传输速率&#xA;12M 意味着 USB 1.0/1.1的速率是 12Mbit/s&#xA;480M 意味着 USB 2.0的速率是 480Mbit/s&#xA;5G 意味着 USB 3.0 的速率是 5Gbit/s&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之在Ubuntu系统上安装部署</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E5%9C%A8Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</link>
      <pubDate>2017-07-13 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Golang之在Ubuntu系统上安装部署&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;旧版本的安装&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install golang-go&#xA;&#xA;export GOROOT=$HOME/go&#xA;export PATH=$GOROOT/bin:$PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;从1.4版本以后go需要编译安装, 不想编译又想使用新版本的go怎么办&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载地址：http://www.golangtc.com/download&#xA;go1.8.linux-amd64.tar.gz&#xA;&#xA;// 把安装包解压到/usr/local目录下&#xA;tar -C /usr/local -xzf go1.8.linux-amd64.tar.gz&#xA;&#xA;// 注意 GOARCH=amd64 或者 386&#xA;vim ~/.bashrc&#xA;export GOPATH=/opt/go&#xA;export GOROOT=/usr/local/go&#xA;export GOARCH=amd64 &#xA;export GOOS=linux&#xA;export GOBIN=$GOROOT/bin/&#xA;export GOTOOLS=$GOROOT/pkg/tool/&#xA;export PATH=$PATH:$GOBIN:$GOTOOLS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# 启用 Go Modules 功能&#xA;export GO111MODULE=on&#xA;# 配置 GOPROXY 环境变量&#xA;export GOPROXY=https://goproxy.io&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenCV之图片相关方法使用</title>
      <link>http://www.nljb.net/default/OpenCV%E4%B9%8B%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2017-07-11 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;旋转图片&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 中心点&#xA;Point center = Point(src.cols/2, src.rows/2);&#xA;double angle = 90.0; // 角度&#xA;double scale = 1; // 缩放&#xA;Mat matrix(2, 3, CV_32FC1);&#xA;matrix = getRotationMatrix2D(center, angle, scale);&#xA;Mat dst = Mat::zeros(src.rows, src.cols, src.type());&#xA;warpAffine(src, dst, matrix, dst.size());&#xA;cv::imwrite(&amp;quot;a.jpg&amp;quot;, src);&#xA;cv::imwrite(&amp;quot;b.jpg&amp;quot;, dst);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;图片切割&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cv::Rect rect;&#xA;rect.x = 0;&#xA;rect.y = 0;&#xA;rect.width = 960;&#xA;rect.height = 1080;&#xA;&#xA;Mat dst;&#xA;src(rect).copyTo(dst);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>使用CMake配置Qt项目时使用OpenMP</title>
      <link>http://www.nljb.net/default/%E4%BD%BF%E7%94%A8CMake%E9%85%8D%E7%BD%AEQt%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%BD%BF%E7%94%A8OpenMP/</link>
      <pubDate>2017-07-10 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OpenMP&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// CMakeLists.txt&#xA;FIND_PACKAGE( OpenMP REQUIRED)&#xA;if(OPENMP_FOUND)&#xA;    message(&amp;quot;OPENMP FOUND&amp;quot;)&#xA;    set(CMAKE_C_FLAGS &amp;quot;${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}&amp;quot;)&#xA;    set(CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}&amp;quot;)&#xA;    set(CMAKE_EXE_LINKER_FLAGS &amp;quot;${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}&amp;quot;)&#xA;endif()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试&#xA;#include &amp;lt;omp.h&amp;gt;&#xA;#pragma omp parallel&#xA;    {&#xA;    printf(&amp;quot;hello world! ThreadID = %d\n&amp;quot;, omp_get_thread_num());&#xA;    }&#xA;    cout &amp;lt;&amp;lt; endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Dialog QML Type</title>
      <link>http://www.nljb.net/default/Dialog-QML-Type/</link>
      <pubDate>2017-07-10 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h1&gt;Dialog QML Type&lt;/h1&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;import QtQuick.Dialogs 1.2&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 基本的 Dialog&#xA;Rectangle {&#xA;    color: &amp;quot;red&amp;quot;&#xA;    anchors.fill: parent&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: {&#xA;            dialog.visible = true&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;Dialog {&#xA;    id: dialog&#xA;    visible: false&#xA;    title: &amp;quot;Blue sky dialog&amp;quot;&#xA;&#xA;    contentItem: Rectangle {&#xA;        color: &amp;quot;lightskyblue&amp;quot;&#xA;        implicitWidth: 400&#xA;        implicitHeight: 100&#xA;        Text {&#xA;            text: &amp;quot;Hello blue sky!&amp;quot;&#xA;            color: &amp;quot;navy&amp;quot;&#xA;            anchors.centerIn: parent&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 Dialog 中增加对象（日历、按钮）&#xA;Rectangle {&#xA;    color: &amp;quot;red&amp;quot;&#xA;    anchors.fill: parent&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: {&#xA;            dateDialog.visible = true&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;Dialog {&#xA;    id: dateDialog&#xA;    visible: false&#xA;    title: &amp;quot;Choose a date&amp;quot;&#xA;    // 标准按钮&#xA;    standardButtons: StandardButton.Save | StandardButton.Cancel | StandardButton.Help&#xA;&#xA;    onClickedButtonChanged: {&#xA;        if (standardButtons &amp;amp; StandardButton.Help) {&#xA;            console.log(&amp;quot;haha&amp;quot;)&#xA;        }&#xA;    }&#xA;&#xA;    onAccepted: {&#xA;        console.log(&amp;quot;Saving the date &amp;quot; +&#xA;        calendar.selectedDate.toLocaleDateString())&#xA;    }&#xA;&#xA;    // 日历&#xA;    Calendar {&#xA;        id: calendar&#xA;        // click -&amp;gt; StandardButton.Save&#xA;        onDoubleClicked: dateDialog.click(StandardButton.Save)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 消息窗口&#xA;Rectangle {&#xA;    color: &amp;quot;red&amp;quot;&#xA;    anchors.fill: parent&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: {&#xA;            messageDialog.visible = true&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&#xA;MessageDialog {&#xA;    id: messageDialog&#xA;    title: &amp;quot;May I have your attention please&amp;quot;&#xA;    text: &amp;quot;It&#39;s so cool that you are using Qt Quick.&amp;quot;&#xA;    onAccepted: {&#xA;        console.log(&amp;quot;And of course you could only agree.&amp;quot;)&#xA;        Qt.quit()&#xA;    }&#xA;    Component.onCompleted: visible = false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MessageDialog {&#xA;    title: &amp;quot;Overwrite?&amp;quot;&#xA;    icon: StandardIcon.Question&#xA;    text: &amp;quot;file.txt already exists.  Replace?&amp;quot;&#xA;    detailedText: &amp;quot;To replace a file means that its existing contents will be lost. &amp;quot; +&#xA;        &amp;quot;The file that you are copying now will be copied over it instead.&amp;quot;&#xA;    standardButtons: StandardButton.Yes | StandardButton.YesToAll |&#xA;        StandardButton.No | StandardButton.NoToAll | StandardButton.Abort&#xA;    Component.onCompleted: visible = true&#xA;    onYes: console.log(&amp;quot;copied&amp;quot;)&#xA;    onNo: console.log(&amp;quot;didn&#39;t copy&amp;quot;)&#xA;    onRejected: console.log(&amp;quot;aborted&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>QmlBook</title>
      <link>http://www.nljb.net/default/QmlBook/</link>
      <pubDate>2017-07-08 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://cwc1987.gitbooks.io/qmlbook-in-chinese/&#xA;&#xA;Qt Quick QML Types&#xA;http://doc.qt.io/qt-5/qtquick-qmlmodule.html&#xA;&#xA;Qt Quick Controls QML Types&#xA;http://doc.qt.io/qt-5/qtquick-controls-qmlmodule.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;快速入门（Quick Starter）&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;语法（QML Syntax）&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 让我们开始用一个简单的QML文件例子来解释这个语法。&#xA;import QtQuick 2.6&#xA;import QtQuick.Window 2.2&#xA;&#xA;// 窗口&#xA;Window {&#xA;&#xA;    visible: true // 显示/隐藏&#xA;    id: root // 根元素ID推荐使用root&#xA;    width: 640&#xA;    height: 480&#xA;    title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;    // 元素可以嵌套，这意味着一个父元素可以拥有多个子元素。&#xA;    // 子元素可以通过访问parent关键字来访问它们的父元素。&#xA;&#xA;    // 矩形&#xA;    Rectangle {&#xA;        // name this element a&#xA;        id: a&#xA;&#xA;        // properties: &amp;lt;name&amp;gt;: &amp;lt;value&amp;gt;&#xA;        width: parent.width; height: parent.height&#xA;&#xA;        // color property&#xA;        color: &amp;quot;#D8D8D8&amp;quot;&#xA;&#xA;        // Declare a nested element (child of root)&#xA;        Image {&#xA;            id: rocket&#xA;&#xA;            // reference the parent&#xA;            x: (parent.width - width)/2; y: 40&#xA;&#xA;            source: &#39;rocket.png&#39;&#xA;        }&#xA;&#xA;        // Another child of root&#xA;        Text {&#xA;            // un-named element&#xA;&#xA;            // reference element by id&#xA;            y: rocket.y + rocket.height + 20&#xA;&#xA;            // reference root element&#xA;            width: root.width&#xA;&#xA;            horizontalAlignment: Text.AlignHCenter&#xA;            text: &#39;Rocket&#39;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;属性（Properties）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Text {&#xA;    // 一个id在一个QML文档中是唯一的，并且不能被设置为其它值，也无法被查询&#xA;    // (1) identifier&#xA;    id: thisLabel&#xA;&#xA;    // 一个属性能够设置一个值，这个值依赖于它的类型。&#xA;    // 如果没有对一个属性赋值，那么它将会被初始化为一个默认值。&#xA;    // (2) set x- and y-position&#xA;    x: 24; y: 16&#xA;&#xA;    // 一个属性能够依赖一个或多个其它的属性，这种操作称作属性绑定。&#xA;    // (3) bind height to 2 * width&#xA;    height: 2 * width&#xA;&#xA;    // 添加自己定义的属性需要使用property修饰符，然后跟上类型，名字和可选择的初始化值&#xA;    /*&#xA;    注意如果属性名与已定义的默认属性名不重复，使用default关键字你可以将一个属性定义为默认属性。&#xA;    这在你添加子元素时用得着，如果他们是可视化的元素，子元素会自动的添加默认属性的子类型链表&#xA;    （children property list）&#xA;    */&#xA;    // (4) custom property&#xA;    property int times: 24&#xA;&#xA;    // alias关键字允许我们转发一个属性或者转发一个属性对象自身到另一个作用域&#xA;    // 我们将在后面定义组件导出内部属性或者引用根级元素id会使用到这个技术。&#xA;    // 一个属性别名不需要类型，它使用引用的属性类型或者对象类型。&#xA;    // (5) property alias&#xA;    property alias anotherTimes: thisLabel.times&#xA;&#xA;    // int整型数据会自动的转换为string字符串类型数据&#xA;    // (6) set text appended by value&#xA;    text: &amp;quot;Greetings &amp;quot; + times&#xA;&#xA;    // 一些属性是按组分配的属性。&#xA;    // 当一个属性需要结构化并且相关的属性需要联系在一起时，我们可以这样使用它。&#xA;    // 另一个组属性的编码方式是 font{family: &amp;quot;UBuntu&amp;quot;; pixelSize: 24 }。&#xA;    // (7) font is a grouped property&#xA;    font.family: &amp;quot;Ubuntu&amp;quot;&#xA;    font.pixelSize: 24&#xA;&#xA;    // 一些属性是元素自身的附加属性。&#xA;    // 这样做是为了全局的相关元素在应用程序中只出现一次&#xA;    // (8) KeyNavigation is an attached property&#xA;    KeyNavigation.tab: otherLabel&#xA;&#xA;    // 对于每个元素你都可以提供一个信号操作。&#xA;    // 这个操作在属性值改变时被调用。&#xA;    // (9) signal handler for property changes&#xA;    onHeightChanged: console.log(&#39;height:&#39;, height)&#xA;&#xA;    // focus is neeed to receive key events&#xA;    focus: true&#xA;&#xA;    // change color based on focus value&#xA;    color: focus?&amp;quot;red&amp;quot;:&amp;quot;black&amp;quot;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;脚本（Scripting）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Text {&#xA;    id: label&#xA;&#xA;    x: 24; y: 24&#xA;&#xA;    // custom counter property for space presses&#xA;    property int spacePresses: 0&#xA;&#xA;    text: &amp;quot;Space pressed: &amp;quot; + spacePresses + &amp;quot; times&amp;quot;&#xA;&#xA;    // (1) handler for text changes&#xA;    onTextChanged: console.log(&amp;quot;text changed to:&amp;quot;, text)&#xA;&#xA;    // need focus to receive key events&#xA;    focus: true&#xA;&#xA;    // (2) handler with some JS&#xA;    Keys.onSpacePressed: {&#xA;        increment()&#xA;    }&#xA;&#xA;    // clear the text on escape&#xA;    Keys.onEscapePressed: {&#xA;        label.text = &#39;&#39;&#xA;    }&#xA;&#xA;    // (3) a JS function&#xA;    function increment() {&#xA;        spacePresses = spacePresses + 1&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;基本元素（Basic Elements）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;元素可以被分为可视化元素与非可视化元素。&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个可视化元素（例如矩形框Rectangle）有着几何形状并且可以在屏幕上显示。&lt;/li&gt;&#xA;&lt;li&gt;一个非可视化元素（例如计时器Timer）提供了常用的功能，通常用于操作可视化元素。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;基础元素对象（Item Element）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Item（基本元素对象）通常被用来作为其它元素的容器使用，类似HTML语言中的div元素。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Item（基础元素对象）是所有可视化元素的基础对象，所有其它的可视化元素都继承自Item。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;它自身不会有任何绘制操作，但是定义了所有可视化元素共有的属性：&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Geometry（几何属性）&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;x,y（坐标）定义了元素左上角的位置，width，height（长和宽）定义元素的显示范围&lt;/li&gt;&#xA;&lt;li&gt;z（堆叠次序）定义元素之间的重叠顺序。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;Layout handling（布局操作）&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;anchors（锚定），包括左（left），右（right），上（top），下（bottom）&lt;/li&gt;&#xA;&lt;li&gt;水平与垂直居中（vertical center，horizontal center）&lt;/li&gt;&#xA;&lt;li&gt;与margins（间距）一起定义了元素与其它元素之间的位置关系。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;Key handlikng（按键操作）&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;附加属性key（按键）和keyNavigation（按键定位）属性来控制按键操作&lt;/li&gt;&#xA;&lt;li&gt;处理输入焦点（focus）可用操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;Transformation（转换）&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缩放（scale）和rotate（旋转）转换，通用的x,y,z属性列表转换（transform）&lt;/li&gt;&#xA;&lt;li&gt;旋转基点设置（transformOrigin）。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;Visual（可视化）&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不透明度（opacity）控制透明度，visible（是否可见）控制元素是否显示&lt;/li&gt;&#xA;&lt;li&gt;clip（裁剪）用来限制元素边界的绘制，smooth（平滑）用来提高渲染质量。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;State definition（状态定义）&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;states（状态列表属性）提供了元素当前所支持的状态列表&lt;/li&gt;&#xA;&lt;li&gt;当前属性的改变也可以使用transitions（转变）属性列表来定义状态转变动画。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;矩形框元素（Rectangle Element）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Rectangle {&#xA;    id: rect1&#xA;    x: 12; y: 12&#xA;    width: 76; height: 96&#xA;    color: &amp;quot;lightsteelblue&amp;quot;&#xA;}&#xA;Rectangle {&#xA;    id: rect2&#xA;    x: 112; y: 12&#xA;    width: 76; height: 96&#xA;    border.color: &amp;quot;lightsteelblue&amp;quot; // 边界颜色&#xA;    border.width: 4 // 边界宽度&#xA;    radius: 8 // 半径&#xA;}&#xA;&#xA;// 此外，填充的颜色与矩形的边框也支持自定义的渐变色。&#xA;// 一个渐变色是由一系列的梯度值定义的。每一个值定义了一个位置与颜色。&#xA;// 位置标记了y轴上的位置（0 = 顶，1 = 底）。&#xA;// GradientStop（倾斜点）的颜色标记了颜色的位置。&#xA;Rectangle {&#xA;    id: rect1&#xA;    x: 12; y: 12&#xA;    width: 176; height: 96&#xA;    gradient: Gradient {&#xA;        GradientStop { position: 0.0; color: &amp;quot;lightsteelblue&amp;quot; }&#xA;        GradientStop { position: 1.0; color: &amp;quot;slategray&amp;quot; }&#xA;    }&#xA;    border.color: &amp;quot;slategray&amp;quot;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;文本元素（Text Element）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文本可以使用horizontalAlignment与verticalAlignment属性来设置它的对齐效果&lt;/li&gt;&#xA;&lt;li&gt;你可以使用style和styleColor属性来配置文字的外框效果，浮雕效果或者凹陷效果&lt;/li&gt;&#xA;&lt;li&gt;对于过长的文本，你可能需要使用省略号来表示，你可以使用elide属性来完成这个操作&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;elide属性允许你设置文本左边，右边或者中间的省略位置&lt;/li&gt;&#xA;&lt;li&gt;如果你不想&amp;rsquo;&amp;hellip;.&amp;lsquo;省略号出现，并且希望使用文字换行的方式显示所有的文本&lt;/li&gt;&#xA;&lt;li&gt;你可以使用wrapMode属性（这个属性只在明确设置了宽度后才生效）&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Text {&#xA;    text: &amp;quot;The quick brown fox&amp;quot; // 文本&#xA;    color: &amp;quot;#303030&amp;quot;&#xA;    font.family: &amp;quot;Ubuntu&amp;quot; // 字体&#xA;    font.pixelSize: 28&#xA;}&#xA;&#xA;Text {&#xA;    width: 40; height: 120&#xA;    text: &#39;A very long text&#39;&#xA;    // &#39;...&#39; shall appear in the middle&#xA;    elide: Text.ElideMiddle&#xA;    // red sunken text styling&#xA;    style: Text.Sunken&#xA;    styleColor: &#39;#FF4444&#39;&#xA;    // align text to the top&#xA;    verticalAlignment: Text.AlignTop&#xA;    // only sensible when no elide mode&#xA;    // wrapMode: Text.WordWrap&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;图像元素（Image Element）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一个图像元素（Image Element）能够显示不同格式的图像（例如PNG,JPG,GIF,BMP）&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;source属性（source property）提供了图像文件的链接信息&lt;/li&gt;&#xA;&lt;li&gt;fillMode（文件模式）属性能够控制元素对象的大小调整行为。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个URL可以是使用&amp;rsquo;/&amp;lsquo;语法的本地路径（&amp;rdquo;./images/home.png&amp;rdquo;）或者一个网络链接&lt;/li&gt;&#xA;&lt;li&gt;使用PreserveAspectCrop可以避免裁剪图像数据被渲染到图像边界外 &amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;默认情况下裁剪是被禁用的（clip:false），你需要打开裁剪（clip:true）来约束边界矩形的绘制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Image {&#xA;    x: 12; y: 12&#xA;    // width: 48&#xA;    // height: 118&#xA;    source: &amp;quot;assets/rocket.png&amp;quot;&#xA;}&#xA;&#xA;Image {&#xA;    x: 112; y: 12&#xA;    width: 48&#xA;    height: 118/2&#xA;    source: &amp;quot;assets/rocket.png&amp;quot;&#xA;    fillMode: Image.PreserveAspectCrop&#xA;    clip: true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;鼠标区域元素（MouseArea Element）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;为了与不同的元素交互，你通常需要使用MouseArea（鼠标区域）元素&#xA;当用户与可视化端口交互时，mouseArea通常被用来与可视化元素对象一起执行命令&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是非常重要的概念，输入处理与可视化显示分开。这样你的交互区域可以比你显示的区域大很多。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Rectangle {&#xA;    id: rect1&#xA;    x: 12; y: 12&#xA;    width: 76; height: 96&#xA;    color: &amp;quot;lightsteelblue&amp;quot;&#xA;    MouseArea {&#xA;        id: area&#xA;        width: parent.width&#xA;        height: parent.height&#xA;        onClicked: rect2.visible = !rect2.visible&#xA;    }&#xA;}&#xA;&#xA;Rectangle {&#xA;    id: rect2&#xA;    x: 112; y: 12&#xA;    width: 76; height: 96&#xA;    border.color: &amp;quot;lightsteelblue&amp;quot;&#xA;    border.width: 4&#xA;    radius: 8&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;组件（Compontents）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一个组件是一个可以重复使用的元素，QML提供几种不同的方法来创建组件&#xA;但是目前我们只对其中一种方法进行讲解：一个文件就是一个基础组件&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Button.qml&#xA;&#xA;// 一个矩形&#xA;Rectangle {&#xA;    // ID为root&#xA;    id: root&#xA;&#xA;    // 将内部嵌套的QML元素的属性导出到外面使用&#xA;    property alias text: label.text // 绑定 label.text&#xA;    signal clicked // 声明信号（实现在mail.qml中）&#xA;&#xA;    width: 116; height: 26&#xA;    color: &amp;quot;lightsteelblue&amp;quot;&#xA;    border.color: &amp;quot;slategrey&amp;quot;&#xA;&#xA;    // Button 文本 ...&#xA;    Text {&#xA;        id: labels&#xA;        anchors.centerIn: parent&#xA;        text: &amp;quot;Start&amp;quot;&#xA;    }&#xA;&#xA;    // 鼠标区域&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        // 点击时调用 root.clicked()&#xA;        onClicked: {&#xA;            root.clicked()&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&#xA;// 我们使用了QML的alias（别名）的功能，它可以将内部嵌套的QML元素的属性导出到外面使用。&#xA;// 有一点很重要，只有根级目录的属性才能够被其它文件的组件访问。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用我们新的Button元素只需要在我们的文件中简单的声明一下就可以了:&#xA;&#xA;Window {&#xA;    visible: true&#xA;    width: 640&#xA;    height: 480&#xA;    title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;    Button { // our Button component&#xA;        id: button&#xA;        x: 12; y: 12&#xA;        text: &amp;quot;Start&amp;quot;&#xA;        onClicked: {&#xA;            status.text = &amp;quot;Button clicked!&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;    Text { // text changes when button was clicked&#xA;        id: status&#xA;        x: 12; y: 76&#xA;        width: 116; height: 26&#xA;        text: &amp;quot;waiting ...&amp;quot;&#xA;        horizontalAlignment: Text.AlignHCenter&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 就个人而言，可以更进一步的使用基础元素对象（Item）作为根元素。&#xA;// 这样可以防止用户改变我们设计的按钮的颜色，并且可以提供出更多相关控制的API（应用程序接口）&#xA;&#xA;Item {&#xA;    id: root&#xA;    Rectangle {&#xA;        anchors.fill parent&#xA;        color: &amp;quot;lightsteelblue&amp;quot;&#xA;        border.color: &amp;quot;slategrey&amp;quot;&#xA;    }&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;简单的转换（Simple Transformations）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;转换操作改变了一个对象的几何状态。QML元素对象通常能够被平移，旋转，缩放。下面我们将讲解这些简单的操作和一些更高级的用法&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;简单的位移是通过改变x,y坐标来完成的。&lt;/li&gt;&#xA;&lt;li&gt;旋转是改变rotation（旋转）属性来完成的，这个值使用角度作为单位（0~360）。&lt;/li&gt;&#xA;&lt;li&gt;缩放是通过改变scale（比例）的属性来完成的，小于1意味着缩小，大于1意味着放大。&lt;/li&gt;&#xA;&lt;li&gt;旋转与缩放不会改变对象的几何形状，对象的x,y（坐标）与width/height（宽/高）也类似。&lt;/li&gt;&#xA;&lt;li&gt;请记住：文档中元素的顺序很重要 &amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import QtQuick 2.0&#xA;&#xA;Item {&#xA;    // set width based on given background&#xA;    width: bg.width&#xA;    height: bg.height&#xA;&#xA;    Image { // nice background image&#xA;        id: bg&#xA;        source: &amp;quot;assets/background.png&amp;quot;&#xA;    }&#xA;&#xA;    MouseArea {&#xA;        id: backgroundClicker&#xA;        // needs to be before the images as order matters&#xA;        // otherwise this mousearea would be before the other elements&#xA;        // and consume the mouse events&#xA;        anchors.fill: parent&#xA;        onClicked: {&#xA;            // reset our little scene&#xA;            rocket1.x = 20 // 坐标&#xA;            rocket2.rotation = 0 // 旋转&#xA;            rocket3.rotation = 0&#xA;            rocket3.scale = 1.0 // 比例&#xA;        }&#xA;    }&#xA;&#xA;    ClickableImage {&#xA;        id: rocket1&#xA;        x: 20; y: 100&#xA;        source: &amp;quot;assets/rocket.png&amp;quot;&#xA;        onClicked: {&#xA;            // increase the x-position on click&#xA;            x += 5&#xA;        }&#xA;    }&#xA;&#xA;    ClickableImage {&#xA;        id: rocket2&#xA;        x: 140; y: 100&#xA;        source: &amp;quot;assets/rocket.png&amp;quot;&#xA;        smooth: true // need antialising // 打开平滑&#xA;        onClicked: {&#xA;            // increase the rotation on click&#xA;            rotation += 5&#xA;        }&#xA;    }&#xA;&#xA;    ClickableImage {&#xA;        id: rocket3&#xA;        x: 240; y: 100&#xA;        source: &amp;quot;assets/rocket.png&amp;quot;&#xA;        smooth: true // need antialising // 打开平滑&#xA;        onClicked: {&#xA;            // several transformations&#xA;            rotation += 5&#xA;            scale -= 0.05&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;定位元素（Positioning Element）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;有一些QML元素被用于放置元素对象，它们被称作定位器，QtQuick模块提供了Row，Column，Grid，Flow用来作为定位器&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 定义一个红色的矩形&#xA;// RedSquare.qml&#xA;&#xA;import QtQuick 2.0&#xA;&#xA;Rectangle {&#xA;    width: 48&#xA;    height: 48&#xA;    color: &amp;quot;#ea7025&amp;quot;&#xA;    border.color: Qt.lighter(color)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Column（列）元素将它的子对象通过顶部对齐的列方式进行排列&#xA;Window {&#xA;    visible: true&#xA;    width: 640&#xA;    height: 480&#xA;    title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;    Rectangle {&#xA;        width: 640&#xA;        height: 480&#xA;&#xA;        Column {&#xA;            id: column&#xA;            anchors.centerIn: parent&#xA;            spacing: 8&#xA;            RedSquare { }&#xA;            RedSquare { width: 96 }&#xA;            RedSquare { }&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Row（行）元素将它的子对象从左到右，或者从右到左依次排列，排列方式取决于layoutDirection属性&#xA;Window {&#xA;    visible: true&#xA;    width: 640&#xA;    height: 480&#xA;    title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;    Rectangle {&#xA;        width: 640&#xA;        height: 480&#xA;&#xA;        Row {&#xA;            id: row&#xA;            anchors.centerIn: parent&#xA;            spacing: 20&#xA;            RedSquare { }&#xA;            RedSquare { height:96 }&#xA;            RedSquare { }&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Grid（栅格）元素通过设置rows（行数）和columns（列数）将子对象排列在一个栅格中&#xA;Window {&#xA;    visible: true&#xA;    width: 640&#xA;    height: 480&#xA;    title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;    Rectangle {&#xA;        width: 640&#xA;        height: 480&#xA;&#xA;        Grid {&#xA;            id: grid&#xA;            rows: 2&#xA;            columns: 2&#xA;            anchors.centerIn: parent&#xA;            spacing: 8&#xA;            RedSquare { }&#xA;            RedSquare { }&#xA;            RedSquare { }&#xA;            RedSquare { }&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 最后一个定位器是Flow（流）。通过flow（流）属性和layoutDirection（布局方向）属性来控制流的方向&#xA;Window {&#xA;    visible: true&#xA;    width: 640&#xA;    height: 480&#xA;    title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;    Rectangle {&#xA;        width: 160&#xA;        height: 160&#xA;&#xA;        Flow { // Rectangle 宽度不够时自动换行 ...&#xA;            anchors.fill: parent&#xA;            anchors.margins: 20&#xA;            spacing: 20&#xA;            RedSquare { }&#xA;            RedSquare { }&#xA;            RedSquare { }&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 循环 ...&#xA;// 通常Repeater（重复元素）与定位器一起使用。&#xA;// 它的工作方式就像for循环与迭代器的模式一样。&#xA;// 在这个最简单的例子中，仅仅提供了一个循环的例子。&#xA;&#xA;Window {&#xA;        visible: true&#xA;        width: 640&#xA;        height: 480&#xA;        title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;        Rectangle {&#xA;                id: root&#xA;                width: 640&#xA;                height: 480&#xA;                // 声明变量 ...&#xA;                property variant colorArray: [&amp;quot;#00bde3&amp;quot;, &amp;quot;#67c111&amp;quot;, &amp;quot;#ea7025&amp;quot;]&#xA;&#xA;                Grid{&#xA;                        anchors.fill: parent&#xA;                        anchors.margins: 8&#xA;                        spacing: 4&#xA;                        Repeater { // Repeater 重复器&#xA;                                model: 16&#xA;                                Rectangle {&#xA;                                        width: 56; height: 56&#xA;                                        property int colorIndex: Math.floor(Math.random()*3)&#xA;                                        color: root.colorArray[colorIndex]&#xA;                                        border.color: Qt.lighter(color)&#xA;                                        Text {&#xA;                                                anchors.centerIn: parent&#xA;                                                color: &amp;quot;#f0f0f0&amp;quot;&#xA;                                                text: &amp;quot;Cell &amp;quot; + index&#xA;                                        }&#xA;                                }&#xA;                        }&#xA;                }&#xA;        }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;布局元素（Layout Items）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;QML使用anchors（锚）对元素进行布局。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;anchoring（锚定）是基础元素对象的基本属性，可以被所有的可视化QML元素使用&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个元素有6条锚定线&#xA;    -（top顶，bottom底，left左，right右，horizontalCenter水平中，verticalCenter垂直中）。&lt;/li&gt;&#xA;&lt;li&gt;在文本元素（Text Element）中有一条文本的锚定基线（baseline）。&lt;/li&gt;&#xA;&lt;li&gt;每一条锚定线都有一个偏移（offset）值&#xA;    - 在top（顶），bottom（底），left（左），right（右）的锚定线中它们也被称作边距。&lt;/li&gt;&#xA;&lt;li&gt;对于horizontalCenter（水平中）与verticalCenter（垂直中）与baseline（文本基线）中被称作偏移值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 元素填充它的父元素。&#xA;Rectangle {&#xA;    Text {&#xA;        width: 12&#xA;        anchors.fill: parent // 锚定: 充满(fill),父(parent)&#xA;        anchors.margins: 8 // （间距）定义了元素与其它元素之间的位置关系。&#xA;        text: &#39;(1)&#39;&#xA;    }&#xA;}&#xA;&#xA;// 元素左对齐它的父元素。&#xA;Rectangle {&#xA;     Text {&#xA;         width: 48&#xA;         y: 8&#xA;         anchors.left: parent.left 锚定: 左，对齐父左&#xA;         anchors.leftMargin: 8&#xA;         text: &#39;(2)&#39;&#xA;     }&#xA; }&#xA;&#xA;// 元素的左边与它父元素的右边对齐。&#xA;Rectangle {&#xA;     Text {&#xA;         width: 48&#xA;         anchors.left: parent.right // 元素左，对齐父右&#xA;         text: &#39;(3)&#39;&#xA;     }&#xA; }&#xA;&#xA;// 元素中间对齐&#xA;Rectangle {&#xA;     Rectangle {&#xA;         id: blue1&#xA;         width: 48; height: 24&#xA;         y: 8&#xA;                     // Blue1与它的父元素水平中间对齐&#xA;         anchors.horizontalCenter: parent.horizontalCenter&#xA;     }&#xA;     Rectangle {&#xA;                     // Blue2与Blue1中间对齐，并且它的顶部对齐Blue1的&#xA;         id: blue2&#xA;         width: 72; height: 24&#xA;         anchors.top: blue1.bottom&#xA;         anchors.topMargin: 4&#xA;         anchors.horizontalCenter: blue1.horizontalCenter&#xA;         text: &#39;(4)&#39;&#xA;     }&#xA; }&#xA;&#xA;// 元素在它的父元素中居中。&#xA;Rectangle {&#xA;     Rectangle {&#xA;         width: 48&#xA;         anchors.centerIn: parent&#xA;         text: &#39;(5)&#39;&#xA;     }&#xA; }&#xA;&#xA;// 元素水平方向居中对齐父元素并向后偏移12像素，垂直方向居中对齐。&#xA;Rectangle {&#xA;     Rectangle {&#xA;         width: 48&#xA;         anchors.horizontalCenter: parent.horizontalCenter&#xA;         anchors.horizontalCenterOffset: -12&#xA;         anchors.verticalCenter: parent.verticalCenter&#xA;         text: &#39;(6)&#39;&#xA;     }&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;输入元素（Input Element）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我们已经使用过MouseArea（鼠标区域）作为鼠标输入元素。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们开始介绍文本编辑的元素：TextInput（文本输入）和TextEdit（文本编辑）。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;文本输入（TextInput）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 文本输入允许用户输入一行文本。&#xA;// 这个元素支持使用正则表达式验证器来限制输入和输入掩码的模式设置。&#xA;Rectangle {&#xA;        width: 200&#xA;        height: 80&#xA;        color: &amp;quot;linen&amp;quot;&#xA;&#xA;        TextInput {&#xA;                id: input1&#xA;                x: 8; y: 8&#xA;                width: 96; height: 20&#xA;                focus: true&#xA;                text: &amp;quot;Text Input 1&amp;quot;&#xA;        }&#xA;&#xA;        TextInput {&#xA;                id: input2&#xA;                x: 8; y: 36&#xA;                width: 96; height: 20&#xA;                text: &amp;quot;Text Input 2&amp;quot;&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 用户可以通过点击TextInput来改变焦点。&#xA;// 为了支持键盘改变焦点，我们可以使用KeyNavigation（按键向导）这个附加属性。&#xA;// KeyNavigation（按键向导）附加属性可以预先设置一个元素id绑定切换焦点的按键。&#xA;Rectangle {&#xA;        width: 200&#xA;        height: 80&#xA;        color: &amp;quot;linen&amp;quot;&#xA;&#xA;        TextInput {&#xA;                id: input1&#xA;                x: 8; y: 8&#xA;                width: 96; height: 20&#xA;                focus: true&#xA;                text: &amp;quot;Text Input 1&amp;quot;&#xA;                KeyNavigation.tab: input2&#xA;        }&#xA;&#xA;        TextInput {&#xA;                id: input2&#xA;                x: 8; y: 36&#xA;                width: 96; height: 20&#xA;                text: &amp;quot;Text Input 2&amp;quot;&#xA;                KeyNavigation.tab: input1&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 一个文本输入元素（text input element）只显示一个闪烁符和已经输入的文本&#xA;// TLineEditV1.qml&#xA;Rectangle {&#xA;    width: 96; height: input.height + 8&#xA;    color: &amp;quot;lightsteelblue&amp;quot;&#xA;    border.color: &amp;quot;gray&amp;quot;&#xA;&#xA;    property alias text: input.text&#xA;    // 如果你想要完整的导出TextInput元素&#xA;    // 你可以使用property alias input: input来导出这个元素&#xA;    // 第一个input是属性名字，第二个input是元素id。&#xA;    property alias input: input&#xA;&#xA;    TextInput {&#xA;        id: input&#xA;        anchors.fill: parent&#xA;        anchors.margins: 4&#xA;        focus: true&#xA;    }&#xA;}&#xA;&#xA;    TLineEditV1 {&#xA;    height: 30&#xA;    text: &amp;quot;aa&amp;quot; // 导出 text&#xA;    input.text: &amp;quot;bbb&amp;quot; // 完整的导出 input&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 我们使用TLineEditV1组件重写了我们的KeyNavigation（按键向导）的例子。&#xA;Rectangle {&#xA;    ...&#xA;    TLineEditV1 {&#xA;        id: input1&#xA;        ...&#xA;    }&#xA;    TLineEditV1 {&#xA;        id: input2&#xA;        ...&#xA;    }&#xA;}&#xA;&#xA;// 尝试使用Tab按键来导航，你会发现焦点无法切换到input2上。&#xA;// 这个例子中使用focus:true的方法不正确，这个问题是因为焦点被转移到input2元素时&#xA;// 包含TlineEditV1的顶部元素接收了这个焦点并且没有将焦点转发给TextInput（文本输入）&#xA;// 为了防止这个问题，QML提供了FocusScope（焦点区域）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;焦点区域（FocusScope）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一个焦点区域（focus scope）定义了如果焦点区域接收到焦点&#xA;它的最后一个使用focus:true的子元素接收焦点&#xA;它将会把焦点传递给最后申请焦点的子元素。&#xA;我们创建了第二个版本的TLineEdit组件，称作TLineEditV2，使用焦点区域（focus scope）作为根元素。&#xA;&#xA;// FocusScope(焦点区域)&#xA;FocusScope {&#xA;        width: 96; height: input.height + 8&#xA;        Rectangle {&#xA;                anchors.fill: parent&#xA;                color: &amp;quot;lightsteelblue&amp;quot;&#xA;                border.color: &amp;quot;gray&amp;quot;&#xA;&#xA;        }&#xA;&#xA;        property alias text: input.text&#xA;        property alias input: input&#xA;&#xA;        TextInput {&#xA;                id: input&#xA;                anchors.fill: parent&#xA;                anchors.margins: 4&#xA;                focus: true&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;文本编辑（TextEdit）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;文本编辑（TextEdit）元素与文本输入（TextInput）非常类似，它支持多行文本编辑。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// TTextEdit.qml&#xA;&#xA;import QtQuick 2.0&#xA;&#xA;FocusScope {&#xA;        width: 96; height: 96&#xA;        Rectangle {&#xA;                anchors.fill: parent&#xA;                color: &amp;quot;lightsteelblue&amp;quot;&#xA;                border.color: &amp;quot;gray&amp;quot;&#xA;&#xA;        }&#xA;&#xA;        property alias text: input.text&#xA;        property alias input: input&#xA;&#xA;        TextEdit {&#xA;                id: input&#xA;                anchors.fill: parent&#xA;                anchors.margins: 4&#xA;                focus: true&#xA;        }&#xA;}&#xA;&#xA;import QtQuick 2.0&#xA;&#xA;Rectangle {&#xA;        width: 136&#xA;        height: 120&#xA;        color: &amp;quot;linen&amp;quot;&#xA;&#xA;        TTextEdit {&#xA;                id: input&#xA;                x: 8; y: 8&#xA;                width: 120; height: 104&#xA;                focus: true&#xA;                text: &amp;quot;Text Edit&amp;quot;&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;按键元素（Key Element）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;附加属性key允许你基于某个按键的点击来执行代码。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用up，down按键来移动一个方块&lt;/li&gt;&#xA;&lt;li&gt;使用left，right按键来旋转一个元素&lt;/li&gt;&#xA;&lt;li&gt;使用plus，minus按键来缩放一个元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Window {&#xA;        visible: true&#xA;        width: 640&#xA;        height: 480&#xA;        title: qsTr(&amp;quot;Hello World&amp;quot;)&#xA;&#xA;        Rectangle {&#xA;&#xA;                width: 400; height: 200&#xA;&#xA;                Rectangle {&#xA;                        width: 38; height: 38&#xA;                        color: &amp;quot;#ea7025&amp;quot;&#xA;                        id: square&#xA;                        x: 20; y: 20&#xA;                }&#xA;                focus: true&#xA;                Keys.onLeftPressed: square.x -= 8&#xA;                Keys.onRightPressed: square.x += 8&#xA;                Keys.onUpPressed: square.y -= 8&#xA;                Keys.onDownPressed: square.y += 8&#xA;                Keys.onPressed: {&#xA;                        switch(event.key) {&#xA;                        case Qt.Key_Plus:&#xA;                                square.scale += 0.2&#xA;                                break;&#xA;                        case Qt.Key_Minus:&#xA;                                square.scale -= 0.2&#xA;                                break;&#xA;                        }&#xA;&#xA;                }&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;动态元素（Fluid Elements）&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;动画（Animations）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;动画被用于属性的改变。一个动画定义了属性值改变的曲线，将一个属性值变化从一个值过渡到另一个值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所有在QtQuick中的动画都由同一个计时器来控制，因此它们始终都保持同步，这也提高了动画的性能和显示效果。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;动画元素（Animation Elements）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PropertyAnimation（属性动画）- 使用属性值改变播放的动画&lt;/li&gt;&#xA;&lt;li&gt;NumberAnimation（数字动画）- 使用数字改变播放的动画&lt;/li&gt;&#xA;&lt;li&gt;ColorAnimation（颜色动画）- 使用颜色改变播放的动画&lt;/li&gt;&#xA;&lt;li&gt;RotationAnimation（旋转动画）- 使用旋转改变播放的动画&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;QtQuick还提供了一切特殊场景下使用的动画&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PauseAnimation（停止动画）- 运行暂停一个动画&lt;/li&gt;&#xA;&lt;li&gt;SequentialAnimation（顺序动画）- 允许动画有序播放&lt;/li&gt;&#xA;&lt;li&gt;ParallelAnimation（并行动画）- 允许动画同时播放&lt;/li&gt;&#xA;&lt;li&gt;AnchorAnimation（锚定动画）- 使用锚定改变播放的动画&lt;/li&gt;&#xA;&lt;li&gt;ParentAnimation（父元素动画）- 使用父对象改变播放的动画&lt;/li&gt;&#xA;&lt;li&gt;SmotthedAnimation（平滑动画）- 跟踪一个平滑值播放的动画&lt;/li&gt;&#xA;&lt;li&gt;SpringAnimation（弹簧动画）- 跟踪一个弹簧变换的值播放的动画&lt;/li&gt;&#xA;&lt;li&gt;PathAnimation（路径动画）- 跟踪一个元素对象的路径的动画&lt;/li&gt;&#xA;&lt;li&gt;Vector3dAnimation（3D容器动画）- 使用QVector3d值改变播放的动画&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;当使用更加复杂的动画时，我们可能需要在播放一个动画时中改变一个属性或者运行一个脚本&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PropertyAction（属性动作）- 在播放动画时改变属性&lt;/li&gt;&#xA;&lt;li&gt;ScriptAction（脚本动作）- 在播放动画时运行脚本&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;应用动画（Applying Animations）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;动画可以通过以下几种方式来应用：&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;属性动画 - 在元素完整加载后自动运行&lt;/li&gt;&#xA;&lt;li&gt;属性动作 - 当属性值改变时自动运行&lt;/li&gt;&#xA;&lt;li&gt;独立运行动画 - 使用start()函数明确指定运行或者running属性被设置为true（比如通过属性绑定）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ClickableImageV2.qml&#xA;// 扩展可点击图像元素版本2（ClickableImage Version2）&#xA;Item {&#xA;    id: root&#xA;    // 父几何对象依赖于子几何对象&#xA;    // 我们使用了Column（列）定位器&#xA;    // 并且使用基于列的子矩形（childRect）&#xA;    // 属性来计算它的宽度和高度（width and height）&#xA;    width: container.childrenRect.width&#xA;    height: container.childrenRect.height&#xA;    property alias text: label.text&#xA;    property alias source: image.source&#xA;    signal clicked&#xA;&#xA;    Column {&#xA;        id: container&#xA;        Image {&#xA;            id: image&#xA;        }&#xA;        Text {&#xA;            id: label&#xA;            width: image.width&#xA;            horizontalAlignment: Text.AlignHCenter&#xA;            // 我们使用文本元素的wrapMode属性来设置文本与图像一样宽并且可以自动换行&#xA;            wrapMode: Text.WordWrap&#xA;            color: &amp;quot;#111111&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: root.clicked()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 同时向上移动 ...&#xA;&#xA;ClickableImageV2 {&#xA;     id: rocket1&#xA;     x: 40; y: 200&#xA;     source: &amp;quot;rocket.png&amp;quot;&#xA;     text: &amp;quot;animation on property&amp;quot;&#xA;     NumberAnimation on y {&#xA;         to: 40; duration: 4000&#xA;     }&#xA; }&#xA;&#xA;ClickableImageV2 {&#xA;     id: rocket2&#xA;     x: 40 + 170; y: 200&#xA;     source: &amp;quot;rocket.png&amp;quot;&#xA;     text: &amp;quot;animation on property&amp;quot;&#xA;     NumberAnimation on y {&#xA;         to: 40; duration: 4000&#xA;     }&#xA; }&#xA;&#xA;ClickableImageV2 {&#xA;     id: rocket3&#xA;     x: 40 + 170 + 170; y: 200&#xA;     source: &amp;quot;rocket.png&amp;quot;&#xA;     text: &amp;quot;animation on property&amp;quot;&#xA;     NumberAnimation on y {&#xA;         to: 40; duration: 4000&#xA;     }&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Behavior&#xA;ClickableImageV2 {&#xA;    id: rocket2&#xA;    x: 152; y: 200&#xA;    source: &amp;quot;rocket.png&amp;quot;&#xA;    text: &amp;quot;behavior on property&amp;quot;&#xA;    // Behavior 定义了特定的属性变化时的默认动画。&#xA;    // 此处：当 y 发生变化时触发 ... 动画&#xA;    Behavior on y {&#xA;        NumberAnimation { duration: 4000 }&#xA;    }&#xA;    // 点击则 y = 40 ... 触发动画&#xA;    onClicked: y = 40&#xA;    // 随机 y 值 ...&#xA;    // onClicked: y = 40+Math.random()*(205-40)&#xA;}   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// standalone animation&#xA;ClickableImageV2 {&#xA;    id: rocket3&#xA;    x: 264; y: 200&#xA;    source: &amp;quot;rocket.png&amp;quot;&#xA;    onClicked: anim.start()&#xA;    // onClicked: anim.restart()&#xA;&#xA;    text: &amp;quot;standalone animation&amp;quot;&#xA;&#xA;    // 每一个动画都有start()，stop()，resume()，restart()函数&#xA;    // 这个动画由一个私有的元素定义&#xA;    // 并且可以写在文档的任何地方&#xA;    NumberAnimation {&#xA;        id: anim&#xA;        target: rocket3&#xA;        properties: &amp;quot;y&amp;quot;&#xA;        from: 205 // 定义了一个from属性的值允许动画可以重复运行&#xA;        to: 40&#xA;        duration: 4000&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Image {&#xA;    id: rocket3&#xA;    x: 264; y: 200&#xA;    source: &amp;quot;rocket.png&amp;quot;&#xA;&#xA;    // 每一个动画都有start()，stop()，resume()，restart()函数&#xA;    // 这个动画由一个私有的元素定义&#xA;    // 并且可以写在文档的任何地方&#xA;    NumberAnimation {&#xA;        id: anim&#xA;        target: rocket3&#xA;        properties: &amp;quot;y&amp;quot;&#xA;        from: 205 // 定义了一个from属性的值允许动画可以重复运行&#xA;        to: 40&#xA;        duration: 4000&#xA;        running: area.pressed // 鼠标长按 ...&#xA;    }&#xA;&#xA;    /*&#xA;        canceled()&#xA;        clicked(MouseEvent  mouse)&#xA;        doubleClicked(MouseEvent  mouse)&#xA;        entered()&#xA;        exited()&#xA;        positionChanged(MouseEvent  mouse)&#xA;        pressAndHold(MouseEvent  mouse)&#xA;        pressed(MouseEvent  mouse)&#xA;        released(MouseEvent  mouse)&#xA;        wheel(MouseEvent  mouse)&#xA;    */&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        id: area&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;缓冲曲线（Easing Curves）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 扩展可点击图像V3（ClickableImage V3）&#xA;// ClickableImageV3.qml&#xA;// Simple image which can be clicked&#xA;&#xA;import QtQuick 2.0&#xA;&#xA;Item {&#xA;    id: root&#xA;    width: container.childrenRect.width + 16&#xA;    height: container.childrenRect.height + 16&#xA;    property alias text: label.text&#xA;    property alias source: image.source&#xA;    signal clicked&#xA;&#xA;    // M1&amp;gt;&amp;gt;&#xA;    // ... add a framed rectangle as container&#xA;    property bool framed : false&#xA;&#xA;    Rectangle {&#xA;        anchors.fill: parent&#xA;        color: &amp;quot;white&amp;quot;&#xA;        visible: root.framed&#xA;    }&#xA;}&#xA;&#xA;/*&#xA;    这个例子的代码非常简洁。&#xA;    我们使用了一连串的缓冲曲线的名称（property variant easings）&#xA;    并且在一个Repeater（重复元素）中将它们分配给一个ClickableImage。&#xA;    图片的源路径通过一个命名方案来定义，一个叫做“InQuad”的缓冲曲线在“curves/InQuad.png”中有一个对应的图片。&#xA;    如果你点击一个曲线图，这个点击将会分配一个缓冲类型给动画然后重新启动动画。&#xA;    动画自身是用来设置方块的x坐标属性在2秒内变化的独立动画。&#xA;*/&#xA;&#xA;// easingtypes.qml&#xA;&#xA;import QtQuick 2.0&#xA;&#xA;DarkSquare {&#xA;    id: root&#xA;    width: 600&#xA;    height: 340&#xA;&#xA;    // A list of easing types&#xA;    property variant easings : [&#xA;        &amp;quot;Linear&amp;quot;, &amp;quot;InQuad&amp;quot;, &amp;quot;OutQuad&amp;quot;, &amp;quot;InOutQuad&amp;quot;,&#xA;        &amp;quot;InCubic&amp;quot;, &amp;quot;InSine&amp;quot;, &amp;quot;InCirc&amp;quot;, &amp;quot;InElastic&amp;quot;,&#xA;        &amp;quot;InBack&amp;quot;, &amp;quot;InBounce&amp;quot; ]&#xA;&#xA;&#xA;    Grid {&#xA;        id: container&#xA;        anchors.top: parent.top&#xA;        anchors.horizontalCenter: parent.horizontalCenter&#xA;        anchors.margins: 16&#xA;        height: 200&#xA;        columns: 5&#xA;        spacing: 16&#xA;        // iterates over the &#39;easings&#39; list&#xA;        Repeater {&#xA;            model: easings&#xA;            ClickableImageV3 {&#xA;                framed: true&#xA;                // the current data entry from &#39;easings&#39; list&#xA;                text: modelData&#xA;                source: &amp;quot;curves/&amp;quot; + modelData + &amp;quot;.png&amp;quot;&#xA;                onClicked: {&#xA;                    // set the easing type on the animation&#xA;                    anim.easing.type = modelData&#xA;                    // restart the animation&#xA;                    anim.restart()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    // The square to be animated&#xA;    GreenSquare {&#xA;        id: square&#xA;        x: 40; y: 260&#xA;    }&#xA;&#xA;    // The animation to test the easing types&#xA;    NumberAnimation {&#xA;        id: anim&#xA;        target: square&#xA;        from: 40; to: root.width - 40 - square.width&#xA;        properties: &amp;quot;x&amp;quot;&#xA;        duration: 2000&#xA;    }&#xA;}&#xA;&#xA;/*&#xA;    除了duration属性与easing.type属性，你也可以对动画进行微调。&#xA;    例如PropertyAnimation属性，大多数动画都支持附加的&#xA;        easing.amplitude（缓冲振幅），easing.overshoot（缓冲溢出），easing.period（缓冲周期）&#xA;        这些属性允许你对个别的缓冲曲线进行微调。不是所有的缓冲曲线都支持这些参数。&#xA;    可以查看Qt PropertyAnimation文档中的缓冲列表（easing table）来查看一个缓冲曲线的相关参数。&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;动画分组（Grouped Animations）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    通常使用的动画比一个属性的动画更加复杂。&#xA;    例如你想同时运行几个动画并把他们连接起来，或者在一个一个的运行，或者在两个动画之间执行一个脚本。&#xA;    动画分组提供了很好的帮助，作为命名建议可以叫做一组动画。&#xA;    有两种方法来分组：平行与连续。&#xA;    你可以使用SequentialAnimation（连续动画）和ParallelAnimation（平行动画）来实现它们&#xA;    它们作为动画的容器来包含其它的动画元素。&#xA;*/&#xA;&#xA;// ClickableImageV3.qml &#xA;Item {&#xA;    id: root&#xA;    width: container.childrenRect.width&#xA;    height: container.childrenRect.height&#xA;&#xA;    property alias text: label.text&#xA;    property alias source: image.source&#xA;    signal clicked&#xA;&#xA;    Column {&#xA;        id: container&#xA;        Image {&#xA;            id: image&#xA;        }&#xA;        Text {&#xA;            id: label&#xA;            width: image.width&#xA;            horizontalAlignment: Text.AlignHCenter&#xA;            // 我们使用文本元素的wrapMode属性来设置文本与图像一样宽并且可以自动换行&#xA;            wrapMode: Text.WordWrap&#xA;            color: &amp;quot;#111111&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;    property bool framed : false&#xA;&#xA;    Rectangle {&#xA;        anchors.fill: parent&#xA;        color: &amp;quot;white&amp;quot;&#xA;        visible: root.framed&#xA;    }&#xA;&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: root.clicked()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 动画组合 ...&#xA;// 分组动画也可以被嵌套，例如一个连续动画可以拥有两个平行动画作为子动画&#xA;// ParallelAnimation 平行动画&#xA;Rectangle {&#xA;    id: root&#xA;    width: 300&#xA;    height: 200&#xA;    property int duration: 3000&#xA;&#xA;    ClickableImageV3 {&#xA;        id: rocket&#xA;        x: 20; y: 120&#xA;        source: &amp;quot;rocket.png&amp;quot;&#xA;        onClicked: anim.restart()&#xA;    }&#xA;&#xA;    // ParallelAnimation 平行动画&#xA;    ParallelAnimation {&#xA;        id: anim&#xA;        // 这个动画改变的是y值&#xA;        NumberAnimation {&#xA;            target: rocket&#xA;            properties: &amp;quot;y&amp;quot;&#xA;            to: 20&#xA;            duration: root.duration&#xA;        }&#xA;        // 这个动画改变的是x值&#xA;        NumberAnimation {&#xA;            target: rocket&#xA;            properties: &amp;quot;x&amp;quot;&#xA;            to: 160&#xA;            duration: root.duration&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 动画组合 ..&#xA;// 分组动画也可以被嵌套，例如一个连续动画可以拥有两个平行动画作为子动画&#xA;// SequentialAnimation（连续动画）&#xA;Rectangle {&#xA;    id: root&#xA;    width: 300&#xA;    height: 200&#xA;    property int duration: 3000&#xA;&#xA;    ClickableImageV3 {&#xA;        id: rocket&#xA;        x: 20; y: 120&#xA;        source: &amp;quot;rocket.png&amp;quot;&#xA;        onClicked: anim.restart()&#xA;    }&#xA;&#xA;    // 先执行Y移动，后执行X移动&#xA;    SequentialAnimation {&#xA;        id: anim&#xA;        NumberAnimation {&#xA;            target: rocket&#xA;            properties: &amp;quot;y&amp;quot;&#xA;            to: 20&#xA;            // 60% of time to travel up&#xA;            duration: root.duration*0.6&#xA;        }&#xA;        NumberAnimation {&#xA;            target: rocket&#xA;            properties: &amp;quot;x&amp;quot;&#xA;            to: 160&#xA;            // 40% of time to travel sideways&#xA;            duration: root.duration*0.4&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 最终组合动画&#xA;Item {&#xA;    id: root&#xA;    width: 480&#xA;    height: 300&#xA;    property int duration: 3000&#xA;&#xA;    Image {&#xA;          id: ball&#xA;          x: 20; y: 240&#xA;          source: &amp;quot;rocket.png&amp;quot;&#xA;&#xA;          MouseArea {&#xA;              anchors.fill: parent&#xA;              onClicked: {&#xA;                  ball.x = 20; ball.y = 240&#xA;                  anim.restart()&#xA;              }&#xA;          }&#xA;      }&#xA;&#xA;    ParallelAnimation {&#xA;        id: anim&#xA;        SequentialAnimation {&#xA;            NumberAnimation {&#xA;                target: ball&#xA;                properties: &amp;quot;y&amp;quot;&#xA;                to: 20&#xA;                duration: root.duration * 0.4&#xA;                easing.type: Easing.OutCirc&#xA;            }&#xA;            NumberAnimation {&#xA;                target: ball&#xA;                properties: &amp;quot;y&amp;quot;&#xA;                to: 240&#xA;                duration: root.duration * 0.6&#xA;                easing.type: Easing.OutBounce&#xA;            }&#xA;        }&#xA;        NumberAnimation {&#xA;            target: ball&#xA;            properties: &amp;quot;x&amp;quot;&#xA;            to: 400&#xA;            duration: root.duration&#xA;        }&#xA;        RotationAnimation {&#xA;            target: ball&#xA;            properties: &amp;quot;rotation&amp;quot;&#xA;            to: 720&#xA;            duration: root.duration * 1.1&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 组合动画学习 ...&#xA;/*&#xA;      ListElement { name: &amp;quot;Easing.Linear&amp;quot;; type: Easing.Linear; ballColor: &amp;quot;DarkRed&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InQuad&amp;quot;; type: Easing.InQuad; ballColor: &amp;quot;IndianRed&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutQuad&amp;quot;; type: Easing.OutQuad; ballColor: &amp;quot;Salmon&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutQuad&amp;quot;; type: Easing.InOutQuad; ballColor: &amp;quot;Tomato&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInQuad&amp;quot;; type: Easing.OutInQuad; ballColor: &amp;quot;DarkOrange&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InCubic&amp;quot;; type: Easing.InCubic; ballColor: &amp;quot;Gold&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutCubic&amp;quot;; type: Easing.OutCubic; ballColor: &amp;quot;Yellow&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutCubic&amp;quot;; type: Easing.InOutCubic; ballColor: &amp;quot;PeachPuff&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInCubic&amp;quot;; type: Easing.OutInCubic; ballColor: &amp;quot;Thistle&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InQuart&amp;quot;; type: Easing.InQuart; ballColor: &amp;quot;Orchid&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutQuart&amp;quot;; type: Easing.OutQuart; ballColor: &amp;quot;Purple&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutQuart&amp;quot;; type: Easing.InOutQuart; ballColor: &amp;quot;SlateBlue&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInQuart&amp;quot;; type: Easing.OutInQuart; ballColor: &amp;quot;Chartreuse&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InQuint&amp;quot;; type: Easing.InQuint; ballColor: &amp;quot;LimeGreen&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutQuint&amp;quot;; type: Easing.OutQuint; ballColor: &amp;quot;SeaGreen&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutQuint&amp;quot;; type: Easing.InOutQuint; ballColor: &amp;quot;DarkGreen&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInQuint&amp;quot;; type: Easing.OutInQuint; ballColor: &amp;quot;Olive&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InSine&amp;quot;; type: Easing.InSine; ballColor: &amp;quot;DarkSeaGreen&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutSine&amp;quot;; type: Easing.OutSine; ballColor: &amp;quot;Teal&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutSine&amp;quot;; type: Easing.InOutSine; ballColor: &amp;quot;Turquoise&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInSine&amp;quot;; type: Easing.OutInSine; ballColor: &amp;quot;SteelBlue&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InExpo&amp;quot;; type: Easing.InExpo; ballColor: &amp;quot;SkyBlue&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutExpo&amp;quot;; type: Easing.OutExpo; ballColor: &amp;quot;RoyalBlue&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutExpo&amp;quot;; type: Easing.InOutExpo; ballColor: &amp;quot;MediumBlue&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInExpo&amp;quot;; type: Easing.OutInExpo; ballColor: &amp;quot;MidnightBlue&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InCirc&amp;quot;; type: Easing.InCirc; ballColor: &amp;quot;CornSilk&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutCirc&amp;quot;; type: Easing.OutCirc; ballColor: &amp;quot;Bisque&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutCirc&amp;quot;; type: Easing.InOutCirc; ballColor: &amp;quot;RosyBrown&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInCirc&amp;quot;; type: Easing.OutInCirc; ballColor: &amp;quot;SandyBrown&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InElastic&amp;quot;; type: Easing.InElastic; ballColor: &amp;quot;DarkGoldenRod&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutElastic&amp;quot;; type: Easing.OutElastic; ballColor: &amp;quot;Chocolate&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutElastic&amp;quot;; type: Easing.InOutElastic; ballColor: &amp;quot;SaddleBrown&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInElastic&amp;quot;; type: Easing.OutInElastic; ballColor: &amp;quot;Brown&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InBack&amp;quot;; type: Easing.InBack; ballColor: &amp;quot;Maroon&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutBack&amp;quot;; type: Easing.OutBack; ballColor: &amp;quot;LavenderBlush&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutBack&amp;quot;; type: Easing.InOutBack; ballColor: &amp;quot;MistyRose&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInBack&amp;quot;; type: Easing.OutInBack; ballColor: &amp;quot;Gainsboro&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutBounce&amp;quot;; type: Easing.OutBounce; ballColor: &amp;quot;Silver&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InBounce&amp;quot;; type: Easing.InBounce; ballColor: &amp;quot;DimGray&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.InOutBounce&amp;quot;; type: Easing.InOutBounce; ballColor: &amp;quot;SlateGray&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.OutInBounce&amp;quot;; type: Easing.OutInBounce; ballColor: &amp;quot;DarkSlateGray&amp;quot; }&#xA;      ListElement { name: &amp;quot;Easing.Bezier&amp;quot;; type: Easing.Bezier; ballColor: &amp;quot;Chartreuse&amp;quot;; }&#xA;  */&#xA;Item {&#xA;    id: root&#xA;    width: 480&#xA;    height: 300&#xA;    property int duration: 3000&#xA;&#xA;    Image {&#xA;          id: ball&#xA;          x: 20; y: 240&#xA;          source: &amp;quot;rocket.png&amp;quot;&#xA;&#xA;          MouseArea {&#xA;              anchors.fill: parent&#xA;              // 点击开始动画 ...&#xA;              onClicked: {&#xA;                  ball.x = 20; ball.y = 240&#xA;                  anim.restart()&#xA;              }&#xA;          }&#xA;      }&#xA;&#xA;    // 平行动画&#xA;    // 平行元素的所有子动画都会平行运行，它允许你在同一时间使用不同的属性来播放动画。&#xA;    ParallelAnimation {&#xA;        id: anim&#xA;        // 同时：1, 连续动画(允许动画有序播放)&#xA;        SequentialAnimation {&#xA;            // 先改动 y 值&#xA;            NumberAnimation {&#xA;                target: ball // target 目标&#xA;                properties: &amp;quot;y&amp;quot;&#xA;                to: 20&#xA;                duration: root.duration * 0.4&#xA;                // Easing曲线定义动画如何在起始值和终止值见产生插值.&#xA;                // 不同的easing曲线定义了一系列的插值.&#xA;                // easing曲线简化了创建动画的效果--如弹跳效果, 加速, 减速, 和周期动画.&#xA;                // Easing.OutCirc缓冲曲线，它看起来更像是一个圆周运动&#xA;                easing.type: Easing.OutCirc&#xA;            }&#xA;            // 后改动 y 值&#xA;            NumberAnimation {&#xA;                target: ball // target 目标&#xA;                properties: &amp;quot;y&amp;quot;&#xA;                to: 240&#xA;                duration: root.duration * 0.6&#xA;                // Easing曲线定义动画如何在起始值和终止值见产生插值.&#xA;                // 不同的easing曲线定义了一系列的插值.&#xA;                // easing曲线简化了创建动画的效果--如弹跳效果, 加速, 减速, 和周期动画.&#xA;                // Easing.OutBounce缓冲曲线，因为在最后球会发生反弹&#xA;                easing.type: Easing.OutBounce&#xA;            }&#xA;        }&#xA;        // 同时：2, 改动 x 值&#xA;        NumberAnimation {&#xA;            target: ball&#xA;            properties: &amp;quot;x&amp;quot;&#xA;            to: 400 // x 移动到 400&#xA;            duration: root.duration // 移动时间/速度&#xA;        }&#xA;        // 同时：3, 旋转动画- 使用旋转改变播放的动画&#xA;        RotationAnimation {&#xA;            target: ball&#xA;            properties: &amp;quot;rotation&amp;quot;&#xA;            to: 720 // 旋转角度&#xA;            from: 0 // 循环 ...&#xA;            duration: root.duration * 1.1 // 旋转时间/速度&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;状态与过渡（States and Transitions）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常我们将用户界面描述为一种状态。一个状态定义了一组属性的改变，并且会在一定的条件下被触发&lt;/li&gt;&#xA;&lt;li&gt;另外在这些状态转化的过程中可以有一个过渡，定义了这些属性的动画或者一些附加的动作。&lt;/li&gt;&#xA;&lt;li&gt;当进入一个新的状态时，动作也可以被执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;状态（States）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以使用一个简单逻辑的脚本来替换QML状态。&#xA;// 开发人员很容易落入这种陷阱，写的代码更像一个JavaScript程序而不是一个QML程序&#xA;&#xA;// 预先初始化两种状态，随着不同的事件改变不同的状态 ...&#xA;Item {&#xA;&#xA;    width: 640&#xA;    height: 480&#xA;&#xA;    // 默认状态&#xA;    state: &amp;quot;stop&amp;quot;&#xA;&#xA;    states: [&#xA;        // 状态 stop&#xA;        State {&#xA;            name: &amp;quot;stop&amp;quot;&#xA;            PropertyChanges { target: light1; color: &amp;quot;red&amp;quot; }&#xA;            PropertyChanges { target: light2; color: &amp;quot;black&amp;quot; }&#xA;        },&#xA;        // 状态 go&#xA;        State {&#xA;            name: &amp;quot;go&amp;quot;&#xA;            PropertyChanges { target: light1; color: &amp;quot;black&amp;quot; }&#xA;            PropertyChanges { target: light2; color: &amp;quot;green&amp;quot; }&#xA;        }&#xA;    ]&#xA;&#xA;    // 状态对应对象&#xA;    Rectangle {&#xA;        id: light1&#xA;        x: 25; y: 15&#xA;        width: 100; height: width&#xA;        radius: width/2 // 半径&#xA;        color: &amp;quot;black&amp;quot;&#xA;    }&#xA;&#xA;    // 状态对应对象&#xA;    Rectangle {&#xA;        id: light2&#xA;        x: 25; y: 135&#xA;        width: 100; height: width&#xA;        radius: width/2 // 半径&#xA;        color: &amp;quot;black&amp;quot;&#xA;    }&#xA;&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: parent.state = (parent.state = &amp;quot;stop&amp;quot;? &amp;quot;go&amp;quot; : &amp;quot;stop&amp;quot;)&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;过渡（Transitions）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一系列的过渡能够被加入任何元素，一个过渡由状态的改变触发执行。你可以使用属性的from:和to:来定义状态改变的指定过渡。&#xA;这两个属性就像一个过滤器，当过滤器为true时，过渡生效。你也可以使用“”来表示任何状态。&#xA;例如from:&amp;ldquo;&amp;rdquo;; to:&amp;rdquo;*&amp;ldquo;表示从任一状态到另一个任一状态的默认值，这意味着过渡用于每个状态的切换。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Item {&#xA;&#xA;    width: 640&#xA;    height: 480&#xA;&#xA;    state: &amp;quot;stop&amp;quot;&#xA;&#xA;    states: [&#xA;        State {&#xA;            name: &amp;quot;stop&amp;quot;&#xA;            PropertyChanges { target: light1; color: &amp;quot;red&amp;quot; }&#xA;            PropertyChanges { target: light2; color: &amp;quot;black&amp;quot; }&#xA;        },&#xA;        State {&#xA;            name: &amp;quot;go&amp;quot;&#xA;            PropertyChanges { target: light1; color: &amp;quot;black&amp;quot; }&#xA;            PropertyChanges { target: light2; color: &amp;quot;green&amp;quot; }&#xA;        }&#xA;    ]&#xA;&#xA;    Rectangle {&#xA;        id: light1&#xA;        x: 25; y: 15&#xA;        width: 100; height: width&#xA;        radius: width/2&#xA;        color: &amp;quot;black&amp;quot;&#xA;    }&#xA;&#xA;    Rectangle {&#xA;        id: light2&#xA;        x: 25; y: 135&#xA;        width: 100; height: width&#xA;        radius: width/2&#xA;        color: &amp;quot;black&amp;quot;&#xA;    }&#xA;&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: parent.state = (parent.state = &amp;quot;stop&amp;quot;? &amp;quot;go&amp;quot; : &amp;quot;stop&amp;quot;)&#xA;    }&#xA;&#xA;    // 过渡动画&#xA;    transitions: [&#xA;        Transition {&#xA;            from: &amp;quot;stop&amp;quot;; to: &amp;quot;go&amp;quot;&#xA;            ColorAnimation { target: light1; properties: &amp;quot;color&amp;quot;; duration: 1000 }&#xA;            ColorAnimation { target: light2; properties: &amp;quot;color&amp;quot;; duration: 1000 }&#xA;        }&#xA;    ]&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;模型－视图－代理&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;基础模型（Basic Model）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;最基本的分离数据与显示的方法是使用Repeater元素。它被用于实例化一组元素项，并且很容易与一个用于填充用户界面的定位器相结合。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 列显示10个Text&#xA;Column {&#xA;    spacing: 2&#xA;&#xA;    Repeater {&#xA;        model: 10&#xA;&#xA;        Rectangle {&#xA;            width: 100&#xA;            height: 20&#xA;&#xA;            radius: 3&#xA;&#xA;            color: &amp;quot;lightBlue&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;                text: index&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 遍历数据&#xA;Column {&#xA;    spacing: 2　// 间距&#xA;&#xA;    Repeater {&#xA;        // 此值可以在 modelData 中获得 ...　index 为下标&#xA;        model: [&amp;quot;Enterprise&amp;quot;, &amp;quot;Colombia&amp;quot;, &amp;quot;Challenger&amp;quot;, &amp;quot;Discovery&amp;quot;, &amp;quot;Endeavour&amp;quot;, &amp;quot;Atlantis&amp;quot;]&#xA;&#xA;        Rectangle {&#xA;            width: 100&#xA;            height: 20&#xA;&#xA;            radius: 3&#xA;&#xA;            color: &amp;quot;lightBlue&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;                text: index +&amp;quot;: &amp;quot;+modelData&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用的模型，ListModel（链表模型）&#xA;Column {&#xA;    spacing: 2&#xA;&#xA;    Repeater {&#xA;        model: ListModel {&#xA;            ListElement { name: &amp;quot;Mercury&amp;quot;; surfaceColor: &amp;quot;gray&amp;quot;; index: 0; }&#xA;            ListElement { name: &amp;quot;Venus&amp;quot;; surfaceColor: &amp;quot;yellow&amp;quot;; index: 1; }&#xA;            ListElement { name: &amp;quot;Earth&amp;quot;; surfaceColor: &amp;quot;blue&amp;quot;; index: 2; }&#xA;            ListElement { name: &amp;quot;Mars&amp;quot;; surfaceColor: &amp;quot;orange&amp;quot;; index: 3; }&#xA;            ListElement { name: &amp;quot;Jupiter&amp;quot;; surfaceColor: &amp;quot;orange&amp;quot;; index: 4; }&#xA;            ListElement { name: &amp;quot;Saturn&amp;quot;; surfaceColor: &amp;quot;yellow&amp;quot;; index: 5; }&#xA;            ListElement { name: &amp;quot;Uranus&amp;quot;; surfaceColor: &amp;quot;lightBlue&amp;quot;; index: 6; }&#xA;            ListElement { name: &amp;quot;Neptune&amp;quot;; surfaceColor: &amp;quot;lightBlue&amp;quot;; index: 7; }&#xA;        }&#xA;&#xA;        Rectangle {&#xA;            width: 150&#xA;            height: 40&#xA;&#xA;            radius: 3&#xA;&#xA;            color: &amp;quot;lightBlue&amp;quot;&#xA;&#xA;            // Text&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;                // text 取决为 name&#xA;                text: name&#xA;            }&#xA;&#xA;            // ICON&#xA;            Rectangle {&#xA;&#xA;                Text {&#xA;                    // text 取决为 index&#xA;                    text: index&#xA;                    anchors.horizontalCenter: parent.horizontalCenter&#xA;                    anchors.verticalCenter: parent.verticalCenter&#xA;                }&#xA;&#xA;                anchors.left: parent.left&#xA;                anchors.verticalCenter: parent.verticalCenter&#xA;                anchors.leftMargin: 2&#xA;&#xA;                width: 32&#xA;                height: 32&#xA;&#xA;                radius: 8&#xA;&#xA;                border.color: &amp;quot;black&amp;quot;&#xA;                border.width: 1&#xA;&#xA;                // 颜色取决为 surfaceColor&#xA;                color: surfaceColor&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;动态视图（Dynamic Views）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;－&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;　QtQuick提供了ListView和GridView元素，这两个都是基于Flickable（可滑动）区域的元素，因此用户可以放入更大的数据。&#xA;同时，它们限制了同时实例化的代理数量。对于一个大型的模型，这意味着在同一个场景下只会加载有限的元素。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 我们由ListView开始&#xA;/*&#xA;    视图末尾的行为是由到boundsBehavior属性的控制的。&#xA;    这是一个枚举值，并且可以配置为默认的Flickable.DragAndOvershootBounds&#xA;    视图可以通过它的边界线来拖拽和翻阅，配置为Flickable.StopAtBounds，视图将不再可以移动到它的边界线之外。&#xA;    配置为Flickable.DragOverBounds，用户可以将视图拖拽到它的边界线外，但是在边界线上翻阅将无效。&#xA;  */&#xA;&#xA;/*&#xA;    使用snapMode属性可以限制一个视图内元素的停止位置。&#xA;    默认行为下是ListView.NoSnap，允许视图内元素在任何位置停止。&#xA;    将snapMode属性设置为ListView.SnapToItem，视图顶部将会与元素对象的顶部对齐排列。&#xA;    使用ListView.SnapOneItem，当鼠标或者触摸释放时，视图将会停止在第一个可见的元素，这种模式对于浏览页面非常便利。&#xA;  */&#xA;Rectangle {&#xA;    width: 80&#xA;    height: 300&#xA;&#xA;    color: &amp;quot;white&amp;quot;&#xA;&#xA;    // ListView它使用了一个model，使用delegate来实例化，并且在两个delegate之间能够设置间隔sapcing&#xA;    ListView {&#xA;        anchors.fill: parent&#xA;        anchors.margins: 20&#xA;&#xA;        // ListView通过设置clip属性为true，来激活裁剪功能&#xA;        clip: true&#xA;&#xA;        model: 100&#xA;&#xA;        // 代理&#xA;        delegate: numberDelegate&#xA;        spacing: 5&#xA;    }&#xA;&#xA;    Component {&#xA;        id: numberDelegate&#xA;&#xA;        Rectangle {&#xA;            width: 40&#xA;            height: 40&#xA;&#xA;            color: &amp;quot;lightGreen&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;                font.pixelSize: 16&#xA;                text: index&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// 链表视图的方向由属性orientation控制。(orientation: ListView.Horizontal)&#xA;// 它能够被设置为默认值ListView.Vertical或者ListView.Horizonta&#xA;// 可以通过设置layoutDirection属性来控制元素顺序方向，它可以设置为Qt.LeftToRight或者Qt.RightToLeft。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;键盘导航和高亮&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在使用键盘甚至仅仅通过方向键选择一个元素的场景下，需要有标识当前选中元素的机制。在QML中，这被叫做高亮。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;视图支持设置一个当前视图中显示代理元素中的高亮代理。它是一个附加的代理元素，这个元素仅仅只实例化一次，并移动到与当前元素相同的位置&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    当使用高亮与链表视图（ListView）结合时，一些属性可以用来控制它的行为。&#xA;    highlightRangeMode控制了高亮如何影响视图中当前的显示。&#xA;    默认设置ListView.NoHighLighRange意味着高亮与视图中的元素距离不相关。&#xA;  */&#xA;/*&#xA;    ListView.StrictlyEnforceRnage确保了高亮始终可见&#xA;    如果某个动作尝试将高亮移出当前视图可见范围，&#xA;    当前元素将会自动切换，确保了高亮始终可见。&#xA;  */&#xA;/*&#xA;    ListView.ApplyRange，它尝试保持高亮代理始终可见&#xA;    但是不会强制切换当前元素始终可见。&#xA;    如果在需要的情况下高亮代理允许被移出当前视图。&#xA;  */&#xA;/*&#xA;    在默认配置下，视图负责高亮移动到指定位置，移动的速度与大小的改变能够被控制&#xA;    使用一个速度值或者一个动作持续时间来完成它。&#xA;    这些属性包括highlightMoveSpeed，highlightMoveDuration，highlightResizeSpeed和highlightResizeDuration。&#xA;    默认下速度被设置为每秒400像素，动作持续时间为-1，表明速度和距离控制了动作的持续时间。&#xA;    如果速度与动作持续时间都被设置，动画将会采用速度较快的结果来完成。&#xA;  */&#xA;/*&#xA;    为了更加详细的控制高亮的移动，highlightFollowCurrentItem属性设置为false。&#xA;    这意味着视图将不再负责高亮代理的移动。取而代之可以通过一个行为（Bahavior）或者一个动画来控制它。&#xA;  */&#xA;Rectangle {&#xA;    width: 240&#xA;    height: 300&#xA;&#xA;    color: &amp;quot;white&amp;quot;&#xA;&#xA;    ListView {&#xA;        anchors.fill: parent&#xA;        anchors.margins: 20&#xA;&#xA;        clip: true&#xA;&#xA;        model: 100&#xA;&#xA;        delegate: numberDelegate&#xA;        spacing: 5&#xA;&#xA;        // highlight属性，指出使用的高亮代理元素&#xA;        highlight: highlightComponent&#xA;        // 首先是focus属性设置为true，它设置链表视图能够获得键盘焦点&#xA;        focus: true&#xA;    }&#xA;&#xA;    // 高亮代理&#xA;    Component {&#xA;        id: highlightComponent&#xA;&#xA;        Rectangle {&#xA;            // ListView.view.width属性被绑定用于高亮元素的宽度&#xA;            width: ListView.view.width&#xA;            color: &amp;quot;lightGreen&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;    Component {&#xA;        id: numberDelegate&#xA;&#xA;        Item {&#xA;            width: 40&#xA;            height: 40&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;&#xA;                font.pixelSize: 10&#xA;&#xA;                text: index&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    在下面的例子中，高亮代理的y坐标属性与ListView.view.currentItem.y属性绑定。&#xA;    这确保了高亮始终跟随当前元素。&#xA;    然而，由于我们没有让视图来移动这个高亮代理，我们需要控制这个元素如何移动&#xA;    通过Behavior on y来完成这个操作，在下面的例子中，移动分为三步完成：淡出，移动，淡入。&#xA;    注意怎样使用SequentialAnimation和PropertyAnimation元素与NumberAnimation结合创建更加复杂的移动效果。&#xA;*/&#xA;Component {&#xA;    id: highlightComponent&#xA;&#xA;// 从新封装了一个Item并增加动画效果&#xA;    Item {&#xA;    // 宽度与 listview 等宽&#xA;        width: ListView.view.width&#xA;    // 高度跟随当前 item current height&#xA;        height: ListView.view.currentItem.height&#xA;&#xA;    // 永远更随着 item current y ...&#xA;        y: ListView.view.currentItem.y&#xA;&#xA;        Behavior on y {&#xA;            SequentialAnimation {&#xA;                PropertyAnimation { &#xA;            target: highlightRectangle; property: &amp;quot;opacity&amp;quot;; to: 0; duration: 200 }&#xA;                NumberAnimation { duration: 1 }&#xA;                PropertyAnimation { &#xA;            target: highlightRectangle; property: &amp;quot;opacity&amp;quot;; to: 1; duration: 200 }&#xA;            }&#xA;        }&#xA;&#xA;        Rectangle {&#xA;            id: highlightRectangle&#xA;            anchors.fill: parent&#xA;            color: &amp;quot;lightGreen&amp;quot;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;页眉与页脚（Header and Footer）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我们能够向链表视图中插入一个页眉（header）元素和一个页脚（footer）元素&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 页眉与页脚代理元素不遵循链表视图（ListView）的间隔（spacing）属性&#xA;// 它们被直接放在相邻的链表元素之上或之下。&#xA;// 这意味着页眉与页脚的间隔必须通过页眉与页脚元素自己设置。&#xA;Rectangle {&#xA;    width: 80&#xA;    height: 300&#xA;&#xA;    color: &amp;quot;white&amp;quot;&#xA;&#xA;    ListView {&#xA;        anchors.fill: parent&#xA;        anchors.margins: 20&#xA;&#xA;        clip: true&#xA;&#xA;        model: 4&#xA;&#xA;        delegate: numberDelegate&#xA;        spacing: 5&#xA;&#xA;        header: headerComponent&#xA;        footer: footerComponent&#xA;    }&#xA;&#xA;    Component {&#xA;        id: headerComponent&#xA;&#xA;        Rectangle {&#xA;            width: 40&#xA;            height: 20&#xA;&#xA;            color: &amp;quot;yellow&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;    Component {&#xA;        id: footerComponent&#xA;&#xA;        Rectangle {&#xA;            width: 40&#xA;            height: 20&#xA;&#xA;            color: &amp;quot;red&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;    Component {&#xA;        id: numberDelegate&#xA;&#xA;        Rectangle {&#xA;            width: 40&#xA;            height: 40&#xA;&#xA;            color: &amp;quot;lightGreen&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;&#xA;                font.pixelSize: 10&#xA;&#xA;                text: index&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;网格视图（The GridView）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用网格视图（GridView）与使用链表视图（ListView）的方式非常类似。&#xA;真正不同的地方是网格视图（GridView）使用了一个二维数组来存放元素，而链表视图（ListView）是使用的线性链表来存放元素。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; /*&#xA;    网格视图（GridView）不依赖于元素间隔和大小来配置元素。&#xA;    它使用单元宽度（cellWidth）与单元高度（cellHeight）属性来控制数组内的二维元素的内容。&#xA;    每个元素从左上角开始依次放入单元格。&#xA;*/&#xA;&#xA;/*&#xA;    一个网格视图（GridView）也包含了页脚与页眉&#xA;    也可以使用高亮代理并且支持捕捉模式（snap mode）的多种反弹行为。&#xA;    它也可以使用不同的方向（orientations）与定向（directions）来定位。&#xA;  */&#xA;/*&#xA;    定向使用flow属性来控制。它可以被设置为GridView.LeftToRight或者GridView.TopToBottom。&#xA;    模型的值从左往右向网格中填充，行添加是从上往下。&#xA;    视图使用一个垂直方向的滚动条。后面添加的元素也是由上到下，由左到右。&#xA;    此外还有flow属性和layoutDirection属性，能够适配网格从左到右或者从右到左，这依赖于你使用的设置值。&#xA;  */&#xA;Rectangle {&#xA;    width: 240&#xA;    height: 300&#xA;&#xA;    color: &amp;quot;white&amp;quot;&#xA;&#xA;    // 网格视图&#xA;    GridView {&#xA;        anchors.fill: parent&#xA;        anchors.margins: 20&#xA;&#xA;        // 裁剪&#xA;        clip: true&#xA;&#xA;        // 100个&#xA;        model: 100&#xA;&#xA;        // 使用单元宽度（cellWidth）与单元高度（cellHeight）属性来控制数组内的二维元素的内容。&#xA;        // 每个元素从左上角开始依次放入单元格。&#xA;        cellWidth: 45&#xA;        cellHeight: 45&#xA;&#xA;        // 代理&#xA;        delegate: numberDelegate&#xA;    }&#xA;&#xA;    // 代理&#xA;    Component {&#xA;        id: numberDelegate&#xA;&#xA;        // 内容&#xA;        Rectangle {&#xA;            width: 40&#xA;            height: 40&#xA;&#xA;            color: &amp;quot;lightGreen&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;&#xA;                font.pixelSize: 10&#xA;&#xA;                text: index&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;代理（Delegate）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;当使用模型与视图来自定义用户界面时，代理在创建显示时扮演了大量的角色。&#xA;在模型中的每个元素通过代理来实现可视化，用户真实可见的是这些代理元素。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 每个代理访问到索引号或者绑定的属性，一些是来自数据模型，一些来自视图。&#xA;// 来自模型的数据将会通过属性传递到代理。来自视图的数据将会通过属性传递视图中与代理相关的状态信息。&#xA;&#xA; /*&#xA;通常使用的视图绑定属性是ListView.isCurrentItem和ListView.view。&#xA;第一个是一个布尔值，标识这个元素是否是视图当前元素，这个值是只读的，引用自当前视图。&#xA;通过访问视图，可以创建可复用的代理，这些代理在被包含时会自动匹配视图的大小。&#xA;在下面这个例子中，每个代理的width（宽度）属性与视图的width（宽度）属性绑定&#xA;    每个代理的背景颜色color依赖于绑定的属性ListView.isCurrentItem属性。&#xA;*/&#xA;&#xA;Rectangle {&#xA;    width: 120&#xA;    height: 300&#xA;&#xA;    color: &amp;quot;white&amp;quot;&#xA;&#xA;    // ListView&#xA;    ListView {&#xA;        anchors.fill: parent&#xA;        anchors.margins: 20&#xA;&#xA;        clip: true&#xA;&#xA;        model: 100&#xA;&#xA;        delegate: numberDelegate&#xA;        spacing: 5&#xA;&#xA;        focus: true&#xA;    }&#xA;&#xA;    // 代理&#xA;    Component {&#xA;        id: numberDelegate&#xA;&#xA;        Rectangle {&#xA;            width: ListView.view.width&#xA;            height: 40&#xA;&#xA;            // 如果是 curent item 则指定颜色&#xA;            color: ListView.isCurrentItem?&amp;quot;gray&amp;quot;:&amp;quot;lightGray&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;&#xA;                font.pixelSize: 10&#xA;&#xA;                text: index&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;动画添加与移除元素（Animating Added and Removed Items）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在某些情况下，视图中的显示内容会随着时间而改变。由于模型数据的改变，元素会添加或者移除&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;为了方便使用，QML视图为每个代理绑定了两个信号，onAdd和onRemove。使用动画连接它们，可以方便创建识别哪些内容被添加或删除的动画&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Rectangle {&#xA;    width: 480&#xA;    height: 300&#xA;&#xA;    color: &amp;quot;white&amp;quot;&#xA;&#xA;    // 链表模型（类似：c++ vector）&#xA;    ListModel {&#xA;        id: theModel&#xA;&#xA;        // 数据&#xA;        ListElement { number: 0 }&#xA;        ListElement { number: 1 }&#xA;        ListElement { number: 2 }&#xA;        ListElement { number: 3 }&#xA;        ListElement { number: 4 }&#xA;        ListElement { number: 5 }&#xA;        ListElement { number: 6 }&#xA;        ListElement { number: 7 }&#xA;        ListElement { number: 8 }&#xA;        ListElement { number: 9 }&#xA;    }&#xA;&#xA;    // 添加按钮&#xA;    Rectangle {&#xA;        anchors.left: parent.left&#xA;        anchors.right: parent.right&#xA;        anchors.bottom: parent.bottom&#xA;        anchors.margins: 20&#xA;&#xA;        height: 40&#xA;&#xA;        color: &amp;quot;darkGreen&amp;quot;&#xA;&#xA;        Text {&#xA;            anchors.centerIn: parent&#xA;&#xA;            text: &amp;quot;Add item!&amp;quot;&#xA;        }&#xA;&#xA;        MouseArea {&#xA;            anchors.fill: parent&#xA;&#xA;            onClicked: {&#xA;                // 向链表中添加数据&#xA;                theModel.append({&amp;quot;number&amp;quot;: ++parent.count});&#xA;            }&#xA;        }&#xA;&#xA;        property int count: 9&#xA;    }&#xA;&#xA;    // 网格视图&#xA;    GridView {&#xA;        anchors.fill: parent&#xA;        anchors.margins: 20&#xA;        anchors.bottomMargin: 80&#xA;&#xA;        // 裁剪&#xA;        clip: true&#xA;&#xA;        // 指定链表数据&#xA;        model: theModel&#xA;&#xA;        // 网格大小&#xA;        cellWidth: 45&#xA;        cellHeight: 45&#xA;&#xA;        // 代理&#xA;        delegate: numberDelegate&#xA;    }&#xA;&#xA;    // 代理&#xA;    Component {&#xA;        id: numberDelegate&#xA;&#xA;        // 网格内容&#xA;        Rectangle {&#xA;            id: wrapper&#xA;&#xA;            width: 40&#xA;            height: 40&#xA;&#xA;            color: &amp;quot;lightGreen&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;                font.pixelSize: 10&#xA;                text: number&#xA;            }&#xA;&#xA;            // 鼠标区域&#xA;            MouseArea {&#xA;                anchors.fill: parent&#xA;&#xA;                onClicked: {&#xA;                    // GridView.delayRemove 代表该 GridView 数据是否可以销毁, 默认 false 不可以&#xA;                    // 判断 GridView 数据是否可以销毁&#xA;                    if (!wrapper.GridView.delayRemove)&#xA;                        theModel.remove(index);&#xA;                }&#xA;            }&#xA;&#xA;            // SequentialAnimation 顺序动画&#xA;            // 当执行 onRemove 时触发该动画&#xA;            GridView.onRemove: SequentialAnimation {&#xA;                // PropertyAction 属性动作(在播放动画时改变属性)&#xA;                // 改变属性为可销毁&#xA;                PropertyAction { target: wrapper; property: &amp;quot;GridView.delayRemove&amp;quot;; value: true }&#xA;                // 数字动画&#xA;                // property - http://doc.qt.io/qt-4.8/qml-propertyanimation.html#property-prop&#xA;                NumberAnimation {&#xA;                    target: wrapper  // 绑定目标&#xA;                    /*&#xA;                      指定特定的属性动画元素&#xA;                      property 与 properties 具有相同含义&#xA;                      */&#xA;                    property: &amp;quot;scale&amp;quot;&#xA;                    to: 0&#xA;                    duration: 250&#xA;                    easing.type: Easing.InOutQuad&#xA;                }&#xA;                // 改变属性为不可销毁&#xA;                PropertyAction { target: wrapper; property: &amp;quot;GridView.delayRemove&amp;quot;; value: false }&#xA;            }&#xA;&#xA;            // SequentialAnimation 顺序动画&#xA;            // 当执行 onAdd 时触发该动画&#xA;            GridView.onAdd: SequentialAnimation {&#xA;                // 数字动画&#xA;                NumberAnimation {&#xA;                    target: wrapper  // 绑定目标&#xA;                    property: &amp;quot;scale&amp;quot;&#xA;                    from: 0&#xA;                    to: 1&#xA;                    duration: 250&#xA;                    easing.type: Easing.InOutQuad&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;形变的代理（Shape-Shifting Delegates）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在使用链表时通常会使用当前项激活时展开的机制。&#xA;这个操作可以被用于动态的将当前项目填充到整个屏幕来添加一个新的用户界面&#xA;或者为链表中的当前项提供更多的信息。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 6.4.2 形变的代理（Shape-Shifting Delegates）&#xA;// https://cwc1987.gitbooks.io/qmlbook-in-chinese/content/model-view-delegate/delegate.html&#xA;Item {&#xA;    width: 300&#xA;    height: 480&#xA;&#xA;    // ListView&#xA;    ListView {&#xA;        id: listView&#xA;&#xA;        anchors.fill: parent&#xA;        // 代理&#xA;        delegate: detailsDelegate&#xA;        // 数据&#xA;        model: planets&#xA;    }&#xA;&#xA;    // 链表数据&#xA;    ListModel {&#xA;        id: planets&#xA;&#xA;        ListElement { name: &amp;quot;Mercury&amp;quot;; imageSource: &amp;quot;images/mercury.jpeg&amp;quot;; &#xA;        facts: &amp;quot;Mercury is the smallest planet in the Solar System.  \&#xA;    It is the closest planet to the sun. It makes one trip around the Sun once every 87.969 days.&amp;quot; }&#xA;        ListElement { name: &amp;quot;Venus&amp;quot;; imageSource: &amp;quot;images/venus.jpeg&amp;quot;; &#xA;        facts: &amp;quot;Venus is the second planet from the Sun. It is a terrestrial planet because it has a solid, rocky surface. \&#xA;    The other terrestrial planets are Mercury, Earth and Mars. Astronomers have known Venus for thousands of years.&amp;quot; }&#xA;        ListElement { name: &amp;quot;Earth&amp;quot;; imageSource: &amp;quot;images/earth.jpeg&amp;quot;; &#xA;        facts: &amp;quot;The Earth is the third planet from the Sun. It is one of the four terrestrial planets in our Solar System. \&#xA;    This means most of its mass is solid. The other three are Mercury, Venus and Mars. The Earth is also called the Blue Planet, &#39;Planet Earth&#39;, and &#39;Terra&#39;.&amp;quot; }&#xA;        ListElement { name: &amp;quot;Mars&amp;quot;; imageSource: &amp;quot;images/mars.jpeg&amp;quot;; &#xA;        facts: &amp;quot;Mars is the fourth planet from the Sun in the Solar System. Mars is dry, rocky and cold. \ &#xA;    It is home to the largest volcano in the Solar System. Mars is named after \&#xA;    the mythological Roman god of war because it is a red planet, which signifies the colour of blood.&amp;quot; }&#xA;    }&#xA;&#xA;    // 代理&#xA;    Component {&#xA;        id: detailsDelegate&#xA;&#xA;        // 内容&#xA;        Item {&#xA;            id: wrapper&#xA;&#xA;            width: listView.width&#xA;            height: 30&#xA;&#xA;            // 未展开(文字部分)&#xA;            Rectangle {&#xA;                anchors.left: parent.left&#xA;                anchors.right: parent.right&#xA;                anchors.top: parent.top&#xA;&#xA;                height: 30&#xA;&#xA;                color: &amp;quot;#ffaa00&amp;quot;&#xA;&#xA;                Text {&#xA;                    anchors.left: parent.left&#xA;                    anchors.verticalCenter: parent.verticalCenter&#xA;&#xA;                    font.pixelSize: parent.height-4&#xA;&#xA;                    text: name&#xA;                }&#xA;            }&#xA;&#xA;            // 未展开（图片部分）&#xA;            Rectangle {&#xA;                id: image&#xA;&#xA;                // 黑色&#xA;                color: &amp;quot;black&amp;quot;&#xA;&#xA;                anchors.right: parent.right&#xA;                anchors.top: parent.top&#xA;                anchors.rightMargin: 2&#xA;                anchors.topMargin: 2&#xA;&#xA;                width: 26&#xA;                height: 26&#xA;&#xA;                Image {&#xA;                    anchors.fill: parent&#xA;&#xA;                    /*&#xA;                        Image.Stretch- 缩放图片，使用拉伸&#xA;                        Image.PreserveAspectFit- 图片按比例缩放，但不裁减。&#xA;                        Image.PreserveAspectCrop-图片按比例缩放，裁减&#xA;                        Image.Tile -图片在水平方向和垂直方向瓷砖平铺。&#xA;                        Image.TileVertically- 图片水平拉什，垂直平铺&#xA;                        Image.TileHorizontally- 图片垂直拉什，水平平铺&#xA;                        Image.Pad - 图片不改变&#xA;                      */&#xA;                    fillMode: Image.PreserveAspectFit&#xA;&#xA;                    source: imageSource&#xA;                }&#xA;            }&#xA;&#xA;            // 鼠标区域&#xA;            MouseArea {&#xA;                anchors.fill: parent&#xA;                onClicked: {&#xA;                    parent.state = &amp;quot;expanded&amp;quot;&#xA;                }&#xA;            }&#xA;&#xA;&#xA;            // 展开区域（文字部分）&#xA;            Item {&#xA;                id: factsView&#xA;&#xA;                anchors.top: image.bottom&#xA;                anchors.left: parent.left&#xA;                anchors.right: parent.right&#xA;                anchors.bottom: parent.bottom&#xA;&#xA;                // 完全透明&#xA;                opacity: 0&#xA;&#xA;                Rectangle {&#xA;                    anchors.fill: parent&#xA;&#xA;                    color: &amp;quot;#cccccc&amp;quot;&#xA;&#xA;                    Text {&#xA;                        anchors.fill: parent&#xA;                        anchors.margins: 5&#xA;&#xA;                        clip: true&#xA;                        wrapMode: Text.WordWrap&#xA;&#xA;                        font.pixelSize: 12&#xA;&#xA;                        text: facts&#xA;                    }&#xA;                }&#xA;            }&#xA;&#xA;            // 展开区域（关闭按钮）&#xA;            Rectangle {&#xA;                id: closeButton&#xA;&#xA;                anchors.right: parent.right&#xA;                anchors.top: parent.top&#xA;                anchors.rightMargin: 2&#xA;                anchors.topMargin: 2&#xA;&#xA;                width: 26&#xA;                height: 26&#xA;&#xA;                // 红色&#xA;                color: &amp;quot;red&amp;quot;&#xA;&#xA;                opacity: 0&#xA;&#xA;                // 点击改变状态&#xA;                MouseArea {&#xA;                    anchors.fill: parent&#xA;                    onClicked: wrapper.state = &amp;quot;&amp;quot;&#xA;                }&#xA;            }&#xA;&#xA;            // 状态&#xA;            states: [&#xA;                State {&#xA;                    name: &amp;quot;expanded&amp;quot;&#xA;&#xA;                    // 改变　wrapper 高度&#xA;                    PropertyChanges { target: wrapper; height: listView.height; }&#xA;                    // 改变　image　宽高位置　...&#xA;                    PropertyChanges { target: image; width: listView.width; height: listView.width; &#xA;            anchors.rightMargin: 0; anchors.topMargin: 30 }&#xA;                    // 改变　factsView(文字区域) 不透明&#xA;                    PropertyChanges { target: factsView; opacity: 1 }&#xA;                    // 改变 closeButton(关闭按钮) 不透明&#xA;                    PropertyChanges { target: closeButton; opacity: 1 }&#xA;                    // 改变 wrapper.ListView.view 的 contentY 等于 wrapper.y&#xA;                    // interactive: false 关闭互动&#xA;                    PropertyChanges { target: wrapper.ListView.view; contentY: wrapper.y; interactive: false }&#xA;                }&#xA;            ]&#xA;&#xA;            // 过渡&#xA;            transitions: [&#xA;                Transition {&#xA;                    NumberAnimation {&#xA;                        duration: 200;&#xA;                        properties: &amp;quot;height,width,anchors.rightMargin,anchors.topMargin,opacity,contentY&amp;quot;&#xA;                    }&#xA;                }&#xA;            ]&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;高级用法（Advanced Techniques）&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;路径视图（The PathView）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;路径视图（PathView）非常强大，但也非常复杂，这个视图由QtQuick提供。&#xA;它创建了一个可以让子项沿着任意路径移动的视图。&#xA;沿着相同的路径，使用缩放（scale），透明（opacity）等元素可以更加详细的控制过程。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// https://cwc1987.gitbooks.io/qmlbook-in-chinese/content/model-view-delegate/advanced_techniques.html&#xA;Item {&#xA;    id: root&#xA;    anchors.fill: parent&#xA;&#xA;    PathView {&#xA;         anchors.fill: parent&#xA;&#xA;         // 代理&#xA;         delegate: flipCardDelegate&#xA;         model: 100&#xA;&#xA;         // 路径（path）属性使用一个路径（path）元素来定义路径视图（PathView）内代理的滚动路径。&#xA;         // 路径使用startx与starty属性来链接路径（path）元素，例如PathLine,PathQuad和PathCubic。&#xA;         // 这些元素都使用二维数组来构造路径。&#xA;         path: Path {&#xA;             startX: root.width/2&#xA;             startY: 0&#xA;&#xA;             // 使用PathPercent元素，它确保了中间的元素居中，并且给其它的元素提供了足够的空间&#xA;             // 使用PathAttribute元素来控制旋转，大小和深度值（z-value）。&#xA;             // 使用PathLine元素来从起点到终端绘制一条线　...&#xA;&#xA;             PathAttribute { name: &amp;quot;itemZ&amp;quot;; value: 0 }&#xA;             PathAttribute { name: &amp;quot;itemAngle&amp;quot;; value: -90.0; }&#xA;             PathAttribute { name: &amp;quot;itemScale&amp;quot;; value: 0.5; }&#xA;             PathLine { x: root.width/2; y: root.height*0.4; }&#xA;             PathPercent { value: 0.48; }&#xA;             PathLine { x: root.width/2; y: root.height*0.5; }&#xA;             PathAttribute { name: &amp;quot;itemAngle&amp;quot;; value: 0.0; }&#xA;             PathAttribute { name: &amp;quot;itemScale&amp;quot;; value: 1.0; }&#xA;             PathAttribute { name: &amp;quot;itemZ&amp;quot;; value: 100 }&#xA;             PathLine { x: root.width/2; y: root.height*0.6; }&#xA;             PathPercent { value: 0.52; }&#xA;             PathLine { x: root.width/2; y: root.height; }&#xA;             PathAttribute { name: &amp;quot;itemAngle&amp;quot;; value: 90.0; }&#xA;             PathAttribute { name: &amp;quot;itemScale&amp;quot;; value: 0.5; }&#xA;             PathAttribute { name: &amp;quot;itemZ&amp;quot;; value: 0 }&#xA;         }&#xA;&#xA;         // pathItemCount属性，控制了一次可见的子项总数&#xA;         pathItemCount: 16&#xA;&#xA;         /*&#xA;           preferredHightlightBegin与preferredHighlightEnd属性由PathView（路径视图）输入到图片元素中。&#xA;           它们的值在0~1之间。结束值大于等于开始值。例如设置这些属性值为0.5，当前项只会显示当前百分之50的图像在这个路径上。&#xA;           */&#xA;         // preferredHighLightBegin属性控制了高亮区间&#xA;         preferredHighlightBegin: 0.5&#xA;         // preferredHighlightEnd与highlightRangeMode，控制了当前项怎样沿着路径显示。&#xA;         preferredHighlightEnd: 0.5&#xA;     }&#xA;&#xA;    // 代理&#xA;    Component {&#xA;        id: flipCardDelegate&#xA;&#xA;        Item {&#xA;            id: wrapper&#xA;&#xA;            width: 64&#xA;            height: 64&#xA;&#xA;            // 通常对于这个属性都绑定为可见，这样允许路径视图（PathView）缓冲不可见的元素&#xA;            // 这不是通过剪裁处理来实现的，与链表视图（ListView）或者栅格视图（GridView）不同&#xA;            visible: PathView.onPath&#xA;&#xA;            scale: PathView.itemScale&#xA;            z: PathView.itemZ&#xA;&#xA;            // 代理如下面所示，使用了一些从PathAttribute中链接的属性，itemZ,itemAngle和itemScale。&#xA;            // 需要注意代理链接的属性只在wrapper中可用。因此，rotX属性在Rotation元素中定义为可访问值。&#xA;            property variant rotX: PathView.itemAngle&#xA;            transform: Rotation { axis { x: 1; y: 0; z: 0 } angle: wrapper.rotX; origin { x: 32; y: 32; } }&#xA;&#xA;            Rectangle {&#xA;                anchors.fill: parent&#xA;                color: &amp;quot;lightGray&amp;quot;&#xA;                border.color: &amp;quot;black&amp;quot;&#xA;                border.width: 3&#xA;            }&#xA;&#xA;            Text {&#xA;                anchors.centerIn: parent&#xA;                text: index&#xA;                font.pixelSize: 30&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;链表分段（Lists with Sections）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;有时，链表的数据需要划分段。例如使用首字母来划分联系人，或者音乐。使用链表视图可以把平面列表按类别划分。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    为了使用分段，section.property与section.criteria必须安装。&#xA;    section.property定义了哪些属性用于内容的划分。&#xA;    在这里，最重要的是知道每一段由哪些连续的元素构成，否则相同的属性名可能出现在几个不同的地方。&#xA;*/&#xA;&#xA;/*&#xA;    section.criteria能够被设置为ViewSection.FullString或者ViewSection.FirstCharacter。&#xA;    默认下使用第一个值，能够被用于模型中有清晰的分段，例如音乐专辑。&#xA;    第二个是使用一个属性的首字母来分段，这说明任何属性都可以被使用。&#xA;    通常的例子是用于联系人名单的姓。&#xA;  */&#xA;/*&#xA;    当段被定义好后，每个子项能够使用绑定属性&#xA;    ListView.section，ListView.previousSection与ListView.nextSection来访问。&#xA;    使用这些属性，可以检测段的第一个与最后一个子项。&#xA;  */&#xA;Rectangle {&#xA;    width: 300&#xA;    height: 290&#xA;&#xA;    color: &amp;quot;white&amp;quot;&#xA;&#xA;    ListModel {&#xA;        id: spaceMen&#xA;&#xA;        ListElement { name: &amp;quot;Abdul Ahad Mohmand&amp;quot;; nation: &amp;quot;Afganistan&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Marcos Pontes&amp;quot;; nation: &amp;quot;Brazil&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Alexandar Panayotov Alexandrov&amp;quot;; nation: &amp;quot;Bulgaria&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Georgi Ivanov&amp;quot;; nation: &amp;quot;Bulgaria&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Roberta Bondar&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Marc Garneau&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Chris Hadfield&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Guy Laliberte&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Steven MacLean&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Julie Payette&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Robert Thirsk&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Bjarni Tryggvason&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;        ListElement { name: &amp;quot;Dafydd Williams&amp;quot;; nation: &amp;quot;Canada&amp;quot;; }&#xA;    }&#xA;&#xA;    ListView {&#xA;        anchors.fill: parent&#xA;        anchors.margins: 20&#xA;&#xA;        // 切割&#xA;        clip: true&#xA;&#xA;        // 数据&#xA;        model: spaceMen&#xA;&#xA;        // 代理&#xA;        delegate: spaceManDelegate&#xA;&#xA;        // 按那个属性进行分组(指定ListModel数据中属性)&#xA;        section.property: &amp;quot;nation&amp;quot;&#xA;        // 指定分组代理&#xA;        section.delegate: sectionDelegate&#xA;    }&#xA;&#xA;    // 代理&#xA;    Component {&#xA;        id: spaceManDelegate&#xA;&#xA;        Item {&#xA;            width: 260&#xA;            height: 20&#xA;&#xA;            Text {&#xA;                anchors.left: parent.left&#xA;                anchors.verticalCenter: parent.verticalCenter&#xA;                anchors.leftMargin: 10&#xA;&#xA;                font.pixelSize: 12&#xA;&#xA;                text: name&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    // 分组代理&#xA;    Component {&#xA;        id: sectionDelegate&#xA;&#xA;        Rectangle {&#xA;            width: 260&#xA;            height: 20&#xA;&#xA;            color: &amp;quot;lightGray&amp;quot;&#xA;&#xA;            Text {&#xA;                anchors.left: parent.left&#xA;                anchors.verticalCenter: parent.verticalCenter&#xA;                anchors.leftMargin: 10&#xA;&#xA;                font.pixelSize: 12&#xA;                font.bold: true&#xA;&#xA;                text: section&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;XML模型（A Model from XML）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;由于XML是一种常见的数据格式，QML提供了XmlListModel元素来包装XML数据。这个元素能够获取本地或者网络上的XML数据，然后通过XPath解析这些数据。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Item {&#xA;    width: 300&#xA;    height: 480&#xA;&#xA;    Component {&#xA;        id: imageDelegate&#xA;&#xA;        Item {&#xA;            width: listView.width&#xA;            height: 400&#xA;&#xA;        Column {&#xA;                Text {&#xA;                    text: title&#xA;                }&#xA;&#xA;                Image {&#xA;                    source: imageSource&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    XmlListModel {&#xA;        id: imageModel&#xA;&#xA;        source: &amp;quot;http://feeds.nationalgeographic.com/ng/photography/photo-of-the-day/&amp;quot;&#xA;        query: &amp;quot;/rss/channel/item&amp;quot;&#xA;&#xA;        XmlRole { name: &amp;quot;title&amp;quot;; query: &amp;quot;title/string()&amp;quot; }&#xA;        XmlRole { name: &amp;quot;imageSource&amp;quot;; query: &amp;quot;substring-before(substring-after(description/string(), &#39;img src=\&amp;quot;&#39;), &#39;\&amp;quot;&#39;)&amp;quot; }&#xA;    }&#xA;&#xA;    ListView {&#xA;        id: listView&#xA;&#xA;        anchors.fill: parent&#xA;&#xA;        model: imageModel&#xA;        delegate: imageDelegate&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;性能协调（Tunning Performance）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一个模型视图的性能很大程度上依赖于代理的创建。&#xA;例如滚动下拉一个链表视图时，代理从外部加入到视图底部，并且从视图顶部移出。&#xA;如果设置剪裁（clip）属性为false，并且代理项花了很多时间来初始化，用户会感觉到视图滚动体验很差。&#xA;&#xA;为了优化这个问题，你可以在滚动时使用像素来调整。&#xA;使用cacheBuffer属性，在上诉情况下的垂直滚动&#xA;它将会调整在链表视图的上下需要预先准备好多少像素的代理项&#xA;结合异步加载图像元素（Image），例如在它们进入视图之前加载。&#xA;&#xA;创建更多的代理项将会牺牲一些流畅的体验，并且花更多的时间来初始化每个代理。&#xA;这并不代表可以解决一些更加复杂的代理项的问题。在每次实例化代理时，它的内容都会被评估和编辑。&#xA;这需要花费时间，如果它花费了太多的时间，它将会导致一个很差的滚动体验。&#xA;在一个代理中包含太多的元素也会降低滚动的性能。&#xA;&#xA;为了补救这个问题，我们推荐使用动态加载元素。当它们需要时，可以初始化这些附加的元素。&#xA;例如，一个展开代理可能推迟它的详细内容的实例化，直到需要使用它时。每个代理中最好减少JavaScript的数量。&#xA;将每个代理中复杂的JavaScript调用放在外面来实现。&#xA;这将会减少每个代理在创建时编译JavaScript。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;网络（Networking）&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;通过HTTP服务UI（Serving UI via HTTP）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;通过HTTP加载一个简单的用户界面，我们需要一个web服务器，它为UI文件服务。&#xA;但是首先我们需要有用户界面，我们在项目里创建一个创建了红色矩形框的main.qml。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// http://localhost:8000/main.qml&#xA;import QtQuick 2.0&#xA;&#xA;Rectangle {&#xA;    width: 320&#xA;    height: 320&#xA;    color: &#39;#ff0000&#39;&#xA;}&#xA;&#xA;// 动态加载&#xA;Loader {&#xA;    id: root&#xA;    source: &#39;http://localhost:8080/main2.qml&#39;&#xA;    onLoaded: {&#xA;        root.width = item.width&#xA;        root.height = item.height&#xA;    }&#xA;}&#xA;&#xA;// 也可以使用 $ qmlscene --resize-to-root remote.qml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;网络组件（Networked Components）&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 我们在远程端添加一个按钮作为可以复用的组件。&#xA;- src/main.qml&#xA;- src/Button.qml&#xA;Rectangle {&#xA;    width: 320&#xA;    height: 320&#xA;    color: &#39;#ff0000&#39;&#xA;&#xA;    Button {&#xA;        anchors.centerIn: parent&#xA;        text: &#39;Click Me&#39;&#xA;        onClicked: Qt.quit()&#xA;    }&#xA;}&#xA;&#xA;// 我们看到一个错误：&#xA;http://localhost:8080/main2.qml:11:5: Button is not a type&#xA;&#xA;// 我们可以在main.qml中使用import声明来强制QML加载元素：&#xA;import &amp;quot;http://localhost:8080&amp;quot; as Remote&#xA;Remote.Button { ... }&#xA;&#xA;// 一个更好的选择是在服务器端使用qmldir文件来控制输出：&#xA;// qmldir&#xA;Button 1.0 Button.qml&#xA;import &amp;quot;http://localhost:8080&amp;quot; 1.0 as Remote&#xA;Remote.Button { ... }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;模板（Templating）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;总之，模板可以实现，但是不推荐，无法完整发挥QML的长处。一个更好的方法是使用web服务提供JSON或者XML数据服务。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    当QML访问一个组件时，缓冲渲染树（render-tree），并且只加载缓冲版本来渲染。&#xA;    磁盘上的修改版本或者远程的修改在没有重新启动客户端时不会被检测到。&#xA;    为了克服这个问题，我们需要跟踪。我们使用URL后缀来加载链接（例如http://localhost:8080/main.qml#1234），“#1234”就是后缀标识。&#xA;    HTTP服务器总是为相同的文档服务，但是QML将使用完整的链接来保存这个文档，包括链接标识。&#xA;    每次我们访问的这个链接的标识获得改变，QML缓冲无法获得这个信息。这个后缀标识可以是当前时间的毫秒或者一个随机数。&#xA;*/&#xA;Loader {&#xA;    source: &#39;http://localhost:8080/main.qml#&#39; + new Date().getTime()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;HTTP请求（HTTP Requests）&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;XMLHttpRequest对象允许用户注册一个响应操作函数和一个链接。&#xA;一个请求能够使用http动作来发送（如get，post，put，delete，等等）&#xA;当响应到达时，会调用注册的操作函数。操作函数会被调用多次&#xA;每次调用请求的状态都已经改变（例如信息头部已接收，或者响应完成）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在响应操作中，我们访问原始响应文本并且将它转换为一个javascript对象。&#xA;// JSON对象是一个可以使用的JS对象（在javascript中，一个对象可以是对象或者一个数组）。&#xA;// toString()转换似乎让代码更加稳定。在不使用显式的转换下我有几次都解析错误。&#xA;function request() {&#xA;    var xhr = new XMLHttpRequest();&#xA;    xhr.onreadystatechange = function() {&#xA;        if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {&#xA;            print(&#39;HEADERS_RECEIVED&#39;);&#xA;        } else if(xhr.readyState === XMLHttpRequest.DONE) {&#xA;            var object = JSON.parse(xhr.responseText.toString());&#xA;            print(JSON.stringify(object, null, 2));&#xA;        }&#xA;    }&#xA;    xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://118.144.129.194:9992/vlc/face/status&amp;quot;);&#xA;    xhr.send();&#xA;}&#xA;&#xA;Rectangle {&#xA;    anchors.fill: parent&#xA;    color: &amp;quot;red&amp;quot;&#xA;    MouseArea {&#xA;        anchors.fill: parent&#xA;        onClicked: {&#xA;            request()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 示例&#xA;Rectangle {&#xA;    width: 320&#xA;    height: 480&#xA;    ListView {&#xA;        id: view&#xA;        anchors.fill: parent&#xA;        delegate: Thumbnail {&#xA;            width: view.width&#xA;            text: modelData.title&#xA;            iconSource: modelData.media.m&#xA;        }&#xA;    }&#xA;&#xA;    function request() {&#xA;        var xhr = new XMLHttpRequest();&#xA;        xhr.onreadystatechange = function() {&#xA;            if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {&#xA;                print(&#39;HEADERS_RECEIVED&#39;)&#xA;            } else if(xhr.readyState === XMLHttpRequest.DONE) {&#xA;                print(&#39;DONE&#39;)&#xA;                var json = JSON.parse(xhr.responseText.toString())&#xA;                view.model = json.items&#xA;            }&#xA;        }&#xA;        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://api.flickr.com/services/feeds/photos_public.gne?format=json&amp;amp;nojsoncallback=1&amp;amp;tags=munich&amp;quot;);&#xA;        xhr.send();&#xA;    }&#xA;&#xA;    Component.onCompleted: {&#xA;        request()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;本地文件（Local files）&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用XMLHttpRequest也可以加载本地文件（XML/JSON）&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 例如加载一个本地名为“colors.json”的文件可以这样使用：&#xA;Rectangle {&#xA;    width: 360&#xA;    height: 360&#xA;    color: &#39;#000&#39;&#xA;&#xA;    GridView {&#xA;        id: view&#xA;        anchors.fill: parent&#xA;        cellWidth: width/4&#xA;        cellHeight: cellWidth&#xA;        delegate: Rectangle {&#xA;            width: view.cellWidth&#xA;            height: view.cellHeight&#xA;            color: modelData.value&#xA;        }&#xA;    }&#xA;&#xA;    function request() {&#xA;        var xhr = new XMLHttpRequest();&#xA;        xhr.onreadystatechange = function() {&#xA;            if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {&#xA;                print(&#39;HEADERS_RECEIVED&#39;)&#xA;            } else if(xhr.readyState === XMLHttpRequest.DONE) {&#xA;                print(&#39;DONE&#39;);&#xA;                var obj = JSON.parse(xhr.responseText.toString());&#xA;                view.model = obj.colors&#xA;            }&#xA;        }&#xA;        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;colors.json&amp;quot;);&#xA;        xhr.send();&#xA;    }&#xA;&#xA;    Component.onCompleted: {&#xA;        request()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 也可以使用XmlListModel来替代XMLHttpRequest访问本地文件。&#xA;// XmlListModel只能用来读取XML文件，不能读取JSON文件。&#xA;import QtQuick.XmlListModel 2.0&#xA;&#xA;XmlListModel {&#xA;    source: &amp;quot;http://localhost:8080/colors.xml&amp;quot;&#xA;    query: &amp;quot;/colors&amp;quot;&#xA;    XmlRole { name: &#39;color&#39;; query: &#39;name/string()&#39; }&#xA;    XmlRole { name: &#39;value&#39;; query: &#39;value/string()&#39; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;存储（Storage）&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;配置（Settings）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Qt自身就提供了基于系统方式的应用程序配置（又名选项，偏好）C++类 QSettings。&#xA;它使用基于当前操作系统的方式存储配置。此外，它支持通用的INI文件格式用来操作跨平台的配置文件。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 每次配置的改变都会被保存&#xA;Rectangle {&#xA;    id: root&#xA;    width: 320; height: 240&#xA;    color: &#39;#000000&#39;&#xA;    Settings {&#xA;        id: settings&#xA;        property alias color: root.color&#xA;    }&#xA;    MousArea {&#xA;        anchors.fill: parent&#xA;        onClicked: root.color = Qt.hsla(Math.random(), 0.5, 0.5, 1.0);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 需要保存时才会被保存&#xA;Rectangle {&#xA;    id: root&#xA;    color: settings.color&#xA;    Settings {&#xA;        id: settings&#xA;        property color color: &#39;#000000&#39;&#xA;    }&#xA;    function storeSettings() { // executed maybe on destruction&#xA;        settings.color = root.color&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以使用category属性存储不同种类的配置。&#xA;Settings {&#xA;    category: &#39;window&#39;&#xA;    property alias x: window.x&#xA;    property alias y: window.x&#xA;    property alias width: window.width&#xA;    property alias height: window.height&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 配置同城根据你的应用程序名称，组织和域存储。&#xA;// 这些信息通常在你的C++ main函数中设置。&#xA;int main(int argc, char** argv) {&#xA;    ...&#xA;    QCoreApplication::setApplicationName(&amp;quot;Awesome Application&amp;quot;);&#xA;    QCoreApplication::setOrganizationName(&amp;quot;Awesome Company&amp;quot;);&#xA;    QCoreApplication::setOrganizationDomain(&amp;quot;org.awesome&amp;quot;);&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;本地存储 - SQL（Local Storage - SQL）&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Qt Quick支持一个与浏览器由区别的本地存储编程接口&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;需要使用&amp;rdquo;import QtQuick.LocalStorage 2.0&amp;rdquo;语句来导入后才能使用这个编程接口&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通常使用基于给定的数据库名称和版本号使用系统特定位置的唯一文件ID号来存储数据到一个SQLITE数据库中。&#xA;// 无法列出或者删除已有的数据库。你可以使用QQmlEngine::offlineStoragePate()来寻找本地存储。&#xA;&#xA;// 使用这个编程接口你首选需要创建一个数据库对象，然后在这个数据库上创建数据库事务。&#xA;// 每个事务可以包含一个或多个SQL查询。当一个SQL查询在事务中失败后，事务会回滚。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import QtQuick 2.2&#xA;import QtQuick.LocalStorage 2.0&#xA;&#xA;Item {&#xA;    Component.onCompleted: {&#xA;        var db = LocalStorage.openDatabaseSync(&amp;quot;MyExample&amp;quot;, &amp;quot;1.0&amp;quot;, &amp;quot;Example database&amp;quot;, 10000);&#xA;        db.transaction( function(tx) {&#xA;            var result = tx.executeSql(&#39;select * from notes&#39;);&#xA;            for(var i = 0; i &amp;lt; result.rows.length; i++) {&#xA;                    print(result.rows[i].text);&#xA;                }&#xA;            }&#xA;        });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Qt 发布了 Qt Quick 的一个全新模块：Qt Quick Controls 这个模块提供了大量类似 Qt Widgets 模块那样可重用的组件&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Bash小数比较</title>
      <link>http://www.nljb.net/default/Bash%E5%B0%8F%E6%95%B0%E6%AF%94%E8%BE%83/</link>
      <pubDate>2017-06-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Bash里本身不支持小数的比较，它只支持整数或者是字符串比较。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;echo &amp;quot;input f1&amp;quot;  &#xA;read f1  &#xA;echo &amp;quot;input f2&amp;quot;  &#xA;read f2  &#xA;&#xA;state=`echo &amp;quot;$f1&amp;lt;$f2&amp;quot;|bc`  &#xA;if [ $state -eq 1 ];then  &#xA;    echo &amp;quot;f1($f1)&amp;lt;f2($f2) is true&amp;quot;  &#xA;else  &#xA;    echo &amp;quot;f1($f1)&amp;lt;f2($f2) is false&amp;quot;  &#xA;fi  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>在Ubuntu中Build人脸识别引擎SeetaFace</title>
      <link>http://www.nljb.net/default/%E5%9C%A8Ubuntu%E4%B8%ADBuild%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BC%95%E6%93%8ESeetaFace/</link>
      <pubDate>2017-05-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;在Ubuntu中Build人脸识别引擎SeetaFace&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;SeetaFace是中科院计算机所山世光老师所带领的团队开发出来的人脸识别库，开源免费可用，据说识别率可达97.1%，实测下来识别率确实是很高&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;FaceDetection&#xA;    人脸识别模块，用于识别出照片中的人脸，染回每个人脸的坐标和人脸总数&#xA;FaceAlignment&#xA;    特征点识别模块，主要识别两个嘴角、鼻子、两个眼睛五个点的坐标&#xA;FaceIdentification&#xA;    人脸比较模块，根据官方的说法，先提取特征值，然后比较。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载&#xA;// 解压获得 SeetaFaceEngine-master/FaceDetection&#xA;// 解压获得 SeetaFaceEngine-master/FaceAlignment&#xA;// 解压获得 SeetaFaceEngine-master/FaceIdentification&#xA;https://github.com/nulijiabei/SeetaFaceEngine（Download SeetaFace）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;编译顺序：FaceDetection、FaceAlignment、FaceIdentification&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;说明：只要编译成功，运行时出现段错误等 ... 都是相关文件路径配置错误&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential&#xA;sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev&#xA;sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载 OpenCV 不要使用 v3.x(测试失败) 使用 2.4.13.2(经过测试) ...&#xA;http://opencv.org/releases.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译 OpenCV&#xA;cd ~/opencv&#xA;mkdir release&#xA;cd release&#xA;cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译 FaceDetection&#xA;cd SeetaFaceEngine-master/FaceDetection&#xA;mkdir build&#xA;cd build  &#xA;cmake ..  &#xA;make -j${npoc}&#xA;&#xA;// 使用 FaceDetection&#xA;./build/facedet_test imagefilePath ./model/seeta_fd_frontal_V1.0.bin&#xA;&#xA;// 注意&#xA;error: ‘isnan’ was not declared in this scope &#xA;解决方法，修改文件中的isnan为“std::isnan”&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译 FaceAlignment&#xA;cd SeetaFaceEngine-master/FaceAlignment&#xA;mkdir build&#xA;cd build  &#xA;cmake .. &#xA;make&#xA;&#xA;// 准备工作&#xA;拷贝FaceDetection中的/include/face_detection.h到FaceAlignment的include&#xA;拷贝FaceDetection中的/build/libseeta_facedet_lib.so文件到FaceAlignment/build&#xA;拷贝FaceDetection/model文件夹下的seeta_fd_frontal_v1.0.bin文件到FaceAlignment的build&#xA;拷贝FaceAlignment中的model文件夹和data文件夹到FaceAlignment/build&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译 FaceIdentification&#xA;cd SeetaFaceEngine-master/FaceIdentification&#xA;mkdir build&#xA;cd build&#xA;cmake .. &amp;amp;&amp;amp; make&#xA;&#xA;// 准备工作&#xA;拷贝FaceDetection中的/include/face_detection.h到FaceIdentification的include&#xA;拷贝FaceDetection中的/build/libseeta_facedet_lib.so文件到FaceIdentification/build&#xA;拷贝FaceAlignment中的/include/face_alignment.h到FaceIdentification的include&#xA;拷贝FaceAlignment中的/build/libseeta_fa_lib.so文件到FaceIdentification/build&#xA;&#xA;// 准备工作 +&#xA;修改FaceIdentification下src/test/CMakeLists.txt&#xA;......&#xA;add_executable(${BIN} ${f}) // 原有参照&#xA;target_link_libraries(${BIN} viplnet ${OpenCV_LIBS}) // 原有参照&#xA;target_link_libraries(${BIN} viplnet ${OpenCV_LIBS} /实际路径/SeetaFaceEngine-master/FaceIdentification/linux/libseeta_facedet_lib.so)&#xA;target_link_libraries(${BIN} viplnet ${OpenCV_LIBS} /实际路径/SeetaFaceEngine-master/FaceIdentification/linux/libseeta_fa_lib.so)&#xA;......&#xA;&#xA;// 准备工作 +&#xA;拷贝FaceDetection/model文件夹下的seeta_fd_frontal_v1.0.bin文件到FaceIdentification的build&#xA;拷贝FaceAlignment/model文件夹下的seeta_fa_v1.1.bin文件到文件到FaceIdentification的build/model&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 项目中Linux系统路径配置都是./而不是../所以最好将./data/和./model拷贝到build目录中&#xA;// 当然你也可以修改这里的配置 ...&#xA;#ifdef _WIN32&#xA;std::string DATA_DIR = &amp;quot;../../data/&amp;quot;;&#xA;std::string MODEL_DIR = &amp;quot;../../model/&amp;quot;;&#xA;#else&#xA;std::string DATA_DIR = &amp;quot;./data/&amp;quot;;&#xA;std::string MODEL_DIR = &amp;quot;./model/&amp;quot;;&#xA;#endif&#xA;&#xA;// FaceIdentification 中 model/seeta_fr_v1.0.bin 是需要解压缩的哦&#xA;apt-get install rar // 然后解压 .. 到当前目录&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 最后重申：只要编译过了 ... 运行段错误，一定是.bin文件路径配置错误造成的 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OpenCV 默认只支持 avi 格式视频读取 ... 如果需要兼容 mp4、mov、等格式 ... 需要 ffmepg&#xA;&#xA;sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next &#xA;sudo apt-get update &#xA;sudo apt-get install ffmpeg&#xA;&#xA;cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_TIFF=ON -D CMAKE_CXX_FLAGS=-D__STDC_CONSTANT_MACROS ..&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install zlib1g-dev&#xA;apt-get install libjpeg8-dev&#xA;apt-get install libpng12-dev&#xA;apt-get install libx264-dev&#xA;apt-get install libxvidcore-dev&#xA;apt-get install libtiff-dev&#xA;apt-get install ffmpeg&#xA;apt-get install libv4l-dev&#xA;apt-get install libgtk2.0-dev&#xA;apt-get install build-essential libavcodec-dev libavformat-dev libswscale-dev libjasper-dev cmake  cmake-curses-gui cmake-qt-gui&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux Integration Services</title>
      <link>http://www.nljb.net/default/Linux-Integration-Services/</link>
      <pubDate>2017-05-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Linux Integration Services&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ubuntu Integration Services for Hyper-V&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过管理员的方式打开&#xA;sudo vi /etc/initramfs-tools/modules&#xA;&#xA;// 并在文件末尾添加如下指令：&#xA;hv_vmbus&#xA;hv_storvsc&#xA;hv_blkvsc&#xA;hv_netvsc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 更新：&#xA;sudo update-initramfs –u&#xA;&#xA;// 关机：&#xA;sudo shutdown -r now&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 重新启动后输入：&#xA;lsmod，就可以看到 hyper-v 被支持了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>在Ubuntu中使用Overlayroot来只读根文件系统</title>
      <link>http://www.nljb.net/default/%E5%9C%A8Ubuntu%E4%B8%AD%E4%BD%BF%E7%94%A8Overlayroot%E6%9D%A5%E5%8F%AA%E8%AF%BB%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>2017-05-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;了解一下 overlayroot 和 overlayfs &amp;hellip; 后续有时间深入研究一下 &amp;hellip; 转发了往上找到的一篇文章&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&#34;http://www.tuicool.com/articles/NNJbq2V&#34;&gt;http://www.tuicool.com/articles/NNJbq2V&lt;/a&gt; (原文更加清晰明了)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;In certain situations, it is desirable to have a read-only root filesystem . This prevents any changes from occurring on the root filesystem that may alter system behavior, and it allows a simple reboot to restore a system to its pristine state. Examples of such applications include kiosks and embedded devices. Using overlayroot on Ubuntu makes creating a read-only root filesystem quick and easy.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Motivation&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Let us imagine that we have an embedded Linux device that needs to run a particular program. The program does not need to store any data (except perhaps some logs), and we want to protect the system against any changes. If the program or any system processes make filesystem modifications, we want to toss them out and return to the original state. We want a robust system that will run our program, but be restored to it’s ‘factory’ state with a power-cycle.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Background&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Overlayroot is a package for Ubuntu which utilizes OverlayFS , a union filesystem implementation. OverlayFS presents a unified view of two different filesystems; the presented filesystem is the result of overlaying one filesystem over another.&#xA;&#xA;In OverlayFS, there is an ‘upper’ filesystem and a ‘lower’ filesystem . If a particular object exists in both the upper filesystem and the lower filesystem, the object from the upper filesystem is presented, and the object from the lower filesystem is hidden. If the object is a directory, the contents of the directory on the upper and lower filesystems are merged and presented.&#xA;&#xA;With overlayroot, the lower filesystem is a read-only mount of the root filesystem, and the upper filesystem is a read-write mount of another block device. That block device can be tmpfs , a standard block device, or an encrypted block device (à la dmcrypt ).&#xA;&#xA;All changes made on top of the root filesystem are stored elsewhere and do not affect the root filesystem. Depending on the block device chosen, those changes can persist across reboots. While the root filesystem will not be affected, the view presented by OverlayFS will include any changes stored in the upper filesystem.&#xA;&#xA;https://en.wikipedia.org/wiki/OverlayFS&#xA;https://en.wikipedia.org/wiki/UnionFS&#xA;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/filesystems/overlayfs.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Situation&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;For our embedded Linux device, we are not interested in preserving any changes to the root filesystem. Any data that we want to preserve will be stored on a separate filesystem dedicated to data storage.&#xA;&#xA;Here is our filesystem structure:&#xA;&#xA;/dev/sda1 on /&#xA;/dev/sda2 on /data&#xA;&#xA;We want to mount / using overlayroot so that we have a read-write filesystem available but not persist any changes to / , and we want to mount /data normally so that our program can write out and persist log files.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Solution&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Overlayroot has been available since Ubuntu 12.10, and has been back-ported to 12.04 LTS. It is quick to install:&#xA;&#xA;apt-get install overlayroot&#xA;&#xA;The configuration file is stored at /etc/overlayroot.conf , and contains a wealth of in-line documention.&#xA;&#xA;The only item to change is the overlayroot variable. By default, it is blank:&#xA;&#xA;overlayroot=;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Start Simple&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Since we want to use tmpfs mode for overlayroot, we set the variable accordingly.&#xA;&#xA;overlayroot=tmpfs&#xA;&#xA;The other modes (specifying a device, or crypt ) are documented in overlayroot.conf , with some nice diagrams on the post introducing overlayroot .&#xA;&#xA;http://blog.dustinkirkland.com/2012/08/introducing-overlayroot-overlayfs.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Add Swap&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;By default, overlayroot disables swap. This can be re-enabled by providing another option to the configuration:&#xA;&#xA;overlayroot=tmpfs:swap=1&#xA;&#xA;(The default value for swap is).&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Don’t Recurse&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;By default, overlayroot will mount all filesystems under / in the specified mode. This can be prevented by adding another option to the configuration:&#xA;&#xA;overlayroot=tmpfs:swap=1,recurse=0&#xA;&#xA;Note that swap=1 and recurse=0 are separated by a comma, not a colon.&#xA;&#xA;(The default value for recurse is 1).&#xA;&#xA;This will prevent overlayroot from overlaying a read-write tmpfs on top of a read-only /data filesystem. All of / will be protected from any modifications, except /data , which is what we want.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;The Result&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;After making changes to overlayroot.conf and rebooting, the root filesystem should now be mounted as a read-write tmpfs overlaying the read-only / filesystem.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Running mount , we should see something like:&#xA;&#xA;overlayroot on / type overlayfs (rw,lowerdir=/media/root-ro/,upperdir=/media/root-rw)&#xA;proc on /proc type proc (rw)&#xA;none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,noexec,nosuid,nodev)&#xA;none on /sys type sysfs (rw,noexec,nosuid,nodev)&#xA;none on /sys/fs/fuse/connections type fusectl (rw)&#xA;devtmpfs on /dev type devtmpfs (rw,mode=0755)&#xA;none on /dev/pts type devpts (rw,noexec,nosuid,gid=5,mode=0620)&#xA;none on /run type tmpfs (rw,noexec,nosuid,size=10%,mode=0755)&#xA;none on /run/lock type tmpfs (rw,noexec,nosuid,nodev,size=5242880)&#xA;none on /run/shm type tmpfs (rw,nosuid,nodev)&#xA;/dev/sda1 on /media/root-ro type ext4 (ro)&#xA;tmpfs-root on /media/root-rw type tmpfs (rw,relatime)&#xA;/dev/sda2 on /data type ext4 (rw)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Note how the root filesystem is of type overlayfs with specified upper and lower filesystems that correspond to the read-write tmpfs and read-only mounts listed.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Disabling Overlayroot&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Once overlayroot is enabled, it is no longer possible to make changes to the root filesystem. This introduces problems if we legitimately need to make changes (such as for updates, tweaks, etc.). Fortunately, we can override any overlayroot configuration by passing overlayroot=disabled to the kernel at boot. This can be done as a one-off operation as needed, or can be set up as an alternate boot configuration in a boot loader such as GRUB.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;For example, with GRUB2, something like the following could be used:&#xA;&#xA;menuentry &#39;Ubuntu, with Linux 3.5.0-54-generic (Writable)&#39; --class ubuntu --class gnu-linux --class gnu --class os {&#xA;    recordfail&#xA;    gfxmode $linux_gfx_mode&#xA;    insmod gzio&#xA;    insmod part_msdos&#xA;    insmod ext2&#xA;    set root=&#39;(hd0,msdos1)&#39;&#xA;    search --no-floppy --fs-uuid --set=root 28adfe9d-c122-479a-ab81-de57d16516dc&#xA;    linux   /vmlinuz-3.5.0-54-generic root=/dev/mapper/faramir-root ro overlayroot=disabled&#xA;    initrd  /initrd.img-3.5.0-54-generic&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Conclusion&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Overlayroot makes the process of mounting the root filesystem as read-only on Ubuntu very easy. Prior to the availability of overlayroot packages, custom scripts were added to the initramfs configuration . These scripts were often fragile, and not always compatible across versions of Ubuntu. With the availability of OverlayFS and overlayroot, creating robust kiosks and embedded Linux devices with rollback capabilities is now extremely easy.&#xA;&#xA;https://help.ubuntu.com/community/aufsRootFileSystemOnUsbFlash&#xA;https://help.ubuntu.com/community/aufsRootFileSystemOnUsbFlash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之容器遍历使用教程</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8B%E5%AE%B9%E5%99%A8%E9%81%8D%E5%8E%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>2017-05-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qt之容器遍历使用教程&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Qt 的容器类提供了两种风格的遍历器：Java 风格和 STL 风格。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Java 风格的遍历器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Java 风格的遍历器是在 Qt4 首先引入的，是 Qt 应用程序首先推荐使用的形式。这种风格比起 STL 风格的遍历器更方便。方便的代价就是不如后者高效。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;| 容器           | 只读遍历器          | 读写遍历器                 |&#xA;| QList,QQueue     | QListIterator       | QMutableListIterator       |&#xA;| QLinkedList      | QLinkedListIterator | QMutableLinkedListIterator |&#xA;| QVector,QStack   | QVectorIterator     | QMutableVectorIterator     |&#xA;| QSet             | QSetIterator        | QMutableSetIterator        |&#xA;| QMap,QMultiMap   | QMapIterator        | QMutableMapIterator        |&#xA;| QHash,QMultiHash | QHashIterator       | QMutableHashIterator       |&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QList&amp;lt;QString&amp;gt; list;&#xA;list &amp;lt;&amp;lt; &amp;quot;A&amp;quot; &amp;lt;&amp;lt; &amp;quot;B&amp;quot; &amp;lt;&amp;lt; &amp;quot;C&amp;quot; &amp;lt;&amp;lt; &amp;quot;D&amp;quot;;&#xA;&#xA;QListIterator&amp;lt;QString&amp;gt; i(list);&#xA;while (i.hasNext()) {&#xA;    qDebug() &amp;lt;&amp;lt; i.next(); &#xA;}&#xA;&#xA;QMutableListIterator&amp;lt;int&amp;gt; i(list);&#xA;while (i.hasNext()) {&#xA;    if (i.next() == “B”) {&#xA;    i.setValue(“b”);     //i.next()=&amp;quot;b&amp;quot;;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QMap&amp;lt;int, QString&amp;gt; map;&#xA;map.insert(1,&amp;quot;A&amp;quot;);&#xA;map.insert(2,&amp;quot;B&amp;quot;);&#xA;map.insert(3,&amp;quot;C&amp;quot;);&#xA;&#xA;QMapIterator&amp;lt;int, QString&amp;gt; i(map);&#xA;while (i.hasNext()) {&#xA;    if(i.next().key() == 2)&#xA;    qDebug() &amp;lt;&amp;lt; i.value();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;STL 风格的遍历器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;STL 风格的遍历器从 Qt 2.0 就开始提供。这种遍历器能够兼容 Qt 和 STL 的通用算法，并且为速度进行了优化。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;| 容器             | 只读遍历器                  | 读写遍历器            |&#xA;| QList,QQueue     | QList::const_iterator       | QList::iterator       |&#xA;| QLinkedList      | QLinkedList::const_iterator | QLinkedList::iterator |&#xA;| QVector,QStack   | QVector::const_iterator     | QVector::iterator     |&#xA;| QSet             | QSet::const_iterator        | QSet::iterator        |&#xA;| QMap,QMultiMap   | QMap::const_iterator        | QMap::iterator        |&#xA;| QHash,QMultiHash | QHash::const_iterator       | QHash::iter           |&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QList&amp;lt;QString&amp;gt; list;&#xA;list &amp;lt;&amp;lt; &amp;quot;A&amp;quot; &amp;lt;&amp;lt; &amp;quot;B&amp;quot; &amp;lt;&amp;lt; &amp;quot;C&amp;quot; &amp;lt;&amp;lt; &amp;quot;D&amp;quot;;&#xA;&#xA;QList&amp;lt;QString&amp;gt;::iterator i;&#xA;for (i = list.begin(); i != list.end(); ++i) {&#xA;　　*i = (*i).toLower(); // 使用 * 运算符获取遍历器所指的元素&#xA;　　 qDebug()&amp;lt;&amp;lt;*i;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QMap&amp;lt;int, int&amp;gt; map;&#xA;&#xA;QMap&amp;lt;int, int&amp;gt;::const_iterator i;&#xA;for (i = map.constBegin(); i != map.constEnd(); ++i) {&#xA;    qDebug() &amp;lt;&amp;lt; i.key() &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; i.value();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;foreach(关键字)&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;如果我们仅仅想要遍历集合所有元素，我们可以使用 Qt 的foreach关键字。这个关键字是 Qt 特有的&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QLinkedList&amp;lt;QString&amp;gt; list;&#xA;...&#xA;QString str;&#xA;foreach (str, list) {&#xA;    qDebug() &amp;lt;&amp;lt; str;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之HMAC的SHA1加密</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BHMAC%E7%9A%84SHA1%E5%8A%A0%E5%AF%86/</link>
      <pubDate>2017-04-27 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Golang之HMAC的SHA1加密&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）&#xA;HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出&#xA;// 也就是说HMAC通过将哈希算法(SHA1, MD5)与密钥进行计算生成摘要...可解密...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 PHP 中是 hash_hmac(&#39;sha1&#39;,$string,$key);&#xA;&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;crypto/hmac&amp;quot;&#xA;    &amp;quot;crypto/sha1&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    //sha1&#xA;    h := sha1.New()&#xA;    io.WriteString(h, &amp;quot;aaaaaa&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%x\n&amp;quot;, h.Sum(nil))&#xA;&#xA;    //hmac ,use sha1&#xA;    key := []byte(&amp;quot;123456&amp;quot;)&#xA;    mac := hmac.New(sha1.New, key)&#xA;    // mac := hmac.New(md5.New, key)&#xA;    mac.Write([]byte(&amp;quot;aaaaaa&amp;quot;))&#xA;    fmt.Printf(&amp;quot;%x\n&amp;quot;, mac.Sum(nil))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;安全哈希算法（Secure Hash Algorithm）&#xA;主要适用于数字签名标准 （Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。&#xA;对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。&#xA;当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。&#xA;在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。&#xA;SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之在窗口对象Close时自动释放内存</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8B%E5%9C%A8%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1Close%E6%97%B6%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/</link>
      <pubDate>2017-03-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qt之在窗口对象Close时自动释放内存&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QT中调用窗口对象close时，默认情况下是不会释放new的内存的&#xA;&#xA;只是干掉了界面，但内存中还有，这个时候有点类似hide函数的功能。&#xA;&#xA;&#xA;virtual void setVisible(bool visible);&#xA;inline void setHidden(bool hidden) { setVisible(!hidden); }&#xA;inline void show() { setVisible(true); }&#xA;inline void hide() { setVisible(false); }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 为窗口对象设置 Qt::WA_DeleteOnClose 属性&#xA;this-&amp;gt;setAttribute(Qt::WA_DeleteOnClose,true);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当设置 Qt::WA_DeleteOnClose 属性&#xA;// 在调用 Close 后，就不能再使用该指针&#xA;Confirm *c = new Confirm();&#xA;c-&amp;gt;setAttribute(Qt::WA_DeleteOnClose);&#xA;c-&amp;gt;show();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之QDialog与QWidget实现模态及非模态</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8BQDialog%E4%B8%8EQWidget%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%80%81%E5%8F%8A%E9%9D%9E%E6%A8%A1%E6%80%81/</link>
      <pubDate>2017-03-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Qt之QDialog与QWidget实现模态及非模态&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;模态与非模态&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;模态对话框工作状态：当它获得焦点时，将垄断用户的输入，在完成本对话框之前，用户无法对本程序的其他部分进行操作  &#xA;非模态对话框类似于WORD里的查找替换，就在应用程序打开非模态对话框的同时还可以切换到其他窗口进行操作&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;对于 QDialog 的模态及非模态是直接可以实现的&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 一，模态QDialog&#xA;QDialog dlg(this);&#xA;dlg.exec();&#xA;&#xA;// 二，模态QDialog&#xA;QDialog *pDlg=new QDialog(this);&#xA;pDlg-&amp;gt;setModal(true);&#xA;pDlg-&amp;gt;show();&#xA;&#xA;// 三，非模态QDialog&#xA;QDialog *pDlg=new QDialog(this);&#xA;pDlg-&amp;gt;show();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;QDialog实现模态非模态很简单，但是对于QWidget有点迷茫，QWidget中没有exec()，也没有setModal()方式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 那QWidget应该如何实现模态与非模态呢&#xA;setWindowModality()，此函数就是用来设置QWidget运行时的程序阻塞方式的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Qt::NonModal      不阻塞&lt;/li&gt;&#xA;&lt;li&gt;Qt::WindowModal   阻塞父窗口，所有祖先窗口及其子窗口&lt;/li&gt;&#xA;&lt;li&gt;Qt::ApplicationModal  阻塞整个应用程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;看来，setModal()也就是使用setWindowModality()设置Qt::ApplicationModal参数也实现的模态。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&amp;hellip;&amp;hellip;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之HTTP请求笔记</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82%E7%AC%94%E8%AE%B0/</link>
      <pubDate>2017-02-07 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;HTTP 请求笔记&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;bytes&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;    &amp;quot;mime/multipart&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;net/url&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;path/filepath&amp;quot;&#xA;)&#xA;&#xA;&#xA;// POST 带参数 + 带文件 ... 请求&#xA;func a1(u string, ff string, params map[string]string) ([]byte, error) {&#xA;    f, err := os.Open(ff)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    defer f.Close()&#xA;    body := new(bytes.Buffer)&#xA;    w := multipart.NewWriter(body)&#xA;    file, err := w.CreateFormFile(&amp;quot;File&amp;quot;, filepath.Base(ff))&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    _, err = io.Copy(file, f)&#xA;    content_type := w.FormDataContentType()&#xA;    for k, v := range params {&#xA;        w.WriteField(k, v)&#xA;    }&#xA;    err = w.Close()&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, u, body)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    req.Header.Set(&amp;quot;Content-Type&amp;quot;, content_type)&#xA;    resp, err := http.DefaultClient.Do(req)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    defer resp.Body.Close()&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return data, nil&#xA;}&#xA;&#xA;// GET 带参数请求 ...&#xA;func a(u string, params map[string]string) ([]byte, error) {&#xA;    p, _ := url.Parse(u)&#xA;    q := p.Query()&#xA;    for k, v := range params {&#xA;        q.Set(k, v)&#xA;    }&#xA;    p.RawQuery = q.Encode()&#xA;    resp, err := http.Get(p.String())&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    defer resp.Body.Close()&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return data, nil&#xA;}&#xA;&#xA;&#xA;// POST 带参数请求 ...&#xA;func a2(u string, params map[string]string) ([]byte, error) {&#xA;    values := make(url.Values)&#xA;    for k, v := range params {&#xA;        values.Add(k, v)&#xA;    }&#xA;    resp, err := http.PostForm(u, values)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    defer resp.Body.Close()&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return data, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>解决Win10由于INF文件失效导致安卓MTP驱动安装失败</title>
      <link>http://www.nljb.net/default/%E8%A7%A3%E5%86%B3Win10%E7%94%B1%E4%BA%8EINF%E6%96%87%E4%BB%B6%E5%A4%B1%E6%95%88%E5%AF%BC%E8%87%B4%E5%AE%89%E5%8D%93MTP%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>2016-12-08 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;解决Win10由于INF文件失效导致安卓MTP驱动安装失败&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;右键桌面“此电脑”—“属性”—左栏“设备管理器”—找到MTP设备中打着三角感叹号的设备—右键点击—选择”升级驱动“&#xA;&#xA;选择”手动选择驱动路径“—填”C:\Windows\WinSxS\”后确定—一路向下有任何提示警告无视之—最后驱动成功安装&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang新特性之动态插件包-plugin</title>
      <link>http://www.nljb.net/default/Golang%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%8A%A8%E6%80%81%E6%8F%92%E4%BB%B6%E5%8C%85-plugin/</link>
      <pubDate>2016-12-06 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Golang新特性之动态插件包 plugin&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;新增加的标准库 plugin 提供了初步的插件支持，它允许程序可以在运行的时候动态的加载插件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方介绍&#xA;https://beta.golang.org/pkg/plugin/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 将以下代码生成插件库 ...&#xA;go build -buildmode=plugin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;// // No C code needed.&#xA;import &amp;quot;C&amp;quot;&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;var V int&#xA;&#xA;func F() { fmt.Printf(&amp;quot;Hello, number %d\n&amp;quot;, V) }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过插件包使用插件库 ...&#xA;&#xA;p, err := plugin.Open(&amp;quot;plugin_name.so&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;v, err := p.Lookup(&amp;quot;V&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;f, err := p.Lookup(&amp;quot;F&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;*v.(*int) = 7&#xA;f.(func())() // prints &amp;quot;Hello, number 7&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;以上只是官方例, 由于1.8版本还处于测试阶段, 还不稳定, 待正式版发布后再进行详细测试&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之通过使用安全证书实现HTTPS访问服务</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0HTTPS%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>2016-12-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;通过使用安全证书实现HTTPS访问服务&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;获取证书流程：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注册阿里云 &lt;a href=&#34;https://www.aliyun.com/&#34;&gt;https://www.aliyun.com/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;在（管理控制台 - 安全云顿 - 证书服务）中购买证书&lt;/li&gt;&#xA;&lt;li&gt;注：阿里云提供免费的（免费型DV SSL）证书 &amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;在证书补全中添加域名（只支持一个域名），并等待审核&lt;/li&gt;&#xA;&lt;li&gt;审核通过后点击下载证书（下载证书 for Nginx）获取证书&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. 购买证书&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2016-12-02-Golang之通过使用安全证书实现HTTPS访问服务/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;2. 补全域名&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2016-12-02-Golang之通过使用安全证书实现HTTPS访问服务/3.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;3. 签发完毕&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2016-12-02-Golang之通过使用安全证书实现HTTPS访问服务/5.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;4. 下载证书&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2016-12-02-Golang之通过使用安全证书实现HTTPS访问服务/4.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;使用证书：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解压下载证书获取 $ID.key 和 $ID.pem 证书，将证书保存到自定义的项目目录中 &amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 配置证书&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;func helloHandler(w http.ResponseWriter, r *http.Request) {&#xA;    io.WriteString(w, &amp;quot;hello world!&amp;quot;)&#xA;}&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/hello&amp;quot;, helloHandler)&#xA;    err := http.ListenAndServeTLS(&amp;quot;:8080&amp;quot;, &amp;quot;213962744560812.pem&amp;quot;, &amp;quot;213962744560812.key&amp;quot;, nil)&#xA;    if err != nil {&#xA;        log.Fatal(&amp;quot;ListenAndServeTLS:&amp;quot;, err.Error())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;测试说明：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;本地测试可以修改hosts文件(127.0.0.1 www.xxx.com)指向证书内的域名 &amp;hellip;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/2016-12-02-Golang之通过使用安全证书实现HTTPS访问服务/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>微信小程序注册程序和页面与模块化</title>
      <link>http://www.nljb.net/default/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>2016-11-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;微信小程序注册程序和页面与模块化&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方开发文档&#xA;https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html?t=20161122&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 注册程序&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;onLaunch  生命周期函数 &amp;ndash; 监听小程序初始化    当小程序初始化完成时，会触发 onLaunch（全局只触发一次）&lt;/li&gt;&#xA;&lt;li&gt;onShow    生命周期函数 &amp;ndash; 监听小程序显示   当小程序启动，或从后台进入前台显示，会触发 onShow&lt;/li&gt;&#xA;&lt;li&gt;onHide    生命周期函数 &amp;ndash; 监听小程序隐藏   当小程序从前台进入后台，会触发 onHide&lt;/li&gt;&#xA;&lt;li&gt;其它      开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;App({&#xA;  onLaunch: function() { &#xA;    // Do something initial when launch.&#xA;  },&#xA;  onShow: function() {&#xA;      // Do something when show.&#xA;  },&#xA;  onHide: function() {&#xA;      // Do something when hide.&#xA;  },&#xA;  globalData: &#39;I am global data&#39;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h5&gt;前台、后台定义：&lt;/h5&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；&#xA;    当再次进入微信或再次打开小程序，又会从后台进入前台。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h5&gt;获取到小程序实例&lt;/h5&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;我们提供了全局的 getApp() 函数，可以获取到小程序实例。&#xA;&#xA;// other.js&#xA;var appInstance = getApp()&#xA;console.log(appInstance.globalData) // I am global data&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h5&gt;注意：&lt;/h5&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;App() 必须在 app.js 中注册，且不能注册多个。&lt;/li&gt;&#xA;&lt;li&gt;不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。&lt;/li&gt;&#xA;&lt;li&gt;不要在 onLaunch 的时候调用 getCurrentPage()，此时 page 还没有生成。&lt;/li&gt;&#xA;&lt;li&gt;通过 getApp() 获取实例之后，不要私自调用生命周期函数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 注册页面&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;data      类型(Object)  页面的初始数据&lt;/li&gt;&#xA;&lt;li&gt;onLoad    类型(Function)    生命周期函数&amp;ndash;监听页面加载&lt;/li&gt;&#xA;&lt;li&gt;onReady   类型(Function)    生命周期函数&amp;ndash;监听页面初次渲染完成&lt;/li&gt;&#xA;&lt;li&gt;onShow    类型(Function)    生命周期函数&amp;ndash;监听页面显示&lt;/li&gt;&#xA;&lt;li&gt;onHide    类型(Function)    生命周期函数&amp;ndash;监听页面隐藏&lt;/li&gt;&#xA;&lt;li&gt;onUnload  类型(Function)    生命周期函数&amp;ndash;监听页面卸载&lt;/li&gt;&#xA;&lt;li&gt;onPullDownRefresh 类型(Function)    页面相关事件处理函数&amp;ndash;监听用户下拉动作&lt;/li&gt;&#xA;&lt;li&gt;onReachBottom     类型(Function)    页面上拉触底事件的处理函数&lt;/li&gt;&#xA;&lt;li&gt;其他    类型(Any) 开发者可以添加任意的函数或数据到 object 参数中，在页面的函数中用 this 可以访问&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//index.js&#xA;Page({&#xA;  data: {&#xA;    text: &amp;quot;This is page data.&amp;quot;&#xA;  },&#xA;  onLoad: function(options) {&#xA;    // Do some initialize when page load.&#xA;  },&#xA;  onReady: function() {&#xA;    // Do something when page ready.&#xA;  },&#xA;  onShow: function() {&#xA;    // Do something when page show.&#xA;  },&#xA;  onHide: function() {&#xA;    // Do something when page hide.&#xA;  },&#xA;  onUnload: function() {&#xA;    // Do something when page close.&#xA;  },&#xA;  onPullDownRefresh: function() {&#xA;    // Do something when pull down.&#xA;  },&#xA;  onReachBottom: function() {&#xA;    // Do something when page reach bottom.&#xA;  },&#xA;  // Event handler.&#xA;  viewTap: function() {&#xA;    this.setData({&#xA;      text: &#39;Set some data for updating view.&#39;&#xA;    })&#xA;  },&#xA;  customData: {&#xA;    hi: &#39;MINA&#39;&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 初始化数据&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;初始化数据将作为页面的第一次渲染。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;data 将会以 JSON 的形式由逻辑层传至渲染层, 所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;渲染层可以通过 WXML 对数据进行绑定。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;view&amp;gt;&amp;lt;/view&amp;gt;&#xA;&amp;lt;view&amp;gt;&amp;lt;/view&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Page({&#xA;  data: {&#xA;    text: &#39;init data&#39;,&#xA;    array: [{msg: &#39;1&#39;}, {msg: &#39;2&#39;}]&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 生命周期函数&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;onLoad: 页面加载&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个页面只会调用一次。&lt;/li&gt;&#xA;&lt;li&gt;接收页面参数可以获取wx.navigateTo和wx.redirectTo及&lt;navigator/&gt;中的 query。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;onShow: 页面显示&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次打开页面都会调用一次。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;onReady: 页面初次渲染完成&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。&lt;/li&gt;&#xA;&lt;li&gt;对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;onHide: 页面隐藏&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当navigateTo或底部tab切换时调用。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;onUnload: 页面卸载&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当redirectTo或navigateBack的时候调用。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 页面相关事件处理函数&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;onPullDownRefresh: 下拉刷新&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;监听用户下拉刷新事件。&lt;/li&gt;&#xA;&lt;li&gt;需要在config的window选项中开启enablePullDownRefresh。&lt;/li&gt;&#xA;&lt;li&gt;当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 事件处理函数(事件绑定)&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;除了初始化数据和生命周期函数，Page 中还可以定义一些特殊的函数：事件处理函数。&#xA;在渲染层可以在组件中加入事件绑定，当达到触发事件时，就会执行 Page 中定义的事件处理函数。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;view bindtap=&amp;quot;viewTap&amp;quot;&amp;gt; click me &amp;lt;/view&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Page({&#xA;  viewTap: function() {&#xA;    console.log(&#39;view tap&#39;)&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;*  Page.prototype.setData()&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：&#xA;&#xA;* 直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。&#xA;* 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;setData() 参数格式:&#xA;&#xA;接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。&#xA;其中 key 可以非常灵活，以数据路径的形式给出&#xA;如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!--index.wxml--&amp;gt;&#xA;&amp;lt;view&amp;gt;&amp;lt;/view&amp;gt;&#xA;&amp;lt;button bindtap=&amp;quot;changeText&amp;quot;&amp;gt; Change normal data &amp;lt;/button&amp;gt;&#xA;&amp;lt;view&amp;gt;&amp;lt;/view&amp;gt;&#xA;&amp;lt;button bindtap=&amp;quot;changeItemInArray&amp;quot;&amp;gt; Change Array data &amp;lt;/button&amp;gt;&#xA;&amp;lt;view&amp;gt;&amp;lt;/view&amp;gt;&#xA;&amp;lt;button bindtap=&amp;quot;changeItemInObject&amp;quot;&amp;gt; Change Object data &amp;lt;/button&amp;gt;&#xA;&amp;lt;view&amp;gt;&amp;lt;/view&amp;gt;&#xA;&amp;lt;button bindtap=&amp;quot;addNewField&amp;quot;&amp;gt; Add new data &amp;lt;/button&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//index.js&#xA;Page({&#xA;  data: {&#xA;    text: &#39;init data&#39;,&#xA;    array: [{text: &#39;init data&#39;}],&#xA;    object: {&#xA;      text: &#39;init data&#39;&#xA;    }&#xA;  },&#xA;  changeText: function() {&#xA;    // this.data.text = &#39;changed data&#39;  // bad, it can not work&#xA;    this.setData({&#xA;      text: &#39;changed data&#39;&#xA;    })&#xA;  },&#xA;  changeItemInArray: function() {&#xA;    // you can use this way to modify a danamic data path&#xA;    this.setData({&#xA;      &#39;array[0].text&#39;:&#39;changed data&#39;&#xA;    })&#xA;  },&#xA;  changeItemInObject: function(){&#xA;    this.setData({&#xA;      &#39;object.text&#39;: &#39;changed data&#39;&#xA;    });&#xA;  },&#xA;  addNewField: function() {&#xA;    this.setData({&#xA;      &#39;newField.text&#39;: &#39;new data&#39;&#xA;    })&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* getCurrentPages()&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：不要尝试修改页面栈，会导致路由以及页面状态错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;页面栈&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化       新页面入栈&lt;/li&gt;&#xA;&lt;li&gt;打开新页面 新页面入栈&lt;/li&gt;&#xA;&lt;li&gt;页面重定向 当前页面出栈，新页面入栈&lt;/li&gt;&#xA;&lt;li&gt;页面返回      页面不断出栈，直到目标返回页，新页面入栈&lt;/li&gt;&#xA;&lt;li&gt;Tab 切换    当前页面出栈，新页面入栈&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 页面的路由&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;在小程序中所有页面的路由全部由框架进行管理，对于路由的触发方式以及页面生命周期函数如下：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化       小程序打开的第一个页面 onLoad，onShow&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;打开新页面 调用 API wx.navigateTo 或使用组件 &lt;navigator /&gt;    onLoad，onShow   onHide&lt;/li&gt;&#xA;&lt;li&gt;页面重定向 调用 API wx.redirectTo 或使用组件 &lt;navigator /&gt;    onLoad，onShow   onUnload&lt;/li&gt;&#xA;&lt;li&gt;页面返回      调用 API wx.navigateBack或用户按左上角返回按钮   onShow  onUnload&lt;/li&gt;&#xA;&lt;li&gt;（多层页面返回每个页面都会按顺序触发onUnload）&lt;/li&gt;&#xA;&lt;li&gt;Tab切换     多 Tab 模式下用户切换 Tab   第一次打开 onLoad，onshow；否则 onShow   onHide&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 文件作用域&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置，如：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// app.js&#xA;App({&#xA;  globalData: 1&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// a.js&#xA;// The localValue can only be used in file a.js.&#xA;var localValue = &#39;a&#39;&#xA;// Get the app instance.&#xA;var app = getApp()&#xA;// Get the global data and change it.&#xA;app.globalData++&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// b.js&#xA;// You can redefine localValue in file b.js, without interference with the localValue in a.js.&#xA;var localValue = &#39;b&#39;&#xA;// If a.js it run before b.js, now the globalData shoule be 2.&#xA;console.log(getApp().globalData)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;* 模块化&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;需要注意的是：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。&#xA;所以我们更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候建议拷贝出相关的代码到小程序的目录中。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// common.js&#xA;function sayHello(name) {&#xA;  console.log(`Hello ${name} !`)&#xA;}&#xA;function sayGoodbye(name) {&#xA;  console.log(`Goodbye ${name} !`)&#xA;}&#xA;&#xA;module.exports.sayHello = sayHello&#xA;exports.sayGoodbye = sayGoodbye&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;在需要使用这些模块的文件中，使用 require(path) 将公共代码引入&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var common = require(&#39;common.js&#39;)&#xA;Page({&#xA;  helloMINA: function() {&#xA;    common.sayHello(&#39;MINA&#39;)&#xA;  },&#xA;  goodbyeMINA: function() {&#xA;    common.sayGoodbye(&#39;MINA&#39;)&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>微信小程序导航与参数传递</title>
      <link>http://www.nljb.net/default/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link>
      <pubDate>2016-11-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;微信小程序导航与参数传递&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方开发文档&#xA;https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html?t=20161122&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;API (wx.navigateTo(OBJECT))&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;url 类型(String) 必填(是)  需要跳转的应用内页面的路径,路径后可以带参数。&lt;/li&gt;&#xA;&lt;li&gt;success 类型(Function) 必填(否) 接口调用成功的回调函数&lt;/li&gt;&#xA;&lt;li&gt;fail 类型(Function) 必填(否) 接口调用失败的回调函数&lt;/li&gt;&#xA;&lt;li&gt;complete 类型(Function) 必填(否) 接口调用结束的回调函数（调用成功、失败都会执行）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;注意: 参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;amp;分隔；如 &amp;lsquo;path?key=value&amp;amp;key2=value2&amp;rsquo;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 跳转页面&#xA;wx.navigateTo({&#xA;  // 需要跳转的应用内页面的路径 , 路径后可以带参数&#xA;  url: &#39;../logs/logs?name=nljb&amp;amp;addr=www.nljb.net&#39;,&#xA;  // 接口调用成功的回调函数&#xA;  success: function (res) {&#xA;    console.log(res)&#xA;  },&#xA;  // 接口调用失败的回调函数&#xA;  fail: function (err) {&#xA;    console.log(err)&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 目标页面&#xA;Page({&#xA;  // option 为传入参数&#xA;  onLoad: function(option){&#xA;    console.log(option.name)&#xA;    console.log(option.addr)&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;API (wx.redirectTo(OBJECT))&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;关闭当前页面，跳转到应用内的某个页面。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;wx.redirectTo({&#xA;  url: &#39;test?id=1&#39;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;API (wx.navigateBack(OBJECT))&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages()) 获取当前的页面栈，决定需要返回几层。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;delta 类型(Number) 默认值(1) 返回的页面数，如果 delta 大于现有页面数，则返回到首页。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>微信小程序学习笔记</title>
      <link>http://www.nljb.net/default/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>2016-11-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;微信小程序学习笔记&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方开发文档&#xA;https://mp.weixin.qq.com/debug/wxadoc/dev/?t=20161122&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;点击开发者工具左侧导航的“编辑”，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;最关键也是必不可少的是：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;app.js - .js后缀的是脚本文件&lt;/li&gt;&#xA;&lt;li&gt;app.json - .json后缀的文件是配置文件&lt;/li&gt;&#xA;&lt;li&gt;app.wxss - .wxss后缀的是样式表文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;app.js是小程序的脚本代码：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。&#xA;调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。&#xA;想了解更多可用 API，可参考 API 文档&#xA;https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161122&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//app.js&#xA;App({&#xA;  onLaunch: function () {&#xA;    //调用API从本地缓存中获取数据&#xA;    var logs = wx.getStorageSync(&#39;logs&#39;) || []&#xA;    logs.unshift(Date.now())&#xA;    wx.setStorageSync(&#39;logs&#39;, logs)&#xA;  },&#xA;  getUserInfo:function(cb){&#xA;    var that = this;&#xA;    if(this.globalData.userInfo){&#xA;      typeof cb == &amp;quot;function&amp;quot; &amp;amp;&amp;amp; cb(this.globalData.userInfo)&#xA;    }else{&#xA;      //调用登录接口&#xA;      wx.login({&#xA;        success: function () {&#xA;          wx.getUserInfo({&#xA;            success: function (res) {&#xA;              that.globalData.userInfo = res.userInfo;&#xA;              typeof cb == &amp;quot;function&amp;quot; &amp;amp;&amp;amp; cb(that.globalData.userInfo)&#xA;            }&#xA;          })&#xA;        }&#xA;      });&#xA;    }&#xA;  },&#xA;  globalData:{&#xA;    userInfo:null&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;app.json 是对整个小程序的全局配置：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口和背景色，配置导航条样式，配置默认标题。&#xA;注意该文件不可添加任何注释。&#xA;更多可配置项可参考配置详解&#xA;https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=20161122&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;{&#xA;  &amp;quot;pages&amp;quot;:[&#xA;    &amp;quot;pages/index/index&amp;quot;,&#xA;    &amp;quot;pages/logs/logs&amp;quot;&#xA;  ],&#xA;  &amp;quot;window&amp;quot;:{&#xA;    &amp;quot;backgroundTextStyle&amp;quot;:&amp;quot;light&amp;quot;,&#xA;    &amp;quot;navigationBarBackgroundColor&amp;quot;: &amp;quot;#fff&amp;quot;,&#xA;    &amp;quot;navigationBarTitleText&amp;quot;: &amp;quot;WeChat&amp;quot;,&#xA;    &amp;quot;navigationBarTextStyle&amp;quot;:&amp;quot;black&amp;quot;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;app.wxss 是整个小程序的公共样式表：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**app.wxss**/&#xA;.container {&#xA;  height: 100%;&#xA;  display: flex;&#xA;  flex-direction: column;&#xA;  align-items: center;&#xA;  justify-content: space-between;&#xA;  padding: 200rpx 0;&#xA;  box-sizing: border-box;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;新建项目有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志页，都在 pages 目录下&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中且 pages 中的第一个页面是小程序的首页。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;每一个小程序页面是由同路径下同名的四个不同后缀文件的组成：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;index.js - .js后缀的文件是脚本文件&lt;/li&gt;&#xA;&lt;li&gt;index.wxml - .wxml后缀的文件是页面结构文件&lt;/li&gt;&#xA;&lt;li&gt;index.wxss - .wxss后缀的是样式表文件&lt;/li&gt;&#xA;&lt;li&gt;index.json - .json后缀的文件是配置文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;index.wxml 是页面的结构文件：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!--index.wxml--&amp;gt;&#xA;&amp;lt;view class=&amp;quot;container&amp;quot;&amp;gt;&#xA;  &amp;lt;view  bindtap=&amp;quot;bindViewTap&amp;quot; class=&amp;quot;userinfo&amp;quot;&amp;gt;&#xA;    &amp;lt;image class=&amp;quot;userinfo-avatar&amp;quot; src=&amp;quot;&amp;quot; background-size=&amp;quot;cover&amp;quot;&amp;gt;&amp;lt;/image&amp;gt;&#xA;    &amp;lt;text class=&amp;quot;userinfo-nickname&amp;quot;&amp;gt;&amp;lt;/text&amp;gt;&#xA;  &amp;lt;/view&amp;gt;&#xA;  &amp;lt;view class=&amp;quot;usermotto&amp;quot;&amp;gt;&#xA;    &amp;lt;text class=&amp;quot;user-motto&amp;quot;&amp;gt;&amp;lt;/text&amp;gt;&#xA;  &amp;lt;/view&amp;gt;&#xA;&amp;lt;/view&amp;gt;&#xA;&#xA;本例中使用了&amp;lt;view/&amp;gt;、&amp;lt;image/&amp;gt;、&amp;lt;text/&amp;gt;来搭建页面结构，绑定数据和交互处理函数。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;index.js 是页面的脚本文件：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。&#xA;&#xA;//index.js&#xA;//获取应用实例&#xA;var app = getApp()&#xA;Page({&#xA;  data: {&#xA;    motto: &#39;Hello World&#39;,&#xA;    userInfo: {}&#xA;  },&#xA;  //事件处理函数&#xA;  bindViewTap: function() {&#xA;    wx.navigateTo({&#xA;      url: &#39;../logs/logs&#39;&#xA;    })&#xA;  },&#xA;  onLoad: function () {&#xA;    console.log(&#39;onLoad&#39;)&#xA;    var that = this&#xA;    //调用应用实例的方法获取全局数据&#xA;    app.getUserInfo(function(userInfo){&#xA;      //更新数据&#xA;      that.setData({&#xA;        userInfo:userInfo&#xA;      })&#xA;    })&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;index.wxss 是页面的样式表：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**index.wxss**/&#xA;.userinfo {&#xA;  display: flex;&#xA;  flex-direction: column;&#xA;  align-items: center;&#xA;}&#xA;&#xA;.userinfo-avatar {&#xA;  width: 128rpx;&#xA;  height: 128rpx;&#xA;  margin: 20rpx;&#xA;  border-radius: 50%;&#xA;}&#xA;&#xA;.userinfo-nickname {&#xA;  color: #aaa;&#xA;}&#xA;&#xA;.usermotto {&#xA;  margin-top: 200px;&#xA;}&#xA;&#xA;页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。&#xA;如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;index.json 是页面的配置文件：&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;页面的配置文件是非必要的。&#xA;当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。&#xA;如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;logs 的页面结构:&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!--logs.wxml--&amp;gt;&#xA;&amp;lt;view class=&amp;quot;container log-list&amp;quot;&amp;gt;&#xA;  &amp;lt;block wx:for=&amp;quot;&amp;quot; wx:for-item=&amp;quot;log&amp;quot;&amp;gt;&#xA;    &amp;lt;text class=&amp;quot;log-item&amp;quot;&amp;gt;. &amp;lt;/text&amp;gt;&#xA;  &amp;lt;/block&amp;gt;&#xA;&amp;lt;/view&amp;gt;&#xA;&#xA;logs 页面使用 &amp;lt;block/&amp;gt; 控制标签来组织代码，在 &amp;lt;block/&amp;gt; 上使用 wx:for 绑定 logs 数据，并将 logs 数据循环展开节点&#xA;&#xA;//logs.js&#xA;var util = require(&#39;../../utils/util.js&#39;)&#xA;Page({&#xA;  data: {&#xA;    logs: []&#xA;  },&#xA;  onLoad: function () {&#xA;    this.setData({&#xA;      logs: (wx.getStorageSync(&#39;logs&#39;) || []).map(function (log) {&#xA;        return util.formatTime(new Date(log))&#xA;      })&#xA;    })&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之第三方库QtAV的编译</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93QtAV%E7%9A%84%E7%BC%96%E8%AF%91/</link>
      <pubDate>2016-10-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;QtAV是基于Qt和FFmpeg多媒体播放库&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;官方网站: &lt;a href=&#34;http://qtav.org&#34;&gt;http://qtav.org&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;项目地址：&lt;a href=&#34;https://github.com/wang-bin/QtAV&#34;&gt;https://github.com/wang-bin/QtAV&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Hardware decoding suppprt: DXVA2, VAAPI, VDA/VideoToolbox, CedarX, CUDA(the 1st player support CUDA on linux?)&#xA;OpenGL and ES2 support for almost all formats including Hi10P videos (The 1st player/library support 10bit in ES2? VLC, XBMC, mplayer does not support now)&#xA;Real time preview&#xA;Video capture in rgb and yuv format&#xA;OSD and custom filters&#xA;Filters in libavfilter, for example stero3d, blur&#xA;Subtitle track select. Dynamic change FFmpeg and libass engine&#xA;Play frame by frame&#xA;Playback speed control&#xA;Variant streams: locale file, http, rtsp etc. and your custom streams&#xA;Audio channel, tracks and external audio tracks&#xA;Dynamically change render engine when playing.&#xA;Dynamically change video decoder&#xA;Multiple video outputs for 1 player&#xA;Video eq(software and OpenGL): brightness, contrast, saturation, hue&#xA;QML support. Most playback APIs are compatible with QtMultimedia module&#xA;Compatiblity: QtAV can be built with both Qt4 and Qt5, FFmpeg(&amp;gt;=1.0) and Libav (&amp;gt;=9.0). Latest FFmpeg release is recommended.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FFmepg (编译需要）&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;事先需要下载对应平台的FFmpeg(https://ffmpeg.org)&#xA;&#xA;需要 FFmepg 的 Static 和 Dev ... 包 ...&#xA;&#xA;解压到系统目录，例如 E:\ffmepg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Windows安装QtAV&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;直接通过 http://qtav.org 下载对应平台的安装包即可 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Windows编译QtAV&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：如果暂时不使用portaudio可以先不准备 ...&#xA;&#xA;&#xA;GCC 环境编译: 在QT项目-构件-构件环境中添加：&#xA;    设置 CPATH 到 E:\ffmpeg\include;&#xA;    设置 LIBRARY_PATH 到 E:\ffmpeg\lib;&#xA;&#xA;MINGW 环境编译: 在QT项目-构件-构件环境中添加：&#xA;    设置 INCLUDE 到 E:\ffmpeg\include;&#xA;    设置 LIB 到 E:\ffmpeg\lib;&#xA;&#xA;当然：Debug 和 Release 按需求编译了&#xA;&#xA;在编译完成后，进入管理员权限的CMD终端&#xA;&#xA;例如: cd E:\QtAV\build-QtAV-Desktop_Qt_5_7_0_MinGW_32bit-Release&#xA;&#xA;安装: sdk_install.bat ... 即可&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;使用 &amp;hellip;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;widget.h&amp;quot;  &#xA;#include &amp;lt;QApplication&amp;gt;  &#xA;#include &amp;lt;QtAV/AVPlayer.h&amp;gt;  &#xA;#include &amp;lt;QtAV/GLWidgetRenderer.h&amp;gt;  &#xA;int main(int argc, char *argv[])  &#xA;{  &#xA;    QApplication a(argc, argv);  &#xA;    QtAV::GLWidgetRenderer renderer;  &#xA;    renderer.show();  &#xA;    QtAV::AVPlayer player;  &#xA;    player.setRenderer(&amp;amp;renderer);  &#xA;    player.play(&amp;quot;http://a.mp4&amp;quot;);  &#xA;    return a.exec();  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>QtAV之VideoDecoder的使用</title>
      <link>http://www.nljb.net/default/QtAV%E4%B9%8BVideoDecoder%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2016-10-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;VideoDecoder是QtAV的解码器&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;本文主要目的是介绍，如何独立使用 VideoDecoder 解码 &amp;hellip; 自定义绘制输出 ..&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;VideoDecoder 支持 &amp;quot;FFmpeg&amp;quot;, &amp;quot;CUDA&amp;quot;, &amp;quot;VDA&amp;quot;, &amp;quot;VAAPI&amp;quot;, &amp;quot;DXVA&amp;quot;, &amp;quot;Cedarv&amp;quot; 解码方式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;VideoDecoder解码（官方案例）&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;请关注文中注释部分&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;QCoreApplication&amp;gt;&#xA;#include &amp;lt;QtDebug&amp;gt;&#xA;#include &amp;lt;QtCore/QDateTime&amp;gt;&#xA;#include &amp;lt;QtCore/QQueue&amp;gt;&#xA;#include &amp;lt;QtCore/QStringList&amp;gt;&#xA;#include &amp;lt;QtAV/AVDemuxer.h&amp;gt;&#xA;#include &amp;lt;QtAV/VideoDecoder.h&amp;gt;&#xA;#include &amp;lt;QtAV/Packet.h&amp;gt;&#xA;&#xA;using namespace QtAV;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    // ---------------------------------&#xA;    // QCoreApplication 只能出现在主线程中 ...&#xA;    // ---------------------------------&#xA;    QCoreApplication a(argc, argv);&#xA;    QString file = QString::fromLatin1(&amp;quot;test.avi&amp;quot;);&#xA;    int idx = a.arguments().indexOf(QLatin1String(&amp;quot;-f&amp;quot;));&#xA;    if (idx &amp;gt; 0)&#xA;        file = a.arguments().at(idx + 1);&#xA;    // ---------------------------------&#xA;    // 使用那种解码器 FFmpeg 默认软解&#xA;    // &amp;quot;FFmpeg&amp;quot;, &amp;quot;CUDA&amp;quot;, &amp;quot;VDA&amp;quot;, &amp;quot;VAAPI&amp;quot;, &amp;quot;DXVA&amp;quot;, &amp;quot;Cedarv&amp;quot;&#xA;    // ---------------------------------&#xA;    QString decName = QString::fromLatin1(&amp;quot;FFmpeg&amp;quot;);&#xA;    idx = a.arguments().indexOf(QLatin1String(&amp;quot;-vc&amp;quot;));&#xA;    if (idx &amp;lt; 0)&#xA;        idx = a.arguments().indexOf(QLatin1String(&amp;quot;-vd&amp;quot;));&#xA;    if (idx &amp;gt; 0)&#xA;        decName = a.arguments().at(idx + 1);&#xA;&#xA;    QString opt;&#xA;    QVariantHash decopt;&#xA;    idx = decName.indexOf(QLatin1String(&amp;quot;:&amp;quot;));&#xA;    if (idx &amp;gt; 0) {&#xA;        opt = decName.right(decName.size() - idx -1);&#xA;        decName = decName.left(idx);&#xA;        QStringList opts(opt.split(QString::fromLatin1(&amp;quot;;&amp;quot;)));&#xA;        QVariantHash subopt;&#xA;        foreach (QString o, opts) {&#xA;            idx = o.indexOf(QLatin1String(&amp;quot;:&amp;quot;));&#xA;            subopt[o.left(idx)] = o.right(o.size() - idx - 1);&#xA;        }&#xA;        decopt[decName] = subopt;&#xA;    }&#xA;    qDebug() &amp;lt;&amp;lt; decopt;&#xA;&#xA;    VideoDecoder *dec = VideoDecoder::create(decName.toLatin1().constData());&#xA;    if (!dec) {&#xA;        fprintf(stderr, &amp;quot;Can not find decoder: %s\n&amp;quot;, decName.toUtf8().constData());&#xA;        return 1;&#xA;    }&#xA;    // -------------------------------------------------------------&#xA;    // 自动释放 ...&#xA;    QScopedPointer&amp;lt;VideoDecoder&amp;gt; decoder;&#xA;    decoder.reset(dec);&#xA;    // -------------------------------------------------------------&#xA;    if (!decopt.isEmpty())&#xA;        dec-&amp;gt;setOptions(decopt);&#xA;    AVDemuxer demux;&#xA;    demux.setMedia(file);&#xA;    if (!demux.load()) {&#xA;        qWarning(&amp;quot;Failed to load file: %s&amp;quot;, file.toUtf8().constData());&#xA;        return 1;&#xA;    }&#xA;    dec-&amp;gt;setCodecContext(demux.videoCodecContext());&#xA;    // -------------------------------------------------------------&#xA;    // 请注意这里是官方对 open 与 close 的要求，不是线程安全的，最好使用锁 ...&#xA;    /*!&#xA;    * default is open FFmpeg codec context&#xA;    * codec config must be done before open&#xA;    * NOTE: open() and close() are not thread safe. You&#39;d better call them in the same thread.&#xA;    */&#xA;    // ---------------------------------------------------------------&#xA;    dec-&amp;gt;open();&#xA;    int count = 0;&#xA;    int vstream = demux.videoStream();&#xA;    QQueue&amp;lt;qint64&amp;gt; t;&#xA;    qint64 t0 = QDateTime::currentMSecsSinceEpoch();&#xA;    while (!demux.atEnd()) {&#xA;        if (!demux.readFrame())&#xA;            continue;&#xA;        if (demux.stream() != vstream)&#xA;            continue;&#xA;        const Packet pkt = demux.packet();&#xA;        if (dec-&amp;gt;decode(pkt)) {&#xA;            VideoFrame frame = dec-&amp;gt;frame(); // why is faster to call frame() for hwdec? no frame() is very slow for VDA&#xA;            // ---------------------------------&#xA;            // 使用前最好判断一下，帧的正确性 ...&#xA;            if (!frame.isValid()) {&#xA;                continue;&#xA;            }&#xA;            // 注意：此处将帧保存 ... 备用 ... 缓存帧数不要太多 ... 1080P(10+-) 4k(5-) 等 ... 以免显存不足&#xA;            // 比如: frames 需自定义，frames 读写需加锁 ...&#xA;            for (;;) {&#xA;                 if (frames.size &amp;lt; 5) {&#xA;                    break;&#xA;                }&#xA;                QThread::msleep(10);&#xA;            }&#xA;            frames.push(frame);&#xA;            // ---------------------------------&#xA;            Q_UNUSED(frame);&#xA;            count++;&#xA;            const qint64 now = QDateTime::currentMSecsSinceEpoch();&#xA;            const qint64 dt = now - t0;&#xA;            t.enqueue(now);&#xA;            printf(&amp;quot;decode count: %d, elapsed: %lld, fps: %.1f/%.1f\r&amp;quot;, count, dt, count*1000.0/dt, t.size()*1000.0/(now - t.first()));fflush(0);&#xA;            if (t.size() &amp;gt; 10)&#xA;                t.dequeue();&#xA;        }&#xA;    }&#xA;    // ---------------------------------&#xA;    // 解码器释放部分 ...&#xA;    dec-&amp;gt;flush();&#xA;    demux.setInterruptStatus(-1);&#xA;    demux.unload();&#xA;    // setCodecContext 相当于 close 需要加锁&#xA;    decoder-&amp;gt;setCodecContext(0);&#xA;    decoder.reset(0);&#xA;    // ---------------------------------&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;如何使用 VideoFrame&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;三种使用VideoFrame思路&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenGL 渲染 VideoFrame 帧&lt;/li&gt;&#xA;&lt;li&gt;SDL 绘制 VideoFrame 帧（需转换格式）&lt;/li&gt;&#xA;&lt;li&gt;QImage 绘制 VideoFrame 帧（需转换格式）(效率低)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;QImage&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 就不多介绍了 ... &#xA;QImage image = frame.toImage();&#xA;QImage image = frame.toImage(QImage::Format_ARGB32);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SDL&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 事先需要将帧转为SDL需要输出的格式，例如：Format_YUV420P&#xA;frame = frame.to(VideoFormat::PixelFormat::Format_YUV420P);&#xA;&#xA;// 将 VideoFrame 转为 AVPicture ...&#xA;AVPicture* Decoder::convert(VideoFrame &amp;amp;inFrame, int w, int h)&#xA;{&#xA;    AVPicture *pFrameYUV = new AVPicture();&#xA;    AVPicture pFrame;&#xA;    avpicture_fill(&amp;amp;pFrame, (uint8_t*) inFrame.bits(), AV_PIX_FMT_YUV420P, w, h);&#xA;    avpicture_alloc(pFrameYUV, AV_PIX_FMT_YUV420P, w, h);&#xA;    av_picture_copy(pFrameYUV, &amp;amp;pFrame, AV_PIX_FMT_YUV420P, w, h);&#xA;    return pFrameYUV;&#xA;}&#xA;&#xA;// 如何用SDL绘制一个AV_PIX_FMT_YUV420P的AVPicture就不用我多说了吧 ....&#xA;SDL_UpdateTexture(texture, NULL, avp-&amp;gt;data[0], avp-&amp;gt;linesize[0]);&#xA;SDL_RenderCopy(renderer, texture, NULL, rect);&#xA;SDL_RenderPresent(renderer);&#xA;&#xA;// 注意：AVPicture 需要手动释放，但不能在 SDL_RenderPresent 前释放 ...&#xA;// 建议：最后有个释放队列，绘制完的帧都从绘制队列移到释放队列 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;OpenGL&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 不用多说, 看代码 ...&#xA;&#xA;// 使用 QtAV 的 OpenGLVideo 渲染 ...&#xA;OpenGLVideo oglv;&#xA;oglv.setOpenGLContext(QOpenGLContext::currentContext());&#xA;oglv.setCurrentFrame(frame);&#xA;oglv.setProjectionMatrixToRect(rectf);&#xA;oglv.render();&#xA;&#xA;// 如果想使用自定义的OGL渲染VideoFrame那研究研究OpenGLVideo吧 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;结语&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QtAV 如何如何好，我就不夸了 ... 但只能说是假开源 ... 代码一坨看得懂叫开源看不懂跟看不到一样 ..&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之Context的使用</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BContext%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2016-08-26 12:00:00 +0800</pubDate>
      <description>&lt;h4&gt;简介&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在golang中的创建一个新的线程并不会返回像c语言类似的pid&#xA;所有我们不能从外部杀死某个线程，所有我就得让它自己结束&#xA;之前我们用channel＋select的方式，来解决这个问题&#xA;但是有些场景实现起来比较麻烦，例如由一个请求衍生出多个线程&#xA;并且之间需要满足一定的约束关系，以实现一些诸如：&#xA;有效期，中止线程树，传递请求全局变量之类的功能。&#xA;于是google 就为我们提供一个解决方案，开源了context包。&#xA;使用context包来实现上下文功能 .....&#xA;约定：需要在你的方法的传入参数的第一个参数是context.Context的变量。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;其实本身非常简单，在导入这个包之后，初始化Context对象，在每个资源访问方法中都调用它，然后在使用时检查Context对象是否已经被Cancel，如果是就释放绑定的资源&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h4&gt;源码剖析&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;context.Context 接口&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;context包里的方法是线程安全的，可以被多个线程使用&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;当Context被canceled或是timeout, Done返回一个被closed 的channel&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;在Done的channel被closed后, Err代表被关闭的原因&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;如果存在, Deadline 返回Context将要关闭的时间&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;如果存在，Value 返回与 key 相关了的值，不存在返回 nil&lt;br /&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// context 包的核心&#xA;type Context interface {               &#xA;    Done() &amp;lt;-chan struct{}      &#xA;    Err() error &#xA;    Deadline() (deadline time.Time, ok bool)&#xA;    Value(key interface{}) interface{}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;我们不需要手动实现这个接口，context 包已经给我们提供了两个&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一个是 Background()，一个是 TODO()&#xA;这两个函数都会返回一个Context的实例&#xA;只是返回的这两个实例都是空 Context。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    TODO返回一个非空，空的上下文&#xA;    在目前还不清楚要使用的上下文或尚不可用时&#xA;*/&#xA;context.TODO()&#xA;/*&#xA;    Background返回一个非空，空的上下文。&#xA;    这是没有取消，没有值，并且没有期限。&#xA;    它通常用于由主功能，初始化和测试，并作为输入的顶层上下文&#xA;*/&#xA;context.Background()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;主要方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func WithCancel(parent Context) (ctx Context, cancel CancelFunc)&#xA;func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)&#xA;func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)&#xA;func WithValue(parent Context, key interface{}, val interface{}) Context&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;WithCancel 对应的是 cancelCtx ,其中，返回一个 cancelCtx ，同时返回一个 CancelFunc，CancelFunc 是 context 包中定义的一个函数类型：type CancelFunc func()。调用这个 CancelFunc 时，关闭对应的c.done，也就是让他的后代goroutine退出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;WithDeadline 和 WithTimeout 对应的是 timerCtx ，WithDeadline 和 WithTimeout 是相似的，WithDeadline 是设置具体的 deadline 时间，到达 deadline 的时候，后代 goroutine 退出，而 WithTimeout 简单粗暴，直接 return WithDeadline(parent, time.Now().Add(timeout))&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;WithValue 对应 valueCtx ，WithValue 是在 Context 中设置一个 map，拿到这个 Context 以及它的后代的 goroutine 都可以拿到 map 里的值&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;context的创建&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;所有的context的父对象，也叫根对象，是一个空的context，它不能被取消，它没有值，从不会被取消，也没有超时时间，它常常作为处理request的顶层context存在，然后通过WithCancel、WithTimeout函数来创建子对象来获得cancel、timeout的能力&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;当顶层的request请求函数结束后，我们就可以cancel掉某个context，从而通知别的routine结束&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;WithValue方法可以把键值对加入context中，让不同的routine获取&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;官方案例&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在 handle 环境中使用 &#xA;func handleSearch(w http.ResponseWriter, req *http.Request) {&#xA;    // ctx is the Context for this handler. Calling cancel closes the&#xA;    // ctx.Done channel, which is the cancellation signal for requests&#xA;    // started by this handler.&#xA;    var (&#xA;        ctx    context.Context&#xA;        cancel context.CancelFunc&#xA;    )&#xA;    // 获取参数 ...&#xA;    timeout, err := time.ParseDuration(req.FormValue(&amp;quot;timeout&amp;quot;))&#xA;    if err == nil {&#xA;        // The request has a timeout, so create a context that is&#xA;        // canceled automatically when the timeout expires.&#xA;        // 获取成功, 则按照参数设置超时时间&#xA;        ctx, cancel = context.WithTimeout(context.Background(), timeout)&#xA;    } else {&#xA;        // 获取失败, 则在该函数结束时结束 ...&#xA;        ctx, cancel = context.WithCancel(context.Background())&#xA;    }&#xA;    // ----------------&#xA;    // 这样随着cancel的执行,所有的线程都随之结束了 ...&#xA;    go A(ctx) +1&#xA;    go B(ctx) +2&#xA;    go C(ctx) +3&#xA;    // ----------------&#xA;    defer cancel() // Cancel ctx as soon as handleSearch returns.&#xA;}&#xA;&#xA;// 监听 ctx.Done() 结束 ...&#xA;func A(ctx context.Context) int {&#xA;    // ... TODO&#xA;    select {&#xA;    case &amp;lt;-ctx.Done():&#xA;            return -1&#xA;    default:&#xA;        // 没有结束 ... 执行 ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;ctxhttp.go&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package ctxhttp // import &amp;quot;golang.org/x/net/context/ctxhttp&amp;quot;&#xA;&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;net/url&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;&#xA;    &amp;quot;golang.org/x/net/context&amp;quot;&#xA;)&#xA;&#xA;// Do sends an HTTP request with the provided http.Client and returns&#xA;// an HTTP response.&#xA;//&#xA;// If the client is nil, http.DefaultClient is used.&#xA;//&#xA;// The provided ctx must be non-nil. If it is canceled or times out,&#xA;// ctx.Err() will be returned.&#xA;func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) {&#xA;    if client == nil {&#xA;        client = http.DefaultClient&#xA;    }&#xA;    resp, err := client.Do(req.WithContext(ctx))&#xA;    // If we got an error, and the context has been canceled,&#xA;    // the context&#39;s error is probably more useful.&#xA;    if err != nil {&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            err = ctx.Err()&#xA;        default:&#xA;        }&#xA;    }&#xA;    return resp, err&#xA;}&#xA;&#xA;// Get issues a GET request via the Do function.&#xA;func Get(ctx context.Context, client *http.Client, url string) (*http.Response, error) {&#xA;    req, err := http.NewRequest(&amp;quot;GET&amp;quot;, url, nil)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return Do(ctx, client, req)&#xA;}&#xA;&#xA;// Head issues a HEAD request via the Do function.&#xA;func Head(ctx context.Context, client *http.Client, url string) (*http.Response, error) {&#xA;    req, err := http.NewRequest(&amp;quot;HEAD&amp;quot;, url, nil)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    return Do(ctx, client, req)&#xA;}&#xA;&#xA;// Post issues a POST request via the Do function.&#xA;func Post(ctx context.Context, client *http.Client, url string, bodyType string, body io.Reader) (*http.Response, error) {&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, url, body)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;    req.Header.Set(&amp;quot;Content-Type&amp;quot;, bodyType)&#xA;    return Do(ctx, client, req)&#xA;}&#xA;&#xA;// PostForm issues a POST request via the Do function.&#xA;func PostForm(ctx context.Context, client *http.Client, url string, data url.Values) (*http.Response, error) {&#xA;    return Post(ctx, client, url, &amp;quot;application/x-www-form-urlencoded&amp;quot;, strings.NewReader(data.Encode()))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;使用示例&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;&#xA;    &amp;quot;golang.org/x/net/context&amp;quot;&#xA;)&#xA;&#xA;func Cdd(ctx context.Context) int {&#xA;    fmt.Println(ctx.Value(&amp;quot;NLJB&amp;quot;))&#xA;    select {&#xA;    // 结束时候做点什么 ...&#xA;    case &amp;lt;-ctx.Done():&#xA;        return -3&#xA;    default:&#xA;        // 没有结束 ... 执行 ...&#xA;    }&#xA;}&#xA;&#xA;func Bdd(ctx context.Context) int {&#xA;    fmt.Println(ctx.Value(&amp;quot;HELLO&amp;quot;))&#xA;    fmt.Println(ctx.Value(&amp;quot;WROLD&amp;quot;))&#xA;    ctx = context.WithValue(ctx, &amp;quot;NLJB&amp;quot;, &amp;quot;NULIJIABEI&amp;quot;)&#xA;    go fmt.Println(Cdd(ctx))&#xA;    select {&#xA;    // 结束时候做点什么 ...&#xA;    case &amp;lt;-ctx.Done():&#xA;        return -2&#xA;    default:&#xA;        // 没有结束 ... 执行 ...&#xA;    }&#xA;}&#xA;&#xA;func Add(ctx context.Context) int {&#xA;    ctx = context.WithValue(ctx, &amp;quot;HELLO&amp;quot;, &amp;quot;WROLD&amp;quot;)&#xA;    ctx = context.WithValue(ctx, &amp;quot;WROLD&amp;quot;, &amp;quot;HELLO&amp;quot;)&#xA;    go fmt.Println(Bdd(ctx))&#xA;    select {&#xA;    // 结束时候做点什么 ...&#xA;    case &amp;lt;-ctx.Done():&#xA;        return -1&#xA;    default:&#xA;        // 没有结束 ... 执行 ...&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    // 自动取消(定时取消)&#xA;    {&#xA;        timeout := 3 * time.Second&#xA;        ctx, _ := context.WithTimeout(context.Background(), timeout)&#xA;        fmt.Println(Add(ctx))&#xA;    }&#xA;    // 手动取消&#xA;    //  {&#xA;    //      ctx, cancel := context.WithCancel(context.Background())&#xA;    //      go func() {&#xA;    //          time.Sleep(2 * time.Second)&#xA;    //          cancel() // 在调用处主动取消&#xA;    //      }()&#xA;    //      fmt.Println(Add(ctx))&#xA;    //  }&#xA;    select {}&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;    &amp;quot;golang.org/x/net/context&amp;quot;&#xA;)&#xA;&#xA;// 模拟一个最小执行时间的阻塞函数&#xA;func inc(a int) int {&#xA;    res := a + 1                // 虽然我只做了一次简单的 +1 的运算,&#xA;    time.Sleep(1 * time.Second) // 但是由于我的机器指令集中没有这条指令,&#xA;    // 所以在我执行了 1000000000 条机器指令, 续了 1s 之后, 我才终于得到结果。B)&#xA;    return res&#xA;}&#xA;&#xA;// 向外部提供的阻塞接口&#xA;// 计算 a + b, 注意 a, b 均不能为负&#xA;// 如果计算被中断, 则返回 -1&#xA;func Add(ctx context.Context, a, b int) int {&#xA;    res := 0&#xA;    for i := 0; i &amp;lt; a; i++ {&#xA;        res = inc(res)&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            return -1&#xA;        default:&#xA;        // 没有结束 ... 执行 ...&#xA;        }&#xA;    }&#xA;    for i := 0; i &amp;lt; b; i++ {&#xA;        res = inc(res)&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            return -1&#xA;        default:&#xA;        // 没有结束 ... 执行 ...&#xA;        }&#xA;    }&#xA;    return res&#xA;}&#xA;&#xA;func main() {&#xA;    {&#xA;        // 使用开放的 API 计算 a+b&#xA;        a := 1&#xA;        b := 2&#xA;        timeout := 2 * time.Second&#xA;        ctx, _ := context.WithTimeout(context.Background(), timeout)&#xA;        res := Add(ctx, 1, 2)&#xA;        fmt.Printf(&amp;quot;Compute: %d+%d, result: %d\n&amp;quot;, a, b, res)&#xA;    }&#xA;    {&#xA;        // 手动取消&#xA;        a := 1&#xA;        b := 2&#xA;        ctx, cancel := context.WithCancel(context.Background())&#xA;        go func() {&#xA;            time.Sleep(2 * time.Second)&#xA;            cancel() // 在调用处主动取消&#xA;        }()&#xA;        res := Add(ctx, 1, 2)&#xA;        fmt.Printf(&amp;quot;Compute: %d+%d, result: %d\n&amp;quot;, a, b, res)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;声明：本文转自&lt;a href=&#34;http://www.01happy.com/golang-context-reading/有修改&#34;&gt;http://www.01happy.com/golang-context-reading/有修改&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之vendor的使用方法</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8Bvendor%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2016-06-07 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Golang之vendor的使用方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Go第三方包依赖和管理的问题由来已久，民间知名的解决方案就有 godep, gb 等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这次Go team在推出vendor前已经在Golang-dev group上做了长时间的调研,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最终Russ Cox在 Keith Rarick 的proposal的基础上做了改良,形成了Go 1.5中的vendor&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Go 1.5 中需要&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;export GO15VENDOREXPERIMENT=1 开启&lt;/li&gt;&#xA;&lt;li&gt;export GO15VENDOREXPERIMENT=0 关闭&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：Go 1.6 默认开启&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Russ Cox基于前期调研的结果，给出了vendor机制的群众意见基础：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不rewrite gopath&lt;/li&gt;&#xA;&lt;li&gt;go tool来解决&lt;/li&gt;&#xA;&lt;li&gt;go get兼容&lt;/li&gt;&#xA;&lt;li&gt;可reproduce building process&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方例&#xA;d/&#xA;    vendor/&#xA;          p/&#xA;            p.go&#xA;    mypkg/&#xA;          main.go&#xA;&#xA;// main.go&#xA;package main&#xA;import &amp;quot;p&amp;quot;&#xA;func main() {&#xA;    p.P()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pkg/&#xA;src/&#xA;    vendor/&#xA;        github.com/system/system.go(package system)&#xA;        github.com/system/socket.go(package socket)&#xA;    stat.go(import github.com/system/system)&#xA;    main.go(import github.com/system/socket)&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全局共享的import库放到GOPATH路径下&lt;/li&gt;&#xA;&lt;li&gt;项目独享的import放在vendor下&lt;/li&gt;&#xA;&lt;li&gt;需要发送或者打包的项目关联库放到项目的vendor下&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>jQuery之AJAX的使用方法</title>
      <link>http://www.nljb.net/default/jQuery%E4%B9%8BAJAX%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2016-05-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;jQuery之AJAX的使用方法&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;什么是 AJAX？&#xA;AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。&#xA;简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。&#xA;使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post&#xA;从远程服务器上请求文本、HTML、XML 或 JSON&#xA;同时您能够把这些外部数据直接载入网页的被选元素中。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;jQuery load()&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;load() 方法从服务器加载数据，并把返回的数据放入被选元素中。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$(selector).load(URL,data,callback);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必需的 URL 参数规定您希望加载的 URL。&lt;/li&gt;&#xA;&lt;li&gt;可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。&lt;/li&gt;&#xA;&lt;li&gt;可选的 callback 参数是 load() 方法完成后所执行的函数名称。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这是示例文件（&amp;quot;demo_test.txt&amp;quot;）的内容：&#xA;&amp;lt;h2&amp;gt;jQuery and AJAX is FUN!!!&amp;lt;/h2&amp;gt;&#xA;&amp;lt;p id=&amp;quot;p1&amp;quot;&amp;gt;This is some text in a paragraph.&amp;lt;/p&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下面的例子会把文件 &amp;quot;demo_test.txt&amp;quot; 的内容加载到指定的 &amp;lt;div&amp;gt; 元素中：&#xA;&amp;lt;script&amp;gt;&#xA;$(document).ready(function(){&#xA;  $(&amp;quot;#btn1&amp;quot;).click(function(){&#xA;    $(&#39;#test&#39;).load(&#39;/example/jquery/demo_test.txt&#39;);&#xA;  })&#xA;})&#xA;&amp;lt;/script&amp;gt;&#xA;&amp;lt;h3 id=&amp;quot;test&amp;quot;&amp;gt;请点击下面的按钮，通过 jQuery AJAX 改变这段文本。&amp;lt;/h3&amp;gt;&#xA;&amp;lt;button id=&amp;quot;btn1&amp;quot; type=&amp;quot;button&amp;quot;&amp;gt;获得外部的内容&amp;lt;/button&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 也可以把 jQuery 选择器添加到 URL 参数。&#xA;// 下面的例子把 &amp;quot;demo_test.txt&amp;quot; 文件中 id=&amp;quot;p1&amp;quot; 的元素的内容，加载到指定的 &amp;lt;div&amp;gt; 元素中：&#xA;$(document).ready(function(){&#xA;  $(&amp;quot;button&amp;quot;).click(function(){&#xA;    $(&amp;quot;#div1&amp;quot;).load(&amp;quot;/example/jquery/demo_test.txt #p1&amp;quot;);&#xA;  });&#xA;});&#xA;&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;&amp;lt;h2&amp;gt;使用 jQuery AJAX 来改变文本&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;button&amp;gt;获得外部内容&amp;lt;/button&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：&#xA;// responseTxt - 包含调用成功时的结果内容&#xA;// statusTXT - 包含调用的状态&#xA;// xhr - 包含 XMLHttpRequest 对象&#xA;$(document).ready(function(){&#xA;  $(&amp;quot;button&amp;quot;).click(function(){&#xA;    $(&amp;quot;#div1&amp;quot;).load(&amp;quot;/example/jquery/demo_test.txt&amp;quot;,function(responseTxt,statusTxt,xhr){&#xA;      if(statusTxt==&amp;quot;success&amp;quot;)&#xA;        alert(&amp;quot;外部内容加载成功！&amp;quot;);&#xA;      if(statusTxt==&amp;quot;error&amp;quot;)&#xA;        alert(&amp;quot;Error: &amp;quot;+xhr.status+&amp;quot;: &amp;quot;+xhr.statusText);&#xA;    });&#xA;  });&#xA;});&#xA;&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;&amp;lt;h2&amp;gt;使用 jQuery AJAX 来改变文本&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;button&amp;gt;获得外部内容&amp;lt;/button&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;HTTP 请求：GET vs. POST&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;两种在客户端和服务器端进行请求-响应的常用方法是：GET 和 POST。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GET - 从指定的资源请求数据&lt;/li&gt;&#xA;&lt;li&gt;POST - 向指定的资源提交要处理的数据&lt;/li&gt;&#xA;&lt;li&gt;GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。&lt;/li&gt;&#xA;&lt;li&gt;POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;jQuery get()&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.get() 方法通过 HTTP GET 请求从服务器上请求数据。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.get(URL,callback);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必需的 URL 参数规定您希望请求的 URL。&lt;/li&gt;&#xA;&lt;li&gt;可选的 callback 参数是请求成功后所执行的函数名。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：&#xA;// $.get() 的第一个参数是我们希望请求的 URL（&amp;quot;demo_test.asp&amp;quot;）。&#xA;// 第二个参数是回调函数。第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。&#xA;$(document).ready(function(){&#xA;  $(&amp;quot;button&amp;quot;).click(function(){&#xA;    $.get(&amp;quot;/example/jquery/demo_test.asp&amp;quot;,function(data,status){&#xA;      alert(&amp;quot;数据：&amp;quot; + data + &amp;quot;\n状态：&amp;quot; + status);&#xA;    });&#xA;  });&#xA;});&#xA;&amp;lt;button&amp;gt;向页面发送 HTTP GET 请求，然后获得返回的结果&amp;lt;/button&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;jQuery $.post()&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.post() 方法通过 HTTP POST 请求从服务器上请求数据。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.post(URL,data,callback);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必需的 URL 参数规定您希望请求的 URL。&lt;/li&gt;&#xA;&lt;li&gt;可选的 data 参数规定连同请求发送的数据。&lt;/li&gt;&#xA;&lt;li&gt;可选的 callback 参数是请求成功后所执行的函数名。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下面的例子使用 $.post() 连同请求一起发送数据：&#xA;// $.post() 的第一个参数是我们希望请求的 URL (&amp;quot;demo_test_post.asp&amp;quot;)。&#xA;// 然后我们连同请求（name 和 city）一起发送数据。&#xA;// &amp;quot;demo_test_post.asp&amp;quot; 中的 ASP 脚本读取这些参数，对它们进行处理，然后返回结果。&#xA;// 第三个参数是回调函数。第一个回调参数存有被请求页面的内容，而第二个参数存有请求的状态。&#xA;$(document).ready(function(){&#xA;  $(&amp;quot;button&amp;quot;).click(function(){&#xA;    $.post(&amp;quot;/example/jquery/demo_test_post.asp&amp;quot;,&#xA;    {&#xA;      name:&amp;quot;Donald Duck&amp;quot;,&#xA;      city:&amp;quot;Duckburg&amp;quot;&#xA;    },&#xA;    function(data,status){&#xA;      alert(&amp;quot;数据：&amp;quot; + data + &amp;quot;\n状态：&amp;quot; + status);&#xA;    });&#xA;  });&#xA;});&#xA;&amp;lt;button&amp;gt;向页面发送 HTTP POST 请求，并获得返回的结果&amp;lt;/button&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;jQuery $.getJSON()&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;jQuery.getJSON(url,data,success(data,status,xhr))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;url   必需。规定将请求发送的哪个 URL。&lt;/li&gt;&#xA;&lt;li&gt;data  可选。规定连同请求发送到服务器的数据。&lt;/li&gt;&#xA;&lt;li&gt;success(data,status,xhr) 可选。规定当请求成功时运行的函数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;success(data,status,xhr) 额外的参数：&lt;/li&gt;&#xA;&lt;li&gt;response - 包含来自请求的结果数据&lt;/li&gt;&#xA;&lt;li&gt;status - 包含请求的状态&lt;/li&gt;&#xA;&lt;li&gt;xhr - 包含 XMLHttpRequest 对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 例子&#xA;$(document).ready(function(){&#xA;  $(&amp;quot;button&amp;quot;).click(function(){&#xA;    $.getJSON(&amp;quot;/example/jquery/demo_ajax_json.js&amp;quot;,function(result){&#xA;      $.each(result, function(i, field){&#xA;        $(&amp;quot;p&amp;quot;).append(field + &amp;quot; &amp;quot;);&#xA;      });&#xA;    });&#xA;  });&#xA;});&#xA;&amp;lt;button&amp;gt;获得 JSON 数据&amp;lt;/button&amp;gt;&#xA;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 从 Flickr JSONP API 载入 4 张最新的关于猫的图片：&#xA;// HTML 代码：&#xA;&amp;lt;div id=&amp;quot;images&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;// jQuery 代码：&#xA;$.getJSON(&amp;quot;http://api.flickr.com/services/feeds/photos_public.gne?&#xA;tags=cat&amp;amp;tagmode=any&amp;amp;format=json&amp;amp;jsoncallback=?&amp;quot;, function(data){&#xA;  $.each(data.items, function(i,item){&#xA;    $(&amp;quot;&amp;lt;img/&amp;gt;&amp;quot;).attr(&amp;quot;src&amp;quot;, item.media.m).appendTo(&amp;quot;#images&amp;quot;);&#xA;    if ( i == 3 ) return false;&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 从 test.js 载入 JSON 数据，附加参数，显示 JSON 数据中一个 name 字段数据：&#xA;$.getJSON(&amp;quot;test.js&amp;quot;, { name: &amp;quot;John&amp;quot;, time: &amp;quot;2pm&amp;quot; }, function(json){&#xA;  alert(&amp;quot;JSON Data: &amp;quot; + json.users[3].name);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Evolver 项目所使用的 getJson()&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$(document).ready(function () {&#xA;    $(&amp;quot;#scan_btn&amp;quot;).click(function (e) {&#xA;        requestJSON(&amp;quot;/api/get/report&amp;quot;, {&amp;quot;mid&amp;quot;: $(&amp;quot;#scan_mid&amp;quot;).val()});&#xA;    });&#xA;    var today = $(&amp;quot;#today&amp;quot;);&#xA;    var aweek = $(&amp;quot;#aweek&amp;quot;);&#xA;    var li_today = $(&amp;quot;#li_today&amp;quot;);&#xA;    var li_aweek = $(&amp;quot;#li_aweek&amp;quot;);&#xA;    today.click(function (e) {&#xA;        li_today.removeClass();&#xA;        li_aweek.removeClass();&#xA;        li_today.addClass(&amp;quot;active&amp;quot;);&#xA;        requestJSON(&amp;quot;/api/get/report&amp;quot;, {&amp;quot;date&amp;quot;: &amp;quot;today&amp;quot;});&#xA;    });&#xA;    aweek.click(function (e) {&#xA;        li_today.removeClass();&#xA;        li_aweek.removeClass();&#xA;        li_aweek.addClass(&amp;quot;active&amp;quot;);&#xA;        requestJSON(&amp;quot;/api/get/report&amp;quot;, {&amp;quot;date&amp;quot;: &amp;quot;aweek&amp;quot;});&#xA;    });&#xA;    today.click();&#xA;});&#xA;&#xA;function requestJSON(addr, data) {&#xA;    $(&amp;quot;#lines_tbody&amp;quot;).html(&amp;quot;&amp;quot;);&#xA;    // 请求JSON数据&#xA;    $.getJSON(addr, data, function (json) {&#xA;        // 打印JSON数据&#xA;        console.log(JSON.stringify(json));&#xA;        if (json.ok) {&#xA;            var data = json.data;&#xA;            $(&amp;quot;#stats_danger&amp;quot;).text(&amp;quot;异常&amp;quot; + &amp;quot;（&amp;quot; + data.stats.danger + &amp;quot;）&amp;quot;);&#xA;            $(&amp;quot;#stats_warning&amp;quot;).text(&amp;quot;警告&amp;quot; + &amp;quot;（&amp;quot; + data.stats.warning + &amp;quot;）&amp;quot;);&#xA;            $(&amp;quot;#stats_default&amp;quot;).text(&amp;quot;正常&amp;quot; + &amp;quot;（&amp;quot; + data.stats.default + &amp;quot;）&amp;quot;);&#xA;            var lines = data.lines;&#xA;            $.each(lines, function (index, content) {&#xA;                var class_tr = &#39;&amp;lt;tr&amp;gt;&#39;;&#xA;                var class_lv = &amp;quot;正常状态&amp;quot;;&#xA;                var class_tm;&#xA;                if (content.level == 1) {&#xA;                    class_tr = &#39;&amp;lt;tr class=&amp;quot;warning&amp;quot;&amp;gt;&#39;;&#xA;                    class_lv = &amp;quot;警告状态&amp;quot;;&#xA;                }&#xA;                if (content.level == 2) {&#xA;                    class_tr = &#39;&amp;lt;tr class=&amp;quot;danger&amp;quot;&amp;gt;&#39;;&#xA;                    class_lv = &amp;quot;异常状态&amp;quot;;&#xA;                }&#xA;                if (content.timeout) {&#xA;                    class_tm = &#39;&amp;lt;span class=&amp;quot;label label-warning&amp;quot;&amp;gt;超时&amp;lt;/span&amp;gt;&#39;;&#xA;                } else {&#xA;                    class_tm = &#39;&amp;lt;span class=&amp;quot;label label-success&amp;quot;&amp;gt;有效&amp;lt;/span&amp;gt;&#39;;&#xA;                }&#xA;                if (content.process.xplay == &amp;quot;&amp;quot;) {&#xA;                    content.process.xplay = &amp;quot;error&amp;quot;;&#xA;                }&#xA;                if (content.process.peanut == &amp;quot;&amp;quot;) {&#xA;                    content.process.peanut = &amp;quot;error&amp;quot;;&#xA;                }&#xA;                if (content.process.watchdog == &amp;quot;&amp;quot;) {&#xA;                    content.process.watchdog = &amp;quot;error&amp;quot;;&#xA;                }&#xA;                if (content.process.x == &amp;quot;&amp;quot;) {&#xA;                    content.process.x = &amp;quot;error&amp;quot;;&#xA;                }&#xA;                $(&amp;quot;#lines_tbody&amp;quot;).append(&#xA;                    class_tr +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + content.id + &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + content.proxy + &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &#39;&amp;lt;td class=&amp;quot;dropdown&amp;quot;&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;a class=&amp;quot;dropdown-toggle&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot; href=&amp;quot;#&amp;quot;&amp;gt;&#39; +&#xA;                    class_lv +&#xA;                    &#39;&amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;/a&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot; aria-describedby=&amp;quot;dropdownMenu1&amp;quot;&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;li class=&amp;quot;text-center&amp;quot;&amp;gt;&#39; + &amp;quot;xplay(&amp;quot; + content.process.xplay + &#39;)&amp;lt;/li&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;li class=&amp;quot;text-center&amp;quot;&amp;gt;&#39; + &amp;quot;peanut(&amp;quot; + content.process.peanut + &#39;)&amp;lt;/li&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;li class=&amp;quot;text-center&amp;quot;&amp;gt;&#39; + &amp;quot;watchdog(&amp;quot; + content.process.watchdog + &#39;)&amp;lt;/li&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;li class=&amp;quot;text-center&amp;quot;&amp;gt;&#39; + &amp;quot;x-window(&amp;quot; + content.process.x + &#39;)&amp;lt;/li&amp;gt;&#39; +&#xA;                    &#39;&amp;lt;/ul&amp;gt;&#39; +&#xA;                    &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + content.pile + &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + content.uptime + &amp;quot;(H)&amp;quot; + &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + content.evolver_sleep + &amp;quot;(S)&amp;quot;+&amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + content.term_time + &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + content.create_time + &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;td&amp;gt;&amp;quot; + class_tm + &amp;quot;&amp;lt;/td&amp;gt;&amp;quot; +&#xA;                    &amp;quot;&amp;lt;/tr&amp;gt;&amp;quot;&#xA;                );&#xA;            });&#xA;        } else {&#xA;            console.log(json.data);&#xA;        }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之X11VNC通过VNC来连接服务器桌面</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8BX11VNC%E9%80%9A%E8%BF%87VNC%E6%9D%A5%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%8C%E9%9D%A2/</link>
      <pubDate>2016-05-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Linux之X11VNC通过VNC来连接服务器桌面&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;x11vnc是一个可以让管理员直接通过VNC Viewer来连接服务器的桌面工具&#xA;&#xA;需要安装：x11vnc&#xA;&#xA; | Name            | Summary                                 | Type&#xA; --+-----------------+-----------------------------------------+------------&#xA;   | X11VNC          | Connect to remote X display through VNC | application&#xA;   | X11VNC Server   | Share this desktop via VNC              | application&#xA; i | x11vnc          | VNC Server for Real X Displays          | package&#xA;   | x11vnc-frontend | Simple GUI Frontend to x11vnc           | package&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 启动脚本&#xA;&#xA;#!/bin/sh&#xA;&#xA;while true;&#xA;do&#xA;    AUTH_ID=`ps -ef | grep auth | grep -v grep | grep -v xinitrc | awk &#39;{print $11;}&#39;`&#xA;&#xA;    if [ &amp;quot;$AUTH_ID&amp;quot; = &amp;quot;&amp;quot; ]; then&#xA;        echo &amp;quot;Waiting for ready, retry 10s later...&amp;quot;&#xA;    else&#xA;        x11vnc -auth $AUTH_ID -display :0 -xdamage -xdamage -ncache_cr&#xA;    fi&#xA;&#xA;    sleep 10&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 执行脚本后，在任意电脑安装VNC Viewer即可登录, 端口号一般从5900开始 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之模版的基本使用</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E6%A8%A1%E7%89%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2016-05-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;说明：Go内置的模版引擎功能很单一，基本上就是个输出替换工具&#xA;如果：希望在模版中实现更多逻辑判断等... 推荐使用三方的引擎&#xA;&#xA;推荐：https://github.com/flosch/pongo2&#xA;原因：兼容Django模版，所以更容易学习&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;模版的使用&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// GO&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;html/template&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;runtime&amp;quot;&#xA;)&#xA;&#xA;// 主&#xA;func main() {&#xA;&#xA;    // 设置CPU核心数量&#xA;    runtime.GOMAXPROCS(runtime.NumCPU())&#xA;&#xA;    // 设置日志的结构&#xA;    log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime | log.Lmicroseconds)&#xA;&#xA;    // -------------------------------------------------------- //&#xA;&#xA;    http.Handle(&amp;quot;/css/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;&#xA;    http.Handle(&amp;quot;/js/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;&#xA;    http.Handle(&amp;quot;/files/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;&#xA;    http.Handle(&amp;quot;/images/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;&#xA;    // -------------------------------------------------------- //&#xA;&#xA;    http.HandleFunc(&amp;quot;/&amp;quot;, index)&#xA;&#xA;    // -------------------------------------------------------- //&#xA;&#xA;    // 建立监听&#xA;    if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;        // 踢出错误&#xA;        log.Panic(err)&#xA;    }&#xA;&#xA;}&#xA;&#xA;func index(w http.ResponseWriter, r *http.Request) {&#xA;&#xA;    // 解析参数&#xA;    r.ParseForm()&#xA;&#xA;    // 解析主页面&#xA;    t, err := template.ParseFiles(&amp;quot;template/default.html&amp;quot;)&#xA;    if err != nil {&#xA;        // 输出错误信息&#xA;        http.Error(w, err.Error(), 500)&#xA;        return&#xA;    }&#xA;&#xA;    // 数据推荐存在MAP中 ...&#xA;    data := make(map[string]interface{})&#xA;&#xA;    // String&#xA;    data[&amp;quot;Name&amp;quot;] = &amp;quot;nljb&amp;quot;&#xA;    data[&amp;quot;Email&amp;quot;] = &amp;quot;nljb@qq.com&amp;quot;&#xA;&#xA;    // 布尔&#xA;    data[&amp;quot;True&amp;quot;] = true&#xA;    data[&amp;quot;False&amp;quot;] = false&#xA;&#xA;    // 整型&#xA;    data[&amp;quot;Year&amp;quot;] = 35&#xA;&#xA;    // 结构体&#xA;    type User struct {&#xA;        Name string&#xA;        Pass string&#xA;    }&#xA;    data[&amp;quot;User&amp;quot;] = User{Name: &amp;quot;nljb&amp;quot;, Pass: &amp;quot;1234&amp;quot;}&#xA;&#xA;    // 列表&#xA;    data[&amp;quot;List&amp;quot;] = []int{1, 2, 3, 4, 5, 6, 7, 8}&#xA;&#xA;    // 列表结构体&#xA;    a := User{Name: &amp;quot;nljb&amp;quot;, Pass: &amp;quot;1234&amp;quot;}&#xA;    b := User{Name: &amp;quot;jbnl&amp;quot;, Pass: &amp;quot;4321&amp;quot;}&#xA;    data[&amp;quot;Structs&amp;quot;] = []User{a, b}&#xA;&#xA;    // 模版变量&#xA;    data[&amp;quot;var&amp;quot;] = &amp;quot;hello world !!!&amp;quot;&#xA;&#xA;    data[&amp;quot;maps&amp;quot;] = map[string]string{&amp;quot;name&amp;quot;: &amp;quot;golang&amp;quot;}&#xA;&#xA;    // 执行&#xA;    t.Execute(w, data)&#xA;&#xA;    // 返回&#xA;    return&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // HTML&#xA;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;&#xA;    &amp;lt;title&amp;gt;GOLANG&amp;lt;/title&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;Name -&amp;gt; [[.Name]] , Email: [[.Email]]&#xA;&amp;lt;br&amp;gt;&#xA;True -&amp;gt; [[.True]] , False: [[.False]]&#xA;&amp;lt;br&amp;gt;&#xA;Year -&amp;gt; [[.Year]]&#xA;&amp;lt;br&amp;gt;&#xA;[[if .True]]&#xA;IF Bool -&amp;gt; true&#xA;[[else]]&#xA;IF Bool -&amp;gt; flase&#xA;[[end]]&#xA;&amp;lt;br&amp;gt;&#xA;Range List -&amp;gt;&#xA;[[range .List]]&#xA;[[.]]&#xA;[[end]]&#xA;&amp;lt;br&amp;gt;&#xA;Struct -&amp;gt; [[.User.Name]] , [[.User.Pass]]&#xA;&amp;lt;br&amp;gt;&#xA;[[with .User]]&#xA;With Struct -&amp;gt; [[.Name]] , [[.Pass]]&#xA;[[else]]&#xA;[[ //* 当 User 为空时会执行这里 *//]]&#xA;[[end]]&#xA;&amp;lt;br&amp;gt;&#xA;Range Struct List -&amp;gt;&#xA;[[range .Structs]]&#xA;[[.Name]] - [[.Pass]] ;&#xA;[[end]]&#xA;&amp;lt;br&amp;gt;&#xA;[[$xxx := .var]]&#xA;Var -&amp;gt; [[$xxx]]&#xA;&amp;lt;br&amp;gt;&#xA;Printf -&amp;gt; [[.var | printf &amp;quot;%s&amp;quot;]]&#xA;&amp;lt;br&amp;gt;&#xA;Printf -&amp;gt; [[printf &amp;quot;Nums -&amp;gt; %s %d&amp;quot; (printf &amp;quot;%d %d&amp;quot; 1 2) 3]]&#xA;&amp;lt;br&amp;gt;&#xA;&amp;lt;!-- index 支持 map, slice, array, string，读取指定类型对应下标的值 --&amp;gt;&#xA;Index Map -&amp;gt; [[index .maps &amp;quot;name&amp;quot;]]&#xA;&amp;lt;br&amp;gt;&#xA;Len -&amp;gt; [[printf &amp;quot;The content length is %d&amp;quot; (.var|len)]]&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之获取上传文件大小</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>2016-05-09 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;获取上传文件大小&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;// 获取文件大小的接口&#xA;type Size interface {&#xA;    Size() int64&#xA;}&#xA;&#xA;// 获取文件信息的接口&#xA;type Stat interface {&#xA;    Stat() (os.FileInfo, error)&#xA;}&#xA;&#xA;// hello world, the web server&#xA;func HelloServer(w http.ResponseWriter, r *http.Request) {&#xA;    if &amp;quot;POST&amp;quot; == r.Method {&#xA;        file, _, err := r.FormFile(&amp;quot;userfile&amp;quot;)&#xA;        if err != nil {&#xA;            http.Error(w, err.Error(), 500)&#xA;            return&#xA;        }&#xA;&#xA;        if statInterface, ok := file.(Stat); ok {&#xA;            fileInfo, _ := statInterface.Stat()&#xA;            fmt.Fprintf(w, &amp;quot;上传文件的大小为: %d&amp;quot;, fileInfo.Size())&#xA;        }&#xA;        if sizeInterface, ok := file.(Size); ok {&#xA;            fmt.Fprintf(w, &amp;quot;上传文件的大小为: %d&amp;quot;, sizeInterface.Size())&#xA;        }&#xA;&#xA;        return&#xA;    }&#xA;&#xA;    // 上传页面&#xA;    w.Header().Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html&amp;quot;)&#xA;    w.WriteHeader(200)&#xA;    html := `&#xA;&amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;/hello&amp;quot; method=&amp;quot;POST&amp;quot;&amp;gt;&#xA;    Send this file: &amp;lt;input name=&amp;quot;userfile&amp;quot; type=&amp;quot;file&amp;quot; /&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Send File&amp;quot; /&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;`&#xA;    io.WriteString(w, html)&#xA;}&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/hello&amp;quot;, HelloServer)&#xA;    err := http.ListenAndServe(&amp;quot;:12345&amp;quot;, nil)&#xA;    if err != nil {&#xA;        log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>bootstrap</title>
      <link>http://www.nljb.net/default/bootstrap/</link>
      <pubDate>2016-05-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h5&gt;Bootstrap&lt;/h5&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 设置viewport --&amp;gt;&#xA;    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;&#xA;    &amp;lt;title&amp;gt;NLJB&amp;lt;/title&amp;gt;&#xA;    &amp;lt;!-- 引入框架 --&amp;gt;&#xA;    &amp;lt;script src=&amp;quot;js/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;    &amp;lt;script src=&amp;quot;js/bootstrap.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;    &amp;lt;!-- 引入样式 --&amp;gt;&#xA;    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;css/bootstrap.css&amp;quot;&amp;gt;&#xA;    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 自定义样式 --&amp;gt;&#xA;    &amp;lt;style&amp;gt;&#xA;        body {&#xA;            padding-top: 50px;&#xA;        }&#xA;&#xA;        .start {&#xA;            padding: 40px 15px;&#xA;            text-align: center;&#xA;        }&#xA;    &amp;lt;/style&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&amp;lt;!-- 导航条 --&amp;gt;&#xA;&amp;lt;!-- 样式： avbar-invers 和 navbar-default --&amp;gt;&#xA;&amp;lt;!-- 位置:  navbar-fixed-top 和 navbar-fixed-bottom --&amp;gt;&#xA;&amp;lt;nav class=&amp;quot;navbar navbar-inverse navbar-fixed-top&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 导航头部 navbar-header --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;navbar-header&amp;quot;&amp;gt;&#xA;            &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;navbar-brand&amp;quot;&amp;gt;NLJB&amp;lt;/a&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 导航项目 --&amp;gt;&#xA;        &amp;lt;!-- 选中状态 active --&amp;gt;&#xA;        &amp;lt;div id=&amp;quot;navbar&amp;quot; class=&amp;quot;collapse navbar-collapse&amp;quot;&amp;gt;&#xA;            &amp;lt;ul class=&amp;quot;nav navbar-nav&amp;quot; id=&amp;quot;mynav&amp;quot;&amp;gt;&#xA;                &amp;lt;li class=&amp;quot;active&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Home&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;About&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;/ul&amp;gt;&#xA;            &amp;lt;!-- 添加表单 --&amp;gt;&#xA;            &amp;lt;form class=&amp;quot;navbar-form navbar-left&amp;quot;&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;                    &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;搜索&amp;quot;&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;                &amp;lt;button type=&amp;quot;submit&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;搜索&amp;lt;/button&amp;gt;&#xA;            &amp;lt;/form&amp;gt;&#xA;            &amp;lt;!- 右对齐 --&amp;gt;&#xA;            &amp;lt;ul class=&amp;quot;nav navbar-nav navbar-right&amp;quot;&amp;gt;&#xA;                &amp;lt;li class=&amp;quot;dropdown&amp;quot;&amp;gt;&#xA;                    &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;dropdown-toggle&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot;&amp;gt;退出&#xA;                        &amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;                    &amp;lt;/a&amp;gt;&#xA;                    &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot;&amp;gt;&#xA;                        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;关于&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                    &amp;lt;/ul&amp;gt;&#xA;                &amp;lt;/li&amp;gt;&#xA;            &amp;lt;/ul&amp;gt;&#xA;            &amp;lt;ul class=&amp;quot;nav navbar-btn navbar-right &amp;quot;&amp;gt;&#xA;                &amp;lt;!-- 下拉菜单与按钮组合 --&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;btn-group&amp;quot;&amp;gt;&#xA;                    &amp;lt;button class=&amp;quot;btn btn-info dropdown-toggle&amp;quot; type=&amp;quot;button&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot;&amp;gt;&#xA;                        菜单&#xA;                        &amp;lt;!-- 向下箭头 --&amp;gt;&#xA;                        &amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;                    &amp;lt;/button&amp;gt;&#xA;                    &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot; aria-describedby=&amp;quot;dropdownMenu1&amp;quot;&amp;gt;&#xA;                        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;一&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;二&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                    &amp;lt;/ul&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;            &amp;lt;/ul&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/nav&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    $(&amp;quot;#mynav a&amp;quot;).click(function (e) {&#xA;        e.preventDefault()&#xA;        $(this).tab(&amp;quot;show&amp;quot;)&#xA;    })&#xA;&amp;lt;/script&amp;gt;&#xA;&amp;lt;!-- 页头 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;page-header&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;        &amp;lt;p&amp;gt;NLJB&amp;lt;/p&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 巨幕 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;jumbotron&amp;quot;&amp;gt;&#xA;        &amp;lt;h1&amp;gt;欢迎来到NLJB&amp;lt;/h1&amp;gt;&#xA;        &amp;lt;p&amp;gt;欢迎来到这个巨幕展示页面 .....&amp;lt;/p&amp;gt;&#xA;        &amp;lt;p&amp;gt;&amp;lt;a class=&amp;quot;btn btn-success&amp;quot;&amp;gt;详情&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 路径导航 --&amp;gt;&#xA;&amp;lt;nav class=&amp;quot;navbar navbar-default navbar-fixed-bottom&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;        &amp;lt;ol class=&amp;quot;breadcrumb&amp;quot;&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Home&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Lib&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Data&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ol&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/nav&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;h1&amp;gt;NLJB(h1)&amp;lt;/h1&amp;gt;&#xA;    &amp;lt;h2&amp;gt;NLJB(h2)&amp;lt;/h2&amp;gt;&#xA;    &amp;lt;h3&amp;gt;NLJB(h3)&amp;lt;/h3&amp;gt;&#xA;    &amp;lt;h4&amp;gt;NLJB(h4)&amp;lt;/h4&amp;gt;&#xA;    &amp;lt;!-- 小号字体 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;small&amp;gt;NLJB(small)&amp;lt;/small&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 标记 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;mark&amp;gt;NLJB(mark)&amp;lt;/mark&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 删除 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;del&amp;gt;NLJB(del)&amp;lt;/del&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 缩略语 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;abbr title=&amp;quot;attribute&amp;quot;&amp;gt;NLJB&amp;lt;/abbr&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 内联代码 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;code&amp;gt;for{ print(&amp;quot;NLJB&amp;quot;) }&amp;lt;/code&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 输入显示 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;kbd&amp;gt;cmd&amp;lt;/kbd&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 输入显示 --&amp;gt;&#xA;    &amp;lt;pre&amp;gt;&#xA;    for {&#xA;        print(NLJB)&#xA;    }&#xA;    &amp;lt;/pre&amp;gt;&#xA;    &amp;lt;!-- 变量输出 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;var&amp;gt;x&amp;lt;/var&amp;gt; = &amp;lt;var&amp;gt;a&amp;lt;/var&amp;gt; + &amp;lt;var&amp;gt;b&amp;lt;/var&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 输出显示 --&amp;gt;&#xA;    &amp;lt;p&amp;gt;&#xA;        &amp;lt;samp&amp;gt;# ifconfig&amp;lt;/samp&amp;gt;&#xA;    &amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 突出显示 --&amp;gt;&#xA;    &amp;lt;p class=&amp;quot;lead&amp;quot;&amp;gt;NLJB(lead)&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 相关 --&amp;gt;&#xA;    &amp;lt;p class=&amp;quot;text-left&amp;quot;&amp;gt;NLJB(text-left)&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p class=&amp;quot;text-right&amp;quot;&amp;gt;NLJB(text-right)&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p class=&amp;quot;text-center&amp;quot;&amp;gt;NLJB(text-center)&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p class=&amp;quot;text-lowercase&amp;quot;&amp;gt;NLJB(text-lowercase)&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p class=&amp;quot;text-uppercase&amp;quot;&amp;gt;nljb(text-uppercase)&amp;lt;/p&amp;gt;&#xA;    &amp;lt;p class=&amp;quot;text-capitalize&amp;quot;&amp;gt;nljb(text-capitalize)&amp;lt;/p&amp;gt;&#xA;    &amp;lt;!-- 无样式列表 --&amp;gt;&#xA;    &amp;lt;ul class=&amp;quot;list-unstyled&amp;quot;&amp;gt;&#xA;        &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;&#xA;        &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;&#xA;        &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 容器class必须为container --&amp;gt;&#xA;&amp;lt;!-- 容器 container-fluid（百分百最宽） --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;start&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 行（最多包含12列） --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 1 代表 1/12 --&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!--  行 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-2&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!--  行 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 偏移量 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1 col-lg-offset-2&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1 col-lg-offset-4&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-1 col-lg-offset-3&amp;quot;&amp;gt;col_md-1&amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 嵌套 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;row&amp;quot; style=&amp;quot;background-color: #5e5e5e&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-9&amp;quot; style=&amp;quot;background-color: #4cae4c&amp;quot;&amp;gt;&#xA;                One&#xA;                &amp;lt;div class=&amp;quot;row&amp;quot; style=&amp;quot;background-color: #5bc0de&amp;quot;&amp;gt;&#xA;                    &amp;lt;div class=&amp;quot;col-md-2&amp;quot;&amp;gt;A&amp;lt;/div&amp;gt;&#xA;                    &amp;lt;div class=&amp;quot;col-md-2&amp;quot;&amp;gt;B&amp;lt;/div&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 排序：从左到右用push  从右往左用pull --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-9 col-md-push-3&amp;quot; style=&amp;quot;background-color: #5e5e5e&amp;quot;&amp;gt;col_md-9&amp;lt;/div&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-3 col-md-pull-9&amp;quot; style=&amp;quot;background-color: #5bc0de&amp;quot;&amp;gt;col_md-3&amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 表格 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- table-striped 斑马线样式 --&amp;gt;&#xA;    &amp;lt;!-- table-bordered 边框 --&amp;gt;&#xA;    &amp;lt;!-- table-hover 鼠标悬停 --&amp;gt;&#xA;    &amp;lt;!-- table-condensed 紧凑型 --&amp;gt;&#xA;    &amp;lt;table class=&amp;quot;table table-striped table-bordered table-hover table-condensed&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 选中样式 --&amp;gt;&#xA;        &amp;lt;thead&amp;gt;&#xA;        &amp;lt;tr&amp;gt;&#xA;            &amp;lt;th&amp;gt;标题&amp;lt;/th&amp;gt;&#xA;            &amp;lt;th&amp;gt;标题&amp;lt;/th&amp;gt;&#xA;            &amp;lt;th&amp;gt;标题&amp;lt;/th&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;/thead&amp;gt;&#xA;        &amp;lt;tbody&amp;gt;&#xA;        &amp;lt;tr&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tr class=&amp;quot;active&amp;quot;&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tr class=&amp;quot;success&amp;quot;&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tr class=&amp;quot;info&amp;quot;&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tr class=&amp;quot;warning&amp;quot;&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tr class=&amp;quot;danger&amp;quot;&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;            &amp;lt;td&amp;gt;内容&amp;lt;/td&amp;gt;&#xA;        &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;/tbody&amp;gt;&#xA;    &amp;lt;/table&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 表单 --&amp;gt;&#xA;    &amp;lt;form role=&amp;quot;form&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- form-group 必须在 form 中　--&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 这个 label 必须存在 --&amp;gt;&#xA;            &amp;lt;!-- 可以通过 sr-only 隐藏 --&amp;gt;&#xA;            &amp;lt;label class=&amp;quot;sr-only&amp;quot;&amp;gt;隐 藏：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Text&amp;quot;&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;p&amp;gt;&amp;lt;label&amp;gt;文 件：&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&#xA;            &amp;lt;!-- 辅助文本 help-block --&amp;gt;&#xA;            &amp;lt;p class=&amp;quot;help-block&amp;quot;&amp;gt;选择需要上传的文件&amp;lt;/p&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;    &amp;lt;!-- 内联表单 form-control --&amp;gt;&#xA;    &amp;lt;!-- 内联表单的宽度是自适应的 --&amp;gt;&#xA;    &amp;lt;form class=&amp;quot;form-inline&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- type 可以指定输入的类型，比如 date email 等 --&amp;gt;&#xA;            &amp;lt;label&amp;gt;用 户：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;email&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Email&amp;quot;&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;label&amp;gt;密 码：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;password&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Password&amp;quot;&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot; style=&amp;quot;padding-top: 10px&amp;quot;&amp;gt;&#xA;    &amp;lt;form&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;label for=&amp;quot;name&amp;quot;&amp;gt;内 容：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;textarea class=&amp;quot;form-control&amp;quot; id=&amp;quot;name&amp;quot;&amp;gt;Hello&amp;lt;/textarea&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 水平表单 form-horizontal --&amp;gt;&#xA;    &amp;lt;!-- 使用栅格系统实现水平对齐 --&amp;gt;&#xA;    &amp;lt;form class=&amp;quot;form-horizontal&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;label class=&amp;quot;col-md-1 control-label&amp;quot;&amp;gt;用 户：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;email&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Email&amp;quot;&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;label class=&amp;quot;col-md-1 control-label&amp;quot;&amp;gt;密 码：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;password&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;Password&amp;quot;&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-4 col-md-offset-1&amp;quot;&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;checkbox&amp;quot;&amp;gt;&#xA;                    &amp;lt;label&amp;gt;&#xA;                        &amp;lt;input type=&amp;quot;checkbox&amp;quot;&amp;gt;记住密码&#xA;                    &amp;lt;/label&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;col-md-1 col-md-offset-2&amp;quot;&amp;gt;&#xA;                    &amp;lt;button type=&amp;quot;submit&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;登录&amp;lt;/button&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;col-md-1&amp;quot;&amp;gt;&#xA;                    &amp;lt;button type=&amp;quot;reset&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;取消&amp;lt;/button&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;form&amp;gt;&#xA;        &amp;lt;!-- 复选按钮 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;checkbox&amp;quot;&amp;gt;&#xA;            &amp;lt;label&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;checkbox&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;时间&#xA;            &amp;lt;/label&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;checkbox&amp;quot;&amp;gt;&#xA;            &amp;lt;label&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;checkbox&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;金钱&#xA;            &amp;lt;/label&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 单选按钮 --&amp;gt;&#xA;        &amp;lt;!-- name 必须相同 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;radio&amp;quot;&amp;gt;&#xA;            &amp;lt;label&amp;gt;&#xA;                &amp;lt;input name=&amp;quot;radio&amp;quot; type=&amp;quot;radio&amp;quot; checked&amp;gt;时间&#xA;            &amp;lt;/label&amp;gt;&#xA;            &amp;lt;label&amp;gt;&#xA;                &amp;lt;input name=&amp;quot;radio&amp;quot; type=&amp;quot;radio&amp;quot;&amp;gt;金钱&#xA;            &amp;lt;/label&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 下拉选项 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;col-md-3&amp;quot;&amp;gt;&#xA;            &amp;lt;label for=&amp;quot;select_one&amp;quot; class=&amp;quot;sr-only&amp;quot;&amp;gt;选 项：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;select id=&amp;quot;select_one&amp;quot; class=&amp;quot;form-control&amp;quot;&amp;gt;&#xA;                &amp;lt;option&amp;gt;时间&amp;lt;/option&amp;gt;&#xA;                &amp;lt;option&amp;gt;金钱&amp;lt;/option&amp;gt;&#xA;            &amp;lt;/select&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 全部显示 multiple --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;col-md-3&amp;quot;&amp;gt;&#xA;            &amp;lt;label for=&amp;quot;select_two&amp;quot; class=&amp;quot;sr-only&amp;quot;&amp;gt;菜 单：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;select multiple id=&amp;quot;select_two&amp;quot; class=&amp;quot;form-control&amp;quot;&amp;gt;&#xA;                &amp;lt;option&amp;gt;时间&amp;lt;/option&amp;gt;&#xA;                &amp;lt;option&amp;gt;金钱&amp;lt;/option&amp;gt;&#xA;            &amp;lt;/select&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 静态控件 form-control-static --&amp;gt;&#xA;&amp;lt;!-- 纯文本和 label 元素放置于同一行 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;form class=&amp;quot;form-horizontal&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;label class=&amp;quot;col-md-1 control-label&amp;quot;&amp;gt;Email：&amp;lt;/label&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;col-md-11&amp;quot;&amp;gt;&#xA;                &amp;lt;p class=&amp;quot;form-control-static&amp;quot;&amp;gt;email@example.com&amp;lt;/p&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 禁用 disabled --&amp;gt;&#xA;&amp;lt;!-- 只读 readonly --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;form&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;disabled&amp;quot; disabled&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;readonly&amp;quot; readonly&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 全部禁用 fieldset disabled --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;form&amp;gt;&#xA;        &amp;lt;fieldset disabled&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;fieldset&amp;quot;&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/fieldset&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 状态 --&amp;gt;&#xA;&amp;lt;!-- 图标 span --&amp;gt;&#xA;&amp;lt;!-- http://v3.bootcss.com/components/ --&amp;gt;&#xA;&amp;lt;!-- &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&amp;quot;&amp;gt; --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;form&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group has-warning has-feedback&amp;quot;&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;has-warning&amp;quot;&amp;gt;&#xA;            &amp;lt;span class=&amp;quot;glyphicon glyphicon-exclamation-sign form-control-feedback&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group has-success has-feedback&amp;quot;&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;has-success&amp;quot;&amp;gt;&#xA;            &amp;lt;span class=&amp;quot;glyphicon glyphicon-ok form-control-feedback&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;form-group has-error has-feedback&amp;quot;&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;has-error&amp;quot;&amp;gt;&#xA;            &amp;lt;span class=&amp;quot;glyphicon glyphicon-remove-circle form-control-feedback&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/form&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 按钮样式 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;default&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-info&amp;quot;&amp;gt;info&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-primary&amp;quot;&amp;gt;primary&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-success&amp;quot;&amp;gt;success&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-warning&amp;quot;&amp;gt;warning&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-link&amp;quot;&amp;gt;link&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-danger&amp;quot;&amp;gt;danger&amp;lt;/button&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 按钮大小 btn-lg btn-sm btn-xs--&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-info btn-lg&amp;quot;&amp;gt;info&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-info&amp;quot;&amp;gt;info&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-info btn-sm&amp;quot;&amp;gt;info&amp;lt;/button&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-info btn-xs&amp;quot;&amp;gt;info&amp;lt;/button&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 不同类型的按钮 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 通过 disabled=&amp;quot;disabled&amp;quot; 禁用 --&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-primary&amp;quot; disabled=&amp;quot;disabled&amp;quot;&amp;gt;primary&amp;lt;/button&amp;gt;&#xA;    &amp;lt;!-- 充满容器 btn-block --&amp;gt;&#xA;    &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;btn btn-warning btn-block&amp;quot; disabled=&amp;quot;disabled&amp;quot;&amp;gt;warning &amp;lt;/a&amp;gt;&#xA;    &amp;lt;input class=&amp;quot;btn btn-success&amp;quot; type=&amp;quot;button&amp;quot; value=&amp;quot;input&amp;quot;&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;img src=&amp;quot;http://static.bootcss.com/www/assets/img/codeguide.png&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;img-circle&amp;quot;&amp;gt;&#xA;    &amp;lt;img src=&amp;quot;http://static.bootcss.com/www/assets/img/codeguide.png&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;img-rounded&amp;quot;&amp;gt;&#xA;    &amp;lt;img src=&amp;quot;http://static.bootcss.com/www/assets/img/codeguide.png&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;img-responsive&amp;quot;&amp;gt;&#xA;    &amp;lt;img src=&amp;quot;http://static.bootcss.com/www/assets/img/codeguide.png&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;img-thumbnail&amp;quot;&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 下拉菜单--&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 右侧 pull-right --&amp;gt;&#xA;    &amp;lt;!-- 左侧 pull-left --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;dropdown pull-right&amp;quot;&amp;gt;&#xA;        &amp;lt;button class=&amp;quot;btn btn-default dropdown-toggle&amp;quot; type=&amp;quot;button&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot;&amp;gt;&#xA;            下拉菜单&#xA;            &amp;lt;!-- 向下箭头 --&amp;gt;&#xA;            &amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/button&amp;gt;&#xA;        &amp;lt;!-- 右侧 dropdown-menu-right --&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;dropdown-menu dropdown-menu-right&amp;quot; aria-describedby=&amp;quot;dropdownMenu1&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 标头 --&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;dropdown-header&amp;quot;&amp;gt;大写&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;一&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;二&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;!-- 不可用 --&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;disabled&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;三&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;四&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;!-- 标头 --&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;dropdown-header&amp;quot;&amp;gt;小写&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;!-- 不可用 --&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;disabled&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;4&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;!-- 分割线 --&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;divider&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;结束&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 按钮组 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 垂直 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;btn-group-vertical&amp;quot;&amp;gt;&#xA;        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-success&amp;quot;&amp;gt;左&amp;lt;/button&amp;gt;&#xA;        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-success&amp;quot;&amp;gt;中&amp;lt;/button&amp;gt;&#xA;        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-success&amp;quot;&amp;gt;右&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;!-- 默认水平 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;btn-group&amp;quot;&amp;gt;&#xA;        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-warning&amp;quot;&amp;gt;左&amp;lt;/button&amp;gt;&#xA;        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-warning&amp;quot;&amp;gt;中&amp;lt;/button&amp;gt;&#xA;        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-warning&amp;quot;&amp;gt;右&amp;lt;/button&amp;gt;&#xA;        &amp;lt;!-- 下拉菜单与按钮组合 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group&amp;quot;&amp;gt;&#xA;            &amp;lt;button class=&amp;quot;btn btn-info dropdown-toggle&amp;quot; type=&amp;quot;button&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot;&amp;gt;&#xA;                下拉菜单&#xA;                &amp;lt;!-- 向下箭头 --&amp;gt;&#xA;                &amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;            &amp;lt;/button&amp;gt;&#xA;            &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot; aria-describedby=&amp;quot;dropdownMenu1&amp;quot;&amp;gt;&#xA;                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;一&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;二&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;/ul&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;!-- 平局充满 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;btn-group btn-group-justified&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group&amp;quot;&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-danger&amp;quot;&amp;gt;左&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group&amp;quot;&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-danger&amp;quot;&amp;gt;中&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group&amp;quot;&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-danger&amp;quot;&amp;gt;右&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;!-- 按钮工具栏 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;btn-toolbar&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 按钮组的大小 btn-group-lg btn-group-sm btn-group-xs --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group btn-group-lg&amp;quot;&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;glyphicon glyphicon-trash&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;glyphicon glyphicon-repeat&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group&amp;quot;&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;glyphicon glyphicon-align-right&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group btn-group-sm&amp;quot;&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;glyphicon glyphicon-volume-up&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;glyphicon glyphicon-font&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;glyphicon glyphicon-plus-sign&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;btn-group btn-group-xs&amp;quot;&amp;gt;&#xA;            &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;glyphicon glyphicon-align-right&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 分列式下拉菜单 + 按钮组 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 按钮组 --&amp;gt;&#xA;    &amp;lt;!-- 向上箭头 dropup --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;btn-group dropup&amp;quot;&amp;gt;&#xA;        &amp;lt;button class=&amp;quot;btn btn-default&amp;quot; type=&amp;quot;button&amp;quot;&amp;gt;下拉菜单&amp;lt;/button&amp;gt;&#xA;        &amp;lt;button class=&amp;quot;btn btn-info dropdown-toggle&amp;quot; type=&amp;quot;button&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 向下箭头 --&amp;gt;&#xA;            &amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/button&amp;gt;&#xA;        &amp;lt;!-- 右侧 dropdown-menu-right --&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot; aria-describedby=&amp;quot;dropdownMenu1&amp;quot;&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;一&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;二&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 输入框组 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;&#xA;        &amp;lt;span class=&amp;quot;input-group-addon&amp;quot;&amp;gt;@&amp;lt;/span&amp;gt;&#xA;        &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;UserNmae&amp;quot;&amp;gt;&#xA;        &amp;lt;span class=&amp;quot;input-group-addon&amp;quot;&amp;gt;.00&amp;lt;/span&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;!-- 尺寸可调节 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;input-group input-group-sm&amp;quot;&amp;gt;&#xA;        &amp;lt;span class=&amp;quot;input-group-addon&amp;quot;&amp;gt;@&amp;lt;/span&amp;gt;&#xA;        &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;UserNmae&amp;quot;&amp;gt;&#xA;        &amp;lt;span class=&amp;quot;input-group-addon&amp;quot;&amp;gt;.00&amp;lt;/span&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 位置大小 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 多选复选的输入框 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;col-md-3&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;&#xA;                  &amp;lt;span class=&amp;quot;input-group-addon&amp;quot;&amp;gt;&#xA;                    &amp;lt;label for=&amp;quot;in&amp;quot;&amp;gt;&amp;lt;/label&amp;gt;&#xA;                    &amp;lt;input id=&amp;quot;in&amp;quot; type=&amp;quot;radio&amp;quot;&amp;gt;&#xA;                &amp;lt;/span&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;UserNmae&amp;quot;&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 带按钮的输入框 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;col-md-3 col-lg-offset-1&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;&#xA;                  &amp;lt;span class=&amp;quot;input-group-btn&amp;quot;&amp;gt;&#xA;                      &amp;lt;button class=&amp;quot;btn btn-default&amp;quot; type=&amp;quot;button&amp;quot;&amp;gt;@&amp;lt;/button&amp;gt;&#xA;                &amp;lt;/span&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;UserNmae&amp;quot;&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 下拉菜单的输入框 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;col-md-3 col-lg-offset-1&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;input-group&amp;quot;&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;input-group-btn&amp;quot;&amp;gt;&#xA;                    &amp;lt;button class=&amp;quot;btn btn-info dropdown-toggle&amp;quot; type=&amp;quot;button&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot;&amp;gt;&#xA;                        下拉菜单&#xA;                        &amp;lt;!-- 向下箭头 --&amp;gt;&#xA;                        &amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;                    &amp;lt;/button&amp;gt;&#xA;                    &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot; aria-describedby=&amp;quot;dropdownMenu1&amp;quot;&amp;gt;&#xA;                        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;一&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;二&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                    &amp;lt;/ul&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; placeholder=&amp;quot;UserNmae&amp;quot;&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 导航页 --&amp;gt;&#xA;&amp;lt;!-- 样式 nav-tabs nav-pills --&amp;gt;&#xA;&amp;lt;!-- 垂直显示 nav-stacked --&amp;gt;&#xA;&amp;lt;!-- 充满全屏 nav-justified --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;ul id=&amp;quot;mytab&amp;quot; class=&amp;quot;nav nav-tabs nav-justified&amp;quot;&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;active&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;新闻&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;dropdown&amp;quot;&amp;gt;&#xA;            &amp;lt;a class=&amp;quot;dropdown-toggle&amp;quot; data-toggle=&amp;quot;dropdown&amp;quot; href=&amp;quot;#&amp;quot;&amp;gt;&#xA;                影视&#xA;                &amp;lt;span class=&amp;quot;caret&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;            &amp;lt;/a&amp;gt;&#xA;            &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot; aria-describedby=&amp;quot;dropdownMenu1&amp;quot;&amp;gt;&#xA;                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;一&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;二&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;/ul&amp;gt;&#xA;        &amp;lt;/li&amp;gt;&#xA;        &amp;lt;!-- 不可点击 --&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;disabled&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;体育&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    $(&amp;quot;#mytab a&amp;quot;).click(function (e) {&#xA;        e.preventDefault()&#xA;        $(this).tab(&amp;quot;show&amp;quot;)&#xA;    })&#xA;&amp;lt;/script&amp;gt;&#xA;&amp;lt;!-- 媒体组件 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;media&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 居左显示图像 --&amp;gt;&#xA;        &amp;lt;!-- 图像位置 media-bottom（居底） media-middle（居中） --&amp;gt;&#xA;        &amp;lt;a class=&amp;quot;media-left media-middle&amp;quot;&amp;gt;&#xA;            &amp;lt;img src=&amp;quot;http://www.iconpng.com/png/gnome-desktop/applications-office.png&amp;quot;&amp;gt;&#xA;        &amp;lt;/a&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;media-body&amp;quot;&amp;gt;&#xA;            &amp;lt;h5 class=&amp;quot;media-heading&amp;quot;&amp;gt;标题&amp;lt;/h5&amp;gt;&#xA;            &amp;lt;p&amp;gt;内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&amp;lt;/p&amp;gt;&#xA;            &amp;lt;!-- 媒体子项 --&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;media&amp;quot;&amp;gt;&#xA;                &amp;lt;a class=&amp;quot;media-left&amp;quot;&amp;gt;&#xA;                    &amp;lt;img src=&amp;quot;http://www.iconpng.com/png/gnome-desktop/applications-office.png&amp;quot;&amp;gt;&#xA;                &amp;lt;/a&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;media-body&amp;quot;&amp;gt;&#xA;                    &amp;lt;h5 class=&amp;quot;media-heading&amp;quot;&amp;gt;标题&amp;lt;/h5&amp;gt;&#xA;                    &amp;lt;p&amp;gt;内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&amp;lt;/p&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;media&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;media-body&amp;quot;&amp;gt;&#xA;            &amp;lt;h5 class=&amp;quot;media-heading&amp;quot;&amp;gt;标题&amp;lt;/h5&amp;gt;&#xA;            &amp;lt;p&amp;gt;内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&amp;lt;/p&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 居右显示图像 --&amp;gt;&#xA;        &amp;lt;a class=&amp;quot;media-right&amp;quot;&amp;gt;&#xA;            &amp;lt;img src=&amp;quot;http://www.iconpng.com/png/gnome-desktop/applications-office.png&amp;quot;&amp;gt;&#xA;        &amp;lt;/a&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 媒体组件列表 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;ul class=&amp;quot;media-list&amp;quot;&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;media&amp;quot;&amp;gt;&#xA;            &amp;lt;a class=&amp;quot;media-left&amp;quot;&amp;gt;&#xA;                &amp;lt;img src=&amp;quot;http://www.iconpng.com/png/gnome-desktop/applications-office.png&amp;quot;&amp;gt;&#xA;            &amp;lt;/a&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;media-body&amp;quot;&amp;gt;&#xA;                &amp;lt;h5 class=&amp;quot;media-heading&amp;quot;&amp;gt;标题&amp;lt;/h5&amp;gt;&#xA;                &amp;lt;p&amp;gt;内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&amp;lt;/p&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 面板 --&amp;gt;&#xA;&amp;lt;!-- 面板颜色 panel-info panel-warning panel-success --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;panel panel-default panel-warning&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-heading&amp;quot;&amp;gt;&#xA;            标题&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 盒子 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-body&amp;quot;&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 标注 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-footer panel-info&amp;quot;&amp;gt;&#xA;            www.nljb.net（标注）&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 面板表格 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;panel panel-default panel-warning&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-heading&amp;quot;&amp;gt;&#xA;            标题&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 盒子 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-body&amp;quot;&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;            Hello World !!!&amp;lt;br&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 表格 --&amp;gt;&#xA;        &amp;lt;table class=&amp;quot;table&amp;quot;&amp;gt;&#xA;            &amp;lt;thead&amp;gt;&#xA;            &amp;lt;tr class=&amp;quot;active&amp;quot;&amp;gt;&#xA;                &amp;lt;th&amp;gt;表格标题&amp;lt;/th&amp;gt;&#xA;                &amp;lt;th&amp;gt;表格标题&amp;lt;/th&amp;gt;&#xA;                &amp;lt;th&amp;gt;表格标题&amp;lt;/th&amp;gt;&#xA;                &amp;lt;th&amp;gt;表格标题&amp;lt;/th&amp;gt;&#xA;            &amp;lt;/tr&amp;gt;&#xA;            &amp;lt;/thead&amp;gt;&#xA;            &amp;lt;tbody&amp;gt;&#xA;            &amp;lt;tr class=&amp;quot;success&amp;quot;&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;            &amp;lt;/tr&amp;gt;&#xA;            &amp;lt;tr class=&amp;quot;success&amp;quot;&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;            &amp;lt;/tr&amp;gt;&#xA;            &amp;lt;tr class=&amp;quot;success&amp;quot;&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;                &amp;lt;td&amp;gt;表格单元格&amp;lt;/td&amp;gt;&#xA;            &amp;lt;/tr&amp;gt;&#xA;            &amp;lt;/tbody&amp;gt;&#xA;        &amp;lt;/table&amp;gt;&#xA;        &amp;lt;!-- 标注 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-footer panel-info&amp;quot;&amp;gt;&#xA;            www.nljb.net&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;style&amp;gt;&#xA;    .table th, .table td {&#xA;        text-align: center;&#xA;    }&#xA;&amp;lt;/style&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;panel panel-default&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-heading&amp;quot;&amp;gt;&#xA;            标题&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 盒子 --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;panel-body&amp;quot;&amp;gt;&#xA;            Hello World !!!&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;!-- 列表 --&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;list-group&amp;quot;&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;list-group-item&amp;quot;&amp;gt;World !!!&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;list-group-item&amp;quot;&amp;gt;World !!!&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;list-group-item&amp;quot;&amp;gt;World !!!&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;list-group-item&amp;quot;&amp;gt;World !!!&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- Well 组件 --&amp;gt;&#xA;&amp;lt;!-- 内容凹陷效果 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!--&amp;lt;div class=&amp;quot;embed-responsive embed-responsive-16by9&amp;quot;&amp;gt;--&amp;gt;&#xA;    &amp;lt;!--&amp;lt;iframe class=&amp;quot;embed-responsive-item&amp;quot; src=&amp;quot;http://www.baidu.com&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;--&amp;gt;&#xA;    &amp;lt;!--&amp;lt;/div&amp;gt;--&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;well well-sm&amp;quot;&amp;gt;&#xA;        Hello World （Well）!!!&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 分页 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;nav&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;pagination pagination-lg&amp;quot;&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;disabled&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;amp;laquo;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;4&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;active&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;pagination&amp;quot;&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;disabled&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;amp;laquo;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;4&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;active&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;pagination pagination-sm&amp;quot;&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;disabled&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;amp;laquo;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;4&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;active&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;/nav&amp;gt;&#xA;    &amp;lt;nav&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;pager&amp;quot;&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;下一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;上一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;        &amp;lt;ul class=&amp;quot;pager&amp;quot;&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;previous&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;向前&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;            &amp;lt;li class=&amp;quot;next&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;向后&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;/nav&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 标签 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;span class=&amp;quot;label label-default&amp;quot;&amp;gt;标签&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span class=&amp;quot;label label-primary&amp;quot;&amp;gt;标签&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span class=&amp;quot;label label-info&amp;quot;&amp;gt;标签&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span class=&amp;quot;label label-warning&amp;quot;&amp;gt;标签&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span class=&amp;quot;label label-danger&amp;quot;&amp;gt;标签&amp;lt;/span&amp;gt;&#xA;    &amp;lt;span class=&amp;quot;label label-success&amp;quot;&amp;gt;标签&amp;lt;/span&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 徽章 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Message&amp;amp;nbsp;&amp;lt;span class=&amp;quot;badge&amp;quot;&amp;gt;30&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-success&amp;quot;&amp;gt;Message&amp;amp;nbsp;&amp;lt;span class=&amp;quot;badge&amp;quot;&amp;gt;30&amp;lt;/span&amp;gt;&amp;lt;/button&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 缩略图 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;thumbnail&amp;quot;&amp;gt;&#xA;                &amp;lt;img src=&amp;quot;http://www.iconpng.com/png/gnome-desktop/applications-office.png&amp;quot;&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;caption&amp;quot;&amp;gt;&#xA;                    &amp;lt;h3&amp;gt;（缩略图）&amp;lt;/h3&amp;gt;&#xA;                    &amp;lt;p&amp;gt;内容内容内容&amp;lt;/p&amp;gt;&#xA;                    &amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;btn btn-primary&amp;quot;&amp;gt;确定&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 警告框 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;alert alert-success&amp;quot;&amp;gt;&#xA;        Hello （警告框） !!!&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;alert alert-danger&amp;quot;&amp;gt;&#xA;        Hello （警告框） !!!&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;alert alert-warning&amp;quot;&amp;gt;&#xA;        Hello （警告框） !!!&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;alert alert-danger&amp;quot;&amp;gt;&#xA;        Hello （警告框） !!!&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 可关闭的警告框 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;alert alert-success&amp;quot;&amp;gt;&#xA;        Hello 大家好（警告框） !!!&#xA;        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;alert-link&amp;quot;&amp;gt;（链接）&amp;lt;/a&amp;gt;&#xA;        &amp;lt;button class=&amp;quot;close&amp;quot; type=&amp;quot;button&amp;quot; data-dismiss=&amp;quot;alert&amp;quot;&amp;gt;&#xA;            &amp;lt;span aria-disabled=&amp;quot;true&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/button&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 进度条 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;progress&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 条纹效果 progress-bar-striped --&amp;gt;&#xA;        &amp;lt;!-- 动画效果 active --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;progress-bar progress-bar-striped active&amp;quot; aria-valuemin=&amp;quot;10&amp;quot; aria-valuenow=&amp;quot;50&amp;quot; aria-valuemax=&amp;quot;100&amp;quot;&#xA;             style=&amp;quot;width: 60%&amp;quot;&amp;gt;&#xA;            &amp;lt;span&amp;gt;60%&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;progress&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;progress-bar progress-bar-info&amp;quot; aria-valuemin=&amp;quot;10&amp;quot; aria-valuenow=&amp;quot;50&amp;quot; aria-valuemax=&amp;quot;100&amp;quot;&#xA;             style=&amp;quot;width: 60%&amp;quot;&amp;gt;&#xA;            &amp;lt;span&amp;gt;60%&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;progress&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;progress-bar progress-bar-danger&amp;quot; aria-valuemin=&amp;quot;10&amp;quot; aria-valuenow=&amp;quot;50&amp;quot; aria-valuemax=&amp;quot;100&amp;quot;&#xA;             style=&amp;quot;width: 60%&amp;quot;&amp;gt;&#xA;            &amp;lt;span&amp;gt;60%&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;progress&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;progress-bar progress-bar-success&amp;quot; aria-valuemin=&amp;quot;10&amp;quot; aria-valuenow=&amp;quot;50&amp;quot; aria-valuemax=&amp;quot;100&amp;quot;&#xA;             style=&amp;quot;width: 60%&amp;quot;&amp;gt;&#xA;            &amp;lt;span&amp;gt;60%&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;progress&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;progress-bar&amp;quot; style=&amp;quot;width: 30%&amp;quot;&amp;gt;&#xA;            &amp;lt;span&amp;gt;30%&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;progress-bar progress-bar-warning progress-bar-striped&amp;quot; aria-valuemin=&amp;quot;10&amp;quot; aria-valuenow=&amp;quot;50&amp;quot;&#xA;             aria-valuemax=&amp;quot;100&amp;quot; style=&amp;quot;width: 60%&amp;quot;&amp;gt;&#xA;            &amp;lt;span&amp;gt;60%&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 列表组 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 不可点击 --&amp;gt;&#xA;    &amp;lt;ul class=&amp;quot;list-group&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 徽章提示 --&amp;gt;&#xA;        &amp;lt;!-- 状态颜色 --&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;list-group-item list-group-item-info&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;badge&amp;quot;&amp;gt;10&amp;lt;/span&amp;gt;列表组&amp;lt;/li&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;list-group-item list-group-item-warning&amp;quot;&amp;gt;列表组&amp;lt;/li&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;list-group-item list-group-item-danger&amp;quot;&amp;gt;列表组&amp;lt;/li&amp;gt;&#xA;        &amp;lt;li class=&amp;quot;list-group-item list-group-item-success&amp;quot;&amp;gt;列表组&amp;lt;/li&amp;gt;&#xA;    &amp;lt;/ul&amp;gt;&#xA;    &amp;lt;!-- 可以点击的 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;list-group&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 比如禁用 disabled --&amp;gt;&#xA;        &amp;lt;!--比如选中 active --&amp;gt;&#xA;        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;list-group-item disabled&amp;quot;&amp;gt;可点击列表组&amp;lt;/a&amp;gt;&#xA;        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;list-group-item list-group-item-success active&amp;quot;&amp;gt;可点击列表组&amp;lt;/a&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;!-- 定制信息 --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;list-group&amp;quot;&amp;gt;&#xA;        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;list-group-item disabled&amp;quot;&amp;gt;&#xA;            &amp;lt;h4 class=&amp;quot;list-group-item-heading&amp;quot;&amp;gt;列表组&amp;lt;/h4&amp;gt;&#xA;            &amp;lt;p class=&amp;quot;list-group-item-text&amp;quot;&amp;gt;这里是内容 ...&amp;lt;/p&amp;gt;&#xA;        &amp;lt;/a&amp;gt;&#xA;        &amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;list-group-item list-group-item-success active&amp;quot;&amp;gt;&#xA;            &amp;lt;h4 class=&amp;quot;list-group-item-heading&amp;quot;&amp;gt;列表组&amp;lt;/h4&amp;gt;&#xA;            &amp;lt;p class=&amp;quot;list-group-item-text&amp;quot;&amp;gt;这里是内容 ...&amp;lt;/p&amp;gt;&amp;lt;/a&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;!-- 模态框 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- 过度效果：fade --&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;modal fade&amp;quot; id=&amp;quot;modal&amp;quot; tabindex=&amp;quot;-1&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 大小：modal-sm modal-lg --&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;modal-dialog modal-lg&amp;quot;&amp;gt;&#xA;            &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;modal-header&amp;quot;&amp;gt;&#xA;                    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;close&amp;quot; data-dismiss=&amp;quot;modal&amp;quot; aria-label=&amp;quot;Close&amp;quot;&amp;gt;&#xA;                        &amp;lt;span aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;amp;times;&amp;lt;/span&amp;gt;&#xA;                    &amp;lt;/button&amp;gt;&#xA;                    &amp;lt;h4 class=&amp;quot;modal-title&amp;quot;&amp;gt;欢迎来到NLJB&amp;lt;/h4&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;modal-body&amp;quot;&amp;gt;&#xA;                    Content&#xA;                    &amp;lt;form&amp;gt;&#xA;                        &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;&#xA;                            &amp;lt;label for=&amp;quot;myinput&amp;quot;&amp;gt;Form&amp;lt;/label&amp;gt;&#xA;                            &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;myinput&amp;quot;&amp;gt;&#xA;                        &amp;lt;/div&amp;gt;&#xA;                    &amp;lt;/form&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;                &amp;lt;div class=&amp;quot;modal-footer&amp;quot;&amp;gt;&#xA;                    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default&amp;quot; data-dismiss=&amp;quot;modal&amp;quot;&amp;gt;Close&amp;lt;/button&amp;gt;&#xA;                    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-success&amp;quot; data-dismiss=&amp;quot;modal&amp;quot;&amp;gt;Save&amp;lt;/button&amp;gt;&#xA;                &amp;lt;/div&amp;gt;&#xA;            &amp;lt;/div&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-success&amp;quot; data-toggle=&amp;quot;modal&amp;quot; data-target=&amp;quot;#modal&amp;quot; data-whatever=&amp;quot;NLJB&amp;quot;&amp;gt;模态框&amp;lt;/button&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    $(&amp;quot;#modal&amp;quot;).on(&amp;quot;show.bs.modal&amp;quot;,function (event) {&#xA;        var button = $(event.relatedTarget)&#xA;        var rrr = button.data(&amp;quot;whatever&amp;quot;)&#xA;        var modal = $(this);&#xA;        modal.find(&amp;quot;.modal-title&amp;quot;).text(rrr)&#xA;        modal.find(&amp;quot;.modal-body input&amp;quot;).val(rrr)&#xA;    })&#xA;&amp;lt;/script&amp;gt;&#xA;&amp;lt;!-- 地址信息 --&amp;gt;&#xA;&amp;lt;div class=&amp;quot;container&amp;quot; style=&amp;quot;padding-top: 50px&amp;quot;&amp;gt;&#xA;    &amp;lt;address class=&amp;quot;pull-right&amp;quot;&amp;gt;&#xA;        &amp;lt;strong&amp;gt;NLJB&amp;lt;/strong&amp;gt;&amp;lt;br&amp;gt;&#xA;        www.nljb.net&amp;lt;br&amp;gt;&#xA;        北京市海淀区上地&#xA;    &amp;lt;/address&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之程道传递浅拷贝所出现的问题</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E7%A8%8B%E9%81%93%E4%BC%A0%E9%80%92%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%89%80%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>2016-04-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h5&gt;程道传递浅拷贝&lt;/h5&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;&lt;em&gt;下面这个例子看来没有什么问题，但是当发送数据时问题就出现了&lt;/em&gt;&lt;/strong&gt;*&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解释一下：&#xA;当发送的[]byte通过buf[0:n]方式获取的浅拷贝只是个原buf的指针&#xA;当发送到程道内后被接收到的也是个指针，而且该指针指向的数据已经被&#xA;下一次读取的数据所覆盖，所以问题就出现了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存&#xA;而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建一个程道&#xA;c = make(chan []byte)&#xA;&#xA;buf := make([]byte, 100)&#xA;for {&#xA;&#xA;    // 读取数据&#xA;    n, _ := socket.Read(buf)&#xA;&#xA;    // 发送到程道&#xA;    c &amp;lt;- buf[0:n]&#xA;&#xA;}&#xA;&#xA;// 接收程道数据&#xA;x := &amp;lt;- c&#xA;fmt.Printf(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如何解决：&#xA;该如何解决这个问题呢，有人会这样做string(buf[0:n])转换后再发送，这样其实跟深层拷贝类似，转换成一个新的对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 或者可以这样来:(深拷贝数据后发送)&#xA;x := make([]byte, nr)&#xA;copy(x, buf[0:nr])&#xA;c &amp;lt;- x&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之获取视频缩略图</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE/</link>
      <pubDate>2016-04-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之获取视频缩略图&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * 获取视频缩略图&#xA; *&#xA; * @param app&#xA; * @param fdir&#xA; * @param fname&#xA; * @return&#xA; */&#xA;public Bitmap getVideoThumbnailByExternal(String app, String fdir, String fname) {&#xA;    File dir = Environment.getExternalStorageDirectory();&#xA;    Log.d(&amp;quot;Get Video Thumbnail -&amp;gt;&amp;quot;, String.format(&amp;quot;%s/%s/%s/%s&amp;quot;, dir, app, fdir, fname));&#xA;    Bitmap bitmap = null;&#xA;    MediaMetadataRetriever retriever = new MediaMetadataRetriever();&#xA;    try {&#xA;        retriever.setDataSource(String.format(&amp;quot;%s/%s/%s/%s&amp;quot;, dir, app, fdir, fname));&#xA;        // 可以指定具体时间的缩略图 ...&#xA;        bitmap = retriever.getFrameAtTime();&#xA;    } catch (IllegalArgumentException e) {&#xA;        e.printStackTrace();&#xA;    } catch (RuntimeException e) {&#xA;        e.printStackTrace();&#xA;    } finally {&#xA;        try {&#xA;            retriever.release();&#xA;        } catch (RuntimeException e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;    }&#xA;    return bitmap;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Win10之卸载不需要的内置应用</title>
      <link>http://www.nljb.net/default/Win10%E4%B9%8B%E5%8D%B8%E8%BD%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/</link>
      <pubDate>2016-04-15 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Win10之卸载不需要的内置应用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;对于通过Windows商店安装的应用，可以直接在开始菜单的磁贴上右键选择“卸载”命令来移除&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;但这个方法对照片、音乐、OneNote、相机等Win10预装应用无效，因为你找不到“卸载”这个选项&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;不过微软并未真正封堵卸载的途径，用户仍可以通过PowerShell这个系统工具以命令行方式卸载预装应用&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;细步骤如下&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以管理员身份运行 Cmd 并执行 powershell&lt;/li&gt;&#xA;&lt;li&gt;查看安装应用 Get-AppxPackage&lt;/li&gt;&#xA;&lt;li&gt;卸载包含应用 Get-Appxpackage &lt;em&gt;onenote&lt;/em&gt; | Remove-AppxPackage&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  // 日历、邮件&#xA;  get-appxpackage *communicationsapps* | remove-appxpackage&#xA;&#xA;  // 人脉&#xA;  get-appxpackage *people* | remove-appxpackage&#xA;&#xA;  // Groove 音乐&#xA;  get-appxpackage *zunemusic* | remove-appxpackage&#xA;&#xA;  // 电影和电视&#xA;  get-appxpackage *zunevideo* | remove-appxpackage&#xA;&#xA;  ·命令 get-appxpackage *zune* | remove-appxpackage 可以同时删除上两项&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  // 财经&#xA;  get-appxpackage *bingfinance* | remove-appxpackage&#xA;&#xA;  // 资讯&#xA;  get-appxpackage *bingnews* | remove-appxpackage&#xA;&#xA;  // 体育&#xA;  get-appxpackage *bingsports* | remove-appxpackage&#xA;&#xA;  // 天气&#xA;  get-appxpackage *bingweather* | remove-appxpackage&#xA;&#xA;  ·命令 get-appxpackage *bing* | remove-appxpackage 可同时删除上述四项&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  // OneNote&#xA;  get-appxpackage *onenote* | remove-appxpackage&#xA;&#xA;  // 闹钟和时钟&#xA;  get-appxpackage *alarms* | remove-appxpackage&#xA;&#xA;  // 计算器&#xA;  get-appxpackage *calculator* | remove-appxpackage&#xA;&#xA;  // 相机&#xA;  get-appxpackage *camera* | remove-appxpackage&#xA;&#xA;  // 照片&#xA;  get-appxpackage *photos* | remove-appxpackage&#xA;&#xA;  // 地图&#xA;  get-appxpackage *maps* | remove-appxpackage&#xA;&#xA;  // 语音录音机&#xA;  get-appxpackage *soundrecorder* | remove-appxpackage&#xA;&#xA;  // XBox&#xA;  get-appxpackage *xbox* | remove-appxpackage&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;恢复卸载的应用&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Get-AppxPackage -allusers |&#xA;foreach {Add-AppxPackage -register “$（$_。InstallLocation）appxmanifest.xml”&#xA;-DisableDevelopmentMode}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>The Docker Book</title>
      <link>http://www.nljb.net/default/The-Docker-Book/</link>
      <pubDate>2016-04-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;The Docker Book&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker info&#xA;// 该命令会返回所有容器的镜像的数量&#xA;// Docker 使用的执行驱动和存储驱动&#xA;// 以及 Docker 的基本配置&#xA;&#xA;$ docker version&#xA;// Docker的版本号，API版本号&#xA;// Git commit， Docker客户端和后台进程的Go版本号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;创建容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker create -i -t nljb_net /bin/bash&#xA;// 创建一个新的容器 ...&#xA;// 似 docker run 如容器不存在则创建 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;运行容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -i -t nljb_net /bin/bash&#xA;// 运行 nljb_net 创建新容器&#xA;// -i 保证容器中STDIN是开启的&#xA;// -t 为创建的容器分配一个伪终端&#xA;// root@f7cbdac22a02:/#&#xA;&#xA;$ docker run -i -t -d nljb_net /bin/bash&#xA;// -d 代表 Docker 容器将在后台运行 ...&#xA;&#xA;$ docker run -d nljb_net /bin/bash &#xA;// 如果这样运行，则容器会立即停止&#xA;// 因为没有程序在容器中运行 ...&#xA;// -t 也是个程序，所以容器不会停止 ...&#xA;&#xA;$ docker run -i -t -h nljb nljb_net /bin/bash &#xA;// -h 标志来为容器设定主机名&#xA;// --hostname 标志来为容器设定主机名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;使用容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：一旦退出容器，/bin/bash 命令也就结束了，这时容器也随之停止了运行&#xA;&#xA;$ docker ps&#xA;// 只能看到正在运行的容器&#xA;&#xA;$ docker ps -a&#xA;// 可以看到所有的容器，包括已经停止的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;有三中方式可以指代唯一容器:&#xA;&#xA;* 短UUID（如：f7cbdac22a02)&#xA;* 长UUID（如：f7cbdac22a02f7cbdac22a02f7cbdac22a02f7cbdac22a02）&#xA;* 或者名称（如：gray_cat）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;容器命名&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run --name ContainerName -i -t nljb_net /bin/bash&#xA;// 通过 --name 为容器指定一个名称 [a-zA-Z0-9_.-]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;重新启动、停止、删除容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：docker run 每次运行都会创建一个全新的容器&#xA;&#xA;$ docker start ContainerName &#xA;$ docker start f7cbdac22a02&#xA;// 除了容器名称，还可以使用容器ID来指定容器&#xA;&#xA;$ docker restart f7cbdac22a02 &#xA;// 重新启动一个容器 ...&#xA;&#xA;// 重新启动的容器会沿用 docker run 命令时指定的参数来运行&#xA;&#xA;$ docker stop ContainerName&#xA;// 停止容器的运行 ...&#xA;&#xA;$ docker kill ContainerName&#xA;// 强制停止容器的运行 ...&#xA;&#xA;$ docker rm ContainerName&#xA;// 删除一个已经停止的容器&#xA;&#xA;$ docker rm `docker ps -a -q`&#xA;// 删除所有的容器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;附着到容器上&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker attach ContainerName&#xA;// 重新附着到容器上 ...&#xA;// 可能需要按下回车键才能呢个进入该会话&#xA;&#xA;$ docker exec -t -i ContainerName /bin/bash&#xA;// 可以通过运行一个模拟终端的交互任务来附着容器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;创建守护式容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run --name ContainerName -d nljb_net /bin/sh -c &#xA;    &amp;quot;while echo hello; sleep 1; done&amp;quot;&#xA;// 该循环会一直运行下去，直到容器或其进程停止运行 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;容器内容都在干什么 &amp;hellip;&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker logs ContainerName &#xA;// Docker 会输出最后几条日期项并返回&#xA;&#xA;$ docker logs -f ContainerName&#xA;// 跟踪守护式容器的日志&#xA;// Ctrl + C 退出跟踪&#xA;&#xA;$ docker logs -ft ContainerName&#xA;// -t 为每条日志项加上时间戳&#xA;&#xA;$ docker top ContainerName&#xA;// 查看容器内的进程&#xA;&#xA;$ docker wait ContainerName&#xA;// 等待程序退出，得到返回代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;在容器内部运行进程&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：&#xA;在容器内运行的进程有两种类型，后台任务和交互任务&#xA;后台任务在容器内运行且没有交互需求&#xA;而交互任务则保持在前台运行 ...&#xA;&#xA;$ docker exec -d ContainerName touch /etc/new_config_file&#xA;// 后台任务 ... 在容器内部额外启动新进程（后台任务） ...&#xA;&#xA;$ docker exec -t -i ContainerName /bin/bash&#xA;// 交互任务 ... 在容器内部启动一个交互任务 ...&#xA;// -t 模拟终端也是个交互程序 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;自动重启容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run --restart=always -d nljb_net ...&#xA;// always 无论容器的退出代码是什么，都会自动重启该容器&#xA;// on-failure 只有当容器的退出代码非0时，才会重启容器&#xA;// --restart=on-failure:5，最多重启次数 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;宿主容器互传文件&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker cp a77a72ac178c:/var/www/html /var/www/&#xA;// 将容器的文件拷贝到宿主机&#xA;&#xA;$ docker inspect -f &#39;&#39; a77a72ac178c&#xA;// 将宿主机的文件拷贝到容器内 ...&#xA;// 输出: a77a72ac178c1e35708d2af446197c10239b0b1bd8932104578e334b83eb93a2&#xA;&#xA;// 下一步 ...&#xA;$ cp /root/golang /var/lib/docker/aufs/mnt &amp;lt;接下行&amp;gt;&#xA;a77a72ac178c1e35708d2af446197c10239b0b1bd8932104578e334b83eb93a2/root/&#xA;// 回到容器内即可看到拷贝过去的文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;宿主目录挂在到容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -it -v /nljb_net_mnt:/nljb_net_mnt nljb_net&#xA;// 将宿主机的目录作为卷，挂在到容器里 ...&#xA;&#xA;$ docker run -it -v /nljb_net_mnt:/nljb_net_mnt:ro nljb_net&#xA;// 这将使&amp;quot;容器&amp;quot;的nljb_net_mnt目录变成只读状态&#xA;// 也就是说&amp;quot;宿主&amp;quot;可以修改内容，而容器不可以修改 ...&#xA;&#xA;* 希望同时对代码做开发和测试&#xA;* 代码改动很频繁，不想在开发过程中重构镜像&#xA;* 希望在多个容器间共享代码 ...&#xA;&#xA;注意：卷可以在容期间共享，即使容器停止，卷里的内容依然存在 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;暂停与恢复容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker pause ContainerName&#xA;// 暂停容器的所有进程&#xA;// docker ps 中 STATUS 会变成 (Paused)&#xA;&#xA;$ docker unpause ContainerName&#xA;// 恢复容器的所有进程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;深入容器&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker inspect ContainerName&#xA;// 来获取更多容器的信息&#xA;&#xA;$ docker inspect --format=&#39;&#39; ContainerName&#xA;// 通过 --format 来查询容器的运行状态 ...&#xA;&#xA;$ docker inspect --format=&#39;&#39; ContainerName&#xA;// 通过 --format 来查询容器的 IP 地址&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;容器互连&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 预先准备&#xA;$ docker run -d --name redis ubuntu/redis&#xA;&#xA;// 开始互连&#xA;$ docker run -p 4567 --name webapp --link redis:db  -it nljb_net /bin/bash&#xA;// --link 标志创建了两个容器间的父子连接 ...&#xA;// --link 参数：一个是要连接的容器名字，另一个是连接后的容器别名&#xA;// 这个例子中：redis 是容器名字 db 是容器别名 ...&#xA;// 则 nljb_net 是要运行的镜像名称 ...&#xA;&#xA;// 注意到启动 redis 时没有使用 -p 标志公开 redis 端口&#xA;// 因为不需要这么做，通过把容器连接到一起，可以让父容器直接访问任意子容器的公开端口&#xA;// 更妙的是，容器端口不需要公开，只有 --link 标志连接到这个容器才能连接到这个端口&#xA;// 所以：端口不需要对本地宿主公开，现在我们已经拥有一个非常安全的模型 ...&#xA;&#xA;$ docker run -p 4567 --name webapp2 --link redis:db ...&#xA;$ docker run -p 4568 --name webapp3 --link redis:db ...&#xA;...&#xA;// 也可以把多个容器连接在一起 ... 比如多个Web应用容器连接到同一个 redis 服务 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在父容器中将(172.17.0.31 db)添加到(/etc/hosts)中 ...&#xA;// 这样只要(ping db)就可以知道父容器是否与(子容器)连接 ...&#xA;&#xA;$ cat /ect/hosts&#xA;172.17.0.33 811bd6d588cb    &#xA;// 容器自己的IP地址和主机名&#xA;172.17.0.31 db              &#xA;// redis 容器的IP地址和从该连接的别名衍生的主机名 db&#xA;&#xA;注意：还记得之前提到过，重启容器时，容器的IP地址会发生变化的事情吗 ...&#xA;如果被连接的容器重启了，/etc/hosts文件中的IP地址会被新的IP地址更新 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;用于连接的环境变量&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ root@811bd6d588cb:/ # env&#xA;HOSTNAME=811bd6d588cb&#xA;DB_NAME=/webapp/db&#xA;DB_PORT_6379_TCP_PORT=6379&#xA;DB_PORT=tcp://172.17.0.31:6379&#xA;DB_PORT_6379_TCP=tcp://172.17.0.31:6379&#xA;DB_ENV_REFRESHED_AT=2014-06-01&#xA;DB_PORT_6379_TCP_ADDR=172.17.0.31&#xA;DB_PORT_6379_TCP_PORTO=tcp&#xA;...&#xA;// 以 DB 开头是因为 DB 是创建连接时使用的别名&#xA;&#xA;这些自动创建的环境变量包含以下信息:&#xA;* 子容器名称&#xA;* 容器里运行的服务所使用的协议、IP和端口号&#xA;* 容器里运行的不同服务所指定的协议、IP和端口号&#xA;* 容器里由 Docker 设置的环境变量值 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;通过环境变量建立连接&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;port = ENV[&#39;DB_PORT&#39;] ...&#xA;// 知道以上的环境变量信息，就可以在程序内通过环境变量获取DB端口号等&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;容器内文件状态变化&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo docker diff 7bb0e258aefe&#xA;C /dev&#xA;A /dev/kmsg&#xA;C /etc&#xA;A /etc/mtab&#xA;A /go&#xA;A /go/src&#xA;A /go/src/github.com&#xA;A /go/src/github.com/dotcloud&#xA;&#xA;// diff 会列出容器内文件状态变化&#xA;// A - Add, D - Delete, C - Change &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;导出和导入容器快照&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker ps -a&#xA;// 获取要导出的容器ID（7691a814370e）&#xA;&#xA;$ docker export 7691a814370e &amp;gt; nljb_net.tar&#xA;// 从容器中导出快照 nljb_net.tar&#xA;&#xA;$ cat nljb_net.tar | sudo docker import - nljb:new&#xA;// 将快照生成镜像 ... nljb:new 是一个新的镜像命名 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;镜像相关命令&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker images&#xA;$ docker images nljb_net&#xA;// 列出本地镜像 ...&#xA;// 本地镜像保存在/var/lib/docker目录下&#xA;&#xA;$ docker pull nljb_net &#xA;$ docker pull nljb_net:11.04&#xA;// 拉取镜像 ...&#xA;// 镜像是保存在 Docker Hub 中的，可以是官方的也可以是三方的&#xA;&#xA;$ docker tag ab035c88d533 nljb_net:11.04&#xA;// 修改镜像标签 ...&#xA;&#xA;$ docker rmi nljb_net&#xA;$ docker rmi `docker images -a -q   `&#xA;// 删除镜像&#xA;// 注意：不是容器，是镜像&#xA;&#xA;注意：官方提供的ubuntu操作系统，我们虽然称之为ubuntu操作系统，&#xA;但实际上它并不是完成的操作系统，它只是一个裁剪版，&#xA;但是它由ubuntu官方制作的，安全的裁剪版本 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;构建镜像&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;* 使用 docker commit 命令&#xA;* 使用 docker build 命令 和 Dockerfile 文件 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -i -t nljb_net /bin/bash&#xA;// 运行一个镜像, 并且做好修改，....&#xA;// 然后退出镜像&#xA;&#xA;$ docker ps -a &#xA;$ docker ps -l -q&#xA;// 可以看一下刚刚修改的容器ID&#xA;&#xA;$ docker commit f7cbdac22a02 nljb/apache2:webserver&#xA;// 讲容器生成一个新的镜像 ...&#xA;// :webserver 为该镜像增加一个标签 ...&#xA;&#xA;$ docker commit -m=&amp;quot;A new custom image&amp;quot; --author=&amp;quot;nljb&amp;quot; f7cbdac22a02 nljb/webserver&#xA;// -m 指定镜像的提交信息 ...&#xA;// --author 用来指定镜像的作者信息 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;导出和导入镜像 &amp;hellip;&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker save nljb:new &amp;gt; nljb_net.tar&#xA;// 导出镜像到文件 ...&#xA;&#xA;$ docker load &amp;lt; nljb_net.tar&#xA;$ docker load --input nljb_net.tar&#xA;// 导入文件到镜像 ...&#xA;&#xA;注意：这样导出的镜像会非常大，因为包含所有镜像的增量备份 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;构建历史&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker history nljb_net:nljb&#xA;// 展示镜像的构建历史 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;历史记录&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker images –tree&#xA;// Docker的文件系统AUFS，一种“增量文件系统”&#xA;// 用户所做修改以增量的方式保存，所以才能看到这些历史的增量。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;镜像其它&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -d -p 80 nljb_net /bin/bash&#xA;* 可以在宿主机器上随机选择49153～65535的端口号来映射到容器的80端口&#xA;* 可以在宿主机器上指定一个具体的端口号来映射到容器的80端口上 ...&#xA;&#xA;$ docker run -d -p 8080(宿主):80(容器) nljb_net /bin/bash&#xA;// 将“容器的80端口”绑定到“宿主机的8080端口”上 ...&#xA;&#xA;$ docker run -d -p 127.0.0.1:80(宿主):80(容器) nljb_net /bin/bash&#xA;// 将容器的80端口绑定到宿主机的127.0.0.1这个IP的80端口上 ...&#xA;&#xA;$ docker run -d -p 127.0.0.1(宿主)::80(容器) nljb_net /bin/bash&#xA;// 只指定宿主机的IP地址，没有端口号，则 docker 会随机指派端口号 ...&#xA;&#xA;$ docker run -d -P nljb_net /bin/bash&#xA;// -P 该命令会将容器80端口对本地宿主机公开，并且绑定到宿主机的一个随机端口上&#xA;// 有了这个端口号，就可以在宿主机中通过127.0.0.1连接到运行的容器查看Web了&#xA;&#xA;$ docker ps -l &#xA;// 可以看到包含端口映射的相关信息&#xA;&#xA;$ docker port f7cbdac22a02 80&#xA;// 通过容器ID查看映射到宿主机80端口的容器端口号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;工作目录&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -it -w /var/log nljb_net pwd&#xA;// 该命令会更改容器内的工作目录 ...&#xA;// 输出：/var/log&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;环境变量&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -it -e &amp;quot;GOPATH=/root/src&amp;quot; nljb_net env&#xA;// -e 标志来传递环境变量, 这些变量只在运行时有效 ...&#xA;// 输出：GOPATH=/root/src&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;Docker Hub&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ docker login&#xA;// 镜像保存在 Docker Hub 中 ...&#xA;// 这条命了将完成登陆到 Docker Hub 中 ...&#xA;&#xA;$ docker search nljb_net &#xA;// 在 Docker Hub 中查找镜像&#xA;&#xA;$ docker push youruser/yourimage&#xA;// 将镜像推送到 Docker Hub 仓库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Docker介绍与使用</title>
      <link>http://www.nljb.net/default/Docker%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2016-04-01 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Docker 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Docker是一种Linux容器管理引擎&lt;/li&gt;&#xA;&lt;li&gt;Docker(&lt;a href=&#34;https://www.docker.com&#34;&gt;https://www.docker.com&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Github(&lt;a href=&#34;https://github.com/docker/docker&#34;&gt;https://github.com/docker/docker&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Go语言编写&lt;/li&gt;&#xA;&lt;li&gt;适用于Linux平台（仅适用）&lt;/li&gt;&#xA;&lt;li&gt;Docker是一种实现打包、输送、运行任意应用的容器解决方案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Docker提供隔离的运行环境&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文件系统隔离&lt;/li&gt;&#xA;&lt;li&gt;网络隔离&lt;/li&gt;&#xA;&lt;li&gt;进程号隔离&lt;/li&gt;&#xA;&lt;li&gt;进程间通信隔离&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Docker容器受到的资源限制&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU计算资源&lt;/li&gt;&#xA;&lt;li&gt;内存资源&lt;/li&gt;&#xA;&lt;li&gt;磁盘I/O资源等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Docker 体验&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Docker Registry 提供进行下载&lt;/li&gt;&#xA;&lt;li&gt;Docker Hub 是 Docker 官方支持的镜像仓库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Docker Hub Mirror&lt;/li&gt;&#xA;&lt;li&gt;缓存 Docker Hub 的镜像&lt;/li&gt;&#xA;&lt;li&gt;加速 Docker Hub 镜像的获取&lt;/li&gt;&#xA;&lt;li&gt;推荐使用DaoCloud加速器&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dashboard.daocloud.io/mirror&#34;&gt;https://dashboard.daocloud.io/mirror&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;配置Docker加速器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;/etc/default/docker (vi)&lt;/li&gt;&#xA;&lt;li&gt;DOCKER_OPTS=&amp;ldquo;&amp;ndash;dns 8.8.8.8 &amp;ndash;dns 8.8.4.4&amp;rdquo;&lt;/li&gt;&#xA;&lt;li&gt;在后面添加 &amp;ndash;registry-mirror 阿里云 &amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;重启 service docker restart&lt;/li&gt;&#xA;&lt;li&gt;下载镜像 docker pull ubuntu:14.04&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;运行Docker容器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统容器：Ubuntu、CentOS、Debian等操作系统&lt;/li&gt;&#xA;&lt;li&gt;应用容器：Ghsot应用、2048应用容器，多为（Web)&lt;/li&gt;&#xA;&lt;li&gt;存储容器：MySQL、MongoDB、Redis容器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看本地镜像 docker images&lt;/li&gt;&#xA;&lt;li&gt;运行本地镜像 docker run -it ubuntu:14.04 /bin/bash&lt;/li&gt;&#xA;&lt;li&gt;后台运行镜像 docker run -d -P ..&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;保存Docker容器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行容器并进行修改 docker run it centos /bin/bash&lt;/li&gt;&#xA;&lt;li&gt;找到修改的容器 docker ps -l (-a)&lt;/li&gt;&#xA;&lt;li&gt;保存容器的修改 docker commit 698 centos-change&lt;/li&gt;&#xA;&lt;li&gt;容器ID 698, 镜像名称：centos-change&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Docekr 常用命令 &amp;hellip;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 查看容器的root用户密码&#xA;docker logs &amp;lt;容器名orID&amp;gt; 2&amp;gt;&amp;amp;1 | grep &#39;^User: &#39; | tail -n1&#xA;&#xA;因为docker容器启动时的root用户的密码是随机分配的。&#xA;通过这种方式就可以得到redmine容器的root用户的密码了。&#xA;&#xA;// 查看容器日志&#xA;docker logs -f &amp;lt;容器名orID&amp;gt;&#xA;&#xA;// 查看正在运行的容器&#xA;docker ps&#xA;&#xA;// 为查看所有的容器，包括已经停止的&#xA;docker ps -a &#xA;&#xA;// 删除所有容器&#xA;docker rm $(docker ps -a -q)&#xA;&#xA;// 删除单个容器&#xA;docker rm &amp;lt;容器名orID&amp;gt;&#xA;&#xA;// 停止、启动、杀死一个容器&#xA;docker stop &amp;lt;容器名orID&amp;gt;&#xA;docker start &amp;lt;容器名orID&amp;gt;&#xA;docker kill &amp;lt;容器名orID&amp;gt;&#xA;&#xA;// 查看所有镜像&#xA;docker images&#xA;&#xA;// 删除所有镜像&#xA;docker rmi $(docker images | grep none | awk &#39;{print $3}&#39; | sort -r)&#xA;&#xA;// 运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例&#xA;docker run --name redmine -p 9003:80 -p 9023:22 -d -v &amp;lt;接下行&amp;gt;&#xA;/var/redmine/files:/redmine/files -v &amp;lt;接下行&amp;gt;&#xA;/var/redmine/mysql:/var/lib/mysql sameersbn/redmine&#xA;&#xA;// 一个容器连接到另一个容器&#xA;docker run -i -t --name sonar -d -link &amp;lt;接下行&amp;gt;&#xA;mmysql:db tpires/sonar-server sonar&#xA;&#xA;// 容器连接到mmysql容器，并将mmysql容器重命名为db。&#xA;// 这样，sonar容器就可以使用db的相关的环境变量了。&#xA;&#xA;&#xA;// 拉取镜像&#xA;docker pull &amp;lt;镜像名:tag&amp;gt;&#xA;&#xA;// 如&#xA;docker pull sameersbn/redmine:latest&#xA;&#xA;// 当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。&#xA;&#xA;// 机器 A&#xA;docker save busybox-1 &amp;gt; /home/save.tar&#xA;&#xA;// 使用scp将save.tar拷到机器B上，然后：&#xA;docker load &amp;lt; /home/save.tar&#xA;&#xA;// 构建自己的镜像&#xA;docker build -t &amp;lt;镜像名&amp;gt; &amp;lt;Dockerfile路径&amp;gt;&#xA;&#xA;// 如Dockerfile在当前路径：&#xA;docker build -t xx/gitlab .&#xA;&#xA;// 重新查看container的stdout&#xA;# 启动top命令，后台运行&#xA;$ ID=$(sudo docker run -d ubuntu /usr/bin/top -b)&#xA;# 获取正在running的container的输出&#xA;$ sudo docker attach $ID&#xA;$ sudo docker stop $ID&#xA;&#xA;// 后台运行(-d)、并暴露端口(-p)&#xA;docker run -d -p 127.0.0.1:33301:22 centos6-ssh&#xA;&#xA;// 从container中拷贝文件出来&#xA;sudo docker cp 7bb0e258aefe:/etc/debian_version .&#xA;&#xA;// 删除 none 镜像&#xA;docker rmi $(docker images | awk &#39;/^&amp;lt;none&amp;gt;/ { print $3 }&#39;)&#xA;// 删除失败, 需先停止&#xA;docker ps -a | grep &amp;quot;Exited&amp;quot; | awk &#39;{print $1 }&#39;|xargs docker stop&#xA;docker ps -a | grep &amp;quot;Exited&amp;quot; | awk &#39;{print $1 }&#39;|xargs docker rm&#xA;// ... 通过 ID 删除 ...&#xA;docker images|grep none|awk &#39;{print $3 }&#39;|xargs docker rmi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>AutoIt的介绍与使用</title>
      <link>http://www.nljb.net/default/AutoIt%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2016-03-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;AutoIt&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/AutoIt的介绍与使用/1.png&#34; alt=&#34;&#34; width=&#34;800&#34; height&#34;500&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;AutoIt 目前最新是v3版本，这是一个使用类似BASIC脚本语言的免费软件,它设计用于Windows GUI(图形用户界面)中进行自动化操作&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;它利用模拟键盘按键，鼠标移动和窗口/控件的组合来实现自动化任务。&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;而这是其它语言不可能做到或无可靠方法实现的(例如VBScript和SendKeys).&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行Windows和Dos程序&lt;/li&gt;&#xA;&lt;li&gt;模拟键击动作(支持大多数键盘布局)&lt;/li&gt;&#xA;&lt;li&gt;模拟鼠标移动和点击动作&lt;/li&gt;&#xA;&lt;li&gt;对窗口进行移动,调整大小和其它操作&lt;/li&gt;&#xA;&lt;li&gt;直接与窗口的“控件“交互(设置/获取文本,移动,关闭等等)&lt;/li&gt;&#xA;&lt;li&gt;配合剪贴板进行剪切/粘贴文本操作&lt;/li&gt;&#xA;&lt;li&gt;对注册表进行操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;; 调用管理员权限&#xA;#RequireAdmin&#xA;&#xA;; 运行&#xA;Run(&amp;quot;q.exe&amp;quot;)&#xA;&#xA;; 等待完成&#xA;WinWaitActive(&amp;quot;[CLASS:#32770]&amp;quot;, &amp;quot;立即安装&amp;quot;)&#xA;&#xA;; 休眠&#xA;Sleep(500)&#xA;&#xA;; 点击&#xA;ControlClick(&amp;quot;腾讯QQ安装向导&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;[CLASS:Button; INSTANCE:3]&amp;quot;)&#xA;&#xA;; 等待完成&#xA;WinWaitActive(&amp;quot;[CLASS:#32770]&amp;quot;, &amp;quot;完成安装&amp;quot;)&#xA;&#xA;; 休眠&#xA;Sleep(500)&#xA;&#xA;；点击&#xA;ControlClick(&amp;quot;腾讯QQ安装向导&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;[CLASS:Button; INSTANCE:8]&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Swift语言面向对象编程</title>
      <link>http://www.nljb.net/default/Swift%E8%AF%AD%E8%A8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</link>
      <pubDate>2016-02-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;断言&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可以使用全局函数assert来声明一个断言。向assert函数传递一个条件表达式，如果表达式为false,可以打印一段信息&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;assert(1 &amp;gt; 2, &amp;quot;Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Class&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：Class 是引用类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Class 继承 扩展类型&lt;/li&gt;&#xA;&lt;li&gt;Class 构造 重载 静态方法 重写 父类方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：类和结构体的选择&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;结构体实例总是通过值传递，类实例总是通过引用传递，这说明两者适用于不同的任务，当在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据构造是定义类还是结构体&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Class&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Class&#xA;class Hi {&#xA;&#xA;    var name:String&#xA;&#xA;    var addr:String?&#xA;&#xA;    // 构造方法&#xA;    init(name:String) {&#xA;        // This 指针 self&#xA;        self.name = name&#xA;    }&#xA;&#xA;    // 构造重载&#xA;    init(name:String, addr:String) {&#xA;        self.name = name&#xA;        self.addr = addr&#xA;    }&#xA;&#xA;    // 方法&#xA;    func sayHi() {&#xA;        if let x = addr {&#xA;            print(&amp;quot;Hi \(name) \(x)&amp;quot;)&#xA;        } else {&#xA;            print(&amp;quot;Hi \(self.name)&amp;quot;)&#xA;        }&#xA;    }&#xA;&#xA;    // 方法重载&#xA;    func sayHi(name:String) {&#xA;        print(&amp;quot;Hi \(name)&amp;quot;)&#xA;    }&#xA;&#xA;    // Class Func 静态方法&#xA;    class func sayClass() {&#xA;        print(&amp;quot;Hi Class&amp;quot;)&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Class 实例&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Class&#xA;var hi = Hi(name: &amp;quot;nljb&amp;quot;, addr: &amp;quot;beijing&amp;quot;)&#xA;hi.sayHi()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Class 静态方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Class Func&#xA;Hi.sayClass()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Class 继承 与 重写&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hello:Hi {&#xA;&#xA;    // 重写方法&#xA;    override func sayHi() {&#xA;        // 执行父类方法&#xA;        super.sayHi(&amp;quot;Hello&amp;quot;)&#xA;        // ...&#xA;       print(&amp;quot;Hello \(name)&amp;quot;)&#xA;    }&#xA;&#xA;}&#xA;&#xA;// Class&#xA;var he = Hello(name: &amp;quot;jbnl&amp;quot;)&#xA;he.sayHi()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Class 扩展&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在原有类的基础上进行扩展&#xA;extension Hi {&#xA;&#xA;    // 扩展方法&#xA;    func sayExten() {&#xA;        print(&amp;quot;Hi Exten&amp;quot;)&#xA;    }&#xA;&#xA;}&#xA;&#xA;// Class&#xA;var ex = Hi(name: &amp;quot;nljb&amp;quot;, addr: &amp;quot;beijing&amp;quot;)&#xA;ex.sayExten()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;接口&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Class protocol&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 接口&#xA;protocol Pro {&#xA;    // 接口方法&#xA;    func sayHello() -&amp;gt; String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Class 继承接口&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 继承 Pro&#xA;class Hi:Pro {&#xA;    // 接口方法&#xA;    func sayHello() -&amp;gt; String {&#xA;        return &amp;quot;Hello&amp;quot;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;标识恒等&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;判定两个常量或者变量是否引用同一个类实例&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;等价于（ === ）&lt;/li&gt;&#xA;&lt;li&gt;不等价于（ !== ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi { ... }&#xA;var a = Hi() // 实例 a&#xA;var b = Hi() // 实例 b&#xA;var c = a // 实例 c 引用 a&#xA;a === b // false&#xA;a === c // true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;属性&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;属性将值跟特定的类、结构体、枚举关联&lt;/li&gt;&#xA;&lt;li&gt;存储属性存储常量或变量作为实例的一部分&lt;/li&gt;&#xA;&lt;li&gt;计算属性计算一个值（而不是存储一个值）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算属性可以用于类、结构体、枚举中&lt;/li&gt;&#xA;&lt;li&gt;存储属性只能用于类和结构体，枚举不可以使用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;存储属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个存储数据就是存储在特定类或结构体实例中的一个常量(let)或变量(var)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：常量存储属性在创建赋值后无法修改它的值&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 结构体（值类型）&#xA;struct Hello {&#xA;    // 存储属性（变量）&#xA;    var addr:Int&#xA;    // 存储属性（常量）&#xA;    let name:Int&#xA;}&#xA;&#xA;// 结构体 变量实例&#xA;var a = Hello(addr:0, name:0)&#xA;&#xA;// 此时变量存储属性是可以修改的&#xA;a.addr = 1 // OK&#xA;&#xA;// 此时常量存储属性是不可以修改的&#xA;a.name = 1 // Error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：当值类型的实例被声明为常量的时候，它的所有属性也就成了常量&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 结构体 常量实例&#xA;let b = Hello(addr:0, name:0)&#xA;&#xA;// 此时变量存储属性是不可修改的&#xA;a.addr = 1 // Error&#xA;&#xA;// 此时常量存储属性是不可以修改的&#xA;a.name = 1 // Error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：引用类型的类则不一样，把一个引用类型的实例赋给一个常量后，仍然可以修改变量的属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Class（引用类型）&#xA;class Hello {&#xA;    var addr:Int = 0&#xA;    let name:Int = 0&#xA;}&#xA;&#xA;// 类（变量）&#xA;var a = Hello()&#xA;a.addr = 1 // OK&#xA;a.name = 1 // Error&#xA;&#xA;// 类（常量）&#xA;let b = Hello()&#xA;b.addr = 1 // OK&#xA;b.name = 1 // Error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;延迟存储属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;必须将延迟属性声明成变量(var)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;在属性声明前使用lazy来标识一个延迟存储属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;常量属性在构造完成前必须要有初始值，因此无法声明成延迟属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Init {&#xA;    init(){&#xA;        print(&amp;quot;init ...&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;class Hello {&#xA;    var i = Init()&#xA;}&#xA;&#xA;var a = Hello()&#xA;&#xA;// 输出了 init ...&#xA;&#xA;// 把 var i = Init() &#xA;// 换 lazy var i = Init()&#xA;// 没有输出 init ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Init {&#xA;    init(){&#xA;        print(&amp;quot;init ...&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;class Hello {&#xA;    lazy var i = Init()&#xA;}&#xA;&#xA;var a = Hello()&#xA;a.i&#xA;// 输出了 init ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;计算属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;计算属性和属性监察器所描述的模式可以用于全局变量和本地变量&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;类、结构体、枚举可以定义计算属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;计算属性不直接存储值，而是提供一个getter来获取值&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个可选的setter来间接设置其它属性或变量的值&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 结构体&#xA;struct Hello {&#xA;    var x:Int&#xA;    var y:Int&#xA;}&#xA;&#xA;// 类&#xA;class Hi {&#xA;&#xA;    var h:Hello?&#xA;&#xA;    // 计算属性&#xA;    var a:Hello {&#xA;        // 读取 a 时调用 Get&#xA;        get {&#xA;            print(&amp;quot;run get ...&amp;quot;)&#xA;            return h ?? Hello(x: 0, y: 0)&#xA;        }&#xA;        // 设置 a 时调用 Set&#xA;        // 也可以 set { ... } 则默认使用 newValue&#xA;        set(hello) {&#xA;            print(&amp;quot;run set ...&amp;quot;)&#xA;            self.h = hello&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 实例&#xA;var h = Hi()&#xA;&#xA;// 设置 a 时调用 Set&#xA;h.a = Hello(x: 5, y: 5)&#xA;&#xA;// 读取 a 时调用 Get&#xA;print(h.a.x)&#xA;print(h.a.y)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;只读计算属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;只有Get没有Set的计算属性就是只读计算属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;只读计算属性的声明可以去掉Get关键字和花括号&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var a:Hello {&#xA;    return Hello(x: 0, y: 0)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;属性监视器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;计算属性和属性监察器所描述的模式可以用于全局变量和本地变量&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;属性监视器监控和响应属性值的变化&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;每次属性被设置的时候都会调用属性监视器，甚至新的值和现在的值相同的时候也不例外&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;willSet 在设置新的值之前调用&lt;/li&gt;&#xA;&lt;li&gt;didSet  在设置新的值之后调用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    var total:Int = 0 {&#xA;        // 在设置新的值之前调用&#xA;       willSet {&#xA;           print(total, newValue)&#xA;       }&#xA;       // 在设置新的值之后调用&#xA;       didSet {&#xA;           print(total)&#xA;       }&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;类型属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;使用关键字static来定义值类型的类型属性，使用关键字class来为类定义类型属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;static 在枚举、结构体中修饰的属性、方法&lt;/li&gt;&#xA;&lt;li&gt;class 在类中修饰的属性、方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意：也就是静态属性与方法，在类中使用(class)在枚举和结构体中使用(static)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Struct {&#xA;    static var a = &amp;quot;Hello&amp;quot;&#xA;    static var b:Int {&#xA;        return 0&#xA;    }&#xA;}&#xA;&#xA;enum Enum {&#xA;    static var a = &amp;quot;Hello&amp;quot;&#xA;    static var b:Int {&#xA;        return 0&#xA;    }&#xA;}&#xA;&#xA;class Class {&#xA;    class var a:Int {&#xA;        return 0&#xA;    }&#xA;    class func b() -&amp;gt; Int {&#xA;        return 0&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意：类型属性是通过类型本身获取和设置的，而不是通过实例&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;方法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;在实例中修改值类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;结构体和枚举是值类型，值类型的属性是不能在它的实例方法中被修改，但是 &amp;hellip;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可以使用变异方法从方法内部改变它的属性（值），并且它做的任何改变在方法结束时还保留在原始结构中&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Hi {&#xA;    var a:Int&#xA;    var b:Int&#xA;    func change() {&#xA;        a = 10 // Error&#xA;        b = 10 // Error&#xA;    }&#xA;}&#xA;&#xA;struct Hi {&#xA;    var a:Int&#xA;    var b:Int&#xA;    // 使用变态方法&#xA;    mutating func change() {&#xA;        a = 10 // OK&#xA;        b = 10 // OK&#xA;    }&#xA;}&#xA;&#xA;*注意：不能在结构体类型常量上调用变异方法，常量属性不能被改变*&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;在变异方法中给self赋值&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;变异方法能够赋值给隐含属性self一个全新的实例&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Hi {&#xA;    var x = 0, y = 0&#xA;    mutating func change() {&#xA;         // 赋值一个全新的实例&#xA;        self = Hi(x: 10, y: 10)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;下标&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;定义下标使用subscript关键字&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;对于同一个类、结构体或枚举可以定义多个下标，通过索引值类型的不同来进行重载，而且索引值的个数可以是多个&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Hi {&#xA;    subscript(index:Int) -&amp;gt; Int {&#xA;        get {&#xA;            if index == 0 {&#xA;                return 100&#xA;            } else {&#xA;                return 1000&#xA;            }&#xA;        }&#xA;        set {&#xA;            print(newValue)&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// 实例&#xA;var h = Hi()&#xA;// 赋值调用 Set&#xA;h[0] = 100&#xA;// 读取调用 Get&#xA;print(h[0])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;只读属性，可以直接将原本写在Get代码块中的代码写在subscript中&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Hi {&#xA;    subscript(index:Int) -&amp;gt; Int {&#xA;        if index == 0 {&#xA;            return 100&#xA;        } else {&#xA;            return 1000&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;下标是用来访问集合、列表或序列中元素的快捷方式&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过下标来访问类、结构体、枚举中的数组&#xA;&#xA;struct Matrix {&#xA;&#xA;    var grid = [Int : String]()&#xA;    subscript(index:Int) -&amp;gt;String {&#xA;    get {&#xA;        return grid[index]!&#xA;    }&#xA;    set {&#xA;            grid.updateValue(newValue, forKey: index)&#xA;    }&#xA;    }&#xA;&#xA;}&#xA;&#xA;var m = Matrix(grid: [Int : String]())&#xA;m[0] = &amp;quot;Hello&amp;quot;&#xA;print(m[0])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;继承&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个类可以继承另一个类的方法、属性、其它特征&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;继承是区分类与其它类型（结构体、枚举）的一个基本特征&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;类可以调用和访问超类的方法、属性、下标、并且可以重写这些方法、属性、和下标，以优化或修改它们的行为&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可以为继承来的属性添加观察器，这样一来当属性值发生改变的时候，类就会被通知到&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可以为任何属性添加观察器，无论它原本被定义为存储属性还是计算属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;子类只允许修改从超类继承来的变量属性，而不能修改继承来的常量属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi:Pro {&#xA;    // 接口方法&#xA;    func sayHello() -&amp;gt; String {&#xA;        return &amp;quot;Hello&amp;quot;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;重写&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;子类可以为继承来的实例方法、类方法、实例属性、或下标提供自己定制的实现，我们把这种行为叫作重写&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;如果要重写某个特征，需要在重写定义的前面加上override关键字&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;访问超类（父类）的方法、属性、下标可以使用（super.xxx）&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hello:Hi {&#xA;    // 重写方法&#xA;    override func sayHi() {&#xA;        // 执行父类方法&#xA;        super.sayHi(&amp;quot;Hello&amp;quot;)&#xA;        // ...&#xA;       print(&amp;quot;Hello \(name)&amp;quot;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;重写方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;在子类中可以重写继承来的实例方法或类型方法（静态方法）&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;重写属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;子类并不知道继承来的属性是存储属性还是计算属性，它只知道继承来的属性会有一个名字和类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;重写一个属性时，必须将它的名字和类型都写出来，这样才能使编译器去检查 &amp;hellip;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可以将一个继承来的只读属性重写为一个读写属性，只要重写时提供Set和Get即可&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意：不可以将一个只读属性重写为只读属性&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;重写属性观察器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;不可以为继承来的常量存储属性或继承来的只读计算属性添加属性观察器，这些属性的值是不可以被设置的&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;不可以同时提供重写的set和重写属性观察器&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;防止重写&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可以通过把方法、属性或下标标记为final来防止它们被重写&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可以通过在关键字class前加final特征来将整个类标记为final，这样的类是不可被继承的&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;构造&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;init&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    init() {&#xA;        ...&#xA;    }&#xA;    init(a:Int,b:String) {&#xA;        ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;构造是为了使用某个类、结构体或枚举的实例而进行的准备过程, 这个过程包括为实例中的每个属性设置初始值和为其执行必要的准备额初始化任务&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意：类和结构体在实例创建时，必须为所有存储属性设置合适的初始值，存储属性的值不能处于一个为止状态&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意：当存储属性设置默认值或在构造中为其赋值时，它们的值会被直接设置，不会出发任何属性检查器&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;如果你在定义构造器时没有提供参数外部名字，系统会为每个构造器的参数自动生成一个跟内部名字相同的外部名&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;构造器参数不使用外部名称，可以使用下划线代替外部参数名称即可&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;可选属性类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可选类型属性将自动初始化为空nil, 表示这个属性是故意在初始化时设置为空的&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    // 可选类型&#xA;    var a:String?&#xA;    // 构造也没有为其赋值&#xA;    init() { }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;构造中修改常量属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;只要在构造结束前常量的值能确定，就可以在构造总的任意时间点修改常量的属性值&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    let a:Int&#xA;    init() {&#xA;        self.a = 99&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;值类型的构造器代理&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;构造器可以通过调用其它构造器来完成实例的部分构造，这一过程成为构造器代理&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Hi {&#xA;    init() {&#xA;        print(&amp;quot;...&amp;quot;)&#xA;    }&#xA;    init(index:Int) {&#xA;        self.init()&#xA;        print(index)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;类的继承和构造&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;每一个类都必须至少拥有一个指定构造器&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;类中所有存储属性，包括所有继承自超类的属性，都必须在构造中设置初始值&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;系统提供两种类型的构造来确保所有类实例中的存储属性都能获得初始值(指定构造器、便利构造器)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;便利构造器是类中次要的、辅助型的构造器，可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值，也可以定义便利构造器来创建一个特殊用途或特定输入参数的实例&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;子类构造器必须调用直接父类的指定构造器&lt;/li&gt;&#xA;&lt;li&gt;便利构造器必须调用同一个类中的其它构造器&lt;/li&gt;&#xA;&lt;li&gt;便利构造器调用的构造器链的最终节点必须是指定构造器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hello {&#xA;    init(index:Int) {&#xA;        print(&amp;quot;init hello = \(index)&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;&#xA;class Hi:Hello {&#xA;&#xA;    var a:Int, b:Int&#xA;&#xA;    init(a:Int,b:Int) {&#xA;        self.a = a&#xA;        self.b = b&#xA;        // 子类必须调用直接父类的指定构造器(除非init(){})&#xA;        // 必须最后一步调用&#xA;        super.init(index: a)&#xA;    }&#xA;&#xA;    convenience init(a:Int,b:Int,c:Int) {&#xA;          // ...&#xA;          // 便利构造器必须调用一个self.init(...)&#xA;          // 必须最后一步调用 ...&#xA;        self.init(a: a, b: b + c)&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 使用指定构造器初始化&#xA;var h = Hi(a: 1, b: 1))&#xA;// 使用便利构造器初始化&#xA;var h = Hi(a: 1, b: 1, c: 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;构造器的继承和重载&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;系统中的子类不会默认继承超类的构造器&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;自动构造器的继承&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;如果子类没有定义任何指定构造器，它将自动继承超类的指定构造器&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Good {&#xA;     // 构造器&#xA;    init(str:String) {&#xA;        print(str)&#xA;    }&#xA;}&#xA;&#xA;// 子类没有定指定构造器&#xA;class Hi:Good {&#xA;    // 自动继承所有超类的指定构造器&#xA;}&#xA;&#xA;// 子类没有定指定构造器&#xA;class Hello:Hi {&#xA;    // 自动继承所有超类的指定构造器&#xA;}&#xA;&#xA;var h = Hello(str: &amp;quot;Hello&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;如何子类提供了所有超类指定的构造器的实现，它将自动继承超类的便利构造器, 不管是通过啥们上面方法自动继承还是通过自定义实现的，它将自动继承所有超类的便利构造器&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    init() {&#xA;&#xA;    }&#xA;    init(index:Int) {&#xA;        print(index)&#xA;    }&#xA;    convenience init(str:String) {&#xA;        self.init()&#xA;        print(str)&#xA;    }&#xA;}&#xA;&#xA;class Hello:Hi {&#xA;    override init() {&#xA;        super.init()&#xA;    }&#xA;    override init(index: Int) {&#xA;        super.init(index: index)&#xA;    }&#xA;}&#xA;&#xA;// 继承了超类的便利构造器&#xA;var h = Hello(str: &amp;quot;hello&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;要求实现或重写构造器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;表示每一个子类都必须实现这个构造器&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    required init() {&#xA;        ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;通过闭包或函数来设置属性的默认值&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;在闭包执行时，实例的其它部分都还没有初始化，这意味着不能再闭包里访问其它属性，就算这个属性有默认值也不可以，也不能使用self属性，或其它实例方法&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    // 闭包来设置属性值&#xA;    let a:Int {&#xA;        return 0&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;析构&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;在一个类的实例被释放之前，析构函数被立即调用, 用关键字deinit来标识析构函数&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;每个类最多只能有一个析构函数，析构函数不带任何参数&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;deinit {&#xA;    ....&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;类型转换&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;类型转换是一种检查实例的方式，让实例作为它的超类或者子类的一种方式&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;类型转换使用is和as操作实现，提供一种简单的方式去检查值的类型或者转换它的类型, 也可以用来检查一个类是否实现了某个协议&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;类型检查&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;is&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;用类型检查操作符(is)来检查一个实例是否属于特定的子类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;向下转换&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;as&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;某类型的一个常量或变量可能属于一个子类，可以尝试向下转换到它的子类型，可用类型转换操作符(as)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;    func a() {&#xA;        print(&amp;quot;a ...&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;class Hello:Hi {&#xA;    func b() {&#xA;        print(&amp;quot;b ...&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;class World:Hi {&#xA;    func c() {&#xA;        print(&amp;quot;c ...&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;let libs = [Hello(), World(), Hello(), World()]&#xA;for item in libs {&#xA;    // item Type is Hi&#xA;    // 所以需要向下转换类型&#xA;    item.a()&#xA;    if let x = item as? Hello {&#xA;        x.b()&#xA;    } else if let y = item as? World {&#xA;        y.c()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意：可选绑定(if let x = item as? Hi)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Any和AnyObject的转换&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AnyObject 可以代表任何class类型实例&lt;/li&gt;&#xA;&lt;li&gt;Any 可以表示任何类型，除了方法类型(func type)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AnyObject 用于任何类实例&lt;/li&gt;&#xA;&lt;li&gt;Any 用于任何变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;AnyObject&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;当需要工作中使用Cocoa API，它一般接收一个[AnyObject]类型的数组，或者说&amp;rdquo;一个任何对象类型的数组&amp;rdquo;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;let obj:[AnyObject] = [Hello(), World()]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Any&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;使用Any类型来混合不同类型一起工作, 但是方法类型不可以&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var things = [Any]()&#xA;things.append(0)&#xA;things.append(0.0)&#xA;things.append(42)&#xA;things.append(3.1415926)&#xA;things.append(&amp;quot;hi&amp;quot;)&#xA;things.append(3.0, 5.0)&#xA;things.append(Hello())&#xA;things.append(World())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;扩展&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展可以:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加计算属性和静态计算属性&lt;/li&gt;&#xA;&lt;li&gt;定义实例方法和类型方法&lt;/li&gt;&#xA;&lt;li&gt;提供新的构造器&lt;/li&gt;&#xA;&lt;li&gt;定义下标&lt;/li&gt;&#xA;&lt;li&gt;定义和使用新的嵌套类型&lt;/li&gt;&#xA;&lt;li&gt;使一个已有类型符合某个协议&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个扩展可以扩展一个已有类型，使其能够适配一个或多个协议&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;extension SomeType: SomeProtocol, AnotherProctocol {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展构造器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;扩展可以向已有类型添加新的构造器，这可以让你扩展其它类型，将自己定制类型作为构造器参数, 或者提供该类型的原始实现中没有包含的额外初始化选项&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Rect {&#xA;    ...&#xA;}&#xA;&#xA;// 添加新的构造器&#xA;extension Rect {&#xA;&#xA;    init(a:Int, b:Int) {&#xA;      ...  &#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Hi {&#xA;&#xA;}&#xA;&#xA;extension Hi {&#xA;    func say() {&#xA;        print(&amp;quot;say Hi&amp;quot;)&#xA;    }&#xA;    class func hello() {&#xA;        print(&amp;quot;say Hello&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;var h = Hi()&#xA;h.say()&#xA;Hi.hello()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展下标&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;extension Hi {&#xA;    subscript(index:Int) -&amp;gt; Int {&#xA;        return 0&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展嵌套类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;extension Character {&#xA;    // 在Character中嵌套一个Kind的枚举&#xA;    enum Kind {&#xA;        ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;协议（接口)&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;协议用于统一方法和属性的名称，而不实现功能，协议能够被类、枚举、结构体实现，满足协议条件的被称为遵循者&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;遵循者需要提供协议指定成员，如属性、方法、操作符、下标等&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol SomeProtocol {&#xA;    // ...&#xA;}&#xA;&#xA;class SomeClass: SomeProtocol {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;当某个类含有超类的同时实现了协议，应吧超类放在所有的协议之前&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class SomeClass: SomeSuperClass, SomeProtocol {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;协议属性要求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;在属性声明后写上{get set}表示属性为可读写的&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 只限协议里面才可以这样设置&#xA;protocol SomeProtocol {&#xA;    var a:Int {get set}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用类来实现协议时，使用class来表示该属性为类成员（静态）&lt;/li&gt;&#xA;&lt;li&gt;用结构体和枚举来实现协议时，使用static来表示 &amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol SomeProtocol {&#xA;       class var a:Int { get set }&#xA;}&#xA;&#xA;protocol SomeProtocol {&#xA;    static var b:Int { get set }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;方法要求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;协议方法支持可变参数，不支持默认参数&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol SomeProtocol {&#xA;    // 不支持, 默认参数&#xA;    func say(a:String = &amp;quot;hi&amp;quot;){&#xA;        // Error&#xA;    }&#xA;}&#xA;&#xA;// 可变参数，可以使一个参数接受零个或多个指定类型的值&#xA;func sayNumber(numbers: Double...){&#xA;    for number in numbers {&#xA;        print(number)&#xA;    }&#xA;&#xA;}&#xA;sayNumber(1, 2, 3, 4, 5)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;可变方法要求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;能在方法或函数内部改变实例类型的方法称谓可变方法&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;在值类型（结构体和枚举）中的函数前加上mutating关键字来表示该函数允许改变该实例和其属性的类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;类中的成员为引用类型，可以方便地修改实例及其属性的值而无需改变类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;结构体和枚举中的成员为值类型，修改变量的值就相当于修改变量的类型，而系统不允许修改类型，因此需要前置mutating来表示该函数中能够修改类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用class实现协议中的mutating方法时，不用写mutating关键字&lt;/li&gt;&#xA;&lt;li&gt;用结构体、枚举实现协议中的mutating方法时，必须写mutating关键字&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Error&#xA;struct Hi {&#xA;    var a:Int = 0&#xA;    var b:Int = 0&#xA;    // 这样是错误的，不允许修改&#xA;    func change(a:Int, b:Int) {&#xA;        self.a = a&#xA;        self.b = b&#xA;    }&#xA;}&#xA;&#xA;// OK&#xA;struct Hi {&#xA;    var a:Int = 0&#xA;    var b:Int = 0&#xA;    // 这样是OK的&#xA;    mutating func change(a:Int, b:Int) {&#xA;        self.a = a&#xA;        self.b = b&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;协议作为类型&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;协议本身不实现任何功能，但可以将它当作类型来使用&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;使用场景:&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;作为函数、方法、或构造器中的参数类型、返回值类型&lt;/li&gt;&#xA;&lt;li&gt;作为常量、变量、属性的类型&lt;/li&gt;&#xA;&lt;li&gt;作为序列、字典或其它集合项的类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;协议类型应与其它类型（Int, String）的写法相同，使用驼峰式&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol Protocol {&#xA;    func sayMe()&#xA;}&#xA;&#xA;class Hello:Protocol {&#xA;    func sayMe() {&#xA;        print(&amp;quot;show me&amp;quot;)&#xA;    }&#xA;}&#xA;&#xA;class Hi {&#xA;    let p:Protocol&#xA;    init(p:Protocol) {&#xA;        self.p = p&#xA;    }&#xA;}&#xA;&#xA;var h = Hello()&#xA;var x = Hi(p: h)&#xA;x.p.sayMe()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;代理&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;代理是一种设计模式，它允许类或结构体将一些需要它们负责的功能交由给其它的类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;代理模式实现：定义协议来封装那些需要被代理的函数和方法，使其遵循者拥有这些被代理的函数和方法&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol Hello {&#xA;    var name:String? {get set}&#xA;    func play()&#xA;}&#xA;&#xA;// 2, 定义一个代理，让别人实现这个方法 ...&#xA;protocol HelloDelegate {&#xA;    func game(hello:Hello)&#xA;}&#xA;&#xA;&#xA;// 3, 继承了代理，就必须实现代理的方法&#xA;class HelloTracker:HelloDelegate {&#xA;    // 4, 实现代理方法&#xA;    func game(hello:Hello) {&#xA;        print(hello.name)&#xA;    }&#xA;}&#xA;&#xA;// 使用代理&#xA;class Hi:Hello {&#xA;&#xA;    var name:String?&#xA;&#xA;    init(name:String) {&#xA;        self.name = name&#xA;    }&#xA;&#xA;    // 代理变量&#xA;    var delegate:HelloDelegate?&#xA;&#xA;    func play() {&#xA;        // 1, 需要一个Game方法，又不想实现&#xA;        delegate?.game(self)&#xA;    }&#xA;&#xA;}&#xA;&#xA;var h = Hi(name: &amp;quot;nljb&amp;quot;)&#xA;h.delegate = HelloTracker()&#xA;h.play()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;通过扩展添加协议一致性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*即使无法修改&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;通过扩展为已存在的类型添加协议时，该类型的所有实例也会随之添加协议中的方法&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol Protocol {&#xA;    func play()&#xA;}&#xA;&#xA;class Dice {&#xA;&#xA;}&#xA;&#xA;extension Dice:Protocol {&#xA;    func play() {&#xA;        print(&amp;quot;扩展添加协议&amp;quot;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;通过扩展补充协议声明&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol Protocol {&#xA;    func play()&#xA;}&#xA;&#xA;class Dice {&#xA;    func play() {&#xA;&#xA;    }&#xA;}&#xA;&#xA;extension Dice:Protocol { }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;集合中的协议类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;协议类型可以被集合使用，表示集合中的元素均为协议类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;协议的继承&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;协议能够继承一到多个其它协议，语法与类的继承相似&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;协议合成&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个协议可由多个协议采用protocol&lt;OneProtocol, TwoProtocol&gt;这样的格式进行组合，称为洗衣合成&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol Named {&#xA;&#xA;}&#xA;&#xA;protocol Aged {&#xA;&#xA;}&#xA;&#xA;struct Person: Named, Aged {&#xA;&#xA;}&#xA;&#xA;func sayHello(a:protocol&amp;lt;Named, Aged&amp;gt;) {&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;检查协议的一致性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用is检查协议一致性&lt;/li&gt;&#xA;&lt;li&gt;使用as将协议类型向下转换为其它协议类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;is操作符用来检查实例是否遵循了某个协议&lt;/li&gt;&#xA;&lt;li&gt;as?返回一个可选值，当实例遵循协议时，返回协议类型，否则返回nil&lt;/li&gt;&#xA;&lt;li&gt;as用以强制转换类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// objc 用来表示协议是可选的&#xA;// 也可用来表示暴露给Objective-C的代码&#xA;// 此外objc型协议只对类有效，只能在类中检查协议的一致性&#xA;objc protocol HasArea {&#xA;    var area: Double { get }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;可选协议要求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;optional&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;可选协议含有可选成员，其遵循者可以选择是否实现这些成功，在协议中使用optional关键字作为前缀&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;objc protocol Hello {&#xA;    optional var name:String { get }&#xA;    optional func sayHi()&#xA;    optional func sayHello()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;泛型&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;泛型代码可以让你写出根据自我需求，适用于任何类型的、灵活且可重用的函数和类型，它可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;泛型函数&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sayHello&amp;lt;T&amp;gt;(inout a:T, inout b:T) {&#xA;    let x = a&#xA;    a = b&#xA;    b = x&#xA;}&#xA;&#xA;var a:String = &amp;quot;a&amp;quot;&#xA;var b:String = &amp;quot;b&amp;quot;&#xA;sayHello(&amp;amp;a, b: &amp;amp;b)&#xA;print(a, b)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;通常用字母T来命名类型参数，不过可以使用任何有效的标识符来作为类型参数名&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;泛型类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Stack&amp;lt;T&amp;gt; {&#xA;    var a:T&#xA;    func sayHello() -&amp;gt; T {&#xA;        return a&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展泛型类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;extension Stack {&#xA;    func sayHi() -&amp;gt; T {&#xA;        return a&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;类型约束&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol SomeProtocol {&#xA;&#xA;}&#xA;&#xA;class SomeClass {&#xA;&#xA;}&#xA;&#xA;func someFunction&amp;lt;T: SomeClass, U: SomeProtocol&amp;gt;(someT: T, someU: U) {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;关联类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;typealias&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;当定义一个协议时，有时候声明一个或多个关联类型作为协议定义的一部分是非常有用的&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个关联类型给定作用于协议部分的类型一个节点名(或别名)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol Container {&#xA;    typealias ItemType&#xA;    mutating func append(item: ItemType)&#xA;    var count: Int { get }&#xA;    subscript(i: Int) -&amp;gt; ItemType { get }&#xA;}&#xA;&#xA;struct IntStack:Container {&#xA;   typealias ItemType = Int&#xA;    func append(item: ItemType) {&#xA;&#xA;    }&#xA;    var count:Int {&#xA;        return 0&#xA;    }&#xA;    subscript(i:Int) -&amp;gt; Int {&#xA;        return 0&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展已知类型为一指定关联类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;extension Array: Container {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;where子句&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个where语句是你能够要求一个关联类型遵循一个特定的协议&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protocol Container {&#xA;    typealias ItemType&#xA;}&#xA;&#xA;func all&amp;lt;C1:Container, C2:Container where C1.ItemType == C2.ItemType&amp;gt;&#xA;    (a:C1, b:C2) -&amp;gt; Bool {&#xA;    typealias ItemType = Int&#xA;    return true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;访问级别&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;提供了三种不同的访问级别, 这些访问级别相对于源文件中定义的实体，同时也相对于这些源文件所属模块&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;public 可以访问自己模块或应用中源文件里的任何实体，别人也可以访问引入该模块中源文件里所有的实体&lt;/li&gt;&#xA;&lt;li&gt;internal 可以访问自己模块或应用中源文件里任何实体，但是别人不能访问该模块中源文件里的实体&lt;/li&gt;&#xA;&lt;li&gt;private 只能在当前源文件中使用的实体，称为私有实体&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;public 某个接口或Framework是可以被任何人使用的，可以将其设置为 public 级别&lt;/li&gt;&#xA;&lt;li&gt;internal 通常情况下，某个接口或 Framework 作为内部结构使用时，可以将其设置为 internal 级别&lt;/li&gt;&#xA;&lt;li&gt;private 使用 private 级别，可以用作隐藏某些功能的实现细节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;一个 public 访问级别的变量，不能将它的类型定义为 internal 和 private 类型&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;函数的访问级别不能高于它的参数、返回类型的访问级别&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;默认的访问级别为 internal&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class SomeClass() { }&#xA;internal class SomeClass() { }&#xA;private class SomeClass() { }&#xA;&#xA;public var some = 0&#xA;internal let some = 0&#xA;private func someFunction() { }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Swift语言基础教程笔记</title>
      <link>http://www.nljb.net/default/Swift%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
      <pubDate>2016-02-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Swift 数据类型&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;数据类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整数类型 Int, UInt&lt;/li&gt;&#xA;&lt;li&gt;浮点类型 Float, Double&lt;/li&gt;&#xA;&lt;li&gt;布尔类型 Bool&lt;/li&gt;&#xA;&lt;li&gt;字符类型 String, Character&lt;/li&gt;&#xA;&lt;li&gt;字典类型 Dictionary&lt;/li&gt;&#xA;&lt;li&gt;数组类型 Array(List)&lt;/li&gt;&#xA;&lt;li&gt;元组类型 Tuples&lt;/li&gt;&#xA;&lt;li&gt;集合理性 Set&lt;/li&gt;&#xA;&lt;li&gt;函数类型 Function&lt;/li&gt;&#xA;&lt;li&gt;闭包类型 Closure&lt;/li&gt;&#xA;&lt;li&gt;结构类型 Struct&lt;/li&gt;&#xA;&lt;li&gt;枚举类型 Enum&lt;/li&gt;&#xA;&lt;li&gt;可选类型 Optionals&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;其它类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类型别名 Typealias&lt;/li&gt;&#xA;&lt;li&gt;类型安全 Type safe&lt;/li&gt;&#xA;&lt;li&gt;类型推断 Type inference&lt;/li&gt;&#xA;&lt;li&gt;强制解析 Forced unwrapping&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;类型赋值&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;let imInt:Int = 2&#xA;let imDouble:Double = 3.1415926&#xA;let imBool:Bool = true&#xA;let imString:String = &amp;quot;Hello&amp;quot;&#xA;let imTuple:(Int, Int) = (2, 4)&#xA;let imPptional:Int? = nil&#xA;let imCharacter:Character = &amp;quot;!&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;值类型与引用类型&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;值类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 值类型传入的都是对象的副本，对值类型的修改不会影响原对象&#xA;Int &#xA;Float &#xA;Double &#xA;Bool &#xA;Tuple &#xA;String &#xA;Array &#xA;Dictionarry &#xA;Struct &#xA;Enum&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;引用类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;引用类型传入的都是对象的引用，对引用类型的修改会影响原对象&#xA;Function（函数） &#xA;Closure(闭包）&#xA;Class(类)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;类型转换&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 最简单的子类转父类：&#xA;var parentObject ＝ childObject as ParentClass&#xA;// 最简单的父类转子类（该父类对象一定要是该子类的引用）：&#xA;var childObject = parentObject as ChildClass&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Int 转其它&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var aInt : Int = 5&#xA;var aFloat = Float(aInt)&#xA;var aDouble = Double(aInt)&#xA;var aInt32 = Int32(aInt)&#xA;var aCGFloat = CGFloat(aInt)&#xA;var aString = String(aInt)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Double 转其它&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var bDouble : Double = 0.99&#xA;var bInt = Int(bDouble)&#xA;var bFloat = Float(bDouble)&#xA;var bCGFloat = CGFloat(bDouble)&#xA;var bString = &amp;quot;\(bDouble)&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;String 转其它&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var cString : String = &amp;quot;5&amp;quot;&#xA;var cInt = NSString(string: aString).integerValue&#xA;var dString : String = &amp;quot;0.99&amp;quot;&#xA;var dDouble = NSString(string: bString).doubleValue&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;可选类型&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Optionals&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当值可能不存在（may be absent）的时候使用Optionals。&#xA;&#xA;// 声明一个 Optionals 类型&#xA;var optionalInteger: Int?&#xA;var optionalInteger: Optional&amp;lt;Int&amp;gt;&#xA;&#xA;// 当你确定可选类型确实包含值之后&#xA;// 你可以用后缀!来访问这个值&#xA;optionalInteger = 42&#xA;optionalInteger! // 42&#xA;&#xA;// 使用操作符！去获取值为nil的可选变量会有运行时错误&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;例&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 普通的函数&#xA;func sayHello(name:String, _ addr:String) {&#xA;    print(name, addr)&#xA;}&#xA;&#xA;// 传入两个参数（可选型）&#xA;var name:String? = &amp;quot;nljb&amp;quot;&#xA;var addr:String? = &amp;quot;beijing&amp;quot;&#xA;&#xA;// 需要解包才可以传入&#xA;// 当然可以这样(name!, addr!)&#xA;// 也可以使用if-let安全解包&#xA;// 并且if-let添加判断条件&#xA;if let name = name where name == &amp;quot;jbnl&amp;quot;, let addr = addr {&#xA;    sayHello(name, addr)&#xA;} else {&#xA;    print(&amp;quot;no nljb&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果值为nil，任何操作都不会执行&#xA;&#xA;var myString:String? = nil&#xA;if myString != nil {&#xA;    print(myString)&#xA;}else{&#xA;    print(&amp;quot;nil&amp;quot;)&#xA;}&#xA;// 输出 nil&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;强制解析&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var myString:String?&#xA;myString = &amp;quot;Hello, Swift!&amp;quot;&#xA;if myString != nil {&#xA;   print(myString)&#xA;}else{&#xA;   print(&amp;quot;myString 值为 nil&amp;quot;)&#xA;}&#xA;// 输出 Optional(&amp;quot;Hello, Swift!&amp;quot;) &#xA;&#xA;var myString:String?&#xA;myString = &amp;quot;Hello, Swift!&amp;quot;&#xA;if myString != nil {&#xA;   // 强制解析&#xA;   print( myString! )&#xA;}else{&#xA;   print(&amp;quot;myString 值为 nil&amp;quot;)&#xA;}&#xA;// 输出 Hello, Swift!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;自动解析&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 你可以在声明可选变量时使用感叹号（!）替换问号（?）。&#xA;// 这样可选变量在使用时就不需要再加一个感叹号（!）来获取值，它会自动解析。&#xA;&#xA;var myString:String!&#xA;myString = &amp;quot;Hello, Swift!&amp;quot;&#xA;if myString != nil {&#xA;   print(myString)&#xA;}else{&#xA;   print(&amp;quot;myString 值为 nil&amp;quot;)&#xA;}&#xA;// 输出 Hello, Swift!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;可选绑定&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用可选绑定（optional binding）来判断可选类型是否包含值&#xA;// 如果包含就把值赋给一个临时常量或者变量。&#xA;&#xA;// 可选绑定可以用在if和while语句中来对可选类型的值进行判断并把值赋给一个常量或者变量。&#xA;&#xA;var myString:String?&#xA;myString = &amp;quot;Hello, Swift!&amp;quot;&#xA;if let yourString = myString {&#xA;   print(&amp;quot;你的字符串值为 - \(yourString)&amp;quot;)&#xA;}else{&#xA;   print(&amp;quot;你的字符串没有值&amp;quot;)&#xA;}&#xA;// 你的字符串值为 - Hello, Swift!&#xA;&#xA;// 注意：还可以使用二元运算符，具体可以看二元运算介绍&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;变量&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 变量 (指定类型)&#xA;var n:Int ; n = 1 ; print(n)&#xA;&#xA;// 变量 (未指定类型, 类型由初始化值决定)&#xA;var nn = 1 ; nn = 2 ; print(nn)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;常量&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 常量&#xA;let x = 100; print(x)&#xA;let xx:Int = 100 ; print(xx)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;字符串&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;String&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 空字符串&#xA;var stringA = &amp;quot;&amp;quot;&#xA;stringA.isEmpty&#xA;&#xA;// 字符串长度&#xA;var varA  = &amp;quot;xxx&amp;quot;&#xA;print(&amp;quot;\(varA.characters.count)&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 字符串连接&#xA;var str = &amp;quot;abc&amp;quot;&#xA;// 字符串与字符串&#xA;str = str + &amp;quot;def&amp;quot;&#xA;// 字符串与Int类型值&#xA;str = &amp;quot;\(str)=\(100)&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;常用方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;isEmpty &#xA;    判断字符串是否为空，返回布尔值&#xA;hasPrefix(prefix: String) &#xA;    检查字符串是否拥有特定前缀&#xA;hasSuffix(suffix: String) &#xA;    检查字符串是否拥有特定后缀。&#xA;Int(String) &#xA;    转换字符串数字为整型&#xA;    let myString: String = &amp;quot;256&amp;quot;&#xA;    let myInt: Int? = Int(myString)&#xA;String.characters.count &#xA;    计算字符串的长度&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Foundation&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以用String使用原来在OC语言里NSString中所有的方法&#xA;import Foundation&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;元运算&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;三元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Exp1 ? Exp2 : Exp3;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;二元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a ?? b -&amp;gt; a != nil ? a! : b&#xA;&#xA;// a 必须为 Optionals 类型&#xA;// b 类型必须是 a 解包后类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;数组&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Array&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 我们可以使用构造语法来创建一个由特定数据类型构成的空数组：&#xA;var someArray = [SomeType]()&#xA;&#xA;// 以下是创建一个初始化大小数组的语法：&#xA;var someArray = [SomeType](count: NumbeOfElements, repeatedValue: InitialValue)&#xA;&#xA;// 以下实例创建了一个类型为 Int ，大小为 3，初始值为 0 的空数组：&#xA;var someInts = [Int](count: 3, repeatedValue: 0)&#xA;&#xA;// 以下实例创建了含有三个元素的数组：&#xA;var someInts:[Int] = [10, 20, 30]&#xA;&#xA;// 我们可以根据数组的索引来访问数组的元素，语法如下：&#xA;var someVar = someArray[index]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;例&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 数组&#xA;var arr1 = []&#xA;var arr2 = [&amp;quot;abc&amp;quot;, 123]&#xA;var arr3 = [String]()&#xA;var arr4:[String] = [&amp;quot;abc&amp;quot;, &amp;quot;bcd&amp;quot;]&#xA;&#xA;// 遍历&#xA;for item in someStrs {&#xA;    print(item)&#xA;}&#xA;&#xA;// 合并&#xA;var intsA = [Int](count:2, repeatedValue: 2)&#xA;var intsB = [Int](count:3, repeatedValue: 1)&#xA;var intsC = intsA + intsB&#xA;&#xA;// isEmpty&#xA;intsC.isEnpty&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;无序集合&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Set&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 无序集合, 初始化&#xA;var s = Set&amp;lt;String&amp;gt;([&amp;quot;D&amp;quot;, &amp;quot;E&amp;quot;])&#xA;// 插入数据&#xA;s.insert(&amp;quot;A&amp;quot;)&#xA;s.insert(&amp;quot;B&amp;quot;)&#xA;&#xA;// 无序集合, 初始化&#xA;var e:Set&amp;lt;String&amp;gt; = [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;]&#xA;// 是否为空&#xA;e.isEmpty&#xA;// 集合数量&#xA;e.count&#xA;// 是否存在&#xA;e.contains(&amp;quot;A&amp;quot;)&#xA;// 移除对象&#xA;e.remove(&amp;quot;B&amp;quot;)&#xA;&#xA;// 两个集合的交集&#xA;s.intersect(e)&#xA;// 两个集合的并集&#xA;s.union(e)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;元组&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Tuples&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 元组（tuples）是把多个值组合成一个复合值&#xA;// 元组内的值可以使任意类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;let http404Error = (404, &amp;quot;Not Found&amp;quot;)&#xA;// 将一个 Int 类型值和一个 String 类型值组合在一起&#xA;&#xA;// 可以将一个元组的内容分解成单独的常量或变量：&#xA;let (statusCode, statusMessage) = http404Error&#xA;println(&amp;quot;The status code is \(statusCode)&amp;quot;)&#xA;println(&amp;quot;The status message is \(statusMessage)&amp;quot;)&#xA;&#xA;// 如果你只需要一部分元组的值，忽略的部分用下划线(_)标记:&#xA;let (justTheStatusCode, _) = http404Error&#xA;println(&amp;quot;The status code is \(justTheStatusCode)&amp;quot;)&#xA;&#xA;// 另外，可以使用索引访问元组中的各个元素，索引数字从0开始:&#xA;println(&amp;quot;The status code is \(http404Error.0)&amp;quot;)&#xA;println(&amp;quot;The status message is \(http404Error.1)&amp;quot;)&#xA;&#xA;// 可以给元组的各个元素进行命名:&#xA;let http200Status = (statusCode: 200, description: &amp;quot;OK&amp;quot;)&#xA;&#xA;// 这时，可以使用元素名来访问这些元素的值:&#xA;println(&amp;quot;The status code is \(http200Status.statusCode)&amp;quot;)&#xA;println(&amp;quot;The status message is \(http200Status.description)&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;字典&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Dictionary&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 我们可以使用以下语法来创建一个特定类型的空字典：&#xA;var someDict =  [KeyType : ValueType]()&#xA;&#xA;// 以下是创建一个空字典，键的类型为 Int，值的类型为 String 的简单语法：&#xA;var someDict = [Int : String]()&#xA;&#xA;// 以下为创建一个字典的实例：&#xA;var someDict:[Int:String] = [1:&amp;quot;One&amp;quot;, 2:&amp;quot;Two&amp;quot;, 3:&amp;quot;Three&amp;quot;]&#xA;&#xA;// 我们可以根据字典的索引来访问数组的元素，语法如下：&#xA;var someVar = someDict[key]&#xA;&#xA;// 我们可以使用 updateValue(forKey:) 增加或更新字典的内容。&#xA;// 如果 key 不存在，则添加值，如果存在则修改 key 对应的值。&#xA;someDict:[Int:String] = [1:&amp;quot;One&amp;quot;, 2:&amp;quot;Two&amp;quot;, 3:&amp;quot;Three&amp;quot;]&#xA;var oldVal = someDict.updateValue(&amp;quot;One 新的值&amp;quot;, forKey: 1)&#xA;&#xA;// 我们可以使用 removeValueForKey() 方法来移除字典 key-value 对。&#xA;// 如果 key 存在该方法返回移除的值，如果不存在返回 nil 。实例如下：&#xA;var someDict:[Int:String] = [1:&amp;quot;One&amp;quot;, 2:&amp;quot;Two&amp;quot;, 3:&amp;quot;Three&amp;quot;]&#xA;var removedValue = someDict.removeValueForKey(2)&#xA;&#xA;// 我们可以使用 for-in 循环来遍历某个字典中的键值对。实例如下:&#xA;var someDict:[Int:String] = [1:&amp;quot;One&amp;quot;, 2:&amp;quot;Two&amp;quot;, 3:&amp;quot;Three&amp;quot;]&#xA;for (key, value) in someDict {&#xA;   print(&amp;quot;字典 key \(key) -  字典 value \(value)&amp;quot;)&#xA;}&#xA;&#xA;// 你可以提取字典的键值(key-value)对，并转换为独立的数组。实例如下：&#xA;var someDict:[Int:String] = [1:&amp;quot;One&amp;quot;, 2:&amp;quot;Two&amp;quot;, 3:&amp;quot;Three&amp;quot;]&#xA;let dictKeys = [Int](someDict.keys)&#xA;let dictValues = [String](someDict.values)&#xA;&#xA;// 我们可以使用只读的 count 属性来计算字典有多少个键值对：&#xA;var someDict1:[Int:String] = [1:&amp;quot;One&amp;quot;, 2:&amp;quot;Two&amp;quot;, 3:&amp;quot;Three&amp;quot;]&#xA;var someDict2:[Int:String] = [4:&amp;quot;Four&amp;quot;, 5:&amp;quot;Five&amp;quot;]&#xA;print(&amp;quot;someDict1 含有 \(someDict1.count) 个键值对&amp;quot;)&#xA;print(&amp;quot;someDict2 含有 \(someDict2.count) 个键值对&amp;quot;)&#xA;&#xA;// 我们可以通过只读属性 isEmpty 来判断字典是否为空，返回布尔值:  &#xA;var someDict3:[Int:String] = [Int:String]()&#xA;print(&amp;quot;someDict1 = \(someDict1.isEmpty)&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;函数&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Function&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Swift 定义函数使用关键字 func&#xA;&#xA;// Swift func 是可以进行嵌套使用的&#xA;&#xA;// 可以指定一个或多个输入参数和一个返回值类型&#xA;// 无参函数 func runoob() -&amp;gt; String &#xA;// 单个参数 func runoob(site:String) -&amp;gt; String &#xA;func runoob(one:String, two:String) -&amp;gt; String {&#xA;    return site&#xA;}&#xA;print(runoob(&amp;quot;xxx&amp;quot;))&#xA;&#xA;// 例&#xA;func sayHello(name:String?) -&amp;gt; String {&#xA;    // 这里如果用户没有指定名称则返回Guest&#xA;    let result = &amp;quot;Hello, &amp;quot; + (name ?? &amp;quot;Guest&amp;quot;) + &amp;quot;!&amp;quot;&#xA;    return result&#xA;}&#xA;var nickname:String?&#xA;nickname = &amp;quot;World&amp;quot;&#xA;print(sayHello(nickname))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;常量参数&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sayHello(name:String) -&amp;gt; String {&#xA;    // 传值操作&#xA;    // 则此时name是常量参数不可以修改&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;变量参数&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sayHello(var name:String) -&amp;gt; String {&#xA;    // 传值操作&#xA;    // 局部变量参数，修改不会影响外部&#xA;    // 则此时name是变量参数可以修改&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;通过元组返回多个值&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ...&#xA;func maxminScores(scores:[Int]) -&amp;gt; (maxscore:Int, minscore:Int) {&#xA;    ...&#xA;    return (scores[0], scores[1])&#xA;}&#xA;&#xA;// 元组返回异常情况, 则这里需要使用 optionals 可选型&#xA;func maxminScores(scores:[Int]) -&amp;gt; (maxscore:Int, minscore:Int)? {&#xA;    if scores.isEmpty {&#xA;        return nil&#xA;    }&#xA;    return (scores[0], scores[1])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;内部与外部 函数名&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// userName 外部函数名, greetingWord 外部函数名&#xA;// nickname 内部函数名, greetingWord 内部函数名&#xA;func sayHello(userName nickname:String, greetingWord greeting:String) -&amp;gt; String {&#xA;    ...&#xA;}&#xA;&#xA;// 使用外部函数名&#xA;sayHello(userNmae: &amp;quot;xxx&amp;quot;, greetingWord: &amp;quot;xxx&amp;quot;)  &#xA;&#xA;// nickname 既是内部参数名，又是外部参数名&#xA;// greeting 既是内部参数名，又是外部参数名&#xA;func sayHello(#nickname:String, #greeting:String) -&amp;gt; String {   &#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;参数的默认值&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ...&#xA;func sayHello(nickname:String, greeting:String = &amp;quot;nljb&amp;quot; ) -&amp;gt; String {   &#xA;    ...&#xA;}&#xA;&#xA;// 使用时如果不传入greeting则使用默认值&#xA;sayHello(&amp;quot;xxx&amp;quot;)&#xA;&#xA;// 如果设置了参数默认值则必须使用外部函数名&#xA;// 如果不指定参数默认值的外部函数名则自动使用内部函数名&#xA;sayHello(&amp;quot;xxx&amp;quot;, greeting: &amp;quot;xxx&amp;quot;)&#xA;&#xA;// _ 取消苹果为参数默认值所指定强制外部函数名的设置&#xA;func sayHello(nickname:String, _ greeting:String = &amp;quot;nljb&amp;quot; ) -&amp;gt; String { &#xA;    ...&#xA;}&#xA;&#xA;// 通过外部函数名可以指定传入的参数&#xA;func sayHello(nickname:String, greeting:String = &amp;quot;nljb&amp;quot;, others:String = &amp;quot;com&amp;quot;) -&amp;gt; String { &#xA;    ...&#xA;}&#xA;&#xA;// ...&#xA;sayHello(&amp;quot;www&amp;quot;, others: &amp;quot;net&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;inout&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 传引用值, 当声明参数的时候加上 inout&#xA;// 则如果修改该值，外部的值也随之改变&#xA;func sayHello(inout a:Int, inout b:Int) {&#xA;    a = 100&#xA;    b = 100 &#xA;}&#xA;&#xA;// ...&#xA;var x = 0&#xA;var y = 0&#xA;sayHello(&amp;amp;x, b: &amp;amp;y)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;函数类型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 函数类型&#xA;func sayHello(a:Int, b:Int) -&amp;gt; String {&#xA;    ...&#xA;}&#xA;&#xA;// 则 another 当 sayHello 用&#xA;let another = sayHello&#xA;&#xA;// 指定类型&#xA;let another:(Int, Int) -&amp;gt; String = sayHello&#xA;&#xA;// 返回值为空也必须写 () or Void&#xA;let another:(Int, Int) -&amp;gt; () = sayHello&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ...&#xA;func sayWorld() -&amp;gt; Int {&#xA;    return 99;&#xA;}&#xA;&#xA;// 返回函数类型&#xA;func sayHello() () -&amp;gt; Int {&#xA;    return sayWorld();&#xA;}&#xA;&#xA;let x = sayHello()&#xA;x()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;闭包&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Closure&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 接受闭包的函数&#xA;func sayHello(a:Int, _ x:(a:Int, b:Int) -&amp;gt; Int) -&amp;gt; Int { return x(a: a,b: a) }&#xA;&#xA;// 传入闭包&#xA;let x = sayHello(100, {(a:Int, b:Int) -&amp;gt; Int in return a + b })&#xA;&#xA;// 传入闭包 简写&#xA;let y = sayHello(100, {a, b in return a + b })&#xA;&#xA;// 传入闭包 简写&#xA;let z = sayHello(100, {a, b in a + b })&#xA;&#xA;// 传入闭包 简写 传入参数($0 ... $n)&#xA;let v = sayHello(100, {$0 + $1})&#xA;&#xA;// 传入闭包 简写 运算符&#xA;let n = sayHello(100, +)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 结尾闭包 ... 当闭包是最后一个参数时&#xA;let m = sayHello(100) {&#xA;    (a:Int, b:Int) -&amp;gt; Int in&#xA;    return a + b&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 闭包内使用外部变量&#xA;var num = 5&#xA;let h = sayHello(100) {&#xA;    (a:Int, b:Int) -&amp;gt; Int in&#xA;    return a + b + 5&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;枚举&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Enum&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 枚举是值类型&#xA;&#xA;// 枚举类型&#xA;enum GameEnding {&#xA;    case Win&#xA;    case Lose&#xA;    case Draw&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用案例&#xA;&#xA;var yourScore:Int = 0&#xA;var enemyScore:Int = 0&#xA;&#xA;var theGameEnding:GameEnding = .Win&#xA;if yourScore &amp;gt; enemyScore { theGameEnding = .Win }&#xA;if yourScore &amp;lt; enemyScore { theGameEnding = .Lose }&#xA;if yourScore == enemyScore { theGameEnding = .Draw }&#xA;&#xA;switch theGameEnding {&#xA;    case .Win: print(&amp;quot;Win&amp;quot;)&#xA;    case .Lose: print(&amp;quot;Lose&amp;quot;)&#xA;    case .Draw: print(&amp;quot;Draw&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 枚举类型（挂接值为Int, 并且自动++)&#xA;enum Month:Int {&#xA;    case Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec&#xA;}&#xA;&#xA;// 枚举变量&#xA;let m:Month = .Jan&#xA;&#xA;// 枚举变量，挂接值&#xA;print(m.rawValue)&#xA;&#xA;// 挂接值创建变量 &#xA;// 使用?的原因是rawValue不可控&#xA;// 如果rawValue在Month中没有则返回nil&#xA;let o:Month? = Month(rawValue: 12)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 枚举类型（挂接值为String)&#xA;enum Month:String {&#xA;    case OK = &amp;quot;Is Ok&amp;quot;&#xA;    case Error = &amp;quot;Is Error&amp;quot;&#xA;}&#xA;&#xA;// 可以进行状态定义&#xA;func isOK() -&amp;gt; Month {&#xA;    return Month.Error&#xA;}&#xA;&#xA;if isOK() == Month.OK {&#xA;    print(Month.OK.rawValue)&#xA;} else {&#xA;    print(Month.Error.rawValue)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 枚举类型&#xA;enum BarCode {&#xA;    // 包含四个Int的UPCA&#xA;    case UPCA(Int, Int, Int, Int)&#xA;    // 包含一个String的QRcode&#xA;    case QRcode(String)&#xA;}&#xA;&#xA;// 枚举变量（方法一）&#xA;let codeA = BarCode.UPCA(100, 200, 300, 400)&#xA;// 枚举变量（方法二）&#xA;let codeB:BarCode = .QRcode(&amp;quot;Hello QRcode&amp;quot;)&#xA;&#xA;// 使用变量&#xA;switch codeA {&#xA;    case .UPCA(let a, let b, let c, let d):&#xA;        print(a,b,c,d)&#xA;    case .QRcode(let s):&#xA;        print(s)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;结构体&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Struct&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 结构体是值类型&#xA;&#xA;// 构造器语法的最简单形式实在结构体或者类型的名称后跟随一个空括号&#xA;&#xA;// 注意：所有的结构体都有一个自动生成的成员构造器&#xA;//   用于初始化新结构体实例中成员的属性&#xA;（与结构体不同，类实例没有默认的成员构造器）&#xA;（类实例需要使用构造函数init(...)自定义初始化成员属性）&#xA;&#xA;// 结构体（未初始化值)&#xA;struct MarkStruct {&#xA;    var mark1: Int&#xA;    var mark2: Int&#xA;    var mark3: Int&#xA;}&#xA;&#xA;// 结构体变量&#xA;var mark = MarkStruct(mark1: 1, mark2: 2, mark3: 3)&#xA;&#xA;// 结构体（初始化值)&#xA;struct MarkStruct {&#xA;    var mark1 = 1&#xA;    var mark2 = 2&#xA;    var mark3 = 3&#xA;}&#xA;&#xA;// 结构体变量&#xA;var mark = MarkStruct();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;备注&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 类(类型)与结构体 T()&#xA;var a:String = String()&#xA;&#xA;// : 后面指定的是类型&#xA;// Swift可以自动识别类型&#xA;var a = String()&#xA;&#xA;// 初始化值，可能在()里面填写&#xA;var a = String(&amp;quot;Hello World&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 数组&#xA;var someArray = [Int]()&#xA;var someInts:[Int] = [10, 20, 30]&#xA;&#xA;// 无序集合&#xA;var e:Set&amp;lt;String&amp;gt; = [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;]&#xA;var e = Set&amp;lt;String&amp;gt;([&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;])&#xA;&#xA;// 字典&#xA;var someDict = [Int : String]()&#xA;var someDict:[Int:String] = [1:&amp;quot;One&amp;quot;, 2:&amp;quot;Two&amp;quot;, 3:&amp;quot;Three&amp;quot;]&#xA;&#xA;....&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之动画相关案例</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B/</link>
      <pubDate>2016-02-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;弹出与收缩 View Layout&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 动画显示 View&#xA;private void showViewAnimation(final View v) {&#xA;    // 点击隐藏View&#xA;    v.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View view) {&#xA;            hideViewAnimation(v);&#xA;        }&#xA;    });&#xA;    // AnimationSet 把多个动画组合成一个组合的机制&#xA;    AnimationSet animSet = new AnimationSet(true);&#xA;    // 缩放动画效果（从小到大）&#xA;    ScaleAnimation sa = new ScaleAnimation(&#xA;            // 动画起始时 X 坐标上的伸缩尺寸&#xA;            // View 宽 / View 父 宽&#xA;            // 宽 / 父宽 = 0 - 1 范围 宽 比例&#xA;            (float) v.getWidth() / ((View) v.getParent()).getWidth(),&#xA;            // 动画结束时 X 坐标上的伸缩尺寸&#xA;            1.0f,&#xA;            // 动画起始时 Y 坐标上的伸缩尺寸&#xA;            // View 高 / View 父 高&#xA;            // 高 / 父高 = 0 - 1 范围 高 比例&#xA;            (float) v.getHeight() / ((View) v.getParent()).getHeight(),&#xA;            // 动画结束时 Y 坐标上的伸缩尺寸&#xA;            1.0f,&#xA;            // 缩放起点 X 轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%&#xA;            // View 的 X 坐标 + View 宽 / 2&#xA;            // 从 X 坐标 开始缩放&#xA;            // 从 View 左上角开始&#xA;            v.getX(),// + v.getWidth() / 2,&#xA;            // 缩放起点 Y 轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%&#xA;            // View 的 Y 坐标 + View 高 / 2&#xA;            // 从 Y 坐标 开始缩放&#xA;            // 从 View 左上角开始&#xA;            v.getY());// + v.getHeight() / 2);&#xA;    // 设置动画持续时间&#xA;    sa.setDuration(1000);&#xA;    // 透明度渐变动画（从透明到不透明）&#xA;    AlphaAnimation aa = new AlphaAnimation(0.2f, 1);&#xA;    // 设置动画持续时间&#xA;    aa.setDuration(2000);&#xA;    // 并可设置组中动画的时序关系，如同时播放，顺序播放等&#xA;    animSet.addAnimation(sa);&#xA;    animSet.addAnimation(aa);&#xA;    // 开始执行动画&#xA;    v.startAnimation(animSet);&#xA;    // 显示 View&#xA;    v.setVisibility(View.VISIBLE);&#xA;}&#xA;&#xA;// 动画隐藏 View&#xA;private void hideViewAnimation(View v) {&#xA;    // 只处理非隐藏状态下的 View&#xA;    if (v.getVisibility() != View.GONE) {&#xA;        // AnimationSet 把多个动画组合成一个组合的机制&#xA;        AnimationSet animSet = new AnimationSet(true);&#xA;        // 缩放动画效果（从大到小）&#xA;        ScaleAnimation sa = new ScaleAnimation(&#xA;                // 从 X 坐标，最大开始&#xA;                1,&#xA;                // 宽 / 父宽 = 0 - 1 范围 宽 比例&#xA;                (float) v.getWidth() / ((View) v.getParent()).getWidth(),&#xA;                // 从 Y 坐标，最大开始&#xA;                1,&#xA;                // 高 / 父高 = 0 - 1 范围 高 比例&#xA;                (float) v.getHeight() / ((View) v.getParent()).getHeight(),&#xA;                // 从 View 右下角开始&#xA;                v.getX() + v.getWidth(),&#xA;                // 从 View 右下角开始&#xA;                v.getY() + v.getHeight());&#xA;        // 设置动画持续时间&#xA;        sa.setDuration(1000);&#xA;        // 透明度渐变动画（从不透明到透明）&#xA;        AlphaAnimation aa = new AlphaAnimation(1f, 0f);&#xA;        // 设置动画持续时间&#xA;        aa.setDuration(2000);&#xA;        // 并可设置组中动画的时序关系，如同时播放，顺序播放等&#xA;        animSet.addAnimation(sa);&#xA;        animSet.addAnimation(aa);&#xA;        // 开始执行动画&#xA;        v.startAnimation(animSet);&#xA;        // 隐藏 View&#xA;        v.setVisibility(View.GONE);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之Go1.5生成C动态库</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BGo1.5%E7%94%9F%E6%88%90C%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>2016-02-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Go1.5 生成 C 动态库&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;不能将单个的包编译成C库；&#xA;&#xA;项目必须包含main包和main入口函数；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// lib.go&#xA;package main&#xA;&#xA;import &amp;quot;C&amp;quot;&#xA;&#xA;//export Hello&#xA;func Hello() string {&#xA;    return &amp;quot;Hello&amp;quot;&#xA;}&#xA;&#xA;func main() { }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;生成动态库&#xA;&#xA;go build -v -x -buildmode=c-shared -o lib.so&#xA;&#xA;生成静态库：&#xA;&#xA;go build -v -x -buildmode=c-archive -o lib.a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;生成动态库后，当前目录会出现, lib.h 与 lib.so&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Go1.5 生成 Go 动态库&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 貌似暂时不支持MacOS与Windows系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package lib&#xA;&#xA;//export Hello&#xA;func Hello() string {&#xA;    return &amp;quot;Hello&amp;quot;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 构建核心基本库&#xA;go install -v -x -buildmode=shared runtime sync/atomic&#xA;// 构建GO动态库&#xA;go install -v -x -buildmode=shared -linkshared &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 调用&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;lib&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fmt.Println(lib.Hello())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译&#xA;go build -v -x -linkshared&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;ubuntu 环境部署&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载地址：http://www.golangtc.com/download&#xA;go1.8.linux-amd64.tar.gz&#xA;&#xA;// 必须解压到 /usr/local 中 ...&#xA;tar -C /usr/local -xzf go1.8.linux-amd64.tar.gz&#xA;&#xA;// 设置环境变量&#xA;vim ~/.bashrc&#xA;&#xA;export GOPATH=/opt/go&#xA;export GOROOT=/usr/local/go&#xA;export GOARCH=386 // 这里也可以是 amd64 &#xA;export GOOS=linux&#xA;export GOBIN=$GOROOT/bin/&#xA;export GOTOOLS=$GOROOT/pkg/tool/&#xA;export PATH=$PATH:$GOBIN:$GOTOOLS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之抽象工厂方法模式</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>2016-02-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;抽象工厂方法模式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;虽然抽象工厂方法模式的类繁多，但是，主要还是分为四类&#xA;&#xA;AbstractFactory 抽象工厂角色&#xA;    它声明了一组用于创建一种产品的方法，每一个方法对应一种产品&#xA;ConcreteFactory 具体工厂角色&#xA;    它实现了在抽象工厂中定义的创建产品的方法，生成一组具体产品&#xA;    这些产品构成了一个产品种类，每一个产品都位于某个产品等级结构中&#xA;AbstractProduct 抽象产品角色&#xA;    它为每种产品舍生命接口&#xA;ConcreteProduct 具体产品角色&#xA;    它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明业务方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 抽象车厂类    &#xA;public abstract class CarFactory {&#xA;&#xA;    // 生产轮胎&#xA;    public abstract ITire createTire();&#xA;&#xA;    // 生产发动机&#xA;    public abstract IEngine createEngine();&#xA;&#xA;    // 生产制动系统&#xA;    public abstract IBrake createBrake();&#xA;&#xA;}   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 轮胎相关类&#xA;public interface ITire {&#xA;    // 轮胎&#xA;    void tire();&#xA;}&#xA;&#xA;// 普通轮胎&#xA;public class NormalTire implements ITire {&#xA;    @Override&#xA;    public void tire() {&#xA;        System.out.println(&amp;quot;普通轮胎&amp;quot;);&#xA;    ｝&#xA;}&#xA;&#xA;// 越野轮胎&#xA;public class SUVTire implements ITire {&#xA;    @Override&#xA;    public void tire() {&#xA;        System.out.println(&amp;quot;越野轮胎&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 发动机相关类&#xA;public interface IEngine {&#xA;    // 发动机&#xA;    void engine();&#xA;}&#xA;&#xA;// 国产发动机&#xA;public class DomesticEngine implements IEngine {&#xA;    @Override&#xA;    public void engine() {&#xA;        System.out.println(&amp;quot;国产发动机&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;// 进口发动机&#xA;public class ImportEngine implements IEngine {&#xA;    @Override&#xA;    public void engine() {&#xA;        System.out.println(&amp;quot;进口发动机&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 制动系统相关类&#xA;public interface IBrake {&#xA;    // 制动系统&#xA;    void brake();&#xA;}&#xA;&#xA;// 普通制动&#xA;public class NormalBrake implements IBrake {&#xA;    @Override&#xA;    public void brake() {&#xA;        System.out.println(&amp;quot;普通制动&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;// 高级制动&#xA;public class SeniorBrake implements IBrake {&#xA;    @Override&#xA;    public void brake() {&#xA;        System.out.println(&amp;quot;高级制动&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Q3 工厂类&#xA;public class Q3Factory entends CarFactory {&#xA;    @Override&#xA;    public ITire createTire() {&#xA;        // Q3 使用普通轮胎&#xA;        return new NormalTire();        &#xA;    }&#xA;    @Override&#xA;    public IEngine createEngine() {&#xA;        // Q3 使用普通发动机&#xA;        return new DomesticEngine();&#xA;    }&#xA;    @Override&#xA;    public IEngine createBrake() {&#xA;        // Q3 使用普通制动&#xA;        return new NormalBrake();&#xA;    }&#xA;}&#xA;&#xA;// Q5 工厂类&#xA;public class Q5Factory entends CarFactory {&#xA;    @Override&#xA;    public ITire createTire() {&#xA;        // Q5 使用越野轮胎&#xA;        return new SUVTire();       &#xA;    }&#xA;    @Override&#xA;    public IEngine createEngine() {&#xA;        // Q5 使用进口发动机&#xA;        return new ImportEngine();&#xA;    }&#xA;    @Override&#xA;    public IEngine createBrake() {&#xA;        // Q5 使用高级制动&#xA;        return new SeniorBrake();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class Client {&#xA;    public static void main(String[] args) {&#xA;        CarFctory factoryQ3 = new Q3Factory();&#xA;        factoryQ3.createTire().tire();&#xA;        factoryQ3.createEngine().engine();&#xA;        factoryQ3.createBrake().brake();&#xA;        CarFctory factoryQ5 = new Q5Factory();&#xA;        factoryQ5.createTire().tire();&#xA;        factoryQ5.createEngine().engine();&#xA;        factoryQ5.createBrake().brake();&#xA;    }&#xA;}   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之工厂方法模式</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>2016-02-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;工厂方法模式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;定义一个用于创建对象的接口，让子类决定实例化哪个类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 产品类（抽象)&#xA;public abstract class Product {&#xA;    // 产品类的抽象方法&#xA;    // 由具体的产品类去实现&#xA;    public abstract void method();&#xA;}&#xA;&#xA;// 具体产品A&#xA;public class ConcreteProductA extends Product {&#xA;    @Override&#xA;    public void method() {&#xA;        System.out.println(&amp;quot;我是具体的产品A&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;// 具体产品B&#xA;public class ConcreteProductB extends Product {&#xA;    @Override&#xA;    public void method() {&#xA;        System.out.println(&amp;quot;我是具体的产品A&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 抽象工厂类&#xA;public abstract class Factory {&#xA;    // 抽象工厂方法&#xA;    // 具体生产什么由子类去实现&#xA;    public abstract Product createProduct();&#xA;}&#xA;&#xA;// 具体工厂类&#xA;public Class ConcreteFactory extends Factory {&#xA;    @Override&#xA;    public Product createProduct() {&#xA;        return new ConcreteProductA();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 客户类&#xA;public class Client {&#xA;    public static void main(String[] args) {&#xA;        // 创建具体工厂对象, 向上转换为抽象工厂对象&#xA;        Factory factory = new ConcreteFactory();&#xA;        // 通过抽象方法，调用，具体工厂的方法&#xA;        // 具体工厂方法，&#xA;        // 创建具体产品对象，向上转换为抽象产品对象&#xA;        Product p = factory.createProduct();&#xA;        // 抽象产品对象, 调用, 具体产品对象方法&#xA;        p.method();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 利用反射的方式更简洁地来生产具体产品对象&#xA;public abstract class Factory {&#xA;    // 抽象工厂方法，具体生产什么由子类去实现&#xA;    public abstract &amp;lt;T extends Product&amp;gt; T createProduct(Class&amp;lt;T&amp;gt; clz);&#xA;}&#xA;&#xA;// 对于具体的工厂类，则通过反射获取类的示例即可&#xA;public class ConcreteFactiry extends Factory {&#xA;    @Overrid&#xA;    public &amp;lt;T extends Product&amp;gt; T createProduct(Class&amp;lt;T&amp;gt; clz) {&#xA;        Product p = null;&#xA;        try {&#xA;            p = (Product) Class.forName(clz.getName()).newInstance();&#xA;        } catch (Exception e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;        return (T) p;&#xA;    }&#xA;}&#xA;&#xA;// Client&#xA;public class Client {&#xA;    public static void main(String[] args) {&#xA;        Factory factiry = new ConcreteFactory();&#xA;        Product p = factory.createProduct(ConcreteProductB.class);&#xA;        p.method();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下面通过一个汽车的自检流程来理解工厂方法&#xA;&#xA;// 汽车，抽象工厂类&#xA;public abstract class Factory {&#xA;    // 汽车的工厂方法&#xA;    public abstract &amp;lt;T extends Car&amp;gt; T createCar(Class&amp;lt;T&amp;gt; clz);&#xA;}&#xA;&#xA;// 汽车，具体工厂类&#xA;public class CarFactory extends Factory {&#xA;    @Override&#xA;    public &amp;lt;T extends Car&amp;gt; T createCar(Class&amp;lt;T&amp;gt; clz) {&#xA;        Car car = null;&#xA;        try {&#xA;            car = (Car) Class.forName(clz.getName()).newInstance();&#xA;        } catch (Exception e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;        return (T) car;&#xA;    }&#xA;}&#xA;&#xA;// 汽车抽象类&#xA;public abstract class Car {&#xA;    // 启动&#xA;    public abstract void drive();&#xA;    // 巡航&#xA;    public abstract void selfNavigation();&#xA;}&#xA;&#xA;// 汽车具体类&#xA;public abstract class AudiCar extends Car {&#xA;    // ...&#xA;}   &#xA;&#xA;// 奥迪汽车，具体类&#xA;public class AudiQ3 extends AudiCar {&#xA;    @Override&#xA;    public void drive() {&#xA;        System.out.println(&amp;quot;Q3 启动了&amp;quot;);&#xA;    }&#xA;    @Override&#xA;    public void selfNavigation() {&#xA;        System.out.println(&amp;quot;Q3 自动巡航&amp;quot;);&#xA;    }   &#xA;}&#xA;&#xA;// 奥迪汽车，具体类&#xA;public class AudiQ5 extends AudiCar {&#xA;    @Override&#xA;    public void drive() {&#xA;        System.out.println(&amp;quot;Q5 启动了&amp;quot;);&#xA;    }&#xA;    @Override&#xA;    public void selfNavigation() {&#xA;        System.out.println(&amp;quot;Q5 自动巡航&amp;quot;);&#xA;    }       &#xA;}&#xA;&#xA;// 奥迪汽车，具体类&#xA;public class AudiQ7 extends AudiCar {&#xA;    @Override&#xA;    public void drive() {&#xA;        System.out.println(&amp;quot;Q7 启动了&amp;quot;);&#xA;    }&#xA;    @Override&#xA;    public void selfNavigation() {&#xA;        System.out.println(&amp;quot;Q7 自动巡航&amp;quot;);&#xA;    }       &#xA;}&#xA;&#xA;// Client&#xA;public class Client {&#xA;    public static void mian(String[] args) {&#xA;        Factory factory = new CarFactory();&#xA;        Car audiQ3 = factory.createCar(AudiQ3.class);&#xA;        audiQ3.drive();&#xA;        audiQ3.selfNavigation();&#xA;        Car audiQ5 = factory.createCar(AudiQ5.class);&#xA;        audiQ5.drive();&#xA;        audiQ5.selfNavigation();&#xA;        Car audiQ7 = factory.createCar(AudiQ7.class);&#xA;        audiQ7.drive();&#xA;        audiQ7.selfNavigation();&#xA;    }&#xA;}&#xA;&#xA;// ...&#xA;Q3 启动了&#xA;Q3 自动巡航&#xA;Q5 启动了&#xA;Q5 自动巡航&#xA;Q7 启动了&#xA;Q7 自动巡航 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之迪米特原则</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/</link>
      <pubDate>2016-02-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;迪米特原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;英文全称：Law of Demeter 缩写：LOD&#xA;&#xA;一个类应该对自己需要耦合或调用的类知道的最少,&#xA;类的内部如何实现与调用着或者依赖者没有关系,&#xA;调用者或者依赖者只需要知道它需要的方法即可&#xA;&#xA;类与类之间的关系越密切，耦合度越大，当一个类&#xA;发生改变时，对另一个类的影响也就越大 ...  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 房间&#xA;public class Room {&#xA;&#xA;    // 面积&#xA;    public float area;&#xA;    // 价格&#xA;    public float price;&#xA;&#xA;    public Room(float area, float price) {&#xA;    }&#xA;&#xA;    @Overrid&#xA;    public String toString() {&#xA;        return &amp;quot;Room [area=&amp;quot; + area + &amp;quot;, price=&amp;quot; + price + &amp;quot;]&amp;quot;;&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 中介&#xA;public class Mediator {&#xA;&#xA;    List&amp;lt;Room&amp;gt; mRooms = new ArrayList&amp;lt;Room&amp;gt;();&#xA;&#xA;    public Mediator() {&#xA;        for (int i = 0; i &amp;lt; 5; i++) {&#xA;            mRooms.add(new Room(14 + i, (14 + i) * 150));&#xA;        }&#xA;    }&#xA;&#xA;    public List&amp;lt;Room&amp;gt; getAllRooms() {&#xA;        return mRooms;&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 租户&#xA;public class Tenant {&#xA;&#xA;    // 理想面积&#xA;    public float roomArea;&#xA;&#xA;    // 理想价格&#xA;    public float roomPrice;&#xA;&#xA;    private boolean isSuitable(Room room) {&#xA;        return (roomPrice &amp;gt;= room.price &amp;amp;&amp;amp; roomArea &amp;gt;= room.area);&#xA;    }&#xA;&#xA;    public void rentRoom(Mediator mediator) {&#xA;        List&amp;lt;Room&amp;gt; rooms = mediator.getAllRooms();&#xA;        for (Room room : rooms) {&#xA;            if (isSuitable(room)) {&#xA;                System.out.println(&amp;quot;租到房啦!&amp;quot; + &amp;quot; &amp;quot; + room);&#xA;                break;  &#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&#xA;// 从以上代码中可以看到，Tenant不仅依赖了Mediator类&#xA;// 还需要频繁地与Room类打交道，如果把这些检索条件都放到Tenant类中&#xA;// 那么中介类的功能就被弱化了，而且导致Tenant与Room的耦合较高&#xA;// 因为Tenant必须知道许多关于Room的细节，当Room变化时Tenant也必须变化&#xA;// Tenant又与Mediator耦合，这就出现了纠缠不清的关系&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解耦 .....&#xA;&#xA;// 中介&#xA;public class Mediator {&#xA;&#xA;    List&amp;lt;Room&amp;gt; mRooms = new ArryList&amp;lt;Room&amp;gt;;&#xA;&#xA;    public Mediator() {&#xA;        for (int i = 0; i &amp;lt; 5; i++) {&#xA;            mRooms.add(new Room(14 + i, (14 + i) * 150));&#xA;        }&#xA;    }&#xA;&#xA;    // 这里将让租户通过房屋列表自己寻找房子&#xA;    // 变成，由中介来寻找房子，并提供结果 ...&#xA;    public Room rentOut(float area, float price) {&#xA;        for (Room room : mRooms) {&#xA;            if (isSuitable(area, price, room)) {&#xA;                return room;&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    private boolean isSuitable(float area, float price, Room room) {&#xA;        return (price &amp;gt;= room.price &amp;amp;&amp;amp; area &amp;gt;= room.area);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 租户&#xA;public class Tenant {&#xA;&#xA;    public float roomArea;&#xA;&#xA;    public float roomPrice;&#xA;&#xA;    public void rentRoom(Mediator mediator) {&#xA;        System.out.println(&amp;quot;租到房子啦 &amp;quot; + mediator.rentOut(roomArea, roomPrice));&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之自由扩展你的项目-Builder模式</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E8%87%AA%E7%94%B1%E6%89%A9%E5%B1%95%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE-Builder%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>2016-02-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Builder 模式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;将一个复杂对象的构建与它的表示分离&#xA;使得同样的构建过程可以创建不同表示&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;（1）相同的方法，不同的执行顺序，产生不同的事件结果&#xA;（2）多个部件或零件，都可以装配到一个对象中&#xA;        但是产生的运行结果又不相同&#xA;（3）产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用&#xA;        这个时候使用建造者模式非常适合&#xA;（3）当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过Builder模式讲解计算机组装过&#xA;&#xA;&#xA;// 计算机（抽象类）&#xA;public abstract class Computer {&#xA;&#xA;    private String mCPU;&#xA;&#xA;    private String mDisplay;&#xA;&#xA;    private String mOS;&#xA;&#xA;    public void setCPU(String cpu) {&#xA;        mCPU = cpu;&#xA;    }&#xA;&#xA;    public void setDisplay(String display) {&#xA;        mDisplay = display;&#xA;    }&#xA;&#xA;    // 之所以用抽象方法，是因为&#xA;    // CPU 与 显示器 是可变的&#xA;    // 但是对于 Macbook 或者 Thinkpad &#xA;    // TA们的系统已经决定是Mac OS 还是 WinX&#xA;    public abstract setOS(String os);&#xA;&#xA;    @Override&#xA;    public String toString() {&#xA;        return String.format(&amp;quot;CPU: %s , Display: %s , OS: %s&amp;quot;);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 具体的 Computer 类, MacBook&#xA;public class Macbook extends Computer {&#xA;&#xA;    @Override&#xA;    public void setOS() {&#xA;        mOS = &amp;quot;Mac OS X 10.10&amp;quot;;&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 抽象 Builder 类型&#xA;public abstract class Builder {&#xA;    // 设置 CPU&#xA;    public abstract void buildCPU(String cpu);&#xA;    // 设置 显示器&#xA;    public abstract void buildDisplay(String display);&#xA;    // 设置 系统&#xA;    public abstract void buildOS(String os);&#xA;    // 创建&#xA;    public abstract Computer create();&#xA;}&#xA;&#xA;// 具体 Builder 类, MacbookBuilder&#xA;public class MacbookBuilder extends Builder {&#xA;&#xA;    private Computer mComputer = new Macbook();&#xA;&#xA;    @Override&#xA;    public void buildCPU(String cpu) {&#xA;        mComputer.setCPU(cpu);  &#xA;    }&#xA;&#xA;    @Override&#xA;    public void buildDisplay(String display) {&#xA;        mComputer.setDisplay(display);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void buildOS(String os) {&#xA;        mComputer.setOS();&#xA;    }&#xA;&#xA;    @Override&#xA;    public void create() {&#xA;        return mComputer;&#xA;    }&#xA;&#xA;}&#xA;&#xA;// Director 类, 负责构造 Computer&#xA;public class Director {&#xA;&#xA;    Builder mBuilder = null;&#xA;&#xA;    public Director(Builder builder) {&#xA;        mBuilder = builder; &#xA;    }&#xA;&#xA;    public void construce(String cpu, String display) {&#xA;        mBuilder.buildCPU(cpu);&#xA;        mBuilder.buildDisplay(display);&#xA;        mBuilder.buildOS();&#xA;    }   &#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 测试&#xA;Builder builder = new MacbookBuilder();&#xA;Director director = new Director(builder);&#xA;director.construce(&amp;quot;英特尔-I7&amp;quot;, &amp;quot;Retina-显示器&amp;quot;);&#xA;builder.create().toString();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之接口隔离原则</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>2016-02-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;接口隔离原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;接口隔离原则：InterfaceSegregaiton Principles 缩写：ISP&#xA;&#xA;定义：&#xA;    客户端不应该依赖它不需要的接口&#xA;    类间的依赖关系应该建立在最小的接口上&#xA;&#xA;接口隔离原则说白了就是，让客户端依赖的接口尽可能地小&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 例：&#xA;public void put(String url, Bitmap bmp) {&#xA;    FileOutputStream fileOutputStream = null;&#xA;    try {&#xA;        fileOutputStream = new FileOutputStream(cacheDir + url);&#xA;        bmp.compress(CompressFormat.PNG, 100, fileOutputStream);&#xA;    } catch (FileNotFoundException e) {&#xA;        e.printStackTrace();&#xA;    } finally {&#xA;        if (fileOutputStream != null) {&#xA;            try {&#xA;                fileOutputStream.close();&#xA;            } catch (IOException e) {&#xA;                e.printStackTrace();&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 按照接口隔离原则，修改如下&#xA;&#xA;public final class CloseUtils {&#xA;    public static void closeQuietly(Closeable closeable) {&#xA;        if (closeable != null) {&#xA;            try {&#xA;                closeable.close();&#xA;            } catch (IOException e) {&#xA;                e.printStackTrace();&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;public void put(String url, Bitmap bmp) {&#xA;    FileOutputStream fileOutputStream = null;&#xA;    try {&#xA;        fileOutputStream = new FileOutputStream(cacheDir + url);&#xA;        bmp.compress(CompressFormat.PNG, 100, fileOutputStream);&#xA;    } catch (FileNotFoundException e) {&#xA;        e.printStackTrace();&#xA;    } finally {&#xA;        CloseUtils.closeQuietly(fileOutputStream);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之单例模式</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>2016-02-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;单例模式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;单例模式是设计模式中比较简单，只有一个单例类&#xA;没有其它的层次结构与抽象，该模式需要确保该类&#xA;只能生成一个对象，通常是需要消耗较多的资源...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;例如: 一个应用只有一个Application对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 单例模式&#xA;public class CEO {&#xA;&#xA;    private static final CEO mCeo = new CEO();&#xA;&#xA;    public static CEO getCeo() {&#xA;        return mCeo;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 懒汉模式&#xA;public class Singleton {&#xA;&#xA;    private static Singleton instance;&#xA;&#xA;    private Singleton() {&#xA;    }&#xA;&#xA;    public static synchronized Singleton getInstance() {&#xA;        // 第一次调用的时候会被初始化&#xA;        if (instance == null) {&#xA;            instance = new Singleton();&#xA;        }&#xA;        return instance;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Double Check Lock (DCL) 单例模式&#xA;public class Singleton {&#xA;&#xA;    private static Singleton mInstance = null;&#xA;&#xA;    private Singleton() {&#xA;    }&#xA;&#xA;    public void doSomething() {&#xA;        System.out.println(&amp;quot;do sth.&amp;quot;);&#xA;    }&#xA;&#xA;    public static Singleton getInstance() {&#xA;        // 避免不必要的同步&#xA;        if (mInstance == null) {&#xA;            // 同步&#xA;            synchronized (Singleton.class) {&#xA;                // 在第一次调用时初始化&#xA;                if (mInstance == null) {&#xA;                    mInstance = new Singleton();&#xA;                }&#xA;                return mInstance;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 静态内部类单例模式&#xA;public class Singleton {&#xA;&#xA;    private Singleton() {&#xA;    }&#xA;&#xA;    public static Singleton getInstance() {&#xA;        return SingletonHolder.sInstance;&#xA;    }&#xA;&#xA;    // 静态内部类&#xA;    private static class SingletonHolder {&#xA;        private static final Singleton sInstance = new Singleton();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 运用单例模式&#xA;public void initImageLoader(Context context) {&#xA;    ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder( ..... );&#xA;    ImageLoader.getInstance().init(config);&#xA;    ImageLoader.getInstance().displayImage(&amp;quot;图片.url&amp;quot;, mImageView);&#xA;}&#xA;&#xA;public final class ImageLoader {&#xA;&#xA;    private static ImageLoader sInstance;&#xA;&#xA;    private ImageLoaderConfig = mConfig;&#xA;&#xA;    ... // 省略若干&#xA;&#xA;    public static ImageLoader getInstance() {&#xA;        if (sInstance == null) {&#xA;            synchronized (ImageLoader.class) {&#xA;                if (sInstance == null) {&#xA;                    sInstance = new ImageLoader();&#xA;                }&#xA;            }&#xA;        }&#xA;        return sInstance;&#xA;    }&#xA;&#xA;    public void init(ImageLoaderConfig config) {&#xA;        mConfig = config;&#xA;        ... // 省略若干&#xA;    }&#xA;&#xA;    public void displayImage(String url, ImageView imageView) {&#xA;        // 通过获取 mConfig.XXX 来处理获取到的 Image &#xA;        // 随后将图片设置到ImageView ...&#xA;        // ... 省略若干&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之依赖倒置原则</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</link>
      <pubDate>2016-02-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;依赖倒置原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;（1）高层模块不应该依赖低层模块，两者都应该依赖其抽象&#xA;（2）抽象不应该依赖细节&#xA;（3）细节应该依赖抽象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;抽象：就是指接口或者抽象类，两者都不能直接被实例化的；&#xA;细节：就是实现类，实现接口或者继承抽象类而产生的类&#xA;      特点就是: &#xA;                可以直接被实例化&#xA;                可以加上关键字 new 产生对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;模块间的依赖通过抽象发生&#xA;实现类之间不发生直接的依赖关系&#xA;其依赖关系是通过借口或抽象类产生的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 例子：依赖于细节&#xA;public class ImageLoader {&#xA;&#xA;    // （直接依赖于细节）&#xA;    DoubleCache mCache = new DoubleCache();&#xA;&#xA;    public void displayImage(String url, ImageView imageView) {&#xA;        ...&#xA;    }&#xA;&#xA;    // (直接依赖于细节）&#xA;    public void setImageCache(DoubleCache cache) {&#xA;        mCache = cache;&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 抽象：接口&#xA;public interface ImageCache {&#xA;    ... &#xA;}&#xA;&#xA;&#xA;// 例子：依赖于抽象&#xA;public class ImageLoader {&#xA;&#xA;    // 依赖于抽象（接口或者抽象类）&#xA;    ImageCache mCache = new MemoryCache();&#xA;&#xA;    // 设置ImageCache依赖于抽象&#xA;    public void setImageCache(ImageCache cache) {&#xA;        mCache = cache;&#xA;    }&#xA;&#xA;    public void displayImage(String url, ImageView imageView) {&#xA;        ...&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之里氏替换原则</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</link>
      <pubDate>2016-02-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;里氏替换原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 里氏替换原则全称是 Liskov Substitution Principle&#xA;// 缩写是，LSP &#xA;&#xA;// 面向对象的豫园的三大特点是：继承、封装、多态&#xA;// 里氏替换原则就是依赖于继承、多态这两大特性&#xA;&#xA;// 所有引用基类的地方必须能透明地使用其子类的对象&#xA;// 只要父类能出现的地方子类就可以出现&#xA;// 而且替换为子类也不会产生任何错误或异常&#xA;// 使用者可能根本就不需要知道是父类还是子类&#xA;// 反过来就不行了，有子类出现的地方，父类未必可行&#xA;&#xA;public class Window {&#xA;&#xA;    // 传入View类型&#xA;    public void show(View view) {   &#xA;        // 所有View类型都拥有draw方法&#xA;        view.draw();&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 抽象类&#xA;public abstract class View {&#xA;&#xA;    // 所有继承 Viwe 的类都必须实现 draw&#xA;    public abstract void draw();&#xA;&#xA;    // 所有子类共享该方法        &#xA;    public void measure(int width, int height) {&#xA;        // ...&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 继承 View&#xA;public class Button extends View {&#xA;&#xA;    // 继承 abstract 必须实现 draw&#xA;    public void draw() {&#xA;        // ... 不同的绘制&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 继承 View&#xA;public class TextView extends View {&#xA;&#xA;    // 继承 abstract 必须实现 draw&#xA;    public void draw() {&#xA;        // ... 不同的绘制&#xA;    }&#xA;&#xA;}&#xA;&#xA;// Window 依赖于View, 而View定义了一个视图抽象&#xA;// measure 是各个子类共享的方法&#xA;// 子类通过覆写Viwe的draw方法实现具有各自特色的功能 &#xA;// 任何继承自View类的子类都可以设置给show方法&#xA;// 就是所说的里氏替换原则 ...&#xA;&#xA;// 继承的优点:&#xA;    (1) 代码重用，减少创建类的成本，每个子类都拥有父类方法属性&#xA;    (2) 子类与父类基本相似，但又与父类有所区别&#xA;    (3) 提高代码的可扩展性&#xA;// 继承的缺点:&#xA;    (1) 继承是侵入的，只要继承就必须拥有父亲的所有属性和方法&#xA;    (2) 可能造成子类冗余，灵活度降低，因为子类必须拥有父类的属性和方法&#xA;&#xA;// 接着上面的 ImageLoader 来说明：&#xA;    既 MemoryCache、DiskCache、DoubleCache &#xA;    都可以替换ImageCache的工作，并且能够保证行为的正确性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之单一原则与开闭原则</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%8D%95%E4%B8%80%E5%8E%9F%E5%88%99%E4%B8%8E%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>2016-02-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;单一原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 案例&#xA;public class ImageLoader {&#xA;&#xA;    // 图片缓存&#xA;    LruCache&amp;lt;String, Bitmap&amp;gt; mImageCache;&#xA;&#xA;    // 构造&#xA;    public ImageLoader() {&#xA;        // 初始化&#xA;        initImageCache()    &#xA;    }&#xA;&#xA;    // 初始化&#xA;    private void initImageCache() {&#xA;        ...&#xA;        // 计算可使用的最大内存&#xA;        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);&#xA;        // 取四分之一的可用内存作为缓存&#xA;        int cacheSize = maxMemory / 4;&#xA;        // 初始化图片缓存&#xA;        mImageCache = new LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize) {&#xA;            ...&#xA;        }&#xA;    }&#xA;&#xA;    // 显示Image&#xA;    public void displayImage(String url, ImageView imageView) {&#xA;        ...&#xA;        Bitmap bitmap = mImageCache.get(url);&#xA;        if (bitmap != null) {&#xA;            imageView.setImageBitmap(bitmap);&#xA;        } else {&#xA;            // ... new Runnable() ...&#xA;            Bitmap bitmap = downloadImage(url);&#xA;            if (bitmap == null) {&#xA;                return;&#xA;            } else {&#xA;                imageView.setImageBitmap(bitmap);&#xA;                miMageCache.put(url, bitmap);&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    // 下载Image&#xA;    public Bitmap downloadImage(String imageUrl) {&#xA;        ...&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 单一原则所表达出的用意就是单一二字&#xA;// 两个完全不一样的功能就不应该放在一个类中...&#xA;// 一个类中应该是一组相关性很高的函数、数据的封装 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class ImageLoader {&#xA;&#xA;    ImageCache mImageCache = new ImageCache();&#xA;&#xA;    public void displayImage(String url, ImageView imageView) {&#xA;        ...&#xA;    }&#xA;&#xA;    public Bitmap downloadImage(String imageUrl) {&#xA;        ...&#xA;    }&#xA;&#xA;}&#xA;&#xA;public class ImageCache {&#xA;&#xA;    LruCache&amp;lt;String, Bitmap&amp;gt; mImageCache;&#xA;&#xA;    private void initImageCache() {&#xA;        ...&#xA;    }&#xA;&#xA;    public void put(String url, Bitmap bitmap) {    &#xA;        mImageCache.put(url, bitmap);&#xA;    }&#xA;&#xA;    public Bitmap get(String url) {&#xA;        return mImageCache.get(url);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;开闭原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 开闭原则（Open Close Principle) OCP &#xA;// 开闭原则的定义是：软件中的对象（类，模块，函数）&#xA;// 应该对于扩展是开放的，对于修改是封闭的 ...&#xA;&#xA;public class ImageLoader {&#xA;&#xA;    // 默认图片缓存&#xA;    ImageCache mImageCache = new MemoryCache();&#xA;&#xA;    // 注入缓存实现&#xA;    public void setImageCache(ImageCache cache) {&#xA;        mImageCache = cache;&#xA;    }&#xA;&#xA;    public void displayImage(String imageUrl, ImageView imageView) {&#xA;        Bitmap bitmap = mImageCache.get(imageUrl);&#xA;        if (bitmap != null) {&#xA;            imageView.setImageBitmap(bitmap);&#xA;            return;&#xA;        }&#xA;        Bitmap bitmap = downloadImage(imageUrl);&#xA;        if (bitmap == null) {&#xA;            return;&#xA;        } else {&#xA;            imageView.setImageBitmap(bitmap);&#xA;            mImageCache.put(imageUrl, bitmap);&#xA;    }&#xA;&#xA;    public Bitmap downloadImage(String imageUrl) {&#xA;    }   &#xA;&#xA;}&#xA;&#xA;// ImageCache 接口&#xA;public interface ImageCache {&#xA;    public Bitmap get(String url);&#xA;    public void put(String url, Bitmap bmp);&#xA;}&#xA;&#xA;// 实现类 +1&#xA;public class MemoryCache implements ImageCache {&#xA;&#xA;    private LruCache&amp;lt;String, Bitmap&amp;gt; mMemeryCache;&#xA;&#xA;    @Override&#xA;    public Bitmap get(String url) {&#xA;        return mMemeryCache.get(url);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void put(String url, Bitmap bmp) {&#xA;        mMemeryCache.put(url, bmp); &#xA;    }&#xA;&#xA;}&#xA;&#xA;// 实现类 +1&#xA;public class DiskCache implements ImageCache {&#xA;    ...&#xA;}&#xA;&#xA;// 实现类 +1&#xA;public class DoubleCache implements ImageCache {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ImageLoader imageLoader = new ImageLoader();&#xA;&#xA;// 使用内存缓存&#xA;imageLoader.setImageCache(new MemoryCache());&#xA;&#xA;// 使用SD卡缓存&#xA;imageLoader.setImageCache(new DiskCache());&#xA;&#xA;// 使用双缓存&#xA;imageLoader.setImageCache(new DoubleCache());&#xA;&#xA;// 使用自定义缓存&#xA;imageLoader.setImageCache(new ImageCache() {&#xA;&#xA;    @Override&#xA;    public void put(String url, Bitmap bmp) {&#xA;        ...&#xA;    }&#xA;&#xA;    @Override&#xA;    public Bitmap get(String url) {&#xA;        ...&#xA;    }&#xA;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之延时策略</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5/</link>
      <pubDate>2015-12-07 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;延时策略&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;所谓延时策略也就是让一个动作Sleep一下再执行&#xA;&#xA;有这么几种方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 线程休眠&#xA;new Thread(new Runnable(){   &#xA;    public void run(){   &#xA;        Thread.sleep(XXXX);   &#xA;        handler.sendMessage(); //告诉主线程执行任务   &#xA;    }   &#xA;}).start &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 定时器&#xA;TimerTask task = new TimerTask(){   &#xA;    public void run(){   &#xA;        // execute the task &#xA;    }   &#xA;&#xA;};   &#xA;Timer timer = new Timer(); &#xA;timer.schedule(task, delay); &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mTimer = new Timer(true);&#xA;TimerTask task = new TimerTask() {&#xA;    @Override&#xA;    public void run() {&#xA;        // 线程内更新UI&#xA;        runOnUiThread(new Runnable() {&#xA;            @Override&#xA;            public void run() {&#xA;                // Log.d(&amp;quot;Step --&amp;gt;&amp;quot;, &amp;quot;更新数据 ...&amp;quot;);&#xA;            }&#xA;        });&#xA;    }&#xA;};&#xA;mTimer.schedule(task, 1000, 1000);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Handler 延时消息机制&#xA;new Handler().postDelayed(new Runnable(){   &#xA;    public void run() {   &#xA;        // execute the task   &#xA;    }   &#xA; }, delay);   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>VirtualBox虚拟机系统相关</title>
      <link>http://www.nljb.net/default/VirtualBox%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</link>
      <pubDate>2015-12-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;VirtualBox虚拟机系统相关&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;在Win7系统中自动启动虚拟机系统&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 写个BAT批处理, 开机运行, 并且自动进入全屏模式&#xA;@ECHO OFF&#xA;start D:\dev\VirtualBox\VirtualBox.exe --startvm ubuntu12.04 --fullscreen&#xA;EXIT&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;通过PowerShell 启动 VirtualBox 与强制另外一个程序最前端显示&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Add-Type @&amp;quot;&#xA;[DllImport(&amp;quot;user32.dll&amp;quot;)]  &#xA;public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);  &#xA;public static IntPtr FindWindow(string windowName){&#xA;    return FindWindow(null,windowName);&#xA;}&#xA;[DllImport(&amp;quot;user32.dll&amp;quot;)]&#xA;public static extern bool SetWindowPos(IntPtr hWnd, &#xA;IntPtr hWndInsertAfter, int X,int Y, int cx, int cy, uint uFlags);&#xA;[DllImport(&amp;quot;user32.dll&amp;quot;)]  &#xA;public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); &#xA;static readonly IntPtr HWND_TOPMOST = new IntPtr(-1);&#xA;static readonly IntPtr HWND_NOTOPMOST = new IntPtr(-2);&#xA;const UInt32 SWP_NOSIZE = 0x0001;&#xA;const UInt32 SWP_NOMOVE = 0x0002;&#xA;const UInt32 TOPMOST_FLAGS = SWP_NOMOVE | SWP_NOSIZE;&#xA;[DllImport(&amp;quot;user32.dll&amp;quot;, CharSet = CharSet.Auto)]&#xA;public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);&#xA;[DllImport(&amp;quot;user32.dll&amp;quot;, CharSet = CharSet.Auto)]&#xA;public static extern bool SetForegroundWindow(IntPtr hWnd);&#xA;[DllImport(&amp;quot;user32.dll&amp;quot;, CharSet = CharSet.Auto)]&#xA;public static extern int MoveWindow(IntPtr hWnd, int x, int y, int nWidth, int nHeight, bool BRePaint);&#xA;public static void RunMoveWindow(IntPtr hWnd, int x, int y, int nWidth, int nHeight) {&#xA;    SetForegroundWindow(hWnd);&#xA;    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, TOPMOST_FLAGS);&#xA;    MoveWindow(hWnd, x, y, nWidth, nHeight, true);&#xA;}&#xA;&amp;quot;@  -name “Auto” -namespace Win32API&#xA;&#xA;# 设置窗口大小及位置&#xA;Function Set-Start&#xA;{&#xA;    # 初始化参数&#xA;    param(&#xA;        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]&#xA;        # 获取目标窗体的句柄&#xA;        [System.Diagnostics.Process]$Process&#xA;    )&#xA;    # 设置窗口大小，位置&#xA;    [Win32API.Auto]::RunMoveWindow($Process.MainWindowHandle, 1000 ,0, 920, 1080)&#xA;}&#xA;&#xA;# 守护&#xA;while(1) {&#xA;    # 捕捉错误&#xA;    Try&#xA;    {&#xA;        # 检查进程是否存在&#xA;        Get-Process virtualbox -ErrorAction Stop  &#xA;    }&#xA;   catch &#xA;    {&#xA;        # 启动进程&#xA;        Start-Process &amp;quot;C:\Program Files\Oracle\VirtualBox\VirtualBox.exe&amp;quot; -ArgumentList &amp;quot;-startvm Linux --fullscreen&amp;quot;&#xA;    }&#xA;    # 捕捉错误&#xA;    Try  &#xA;    {&#xA;        # 检查进程是否存在&#xA;        Get-Process notepad -ErrorAction Stop&#xA;    }  &#xA;    catch  &#xA;    {  &#xA;        # 启动进程&#xA;        Start-Process notepad&#xA;    }&#xA;    # 设置窗口大小及位置&#xA;    Get-Process notepad | Set-Start&#xA;    # 休息一下&#xA;    Start-Sleep -Seconds 1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;powershell -ExecutionPolicy Bypass &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>This Handler class should be static or leaks might occur</title>
      <link>http://www.nljb.net/default/This-Handler-class-should-be-static-or-leaks-might-occur/</link>
      <pubDate>2015-11-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;This Handler class should be static or leaks might occur&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;关于Android在GC(垃圾回收)时回收Handler会造成空指针异常&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android推荐将Handler变为Static(静态)但这样一来其内部调用的都需要为静态&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Handler 类应该应该为static类型，否则有可能造成泄露。&#xA;在程序消息队列中排队的消息保持了对目标Handler类的应用。&#xA;如果Handler是个内部类，那 么它也会保持它所在的外部类的引用。&#xA;为了避免泄露这个外部类，应该将Handler声明为static嵌套类，并且使用对外部类的弱应用。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;解决方法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;static class MyHandler extends android.os.Handler {&#xA;&#xA;    private MainActivity mMainActivity;&#xA;&#xA;    DynamicHandler(MainActivity mainActivity) {&#xA;        mMainActivity = mainActivity;&#xA;    }&#xA;&#xA;    @Override&#xA;    public void handleMessage(Message msg) {&#xA;        super.handleMessage(msg);&#xA;        // 这里使用 mMainActivity 调用外部方法 ...&#xA;    }&#xA;&#xA;}&#xA;&#xA;private MyHandler mMyHandler = new MyHandler(this);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;参考 &lt;a href=&#34;http://www.cnblogs.com/jevan/p/3168828.html&#34;&gt;http://www.cnblogs.com/jevan/p/3168828.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Broadcast发送广播</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BBroadcast%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD/</link>
      <pubDate>2015-11-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android之Broadcast发送广播&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第一步&#xA;&#xA;// 创建一个BroadcastReceiver消息广播类&#xA;public class MessageRecevier extends BroadcastReceiver {&#xA;&#xA;    @Override&#xA;    public void onReceive(Context context, Intent intent) {&#xA;        // 收到广播，通知更新 ( 这里可以是 Object)&#xA;        String obj = intent.getStringExtra(&amp;quot;obj&amp;quot;);&#xA;        int what = intent.getIntExtra(&amp;quot;what&amp;quot;, 0);&#xA;        // 把收到的广播再发出去&#xA;        Message m = new Message();&#xA;        m.obj = obj;&#xA;        m.what = what;&#xA;        message.sendMessage(m);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 第二步&#xA;&#xA;// 广播绑定&#xA;public final static String MESSAGE_RECEVIER_ACTION = &amp;quot;com.danoo.caraide&amp;quot;;&#xA;MessageRecevier mRecevier = new MessageRecevier();&#xA;registerReceiver(mRecevier, new IntentFilter(MESSAGE_RECEVIER_ACTION));&#xA;&#xA;// 第三步&#xA;&#xA;// 发送广播&#xA;Intent order = new Intent(MESSAGE_RECEVIER_ACTION);&#xA;order.putExtra(&amp;quot;obj&amp;quot;, &amp;quot;order&amp;quot;);&#xA;order.putExtra(&amp;quot;what&amp;quot;, msg.getOrder());&#xA;context.sendBroadcast(order);&#xA;&#xA;// 第四步&#xA;&#xA;// 收工&#xA;@Override&#xA;protected void onDestroy() {&#xA;    super.onDestroy();&#xA;    // 取消广播接收器&#xA;    unregisterReceiver(mRecevier);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之百度地图获取坐标及地址</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E8%8E%B7%E5%8F%96%E5%9D%90%E6%A0%87%E5%8F%8A%E5%9C%B0%E5%9D%80/</link>
      <pubDate>2015-11-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;百度地图获取坐标及地址&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 坐标定位&#xA;public void initLocation() {&#xA;    // 定位初始化&#xA;    mLocClient = new LocationClient(this);&#xA;    mLocClient.registerLocationListener(myListener);&#xA;    LocationClientOption option = new LocationClientOption();&#xA;    option.setOpenGps(true);// 打开gps&#xA;    option.setCoorType(&amp;quot;bd09ll&amp;quot;); // 设置坐标类型&#xA;    option.setScanSpan(LocationClientOption.MIN_SCAN_SPAN);&#xA;    option.setIsNeedAddress(true);&#xA;    mLocClient.setLocOption(option);&#xA;    mLocClient.start();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * 定位SDK监听函数&#xA; */&#xA;public class MyLocationListenner implements BDLocationListener {&#xA;&#xA;    @Override&#xA;    public void onReceiveLocation(BDLocation location) {&#xA;        if (location == null)&#xA;            return;&#xA;        MyLocationData locData = new MyLocationData.Builder()&#xA;                .accuracy(location.getRadius())&#xA;                .direction(100).latitude(location.getLatitude())&#xA;                .longitude(location.getLongitude()).build();&#xA;        Log.i(&amp;quot;纬度&amp;quot;, String.valueOf(locData.latitude));&#xA;        Log.i(&amp;quot;经度&amp;quot;, String.valueOf(locData.longitude));&#xA;        Log.i(&amp;quot;速度&amp;quot;, String.valueOf(locData.speed));&#xA;        Log.i(&amp;quot;方向&amp;quot;, String.valueOf(locData.direction));&#xA;        Log.i(&amp;quot;精度&amp;quot;, String.valueOf(locData.accuracy));&#xA;        Log.i(&amp;quot;地址&amp;quot;, String.valueOf(location.getAddress().city));&#xA;        // ...&#xA;        if (location.getAddress() != null &amp;amp;&amp;amp; location.getAddress().city != null) {&#xA;            // 销毁定位&#xA;            mLocClient.stop();&#xA;        }&#xA;    }&#xA;&#xA;    public void onReceivePoi(BDLocation poiLocation) {&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之ProgressDialog使用介绍</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BProgressDialog%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-11-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ProgressDialog&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;ProgressDialog为进度对话框&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;ProgressDialog的样式有两种，一种是圆形不明确状态，一种是水平进度条状态&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 设置进度条的形式为圆形转动的进度条&#xA;dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);&#xA;// 设置是否可以通过点击Back键取消 &#xA;dialog.setCancelable(true);&#xA;// 设置在点击Dialog外是否取消Dialog进度条&#xA;dialog.setCanceledOnTouchOutside(false);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ProgressDialog&#xA;private ProgressDialog mDialog;&#xA;&#xA;// ...&#xA;mDialog = new ProgressDialog(PreviewActivity.this);&#xA;mDialog.setCanceledOnTouchOutside(false);&#xA;mDialog.setCancelable(false);&#xA;mDialog.setMessage(&amp;quot;请稍后 ...&amp;quot;);&#xA;mDialog.show();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Layout实现Animation动画</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BLayout%E5%AE%9E%E7%8E%B0Animation%E5%8A%A8%E7%94%BB/</link>
      <pubDate>2015-11-02 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Layout实现Animation动画&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 获取Layout&#xA;LinearLayout head = (LinearLayout) findViewById(R.id.head);&#xA;&#xA;// 设置Layout的宽高&#xA;ViewGroup.LayoutParams lp = head.getLayoutParams();&#xA;if (lp == null) {&#xA;    lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,&#xA;                                     ViewGroup.LayoutParams.WRAP_CONTENT);&#xA;}&#xA;int widthMeasureSpec = ViewGroup.getChildMeasureSpec(0, 0, lp.width);&#xA;int heightMeasureSpec;&#xA;int heightTemp = lp.height;&#xA;if (heightTemp &amp;gt; 0) {&#xA;    heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(heightTemp, View.MeasureSpec.EXACTLY);&#xA;} else {&#xA;    heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);&#xA;}&#xA;head.measure(widthMeasureSpec, heightMeasureSpec);&#xA;&#xA;// 隐藏Layout&#xA;RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) head.getLayoutParams();&#xA;params.setMargins(head.getLeft(), -head.getMeasuredHeight(), head.getRight(), head.getBottom());&#xA;head.setLayoutParams(params);&#xA;&#xA;// 显示Layout动画&#xA;Animation mTranslateAnimation = new TranslateAnimation(0, 0, 0, head.getMeasuredHeight());&#xA;mTranslateAnimation.setDuration(1000);&#xA;mTranslateAnimation.setAnimationListener(new Animation.AnimationListener() {&#xA;            public void onAnimationStart(Animation animation) {&#xA;            }&#xA;&#xA;            public void onAnimationEnd(Animation animation) {&#xA;                head.clearAnimation();&#xA;                RelativeLayout.LayoutParams params = &#xA;                                new RelativeLayout.LayoutParams(head.getLayoutParams());&#xA;                // params.setMargins(0, head.getMeasuredHeight(), 0, 0);&#xA;                head.setLayoutParams(params);&#xA;            }&#xA;&#xA;            public void onAnimationRepeat(Animation animation) {&#xA;&#xA;            }&#xA;        });&#xA;head.startAnimation(mTranslateAnimation);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Photoshop之修改图片颜色</title>
      <link>http://www.nljb.net/default/Photoshop%E4%B9%8B%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2/</link>
      <pubDate>2015-10-28 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;修改图片颜色&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过：图像 -&amp;gt; 调整 -&amp;gt; 替换颜色 来修改图片颜色&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Photoshop之修改图片颜色/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;400&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Photoshop之修改图片颜色/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;400&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过：图像 -&amp;gt; 调整 -&amp;gt; 色阶 来修改图片色阶 凸显要修改的颜色区域&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Photoshop之修改图片颜色/3.png&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;400&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过：图像 -&amp;gt; 调整 -&amp;gt; 替换颜色 来替换图片颜色&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Photoshop之修改图片颜色/4.jpg&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;500&#34; &gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之封装volley的ObjectRequest</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%B0%81%E8%A3%85volley%E7%9A%84ObjectRequest/</link>
      <pubDate>2015-10-27 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;封装volley的ObjectRequest&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;封装volley的两个数据请求类JsonObjectRequest和StringRequest&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// SuperJsonRequest&#xA;public class SuperJsonRequest {&#xA;&#xA;    // 委托&#xA;    private OnJsonRequestDelegate mOnJsonRequestDelegate;&#xA;&#xA;    // 请求标签&#xA;    private String mJsonRequestTag;&#xA;&#xA;    // 委托方法&#xA;    public interface OnJsonRequestDelegate {&#xA;&#xA;        void onResponse(JSONObject response);&#xA;&#xA;        void onErrorResponse(VolleyError arg0);&#xA;&#xA;    }&#xA;&#xA;    // 设置该委托&#xA;    public void setOnJsonRequestDelegate(OnJsonRequestDelegate m) {&#xA;        this.mOnJsonRequestDelegate = m;&#xA;    }&#xA;&#xA;    // 停止该请求&#xA;    public void stopOnJsonRequest() {&#xA;        MainApplication.getHttpQueue().cancelAll(this.mJsonRequestTag);&#xA;    }&#xA;&#xA;    // 执行该请求&#xA;    public void startOnJsonRequest(String url, JSONObject json, String tag) {&#xA;&#xA;        // 默认POST请求，请求地址，请求参数JSON&#xA;        JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(Request.Method.POST, url, json,&#xA;                new Response.Listener&amp;lt;JSONObject&amp;gt;() {&#xA;                    public void onResponse(JSONObject response) {&#xA;                        // 委托&#xA;                        mOnJsonRequestDelegate.onResponse(response);&#xA;                    }&#xA;                },&#xA;                new Response.ErrorListener() {&#xA;                    public void onErrorResponse(com.android.volley.VolleyError arg0) {&#xA;                        // 委托&#xA;                        mOnJsonRequestDelegate.onErrorResponse(arg0);&#xA;                    }&#xA;                }) {&#xA;&#xA;            @Override&#xA;            protected Response&amp;lt;JSONObject&amp;gt; parseNetworkResponse(NetworkResponse response) {&#xA;                try {&#xA;                    String jsonString = new String(response.data, &amp;quot;UTF-8&amp;quot;);&#xA;                    return Response.success(new JSONObject(jsonString),&#xA;                            HttpHeaderParser.parseCacheHeaders(response));&#xA;                } catch (UnsupportedEncodingException e) {&#xA;                    return Response.error(new ParseError(e));&#xA;                } catch (JSONException je) {&#xA;                    return Response.error(new ParseError(je));&#xA;                }&#xA;            }&#xA;&#xA;            @Override&#xA;            public Map&amp;lt;String, String&amp;gt; getHeaders() {&#xA;                Map&amp;lt;String, String&amp;gt; headers = new ArrayMap&amp;lt;&amp;gt;();&#xA;                headers.put(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;);&#xA;                headers.put(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json; charset=UTF-8&amp;quot;);&#xA;                return headers;&#xA;            }&#xA;&#xA;        };&#xA;        // 全局标签&#xA;        this.mJsonRequestTag = tag;&#xA;        // 设置标签&#xA;        jsonObjectRequest.setTag(tag);&#xA;        // 添加请求&#xA;        MainApplication.getHttpQueue().add(jsonObjectRequest);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// SuperStringRequest&#xA;public class SuperStringRequest {&#xA;&#xA;    // 委托&#xA;    private OnStringRequestDelegate mOnStringRequestDelegate;&#xA;&#xA;    // 请求标签&#xA;    private String mStringRequestTag;&#xA;&#xA;    // 委托方法&#xA;    public interface OnStringRequestDelegate {&#xA;&#xA;        void onResponse(String arg0);&#xA;&#xA;        void onErrorResponse(VolleyError arg0);&#xA;&#xA;        Map&amp;lt;String, String&amp;gt; getParams();&#xA;&#xA;    }&#xA;&#xA;    // 设置该委托&#xA;    public void setOnStringRequestDelegate(OnStringRequestDelegate m) {&#xA;        this.mOnStringRequestDelegate = m;&#xA;    }&#xA;&#xA;    // 停止该请求&#xA;    public void stopOnStringRequest() {&#xA;        MainApplication.getHttpQueue().cancelAll(this.mStringRequestTag);&#xA;    }&#xA;&#xA;    // 开始该请求&#xA;    // Request.Method&#xA;    public void startOnStringRequest(String url, String tag) {&#xA;&#xA;        // 通过GET请求，请求地址&#xA;        StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&amp;lt;String&amp;gt;() {&#xA;            @Override&#xA;            public void onResponse(String arg0) {&#xA;                mOnStringRequestDelegate.onResponse(arg0);&#xA;            }&#xA;        }, new Response.ErrorListener() {&#xA;            @Override&#xA;            public void onErrorResponse(VolleyError arg0) {&#xA;                mOnStringRequestDelegate.onErrorResponse(arg0);&#xA;            }&#xA;        }) {&#xA;&#xA;            @Override&#xA;            protected Map&amp;lt;String, String&amp;gt; getParams() throws AuthFailureError {&#xA;                // 返回指定的参数MAP&#xA;                return mOnStringRequestDelegate.getParams();&#xA;            }&#xA;&#xA;            @Override&#xA;            protected Response&amp;lt;String&amp;gt; parseNetworkResponse(NetworkResponse response) {&#xA;                try {&#xA;                    String dataString = new String(response.data, &amp;quot;UTF-8&amp;quot;);&#xA;                    return Response.success(dataString, HttpHeaderParser.parseCacheHeaders(response));&#xA;                } catch (UnsupportedEncodingException e) {&#xA;                    return Response.error(new ParseError(e));&#xA;                }&#xA;            }&#xA;&#xA;        };&#xA;        // 全局标签&#xA;        this.mStringRequestTag = tag;&#xA;        // 设置标签&#xA;        stringRequest.setTag(tag);&#xA;        // 添加请求&#xA;        MainApplication.getHttpQueue().add(stringRequest);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之LinearLayout中baselineAligned的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BLinearLayout%E4%B8%ADbaselineAligned%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-10-27 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;baselineAligned&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android线性布局中的属性主要的就是控制浮动方向的orientation&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;其他的就是辅助浮动显示的，其中有一个属性控制基线，也就是baselineAligned&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.首先这个基线主要是对可以显示文字的View，如TextView，Button等控件的&#xA;&#xA;2.这个baseline指的是这个UI控件的baseline--文字距UI控件顶部的偏移量&#xA;&#xA;3.LinearLayout控件默认有属性android:baselineAligned为true&#xA;    如果LinearLayout的orientation为horizontal的话，其中的文字默认是文字对齐的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之LinearLayout中baselineAligned的使用/1.png&#34; alt=&#34;&#34; width=&#34;350&#34; height=&#34;120&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 其中的baselineAlignedChildIndex指的是其中的第几个子控件按照baseline对齐的。&#xA;&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:baselineAlignedChildIndex=&amp;quot;3&amp;quot;&#xA;    android:orientation=&amp;quot;horizontal&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;TextView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_marginRight=&amp;quot;3dip&amp;quot;&#xA;        android:text=&amp;quot;String1&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:baselineAlignedChildIndex=&amp;quot;1&amp;quot;&#xA;        android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;&#xA;&#xA;        &amp;lt;ImageView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:src=&amp;quot;@android:drawable/arrow_up_float&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_marginRight=&amp;quot;5dip&amp;quot;&#xA;            android:text=&amp;quot;String2&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;ImageView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:src=&amp;quot;@android:drawable/arrow_down_float&amp;quot; /&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:baselineAligned=&amp;quot;true&amp;quot;&#xA;        android:baselineAlignedChildIndex=&amp;quot;2&amp;quot;&#xA;        android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;&#xA;&#xA;        &amp;lt;ImageView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:src=&amp;quot;@android:drawable/arrow_up_float&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;ImageView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:src=&amp;quot;@android:drawable/arrow_down_float&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_marginRight=&amp;quot;5dip&amp;quot;&#xA;            android:text=&amp;quot;String3&amp;quot; /&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;    &amp;lt;TextView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;String4&amp;quot;&#xA;        android:textSize=&amp;quot;60sp&amp;quot; /&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之圆形的ImageView</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%9C%86%E5%BD%A2%E7%9A%84ImageView/</link>
      <pubDate>2015-08-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Circle ImageView&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/hdodenhof/CircleImageView&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dependencies {&#xA;    ...&#xA;    compile &#39;de.hdodenhof:circleimageview:1.3.0&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之圆形的ImageView/1.png&#34; alt=&#34;&#34; width=&#34;500&#34; hight=&#34;900&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;de.hdodenhof.circleimageview.CircleImageView xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;    android:id=&amp;quot;@+id/user_logo&amp;quot;&#xA;    android:layout_width=&amp;quot;96dp&amp;quot;&#xA;    android:layout_height=&amp;quot;96dp&amp;quot;&#xA;    android:layout_below=&amp;quot;@+id/user_title&amp;quot;&#xA;    android:layout_centerHorizontal=&amp;quot;true&amp;quot;&#xA;    android:layout_marginTop=&amp;quot;30dp&amp;quot;&#xA;    android:src=&amp;quot;@mipmap/ic_launcher&amp;quot;&#xA;    app:border_color=&amp;quot;#FF000000&amp;quot;&#xA;    app:border_width=&amp;quot;2dp&amp;quot; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之闪烁发光字体效果</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E9%97%AA%E7%83%81%E5%8F%91%E5%85%89%E5%AD%97%E4%BD%93%E6%95%88%E6%9E%9C/</link>
      <pubDate>2015-08-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;闪烁发光字体&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Facebook开源了一款加载效果工具Shimmer，可以实现字体的闪闪发光效果，效果如下&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/facebook/Shimmer，针对iOS开发实现&#xA;&#xA;http://facebook.github.io/shimmer-android/ 针对Android开发实现&#xA;&#xA;https://github.com/RomainPiel/Shimmer-android 针对Android开发实现&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之闪烁发光字体效果/1.gif&#34; alt=&#34;&#34; width=&#34;300&#34; hight=&#34;160&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;com.facebook.shimmer.ShimmerFrameLayout&#xA;    android:id=&amp;quot;@+id/shimmer_view_container&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_below=&amp;quot;@+id/welcome_slogan&amp;quot;&#xA;    android:layout_centerHorizontal=&amp;quot;true&amp;quot;&#xA;    android:layout_gravity=&amp;quot;center&amp;quot;&#xA;    android:layout_marginTop=&amp;quot;150dp&amp;quot;&#xA;    shimmer:duration=&amp;quot;1000&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;ImageButton&#xA;        android:id=&amp;quot;@+id/welcome_start&amp;quot;&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_alignParentBottom=&amp;quot;true&amp;quot;&#xA;        android:layout_centerHorizontal=&amp;quot;true&amp;quot;&#xA;        android:background=&amp;quot;@drawable/welcome_start&amp;quot; /&amp;gt;&#xA;&amp;lt;/com.facebook.shimmer.ShimmerFrameLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private ShimmerFrameLayout mShimmer = null;&#xA;&#xA;@Override&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_welcome);&#xA;    mShimmer = (ShimmerFrameLayout) findViewById(R.id.shimmer_view_container);&#xA;}&#xA;&#xA;@Override&#xA;public void onResume() {&#xA;    super.onResume();&#xA;    if (mShimmer != null) {&#xA;        mShimmer.startShimmerAnimation();&#xA;    }&#xA;}&#xA;&#xA;@Override&#xA;public void onPause() {&#xA;    if (mShimmer != null) {&#xA;        mShimmer.stopShimmerAnimation();&#xA;    }&#xA;    super.onPause();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之万能适配器Adapter的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E4%B8%87%E8%83%BD%E9%80%82%E9%85%8D%E5%99%A8Adapter%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-08-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;万能适配器&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;万能适配器共有两个部分：SuperViewHolder 和 SuperBaseAdapter&lt;T&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;万能的ViewHolder&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class SuperViewHolder {&#xA;&#xA;    private SparseArray&amp;lt;View&amp;gt; mViews;&#xA;&#xA;    private View mConvertView;&#xA;&#xA;    private int mPosition;&#xA;&#xA;    public SuperViewHolder(Context context, ViewGroup parent, int layoutId, int position) {&#xA;        mPosition = position;&#xA;        mViews = new SparseArray&amp;lt;&amp;gt;();&#xA;        mConvertView = LayoutInflater.from(context).inflate(layoutId, parent, false);&#xA;        mConvertView.setTag(this);&#xA;    }&#xA;&#xA;    public static SuperViewHolder make(Context context, int layoutId, View convertView, ViewGroup parent, int position) {&#xA;        if (convertView == null) {&#xA;            return new SuperViewHolder(context, parent, layoutId, position);&#xA;        } else {&#xA;            SuperViewHolder superViewHolder = (SuperViewHolder) convertView.getTag();&#xA;            superViewHolder.mPosition = position;&#xA;            return superViewHolder;&#xA;        }&#xA;    }&#xA;&#xA;    public &amp;lt;T extends View&amp;gt; T getView(int viewId) {&#xA;        View view = mViews.get(viewId);&#xA;        if (view == null) {&#xA;            view = mConvertView.findViewById(viewId);&#xA;            mViews.put(viewId, view);&#xA;        }&#xA;        return (T) view;&#xA;    }&#xA;&#xA;    public int getPosition() {&#xA;        return mPosition;&#xA;    }&#xA;&#xA;    public View getConvertView() {&#xA;        return mConvertView;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;万能的SuperBaseAdapter&lt;T&gt;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public abstract class SuperBaseAdapter&amp;lt;T&amp;gt; extends BaseAdapter {&#xA;&#xA;    protected Context mContext;&#xA;&#xA;    protected List&amp;lt;T&amp;gt; mDatas;&#xA;&#xA;    public SuperBaseAdapter(Context context, List&amp;lt;T&amp;gt; datas) {&#xA;        mContext = context;&#xA;        mDatas = datas;&#xA;    }&#xA;&#xA;    @Override&#xA;    public int getCount() {&#xA;        return mDatas.size();&#xA;    }&#xA;&#xA;    @Override&#xA;    public Object getItem(int position) {&#xA;        return mDatas.get(position);&#xA;    }&#xA;&#xA;    @Override&#xA;    public long getItemId(int position) {&#xA;        return position;&#xA;    }&#xA;&#xA;    @Override&#xA;    public abstract View getView(int position, View convertView, ViewGroup parent);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;结合使用 SuperViewHolder 和 SuperBaseAdapter&lt;T&gt;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class CalendarBaseAdapter extends SuperBaseAdapter&amp;lt;String&amp;gt; {&#xA;&#xA;    public CalendarBaseAdapter(Context context, List&amp;lt;String&amp;gt; datas) {&#xA;        super(context, datas);&#xA;    }&#xA;&#xA;    @Override&#xA;    public View getView(int position, View convertView, ViewGroup parent) {&#xA;        SuperViewHolder superViewHolder = SuperViewHolder.make(mContext, R.layout.item_calendar, convertView, parent, position);&#xA;        ((TextView)superViewHolder.getView(R.id.calendar_time)).setText(mDatas.get(position));&#xA;        return superViewHolder.getConvertView();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充问题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 焦点抢占&#xA;关于在ListView的Item里增加(例CheckBox对象)造成Item无法点击问题&#xA;&#xA;此问题是因为CheckBox对象抢占了Item的焦点，造成Item无法点击的&#xA;&#xA;只需要在将CheckBox对象android:focusable属性值设置为false即可&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 复用导致内容错乱&#xA;比如: 当Item中使用CheckBox时点击第一个则其它CheckBox也被选中了&#xA;      这是因为使用的是同一个CheckBox对象的缘故 ...&#xA;&#xA;解决: 这样就需要记录CheckBox对象的状态来判断CheckBox是否被选中&#xA;      可以通过position来作为ID，来记录CheckBox状态是True或False&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Animation的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BAnimation%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-08-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Animation&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android支持两种动画模式: tween animation, frame animation&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在android 3.0中又引入了一个新的动画系统：property animation&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这三种动画模式在SDK中被称为property animation,view animation,drawable animation。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;可通过NineOldAndroids项目在3.0之前的系统中使用Property Animation&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;View Animation（Tween Animation）&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;View Animation（Tween Animation）：&#xA;    补间动画，给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。&#xA;&#xA;View animation只能应用于View对象，而且只支持一部分属性，如支持缩放旋转而不支持背景颜色的改变。&#xA;&#xA;而且对于View animation，它只是改变了View对象绘制的位置，而没有改变View对象本身&#xA;    比如，你有一个Button，坐标（100,100），Width:200,Height:50&#xA;    而你有一个动画使其变为Width：100，Height：100&#xA;    你会发现动画过程中触发按钮点击的区域仍是(100,100)-(300,150)。&#xA;&#xA;View Animation就是一系列View形状的变换，如大小的缩放，透明度的改变，位置的改变&#xA;    动画的定义既可以用代码定义也可以用XML定义，当然，建议用XML定义。&#xA;&#xA;可以给一个View同时设置多个动画，比如从透明至不透明的淡入效果，与从小到大的放大效果&#xA;    这些动画可以同时进行，也可以在一个完成之后开始另一个。&#xA;&#xA;用XML定义的动画放在/res/anim/文件夹内&#xA;    XML文件的根元素可以为&amp;lt;alpha&amp;gt;,&amp;lt;scale&amp;gt;,&amp;lt;translate&amp;gt;,&amp;lt;rotate&amp;gt;,interpolator元素或&amp;lt;set&amp;gt;&#xA;    (表示以上几个动画的集合，set可以嵌套)。&#xA;    默认情况下，所有动画是同时进行的，可以通过startOffset属性设置各个动画的开始偏移&#xA;    （开始时间）来达到动画顺序播放的效果。&#xA;&#xA;可以通过设置interpolator属性改变动画渐变的方式&#xA;    如AccelerateInterpolator，开始时慢，然后逐渐加快。默认为AccelerateDecelerateInterpolator。&#xA;&#xA;定义好动画的XML文件后，可以通过类似下面的代码对指定View应用动画。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ImageView spaceshipImage = (ImageView)findViewById(R.id.spaceshipImage);&#xA;Animation hyperspaceJumpAnimation=AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);&#xA;spaceshipImage.startAnimation(hyperspaceJumpAnimation);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Drawable Animation（Frame Animation）&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Drawable Animation（Frame Animation）：帧动画，就像GIF图片&#xA;    通过一系列Drawable依次显示来模拟动画的效果&#xA;&#xA;在XML中的定义方式如下：&#xA;&amp;lt;animation-list xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:oneshot=&amp;quot;true&amp;quot;&amp;gt;&#xA;    &amp;lt;item android:drawable=&amp;quot;@drawable/rocket_thrust1&amp;quot; android:duration=&amp;quot;200&amp;quot; /&amp;gt;&#xA;    &amp;lt;item android:drawable=&amp;quot;@drawable/rocket_thrust2&amp;quot; android:duration=&amp;quot;200&amp;quot; /&amp;gt;&#xA;    &amp;lt;item android:drawable=&amp;quot;@drawable/rocket_thrust3&amp;quot; android:duration=&amp;quot;200&amp;quot; /&amp;gt;&#xA;&amp;lt;/animation-list&amp;gt;&#xA;&#xA;必须以&amp;lt;animation-list&amp;gt;为根元素，以&amp;lt;item&amp;gt;表示要轮换显示的图片，duration属性表示各项显示的时间。&#xA;    XML文件要放在/res/drawable/目录下。&#xA;&#xA;示例：&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;    // TODO Auto-generated method stub&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.main);&#xA;    imageView = (ImageView) findViewById(R.id.imageView1);&#xA;    imageView.setBackgroundResource(R.drawable.drawable_anim);&#xA;    anim = (AnimationDrawable) imageView.getBackground();&#xA;}&#xA;&#xA;public boolean onTouchEvent(MotionEvent event) {&#xA;    if (event.getAction() == MotionEvent.ACTION_DOWN) {&#xA;        anim.stop();&#xA;        anim.start();&#xA;        return true;&#xA;    }&#xA;    return super.onTouchEvent(event);&#xA;}&#xA;&#xA;在实验中遇到问题(转)：&#xA;    要在代码中调用Imageview的setBackgroundResource方法，如果直接在XML布局文件中设置其src属性当触发动画时会FC。&#xA;    在动画start()之前要先stop()，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次。&#xA;    最后一点是SDK中提到的，不要在onCreate中调用start，因为AnimationDrawable还没有完全跟Window相关联&#xA;    如果想要界面显示时就开始动画的话，可以在onWindowFoucsChanged()中调用start()。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Property Animation&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;属性动画，这个是在Android 3.0中才引进的，以前学WPF时里面的动画机制好像就是这个&#xA;    它更改的是对象的实际属性，在（Tween Animation）中，其改变的是View的绘制效果，真正的View的属性保持不变&#xA;    比如无论你在对话中如何缩放Button的大小，Button的有效点击区域还是没有应用动画时的区域，其位置与大小都不变。&#xA;    而在Property Animation中，改变的是对象的实际属性，如Button的缩放，Button的位置与大小属性值都改变了。&#xA;    而且Property Animation不止可以应用于View，还可以应用于任何对象。&#xA;    Property Animation只是表示一个值在一段时间内的改变，当值改变时要做什么事情完全是你自己决定的。&#xA;&#xA;在Property Animation中，可以对动画应用以下属性：&#xA;&#xA;Duration：&#xA;    动画的持续时间&#xA;TimeInterpolation：&#xA;    属性值的计算方式，如先快后慢&#xA;TypeEvaluator：&#xA;    根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值&#xA;Repeat Count and behavoir：&#xA;    重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放&#xA;Animation sets：&#xA;    动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移&#xA;Frame refreash delay：&#xA;    多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Property Animation的工作方式&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;对于下图的动画，这个对象的X坐标在40ms内从0移动到40 pixel&#xA;&#xA;按默认的10ms刷新一次，这个对象会移动4次，每次移动40/4=10pixel。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之Animation的使用方法/1.png&#34; alt=&#34;&#34; width=&#34;560&#34; hight=&#34;160&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;也可以改变属性值的改变方法，即设置不同的interpolation，在下图中运动速度先逐渐增大再逐渐减小&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之Animation的使用方法/2.png&#34; alt=&#34;&#34; width=&#34;560&#34; hight=&#34;160&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;下图显示了与上述动画相关的关键对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之Animation的使用方法/3.png&#34; alt=&#34;&#34; width=&#34;720&#34; hight=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ValueAnimator  表示一个动画，包含动画的开始值，结束值，持续时间等属性。&#xA;ValueAnimator封装了一个TimeInterpolator，TimeInterpolator定义了属性值在开始值与结束值之间的插值方法。&#xA;ValueAnimator还封装了一个TypeAnimator，根据开始、结束值与TimeIniterpolator计算得到的值计算出属性值。&#xA;ValueAnimator根据动画已进行的时间跟动画总时间（duration）的比计算出一个时间因子（0~1）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ValueAnimator&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;ValueAnimator包含了Property Animation动画的所有核心功能，如动画时间，开始、结束属性值，相应时间属性值计算方法等。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在我看来，使用 ValueAnimator 只是为我们创建了一个过程&#xA;    我们可以用ValueAnimator.ofXXX()进行创建&#xA;    然后通过各种setXXX()给其设定过程的时间，速率变化效果等&#xA;    然后通过addUpdateListener()中去拿这个过程中回调回来的中间值&#xA;    然后使用这些中间值改变view的属性形成动态效果；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;比如我们使用 ValueAnimator 在2S内将view横向拉长为2倍，纵向压缩为0：&#xA;&#xA;// 在2S内将view横向拉长为2倍，纵向压缩为0&#xA;// 创建0－1的一个过程,任何复杂的过程都可以采用归一化，然后在addUpdateListener回调里去做自己想要的变化&#xA;ValueAnimator valueAnimator = ValueAnimator.ofFloat(0, 1);&#xA;// 设置过程的时间为2S&#xA;valueAnimator.setDuration(SCALE_ANIM_TIME);&#xA;// 设置这个过程是速度不断变快的&#xA;valueAnimator.setInterpolator(new AccelerateInterpolator());&#xA;// 这个过程中不断执行的回调&#xA;valueAnimator.addUpdateListener(new AnimatorUpdateListener() {&#xA;    @Override&#xA;    public void onAnimationUpdate(ValueAnimator animation) {&#xA;        // 不断回调的在0-1这个范围内，经过插值器插值之后的返回值&#xA;        float value = (Float) animation.getAnimatedValue();&#xA;        // ViewHelper可直接用于修改view属性&#xA;        // 将宽在2S内放大一倍&#xA;        ViewHelper.setScaleX(mTestImage, 1 + value);&#xA;        // 将高在2S内压缩为0&#xA;        ViewHelper.setScaleY(mTestImage, 1 - value);&#xA;    }&#xA;});&#xA;// AnimatorListenerAdapter是AnimatorListener的空实现，根据需要覆盖的方法自行选择&#xA;valueAnimator.addListener(new AnimatorListenerAdapter() {&#xA;    @Override&#xA;    public void onAnimationStart(Animator animation) {&#xA;        super.onAnimationStart(animation);&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;onAnimationStart&amp;quot;, Toast.LENGTH_SHORT)&#xA;                .show();&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onAnimationEnd(Animator animation) {&#xA;        super.onAnimationEnd(animation);&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;onAnimationEnd&amp;quot;, Toast.LENGTH_SHORT)&#xA;                .show();&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onAnimationCancel(Animator animation) {&#xA;        super.onAnimationCancel(animation);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onAnimationRepeat(Animator animation) {&#xA;        super.onAnimationRepeat(animation);&#xA;    }&#xA;});&#xA;valueAnimator.start();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;动画其实就是在一个时间段内不断去改变view的一些属性值&#xA;    这些属性值动态变化，不断重绘的过程，也就形成了我们所看到的动效；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;那么基于此，我们可以知道这个过程都是通过时间来控制的，时间走过的比例肯定在 0-1 之间&#xA;    如果我们直接用这个走过的时间比例去算当前属性值，那么整个过程则是匀速（线性）的；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;横轴就是经过的时间比例，肯定是匀速的从0-1，纵轴则是时间比例经过加工后的插值&#xA;    这个对应过程则是Interpolator（插值器）对应的过程；&#xA;&#xA;减速线则对应DecelerateInterpolater,因为它的斜率越来越平，所以瞬时速度越来越小，则形成了减速效果；&#xA;&#xA;其他的效果类似，目前android里提供的插值器有如下一些：&#xA;&#xA;AccelerateInterpolator　　　　　     &#xA;    加速，开始时慢中间加速&#xA;DecelerateInterpolator　　　 　　   &#xA;    减速，开始时快然后减速&#xA;AccelerateDecelerateInterolator　   &#xA;    先加速后减速，开始结束时慢，中间加速&#xA;AnticipateInterpolator　　　　　　  &#xA;    反向 ，先向相反方向改变一段再加速播放&#xA;AnticipateOvershootInterpolator　   &#xA;    反向加回弹，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值&#xA;BounceInterpolator　　　　　　　  &#xA;    跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100&#xA;CycleIinterpolator　　　　　　　　 &#xA;    循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI * input)&#xA;LinearInterpolator　　　　　　　　 &#xA;    线性，线性均匀改变&#xA;OvershottInterpolator　　　　　　  &#xA;    回弹，最后超出目的值然后缓慢改变到目的值&#xA;TimeInterpolator　　　　　　　　   &#xA;    一个接口，允许你自定义interpolator，以上几个都是实现了这个接口&#xA;&#xA;其实想实现对应的效果，其实是找一条曲线对对应条件进行模拟&#xA;    然后根据曲线函数，和X值，得出每个时间点上对应的Y值（插值），这也就是插值器原理；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ObjectAnimator&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;bjectAnimator 是ValueAnimator 的子类，可以直接改变Object的属性，目前可供改变的属性主要有：&#xA;&#xA;translationX, translationY           &#xA;    View相对于原始位置的偏移量&#xA;rotation, rotationX, rotationY       &#xA;    旋转，rotation用于2D旋转角度，3D中用到后两个&#xA;scaleX, scaleY                           &#xA;    缩放比&#xA;x, y                                             &#xA;    View的最终坐标，是View的left，top位置加上translationX，translationY&#xA;alpha                                          &#xA;    透明度&#xA;&#xA;关于Animator主要分享这两个类，其他的比如 PropertyValuesHolder 大家可以自己去看；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之TextView绘制圆形背景</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BTextView%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2%E8%83%8C%E6%99%AF/</link>
      <pubDate>2015-08-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;TextView Draw Circle Background&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class CircleView extends TextView {&#xA;&#xA;    private Paint mBgPaint = new Paint();&#xA;&#xA;    PaintFlagsDrawFilter pfd = new PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);&#xA;&#xA;    public CircleView(Context context, AttributeSet attrs, int defStyle) {&#xA;        super(context, attrs, defStyle);&#xA;        // TODO Auto-generated constructor stub&#xA;    }&#xA;&#xA;    public CircleView(Context context, AttributeSet attrs) {&#xA;        super(context, attrs);&#xA;        // TODO Auto-generated constructor stub&#xA;        mBgPaint.setColor(Color.WHITE);&#xA;        mBgPaint.setAntiAlias(true);&#xA;    }&#xA;&#xA;    public CircleView(Context context) {&#xA;        super(context);&#xA;        // TODO Auto-generated constructor stub&#xA;        mBgPaint.setColor(Color.WHITE);&#xA;        mBgPaint.setAntiAlias(true);&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {&#xA;        // TODO Auto-generated method stub&#xA;        super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#xA;        int measuredWidth = getMeasuredWidth();&#xA;        int measuredHeight = getMeasuredHeight();&#xA;        int max = Math.max(measuredWidth, measuredHeight);&#xA;        setMeasuredDimension(max, max);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void setBackgroundColor(int color) {&#xA;        // TODO Auto-generated method stub&#xA;        mBgPaint.setColor(color);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void draw(Canvas canvas) {&#xA;        // TODO Auto-generated method stub&#xA;        canvas.setDrawFilter(pfd);&#xA;        canvas.drawCircle(getWidth() / 2, getHeight() / 2, Math.max(getWidth(), getHeight()) / 4, mBgPaint);&#xA;        super.draw(canvas);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Color颜色值</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BColor%E9%A2%9C%E8%89%B2%E5%80%BC/</link>
      <pubDate>2015-08-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Color 颜色值&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;color name=&amp;quot;white&amp;quot;&amp;gt;#FFFFFF&amp;lt;/color&amp;gt;&amp;lt;!--白色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;ivory&amp;quot;&amp;gt;#FFFFF0&amp;lt;/color&amp;gt;&amp;lt;!--象牙色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightyellow&amp;quot;&amp;gt;#FFFFE0&amp;lt;/color&amp;gt;&amp;lt;!--亮黄色--&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;yellow&amp;quot;&amp;gt;#FFFF00&amp;lt;/color&amp;gt;&amp;lt;!--黄色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;snow&amp;quot;&amp;gt;#FFFAFA&amp;lt;/color&amp;gt;&amp;lt;!--雪白色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;floralwhite&amp;quot;&amp;gt;#FFFAF0&amp;lt;/color&amp;gt;&amp;lt;!--花白色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lemonchiffon&amp;quot;&amp;gt;#FFFACD&amp;lt;/color&amp;gt;&amp;lt;!--柠檬绸色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;cornsilk&amp;quot;&amp;gt;#FFF8DC&amp;lt;/color&amp;gt;&amp;lt;!--米绸色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;seashell&amp;quot;&amp;gt;#FFF5EE&amp;lt;/color&amp;gt;&amp;lt;!--海贝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lavenderblush&amp;quot;&amp;gt;#FFF0F5&amp;lt;/color&amp;gt;&amp;lt;!--淡紫红 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;papayawhip&amp;quot;&amp;gt;#FFEFD5&amp;lt;/color&amp;gt;&amp;lt;!--番木色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;blanchedalmond&amp;quot;&amp;gt;#FFEBCD&amp;lt;/color&amp;gt;&amp;lt;!--白杏色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mistyrose&amp;quot;&amp;gt;#FFE4E1&amp;lt;/color&amp;gt;&amp;lt;!--浅玫瑰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;bisque&amp;quot;&amp;gt;#FFE4C4&amp;lt;/color&amp;gt;&amp;lt;!--桔黄色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;moccasin&amp;quot;&amp;gt;#FFE4B5&amp;lt;/color&amp;gt;&amp;lt;!--鹿皮色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;navajowhite&amp;quot;&amp;gt;#FFDEAD&amp;lt;/color&amp;gt;&amp;lt;!--纳瓦白 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;peachpuff&amp;quot;&amp;gt;#FFDAB9&amp;lt;/color&amp;gt;&amp;lt;!--桃色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;gold&amp;quot;&amp;gt;#FFD700&amp;lt;/color&amp;gt;&amp;lt;!--金色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;pink&amp;quot;&amp;gt;#FFC0CB&amp;lt;/color&amp;gt;&amp;lt;!--粉红色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightpink&amp;quot;&amp;gt;#FFB6C1&amp;lt;/color&amp;gt;&amp;lt;!--亮粉红色--&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;orange&amp;quot;&amp;gt;#FFA500&amp;lt;/color&amp;gt;&amp;lt;!--橙色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightsalmon&amp;quot;&amp;gt;#FFA07A&amp;lt;/color&amp;gt;&amp;lt;!--亮肉色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkorange&amp;quot;&amp;gt;#FF8C00&amp;lt;/color&amp;gt;&amp;lt;!--暗桔黄色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;coral&amp;quot;&amp;gt;#FF7F50&amp;lt;/color&amp;gt;&amp;lt;!--珊瑚色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;hotpink&amp;quot;&amp;gt;#FF69B4&amp;lt;/color&amp;gt;&amp;lt;!--热粉红色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;tomato&amp;quot;&amp;gt;#FF6347&amp;lt;/color&amp;gt;&amp;lt;!--西红柿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;orangered&amp;quot;&amp;gt;#FF4500&amp;lt;/color&amp;gt;&amp;lt;!--红橙色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;deeppink&amp;quot;&amp;gt;#FF1493&amp;lt;/color&amp;gt;&amp;lt;!--深粉红色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;fuchsia&amp;quot;&amp;gt;#FF00FF&amp;lt;/color&amp;gt;&amp;lt;!--紫红色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;magenta&amp;quot;&amp;gt;#FF00FF&amp;lt;/color&amp;gt;&amp;lt;!--红紫色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;red&amp;quot;&amp;gt;#FF0000&amp;lt;/color&amp;gt;&amp;lt;!--红色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;oldlace&amp;quot;&amp;gt;#FDF5E6&amp;lt;/color&amp;gt;&amp;lt;!--老花色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightgoldenrodyellow&amp;quot;&amp;gt;#FAFAD2&amp;lt;/color&amp;gt;&amp;lt;!--亮金黄色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;linen&amp;quot;&amp;gt;#FAF0E6&amp;lt;/color&amp;gt;&amp;lt;!--亚麻色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;antiquewhite&amp;quot;&amp;gt;#FAEBD7&amp;lt;/color&amp;gt;&amp;lt;!--古董白 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;salmon&amp;quot;&amp;gt;#FA8072&amp;lt;/color&amp;gt;&amp;lt;!--鲜肉色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;ghostwhite&amp;quot;&amp;gt;#F8F8FF&amp;lt;/color&amp;gt;&amp;lt;!--幽灵白 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mintcream&amp;quot;&amp;gt;#F5FFFA&amp;lt;/color&amp;gt;&amp;lt;!--薄荷色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;whitesmoke&amp;quot;&amp;gt;#F5F5F5&amp;lt;/color&amp;gt;&amp;lt;!--烟白色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;beige&amp;quot;&amp;gt;#F5F5DC&amp;lt;/color&amp;gt;&amp;lt;!--米色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;wheat&amp;quot;&amp;gt;#F5DEB3&amp;lt;/color&amp;gt;&amp;lt;!--浅黄色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;sandybrown&amp;quot;&amp;gt;#F4A460&amp;lt;/color&amp;gt;&amp;lt;!--沙褐色--&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;azure&amp;quot;&amp;gt;#F0FFFF&amp;lt;/color&amp;gt;&amp;lt;!--天蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;honeydew&amp;quot;&amp;gt;#F0FFF0&amp;lt;/color&amp;gt;&amp;lt;!--蜜色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;aliceblue&amp;quot;&amp;gt;#F0F8FF&amp;lt;/color&amp;gt;&amp;lt;!--艾利斯兰 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;khaki&amp;quot;&amp;gt;#F0E68C&amp;lt;/color&amp;gt;&amp;lt;!--黄褐色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightcoral&amp;quot;&amp;gt;#F08080&amp;lt;/color&amp;gt;&amp;lt;!--亮珊瑚色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;palegoldenrod&amp;quot;&amp;gt;#EEE8AA&amp;lt;/color&amp;gt;&amp;lt;!--苍麒麟色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;violet&amp;quot;&amp;gt;#EE82EE&amp;lt;/color&amp;gt;&amp;lt;!--紫罗兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darksalmon&amp;quot;&amp;gt;#E9967A&amp;lt;/color&amp;gt;&amp;lt;!--暗肉色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lavender&amp;quot;&amp;gt;#E6E6FA&amp;lt;/color&amp;gt;&amp;lt;!--淡紫色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightcyan&amp;quot;&amp;gt;#E0FFFF&amp;lt;/color&amp;gt;&amp;lt;!--亮青色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;burlywood&amp;quot;&amp;gt;#DEB887&amp;lt;/color&amp;gt;&amp;lt;!--实木色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;plum&amp;quot;&amp;gt;#DDA0DD&amp;lt;/color&amp;gt;&amp;lt;!--洋李色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;gainsboro&amp;quot;&amp;gt;#DCDCDC&amp;lt;/color&amp;gt;&amp;lt;!--淡灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;crimson&amp;quot;&amp;gt;#DC143C&amp;lt;/color&amp;gt;&amp;lt;!--暗深红色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;palevioletred&amp;quot;&amp;gt;#DB7093&amp;lt;/color&amp;gt;&amp;lt;!--苍紫罗兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;goldenrod&amp;quot;&amp;gt;#DAA520&amp;lt;/color&amp;gt;&amp;lt;!--金麒麟色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;orchid&amp;quot;&amp;gt;#DA70D6&amp;lt;/color&amp;gt;&amp;lt;!--淡紫色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;thistle&amp;quot;&amp;gt;#D8BFD8&amp;lt;/color&amp;gt;&amp;lt;!--蓟色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightgray&amp;quot;&amp;gt;#D3D3D3&amp;lt;/color&amp;gt;&amp;lt;!--亮灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightgrey&amp;quot;&amp;gt;#D3D3D3&amp;lt;/color&amp;gt;&amp;lt;!--亮灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;tan&amp;quot;&amp;gt;#D2B48C&amp;lt;/color&amp;gt;&amp;lt;!--茶色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;chocolate&amp;quot;&amp;gt;#D2691E&amp;lt;/color&amp;gt;&amp;lt;!--巧可力色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;peru&amp;quot;&amp;gt;#CD853F&amp;lt;/color&amp;gt;&amp;lt;!--秘鲁色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;indianred&amp;quot;&amp;gt;#CD5C5C&amp;lt;/color&amp;gt;&amp;lt;!--印第安红 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumvioletred&amp;quot;&amp;gt;#C71585&amp;lt;/color&amp;gt;&amp;lt;!--中紫罗兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;silver&amp;quot;&amp;gt;#C0C0C0&amp;lt;/color&amp;gt;&amp;lt;!--银色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkkhaki&amp;quot;&amp;gt;#BDB76B&amp;lt;/color&amp;gt;&amp;lt;!--暗黄褐色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;rosybrown&amp;quot;&amp;gt;#BC8F8F&amp;lt;/color&amp;gt; &amp;lt;!--褐玫瑰红 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumorchid&amp;quot;&amp;gt;#BA55D3&amp;lt;/color&amp;gt;&amp;lt;!--中粉紫色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkgoldenrod&amp;quot;&amp;gt;#B8860B&amp;lt;/color&amp;gt;&amp;lt;!--暗金黄色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;firebrick&amp;quot;&amp;gt;#B22222&amp;lt;/color&amp;gt;&amp;lt;!--火砖色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;powderblue&amp;quot;&amp;gt;#B0E0E6&amp;lt;/color&amp;gt;&amp;lt;!--粉蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightsteelblue&amp;quot;&amp;gt;#B0C4DE&amp;lt;/color&amp;gt;&amp;lt;!--亮钢兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;paleturquoise&amp;quot;&amp;gt;#AFEEEE&amp;lt;/color&amp;gt;&amp;lt;!--苍宝石绿 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;greenyellow&amp;quot;&amp;gt;#ADFF2F&amp;lt;/color&amp;gt;&amp;lt;!--黄绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightblue&amp;quot;&amp;gt;#ADD8E6&amp;lt;/color&amp;gt;&amp;lt;!--亮蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkgray&amp;quot;&amp;gt;#A9A9A9&amp;lt;/color&amp;gt;&amp;lt;!--暗灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkgrey&amp;quot;&amp;gt;#A9A9A9&amp;lt;/color&amp;gt;&amp;lt;!--暗灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;brown&amp;quot;&amp;gt;#A52A2A&amp;lt;/color&amp;gt;&amp;lt;!--褐色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;sienna&amp;quot;&amp;gt;#A0522D&amp;lt;/color&amp;gt;&amp;lt;!--赭色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkorchid&amp;quot;&amp;gt;#9932CC&amp;lt;/color&amp;gt;&amp;lt;!--暗紫色--&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;palegreen&amp;quot;&amp;gt;#98FB98&amp;lt;/color&amp;gt;&amp;lt;!--苍绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkviolet&amp;quot;&amp;gt;#9400D3&amp;lt;/color&amp;gt;&amp;lt;!--暗紫罗兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumpurple&amp;quot;&amp;gt;#9370DB&amp;lt;/color&amp;gt;&amp;lt;!--中紫色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightgreen&amp;quot;&amp;gt;#90EE90&amp;lt;/color&amp;gt;&amp;lt;!--亮绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkseagreen&amp;quot;&amp;gt;#8FBC8F&amp;lt;/color&amp;gt;&amp;lt;!--暗海兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;saddlebrown&amp;quot;&amp;gt;#8B4513&amp;lt;/color&amp;gt;&amp;lt;!--重褐色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkmagenta&amp;quot;&amp;gt;#8B008B&amp;lt;/color&amp;gt;&amp;lt;!--暗洋红 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkred&amp;quot;&amp;gt;#8B0000&amp;lt;/color&amp;gt;&amp;lt;!--暗红色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;blueviolet&amp;quot;&amp;gt;#8A2BE2&amp;lt;/color&amp;gt;&amp;lt;!--紫罗兰蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightskyblue&amp;quot;&amp;gt;#87CEFA&amp;lt;/color&amp;gt;&amp;lt;!--亮天蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;skyblue&amp;quot;&amp;gt;#87CEEB&amp;lt;/color&amp;gt;&amp;lt;!--天蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;gray&amp;quot;&amp;gt;#808080&amp;lt;/color&amp;gt;&amp;lt;!--灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;grey&amp;quot;&amp;gt;#808080&amp;lt;/color&amp;gt;&amp;lt;!--灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;olive&amp;quot;&amp;gt;#808000&amp;lt;/color&amp;gt;&amp;lt;!--橄榄色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;purple&amp;quot;&amp;gt;#800080&amp;lt;/color&amp;gt;&amp;lt;!--紫色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;maroon&amp;quot;&amp;gt;#800000&amp;lt;/color&amp;gt;&amp;lt;!--粟色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;aquamarine&amp;quot;&amp;gt;#7FFFD4&amp;lt;/color&amp;gt;&amp;lt;!--碧绿色--&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;chartreuse&amp;quot;&amp;gt;#7FFF00&amp;lt;/color&amp;gt;&amp;lt;!--黄绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lawngreen&amp;quot;&amp;gt;#7CFC00&amp;lt;/color&amp;gt;&amp;lt;!--草绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumslateblue&amp;quot;&amp;gt;#7B68EE&amp;lt;/color&amp;gt;&amp;lt;!--中暗蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightslategray&amp;quot;&amp;gt;#778899&amp;lt;/color&amp;gt;&amp;lt;!--亮蓝灰 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightslategrey&amp;quot;&amp;gt;#778899&amp;lt;/color&amp;gt;&amp;lt;!--亮蓝灰 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;slategray&amp;quot;&amp;gt;#708090&amp;lt;/color&amp;gt;&amp;lt;!--灰石色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;slategrey&amp;quot;&amp;gt;#708090&amp;lt;/color&amp;gt;&amp;lt;!--灰石色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;olivedrab&amp;quot;&amp;gt;#6B8E23&amp;lt;/color&amp;gt;&amp;lt;!--深绿褐色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;slateblue&amp;quot;&amp;gt;#6A5ACD&amp;lt;/color&amp;gt;&amp;lt;!--石蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;dimgray&amp;quot;&amp;gt;#696969&amp;lt;/color&amp;gt;&amp;lt;!--暗灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;dimgrey&amp;quot;&amp;gt;#696969&amp;lt;/color&amp;gt;&amp;lt;!--暗灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumaquamarine&amp;quot;&amp;gt;#66CDAA&amp;lt;/color&amp;gt;&amp;lt;!--中绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;cornflowerblue&amp;quot;&amp;gt;#6495ED&amp;lt;/color&amp;gt;&amp;lt;!--菊兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;cadetblue&amp;quot;&amp;gt;#5F9EA0&amp;lt;/color&amp;gt;&amp;lt;!--军兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkolivegreen&amp;quot;&amp;gt;#556B2F&amp;lt;/color&amp;gt;&amp;lt;!--暗橄榄绿  --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;indigo&amp;quot;&amp;gt;#4B0082&amp;lt;/color&amp;gt;&amp;lt;!--靛青色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumturquoise&amp;quot;&amp;gt;#48D1CC&amp;lt;/color&amp;gt;&amp;lt;!--中绿宝石 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkslateblue&amp;quot;&amp;gt;#483D8B&amp;lt;/color&amp;gt;&amp;lt;!--暗灰蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;steelblue&amp;quot;&amp;gt;#4682B4&amp;lt;/color&amp;gt;&amp;lt;!--钢兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;royalblue&amp;quot;&amp;gt;#4169E1&amp;lt;/color&amp;gt;&amp;lt;!--皇家蓝 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;turquoise&amp;quot;&amp;gt;#40E0D0&amp;lt;/color&amp;gt;&amp;lt;!--青绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumseagreen&amp;quot;&amp;gt;#3CB371&amp;lt;/color&amp;gt;&amp;lt;!--中海蓝 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;limegreen&amp;quot;&amp;gt;#32CD32&amp;lt;/color&amp;gt;&amp;lt;!--橙绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkslategray&amp;quot;&amp;gt;#2F4F4F&amp;lt;/color&amp;gt;&amp;lt;!--暗瓦灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkslategrey&amp;quot;&amp;gt;#2F4F4F&amp;lt;/color&amp;gt;&amp;lt;!--暗瓦灰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;seagreen&amp;quot;&amp;gt;#2E8B57&amp;lt;/color&amp;gt;&amp;lt;!--海绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;forestgreen&amp;quot;&amp;gt;#228B22&amp;lt;/color&amp;gt;&amp;lt;!--森林绿 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lightseagreen&amp;quot;&amp;gt;#20B2AA&amp;lt;/color&amp;gt;&amp;lt;!--亮海蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;dodgerblue&amp;quot;&amp;gt;#1E90FF&amp;lt;/color&amp;gt;&amp;lt;!--闪兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;midnightblue&amp;quot;&amp;gt;#191970&amp;lt;/color&amp;gt;&amp;lt;!--中灰兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;aqua&amp;quot;&amp;gt;#00FFFF&amp;lt;/color&amp;gt;&amp;lt;!--浅绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;cyan&amp;quot;&amp;gt;#00FFFF&amp;lt;/color&amp;gt;&amp;lt;!--青色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;springgreen&amp;quot;&amp;gt;#00FF7F&amp;lt;/color&amp;gt;&amp;lt;!--春绿色--&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;lime&amp;quot;&amp;gt;#00FF00&amp;lt;/color&amp;gt;&amp;lt;!--酸橙色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumspringgreen&amp;quot;&amp;gt;#00FA9A&amp;lt;/color&amp;gt;&amp;lt;!--中春绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkturquoise&amp;quot;&amp;gt;#00CED1&amp;lt;/color&amp;gt;&amp;lt;!--暗宝石绿 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;deepskyblue&amp;quot;&amp;gt;#00BFFF&amp;lt;/color&amp;gt;&amp;lt;!--深天蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkcyan&amp;quot;&amp;gt;#008B8B&amp;lt;/color&amp;gt;&amp;lt;!--暗青色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;teal&amp;quot;&amp;gt;#008080&amp;lt;/color&amp;gt;&amp;lt;!--水鸭色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;green&amp;quot;&amp;gt;#008000&amp;lt;/color&amp;gt;&amp;lt;!--绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkgreen&amp;quot;&amp;gt;#006400&amp;lt;/color&amp;gt;&amp;lt;!--暗绿色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;blue&amp;quot;&amp;gt;#0000FF&amp;lt;/color&amp;gt;&amp;lt;!--蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;mediumblue&amp;quot;&amp;gt;#0000CD&amp;lt;/color&amp;gt;&amp;lt;!--中兰色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;darkblue&amp;quot;&amp;gt;#00008B&amp;lt;/color&amp;gt;&amp;lt;!--暗蓝色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;navy&amp;quot;&amp;gt;#000080&amp;lt;/color&amp;gt;&amp;lt;!--海军色 --&amp;gt;    &#xA;&amp;lt;color name=&amp;quot;black&amp;quot;&amp;gt;#000000&amp;lt;/color&amp;gt;&amp;lt;!--黑色 --&amp;gt;    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之日期时间选择器使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-08-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;日期时间选择器&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 设置日期&#xA;@Override&#xA;public void onClick(View v) {&#xA;    new DatePickerDialog(activity,&#xA;            new DatePickerDialog.OnDateSetListener() {&#xA;                @Override&#xA;                public void onDateSet(DatePicker view, int year,&#xA;                                      int monthOfYear, int dayOfMonth) {&#xA;                    // 设置&#xA;                    calendar.set(year, monthOfYear, dayOfMonth);&#xA;                }&#xA;            }, // 设置年,月,日&#xA;            calendar.get(Calendar.YEAR),&#xA;            calendar.get(Calendar.MONTH),&#xA;            calendar.get(Calendar.DAY_OF_MONTH)).show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 设置时间&#xA;public void onClick(View v) {&#xA;    new TimePickerDialog(activity,&#xA;            new TimePickerDialog.OnTimeSetListener() {&#xA;                @Override&#xA;                public void onTimeSet(TimePicker view,&#xA;                                      int hourOfDay, int minute) {&#xA;                    // 设置&#xA;                    calendar.set(calendar.get(Calendar.YEAR),&#xA;                            calendar.get(Calendar.MONTH),&#xA;                            calendar.get(Calendar.DAY_OF_MONTH),&#xA;                            hourOfDay, minute);&#xA;                }&#xA;            }, // 设置 时,分,是否是24小时制&#xA;            calendar.get(Calendar.HOUR_OF_DAY),&#xA;            calendar.get(Calendar.MINUTE), true).show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 获取日期与时间&#xA;SimpleDateFormat format = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);&#xA;format.format(calendar.getTime())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之日期时间选择器使用方法/1.jpg&#34; alt=&#34;&#34; width=&#34;300&#34; hight=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之百度地图坐标定位</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>2015-08-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;百度地图坐标定位&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;百度地图Android定位SDK提供GPS，基站，Wi-Fi等多种定位方式&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;适用于室、内外多种定位场景，具有出色的定位性能：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;定位精度高、覆盖率广、网络定位请求流量小、定位速度快。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之百度地图坐标定位/1.jpeg&#34; alt=&#34;&#34; width=&#34;350&#34; hight=&#34;600&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1，在百度开放平台创建应用，并且设置安全码&#xA;    地址：http://lbsyun.baidu.com/apiconsole/key&#xA;&#xA;2，获取应用访问应用（AK）...&#xA;&#xA;3，从百度开放平台下载SDK&#xA;    地址：http://lbsyun.baidu.com/sdk/download&#xA;&#xA;4，基础SDK开发包：定位功能，基础地图，检索功能，LBS云检索&#xA;    获取文件：BaiduLBS_Android.jar + armeabi（目录）&#xA;&#xA;5，将armeabi目录内文件拷贝到项目的../app/src/main/jniLibs/armeabi下&#xA;    将BaiduLBS_Android.jar拷贝到../app/libs目录下，并导入项目（Studio默认自动导入)&#xA;&#xA;6，下载示例代码：http://lbsyun.baidu.com/sdk/download&#xA;    找到：地图+检索+LBS云检索+工具+周边雷达（目录）&#xA;    找到：/BaiduMapsApiDemo/src/baidumapsdk/demo（目录）&#xA;    找到：LocationDemo.java 文件就是定位示例）&#xA;&#xA;7, 将 LocationDemo.java 导入到项目&#xA;    找到：示例项目中的 AndroidManifest.xml （文件）&#xA;    取出：下面示例中的内容，拷贝到当前项目中 ...&#xA;&#xA;8，下面的：LocationActivity.java 是我稍加修改的 LocationDemo.java&#xA;&#xA;9，先做到可以正常运行官方示例（LocationDemo.java）&#xA;&#xA;10，需要提醒的是，生成APK需要通过, Build/Generate Signed APK(Studio) 生成&#xA;        否则程序的指纹信息无法与安全码进行匹配...&#xA;&#xA;// 百度地图仅LBS搜索还有着很多功能... 具体请看官方文档&#xA;// http://developer.baidu.com/map/index.php?title=android-locsdk&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在application标签中声明service组件,每个app拥有自己单独的定位service&#xA;&amp;lt;service &#xA;    android:name=&amp;quot;com.baidu.location.f&amp;quot; &#xA;    android:enabled=&amp;quot;true&amp;quot; &#xA;    android:process=&amp;quot;:remote&amp;quot;&amp;gt;&#xA;&amp;lt;/service&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;【重要提醒】&#xA;定位SDKv3.1版本之后，以下权限已不需要，请取消声明&#xA;否则将由于Android 5.0多帐户系统加强权限管理而导致应用安装失败。&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.BAIDU_LOCATION_SERVICE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 声明使用权限&#xA;&amp;lt;!-- 这个权限用于进行网络定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_COARSE_LOCATION&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 这个权限用于访问GPS定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_FINE_LOCATION&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_WIFI_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_NETWORK_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.CHANGE_WIFI_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 用于读取手机当前的状态--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_PHONE_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 访问网络，网络定位需要上网--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;&#xA;&amp;lt;!-- SD卡读取权限，用户写入离线定位数据--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;SDK4.2及之后版本需要在Mainfest.xml设置Accesskey&#xA;设置有误会引起定位和地理围栏服务不能正常使用，必须进行Accesskey的正确设置。&#xA;设置AccessKey，在application标签中加入&#xA;// key:开发者申请的key&#xA;&amp;lt;meta-data android:name=&amp;quot;com.baidu.lbsapi.API_KEY&amp;quot; android:value=&amp;quot;key&amp;quot; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 具体获取坐标代码&#xA;&#xA;// 定位相关&#xA;LocationClient mLocClient;&#xA;public MyLocationListenner myListener = new MyLocationListenner();&#xA;&#xA;@Override&#xA;public void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_location);&#xA;    // 定位初始化&#xA;    mLocClient = new LocationClient(this);&#xA;    mLocClient.registerLocationListener(myListener);&#xA;    LocationClientOption option = new LocationClientOption();&#xA;    option.setOpenGps(true);// 打开gps&#xA;    option.setCoorType(&amp;quot;bd09ll&amp;quot;); // 设置坐标类型&#xA;    option.setScanSpan(1000);&#xA;    mLocClient.setLocOption(option);&#xA;    mLocClient.start();&#xA;}&#xA;&#xA;/**&#xA; * 定位SDK监听函数&#xA; */&#xA;public class MyLocationListenner implements BDLocationListener {&#xA;    @Override&#xA;    public void onReceiveLocation(BDLocation location) {&#xA;        MyLocationData locData = new MyLocationData.Builder()&#xA;                .accuracy(location.getRadius())&#xA;                // 此处设置开发者获取到的方向信息，顺时针0-360&#xA;                // 这里的方向需要用户通过传感器自定获取并设置&#xA;                .direction(100).latitude(location.getLatitude())&#xA;                .longitude(location.getLongitude()).build();&#xA;        Log.i(&amp;quot;纬度&amp;quot;, String.valueOf(locData.latitude));&#xA;        Log.i(&amp;quot;经度&amp;quot;, String.valueOf(locData.longitude));&#xA;        Log.i(&amp;quot;速度&amp;quot;, String.valueOf(locData.speed));&#xA;        Log.i(&amp;quot;方向&amp;quot;, String.valueOf(locData.direction));&#xA;        Log.i(&amp;quot;精度&amp;quot;, String.valueOf(locData.accuracy));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 完整的官方SDK定位示例&#xA;public class LocationActivity extends Activity {&#xA;&#xA;    // 定位相关&#xA;    LocationClient mLocClient;&#xA;    public MyLocationListenner myListener = new MyLocationListenner();&#xA;    private LocationMode mCurrentMode;&#xA;    BitmapDescriptor mCurrentMarker;&#xA;&#xA;    MapView mMapView;&#xA;    BaiduMap mBaiduMap;&#xA;&#xA;    // UI相关&#xA;    OnCheckedChangeListener radioButtonListener;&#xA;    Button requestLocButton;&#xA;    boolean isFirstLoc = true;// 是否首次定位&#xA;&#xA;    @Override&#xA;    public void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_location);&#xA;        requestLocButton = (Button) findViewById(R.id.button1);&#xA;        mCurrentMode = LocationMode.NORMAL;&#xA;        requestLocButton.setText(&amp;quot;普通&amp;quot;);&#xA;        OnClickListener btnClickListener = new OnClickListener() {&#xA;            public void onClick(View v) {&#xA;                switch (mCurrentMode) {&#xA;                    case NORMAL:&#xA;                        requestLocButton.setText(&amp;quot;跟随&amp;quot;);&#xA;                        mCurrentMode = LocationMode.FOLLOWING;&#xA;                        mBaiduMap.setMyLocationConfigeration(&#xA;                            new MyLocationConfiguration(mCurrentMode, true, mCurrentMarker));&#xA;                        break;&#xA;                    case COMPASS:&#xA;                        requestLocButton.setText(&amp;quot;普通&amp;quot;);&#xA;                        mCurrentMode = LocationMode.NORMAL;&#xA;                        mBaiduMap.setMyLocationConfigeration(&#xA;                            new MyLocationConfiguration(mCurrentMode, true, mCurrentMarker));&#xA;                        break;&#xA;                    case FOLLOWING:&#xA;                        requestLocButton.setText(&amp;quot;罗盘&amp;quot;);&#xA;                        mCurrentMode = LocationMode.COMPASS;&#xA;                        mBaiduMap.setMyLocationConfigeration(&#xA;                            new MyLocationConfiguration(mCurrentMode, true, mCurrentMarker));&#xA;                        break;&#xA;                }&#xA;            }&#xA;        };&#xA;        requestLocButton.setOnClickListener(btnClickListener);&#xA;&#xA;        RadioGroup group = (RadioGroup) this.findViewById(R.id.radioGroup);&#xA;        radioButtonListener = new OnCheckedChangeListener() {&#xA;            @Override&#xA;            public void onCheckedChanged(RadioGroup group, int checkedId) {&#xA;                if (checkedId == R.id.defaulticon) {&#xA;                    // 传入null则，恢复默认图标&#xA;                    mCurrentMarker = null;&#xA;                    mBaiduMap.setMyLocationConfigeration(&#xA;                        new MyLocationConfiguration(mCurrentMode, true, null));&#xA;                }&#xA;                if (checkedId == R.id.customicon) {&#xA;                    // 修改为自定义marker&#xA;                    mCurrentMarker = BitmapDescriptorFactory.fromResource(R.drawable.icon_geo);&#xA;                    mBaiduMap.setMyLocationConfigeration(&#xA;                        new MyLocationConfiguration(mCurrentMode, true, mCurrentMarker));&#xA;                }&#xA;            }&#xA;        };&#xA;        group.setOnCheckedChangeListener(radioButtonListener);&#xA;&#xA;        // 地图初始化&#xA;        mMapView = (MapView) findViewById(R.id.bmapView);&#xA;        mBaiduMap = mMapView.getMap();&#xA;        // 开启定位图层&#xA;        mBaiduMap.setMyLocationEnabled(true);&#xA;        // 定位初始化&#xA;        mLocClient = new LocationClient(this);&#xA;        mLocClient.registerLocationListener(myListener);&#xA;        LocationClientOption option = new LocationClientOption();&#xA;        option.setOpenGps(true);// 打开gps&#xA;        option.setCoorType(&amp;quot;bd09ll&amp;quot;); // 设置坐标类型&#xA;        option.setScanSpan(1000);&#xA;        mLocClient.setLocOption(option);&#xA;        mLocClient.start();&#xA;    }&#xA;&#xA;    /**&#xA;     * 定位SDK监听函数&#xA;     */&#xA;    public class MyLocationListenner implements BDLocationListener {&#xA;&#xA;        @Override&#xA;        public void onReceiveLocation(BDLocation location) {&#xA;            // map view 销毁后不在处理新接收的位置&#xA;            if (location == null || mMapView == null)&#xA;                return;&#xA;            MyLocationData locData = new MyLocationData.Builder()&#xA;                    .accuracy(location.getRadius())&#xA;                    // 此处设置开发者获取到的方向信息，顺时针0-360&#xA;                    // 这里的方向需要用户通过传感器自定获取并设置&#xA;                    .direction(100).latitude(location.getLatitude())&#xA;                    .longitude(location.getLongitude()).build();&#xA;            Log.i(&amp;quot;纬度&amp;quot;, String.valueOf(locData.latitude));&#xA;            Log.i(&amp;quot;经度&amp;quot;, String.valueOf(locData.longitude));&#xA;            Log.i(&amp;quot;速度&amp;quot;, String.valueOf(locData.speed));&#xA;            Log.i(&amp;quot;方向&amp;quot;, String.valueOf(locData.direction));&#xA;            Log.i(&amp;quot;精度&amp;quot;, String.valueOf(locData.accuracy));&#xA;            mBaiduMap.setMyLocationData(locData);&#xA;            if (isFirstLoc) {&#xA;                isFirstLoc = false;&#xA;                LatLng ll = new LatLng(location.getLatitude(),&#xA;                        location.getLongitude());&#xA;                MapStatusUpdate u = MapStatusUpdateFactory.newLatLng(ll);&#xA;                mBaiduMap.animateMapStatus(u);&#xA;            }&#xA;        }&#xA;&#xA;        public void onReceivePoi(BDLocation poiLocation) {&#xA;        }&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onPause() {&#xA;        mMapView.onPause();&#xA;        super.onPause();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onResume() {&#xA;        mMapView.onResume();&#xA;        super.onResume();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onDestroy() {&#xA;        // 退出时销毁定位&#xA;        mLocClient.stop();&#xA;        // 关闭定位图层&#xA;        mBaiduMap.setMyLocationEnabled(false);&#xA;        mMapView.onDestroy();&#xA;        mMapView = null;&#xA;        super.onDestroy();&#xA;    }&#xA;&#xA;}:wq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之百度地图LBS云搜索</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BELBS%E4%BA%91%E6%90%9C%E7%B4%A2/</link>
      <pubDate>2015-07-31 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;百度地图LBS云搜索&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;LBS.云是百度地图针对LBS开发者推出的平台级服务&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;结合已有的地图API和SDK服务，通过开放服务端存储和计算能力，提供海量位置数据存储、检索、展示一体化解决方案。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1，在百度开放平台创建应用，并且设置安全码&#xA;    地址：http://lbsyun.baidu.com/apiconsole/key&#xA;&#xA;2，获取应用访问应用（AK）...&#xA;    这里与兴趣点不同，同时需要服务器(AK)&#xA;&#xA;3，从百度开放平台下载SDK&#xA;    地址：http://lbsyun.baidu.com/sdk/download&#xA;&#xA;4，基础SDK开发包：定位功能，基础地图，检索功能，LBS云检索&#xA;    获取文件：BaiduLBS_Android.jar + armeabi（目录）&#xA;&#xA;5，将armeabi目录内文件拷贝到项目的../app/src/main/jniLibs/armeabi下&#xA;    将BaiduLBS_Android.jar拷贝到../app/libs目录下，并导入项目（Studio默认自动导入)&#xA;&#xA;6，下载示例代码：http://lbsyun.baidu.com/sdk/download&#xA;    找到：地图+检索+LBS云检索+工具+周边雷达（目录）&#xA;    找到：/BaiduMapsApiDemo/src/baidumapsdk/demo（目录）&#xA;    找到：CloudSearchActivity.java 文件就是LBS云搜索示例）&#xA;&#xA;7, 将 CloudSearchActivity.java 导入到项目&#xA;    找到：示例项目中的 AndroidManifest.xml （文件）&#xA;    取出：下面示例中的内容，拷贝到当前项目中 ...&#xA;&#xA;8，下面的：CloudSearchActivity.java 是我稍加修改的 CloudSearchActivity.java&#xA;&#xA;9，先做到可以正常运行官方示例（CloudSearchActivity.java）&#xA;&#xA;10，需要提醒的是，生成APK需要通过, Build/Generate Signed APK(Studio) 生成&#xA;        否则程序的指纹信息无法与安全码进行匹配...&#xA;&#xA;// 百度地图仅LBS搜索还有着很多功能... 具体请看官方文档&#xA;// http://developer.baidu.com/map/index.php?title=lbscloud/api/geosearch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;云搜索具体介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;云搜索分为：云存储，云搜索&#xA;云存储：将需要被搜索到的POI点存储到百度云数据中&#xA;云搜索：通过设置的POI点ID及相关参数进行搜索，比如：坐标，标签等&#xA;// 云存储地址：http://lbsyun.baidu.com/datamanager/datamanage&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;云搜索分为：本地搜索，周边搜索，矩形搜索，详情检索&#xA;本地搜索：通过，城市+关键字+标签，在存储中搜索匹配数据&#xA;周边搜索：通过，当前坐标+范围+标签，在存储中搜索匹配数据&#xA;矩形搜索：通过，指定区域坐标+关键字+标签，在存储中搜索匹配数据&#xA;// 官方文档：http://developer.baidu.com/map/index.php?title=lbscloud/api/geosearch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在百度云存储数据进行设置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之百度地图LBS云搜索/1.png&#34; alt=&#34;&#34; width=&#34;800&#34; hight=&#34;450&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在手机地图中显示的效果&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之百度地图LBS云搜索/2.jpg&#34; alt=&#34;&#34; width=&#34;350&#34; hight=&#34;600&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;LBS云搜索示例&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class CloudSearchActivity extends Activity implements CloudListener {&#xA;    private static final String LTAG = CloudSearchActivity.class&#xA;            .getSimpleName();&#xA;    private MapView mMapView;&#xA;    private BaiduMap mBaiduMap;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle icicle) {&#xA;        super.onCreate(icicle);&#xA;        setContentView(R.layout.activity_lbssearch);&#xA;        CloudManager.getInstance().init(CloudSearchActivity.this);&#xA;        mMapView = (MapView) findViewById(R.id.bmapView);&#xA;        mBaiduMap = mMapView.getMap();&#xA;        findViewById(R.id.regionSearch).setOnClickListener(&#xA;                new OnClickListener() {&#xA;                    @Override&#xA;                    public void onClick(View v) {&#xA;                        /**&#xA;                         * 本地检索是指可检索指定区域范围内的poi信息&#xA;                         * 区域通过region参数来设定&#xA;                         * 可以是全国范围也可以是小范围的如海淀区。&#xA;                         * 检索时可通过tags参数指定检索类型；&#xA;                         * 通过sortby参数对检索结果进行排序（支持多字段排序）；&#xA;                         * filter参数可以完成对指定数据范围的筛选。&#xA;                         */&#xA;                        LocalSearchInfo info = new LocalSearchInfo();&#xA;                        // AK 需要使用服务器AK&#xA;                        info.ak = &amp;quot;eU8VKgzQQSwVCAq1AXDRkHmq&amp;quot;;&#xA;                        // 指定LBS云可以搜索的坐标组ID&#xA;                        info.geoTableId = 115616;&#xA;                        // 在LBS云可以设置TAGS类型&#xA;                        info.tags = &amp;quot;公司&amp;quot;;&#xA;                        // 在指定的地区搜索geoTableId内符合的坐标&#xA;                        info.q = &amp;quot;海淀区&amp;quot;;&#xA;                        // 在指定的城市搜索geoTableId内符合的坐标&#xA;                        info.region = &amp;quot;北京市&amp;quot;;&#xA;                        // ...&#xA;                        CloudManager.getInstance().localSearch(info);&#xA;                    }&#xA;                });&#xA;        findViewById(R.id.nearbySearch).setOnClickListener(&#xA;                new OnClickListener() {&#xA;                    public void onClick(View v) {&#xA;                        /**&#xA;                         * 周边检索是指以一点为中心（中心点通过location参数指定）&#xA;                         * 搜索中心点附近指定距离范围（搜索半径通过radius参数指定）内的POI点。&#xA;                         * 检索时可通过tags参数指定检索的类型；&#xA;                         * 通过sortby参数进行检索结果的排序（支持多字段排序）；&#xA;                         * filter参数可以完成对指定数据范围的筛选。&#xA;                         */&#xA;                        NearbySearchInfo info = new NearbySearchInfo();&#xA;                        // AK 需要使用服务器AK&#xA;                        info.ak = &amp;quot;eU8VKgzQQSwVCAq1AXDRkHmq&amp;quot;;&#xA;                        // 指定LBS云可以搜索的坐标组ID&#xA;                        info.geoTableId = 115616;&#xA;                        // 搜索的范围&#xA;                        info.radius = 1000;&#xA;                        // 搜索的类型&#xA;                        info.tags = &amp;quot;企业&amp;quot;;&#xA;                        // 搜索的起始坐标&#xA;                        info.location = &amp;quot;116.315047,40.043694&amp;quot;;&#xA;                        // ...&#xA;                        CloudManager.getInstance().nearbySearch(info);&#xA;                    }&#xA;                });&#xA;&#xA;        findViewById(R.id.boundsSearch).setOnClickListener(&#xA;                new OnClickListener() {&#xA;                    public void onClick(View v) {&#xA;                        /**&#xA;                         * 矩形检索是指可检索指定矩形范围内的poi信息&#xA;                         * 检索区域通过bounds参数设定的矩形的左下角和右上角的经纬度坐标来确定。&#xA;                         * 检索时可通过tags参数指定检索类型；&#xA;                         * 检索结果可通过sortby参数进行排序（支持多字段排序）；&#xA;                         * 可通过filter参数筛选出指定的数据范围的结果。&#xA;                         */&#xA;                        BoundSearchInfo info = new BoundSearchInfo();&#xA;                        info.ak = &amp;quot;B266f735e43ab207ec152deff44fec8b&amp;quot;;&#xA;                        info.geoTableId = 31869;&#xA;                        info.q = &amp;quot;天安门&amp;quot;;&#xA;                        info.bound = &amp;quot;116.401663,39.913961;116.406529,39.917396&amp;quot;;&#xA;                        CloudManager.getInstance().boundSearch(info);&#xA;                    }&#xA;                });&#xA;        findViewById(R.id.detailsSearch).setOnClickListener(&#xA;                new OnClickListener() {&#xA;                    public void onClick(View v) {&#xA;                        /**&#xA;                         * 坐标点的详情信息&#xA;                         */&#xA;                        DetailSearchInfo info = new DetailSearchInfo();&#xA;                        info.ak = &amp;quot;eU8VKgzQQSwVCAq1AXDRkHmq&amp;quot;;&#xA;                        info.geoTableId = 115616;&#xA;                        info.uid = 1128794574;&#xA;                        CloudManager.getInstance().detailSearch(info);&#xA;                    }&#xA;                });&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onDestroy() {&#xA;        super.onDestroy();&#xA;        mMapView.onDestroy();&#xA;        CloudManager.getInstance().destroy();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onPause() {&#xA;        super.onPause();&#xA;        mMapView.onPause();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onResume() {&#xA;        super.onResume();&#xA;        mMapView.onResume();&#xA;    }&#xA;&#xA;    public void onGetDetailSearchResult(DetailSearchResult result, int error) {&#xA;        if (result != null) {&#xA;            if (result.poiInfo != null) {&#xA;                Toast.makeText(CloudSearchActivity.this, result.poiInfo.title,&#xA;                        Toast.LENGTH_SHORT).show();&#xA;            } else {&#xA;                Toast.makeText(CloudSearchActivity.this,&#xA;                        &amp;quot;status:&amp;quot; + result.status, Toast.LENGTH_SHORT).show();&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    public void onGetSearchResult(CloudSearchResult result, int error) {&#xA;        if (result != null &amp;amp;&amp;amp; result.poiList != null&#xA;                &amp;amp;&amp;amp; result.poiList.size() &amp;gt; 0) {&#xA;            Log.d(LTAG, &amp;quot;onGetSearchResult, result length: &amp;quot; + result.poiList.size());&#xA;            mBaiduMap.clear();&#xA;            BitmapDescriptor bd = BitmapDescriptorFactory.fromResource(R.drawable.icon_gcoding);&#xA;            LatLng ll;&#xA;            Builder builder = new Builder();&#xA;            for (CloudPoiInfo info : result.poiList) {&#xA;                ll = new LatLng(info.latitude, info.longitude);&#xA;                OverlayOptions oo = new MarkerOptions().icon(bd).position(ll);&#xA;                mBaiduMap.addOverlay(oo);&#xA;                builder.include(ll);&#xA;            }&#xA;            LatLngBounds bounds = builder.build();&#xA;            MapStatusUpdate u = MapStatusUpdateFactory.newLatLngBounds(bounds);&#xA;            mBaiduMap.animateMapStatus(u);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之百度地图兴趣点搜索</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%85%B4%E8%B6%A3%E7%82%B9%E6%90%9C%E7%B4%A2/</link>
      <pubDate>2015-07-30 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;百度地图兴趣点搜索&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;POI（Point of Interest），中文可以翻译为“兴趣点”。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在地理信息系统中，一个POI可以是一栋房子、一个商铺、一个邮筒、一个公交站等。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;百度地图SDK提供三种类型的POI检索：周边检索、区域检索和城市内检索。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1，在百度开放平台创建应用，并且设置安全码&#xA;    地址：http://lbsyun.baidu.com/apiconsole/key&#xA;&#xA;2，获取应用访问应用（AK）...&#xA;&#xA;3，从百度开放平台下载SDK&#xA;    地址：http://lbsyun.baidu.com/sdk/download&#xA;&#xA;4，基础SDK开发包：定位功能，基础地图，检索功能，LBS云检索&#xA;    获取文件：BaiduLBS_Android.jar + armeabi（目录）&#xA;&#xA;5，将armeabi目录内文件拷贝到项目的../app/src/main/jniLibs/armeabi下&#xA;    将BaiduLBS_Android.jar拷贝到../app/libs目录下，并导入项目（Studio默认自动导入)&#xA;&#xA;6，下载示例代码：http://lbsyun.baidu.com/sdk/download&#xA;    找到：地图+检索+LBS云检索+工具+周边雷达（目录）&#xA;    找到：/BaiduMapsApiDemo/src/baidumapsdk/demo（目录）&#xA;    找到：PoiSearchDemo.java （文件就是兴趣点搜索示例）&#xA;&#xA;7, 将 PoiSearchDemo.java 导入到项目&#xA;    找到：示例项目中的 AndroidManifest.xml （文件）&#xA;    取出：下面示例中的内容，拷贝到当前项目中 ...&#xA;&#xA;8，下面的：PoiSearchActivity 是我稍加修改的 PoiSearchDemo&#xA;&#xA;9，这样通过指定：city（城市）和（searchkey）地址，就可以进行搜索了&#xA;&#xA;10，需要提醒的是，生成APK需要通过, Build/Generate Signed APK(Studio) 生成&#xA;        否则程序的指纹信息无法与安全码进行匹配...&#xA;&#xA;// 百度地图仅POI搜索还有着很多功能... 具体请看官方文档&#xA;// http://developer.baidu.com/map/index.php?title=androidsdk&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;application&#xA;    ...&#xA;    &amp;lt;activity android:name=&amp;quot;.PoiSearchDemo&amp;quot; /&amp;gt;&#xA;    &amp;lt;meta-data&#xA;        android:name=&amp;quot;com.baidu.lbsapi.API_KEY&amp;quot;&#xA;        android:value=&amp;quot;OCEmzFbp7EA8LOFmUzzMkHnX&amp;quot; /&amp;gt;&#xA;    &amp;lt;service&#xA;        android:name=&amp;quot;com.baidu.location.f&amp;quot;&#xA;        android:enabled=&amp;quot;true&amp;quot;&#xA;        android:process=&amp;quot;:remote&amp;quot; &amp;gt;&#xA;    &amp;lt;/service&amp;gt;&#xA;    ...&#xA;&amp;lt;/application&amp;gt;&#xA;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_NETWORK_STATE&amp;quot; &amp;gt;&#xA;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; &amp;gt;&#xA;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;com.android.launcher.permission.READ_SETTINGS&amp;quot; /&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.WAKE_LOCK&amp;quot; &amp;gt;&#xA;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.CHANGE_WIFI_STATE&amp;quot; /&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_WIFI_STATE&amp;quot; /&amp;gt;&#xA;&amp;lt;!-- SDK1.5需要android.permission.GET_TASKS权限判断本程序是否为当前运行的应用? --&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.GET_TASKS&amp;quot; /&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot; &amp;gt;&#xA;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_SETTINGS&amp;quot; /&amp;gt;&#xA;&amp;lt;!-- 这个权限用于进行网络定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_COARSE_LOCATION&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 这个权限用于访问GPS定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_FINE_LOCATION&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_WIFI_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_NETWORK_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.CHANGE_WIFI_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 用于读取手机当前的状态--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_PHONE_STATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!-- 访问网络，网络定位需要上网--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;&#xA;&amp;lt;!-- SD卡读取权限，用户写入离线定位数据--&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;!--允许应用读取低级别的系统日志文件 --&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_LOGS&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&#xA;&amp;lt;supports-screens&#xA;    android:anyDensity=&amp;quot;true&amp;quot;&#xA;    android:largeScreens=&amp;quot;true&amp;quot;&#xA;    android:normalScreens=&amp;quot;false&amp;quot;&#xA;    android:resizeable=&amp;quot;true&amp;quot;&#xA;    android:smallScreens=&amp;quot;true&amp;quot; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 城市内检索&#xA;mPoiSearch.searchInCity(...);&#xA;// 范围内检索&#xA;mPoiSearch.searchInBound(...);&#xA;// 周边检索&#xA;mPoiSearch.searchNearby(...);&#xA;// POI 详情检索&#xA;mPoiSearch.searchPoiDetail(...);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;官方演示（稍加修改)&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * poi搜索功能&#xA; */&#xA;public class PoiSearchActivity extends FragmentActivity implements&#xA;        OnGetPoiSearchResultListener, OnGetSuggestionResultListener {&#xA;&#xA;    /**&#xA;     * city         城市&#xA;     * searchkey    地址&#xA;     */&#xA;    private PoiSearch mPoiSearch = null;&#xA;    private SuggestionSearch mSuggestionSearch = null;&#xA;    private BaiduMap mBaiduMap = null;&#xA;    /**&#xA;     * 搜索关键字输入窗口&#xA;     */&#xA;    private AutoCompleteTextView keyWorldsView = null;&#xA;    private ArrayAdapter&amp;lt;String&amp;gt; sugAdapter = null;&#xA;    private int load_Index = 0;&#xA;    /**&#xA;     * 返回&#xA;     */&#xA;    private ImageView backing;&#xA;&#xA;    @Override&#xA;    public void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_poisearch);&#xA;        // 返回&#xA;        backing = (ImageView) findViewById(R.id.car_backing);&#xA;        backing.setOnClickListener(new View.OnClickListener() {&#xA;            @Override&#xA;            public void onClick(View v) {&#xA;                finish();&#xA;            }&#xA;        });&#xA;        // 初始化搜索模块，注册搜索事件监听&#xA;        mPoiSearch = PoiSearch.newInstance();&#xA;        mPoiSearch.setOnGetPoiSearchResultListener(this);&#xA;        mSuggestionSearch = SuggestionSearch.newInstance();&#xA;        mSuggestionSearch.setOnGetSuggestionResultListener(this);&#xA;        keyWorldsView = new AutoCompleteTextView(this);&#xA;        // keyWorldsView = (AutoCompleteTextView) findViewById(R.id.searchkey);&#xA;        sugAdapter = new ArrayAdapter&amp;lt;String&amp;gt;(this,&#xA;                android.R.layout.simple_dropdown_item_1line);&#xA;        keyWorldsView.setAdapter(sugAdapter);&#xA;        mBaiduMap = ((SupportMapFragment) (getSupportFragmentManager()&#xA;                .findFragmentById(R.id.map))).getBaiduMap();&#xA;        // 获取搜索地址&#xA;        Intent intent = getIntent();&#xA;        String city = intent.getStringExtra(&amp;quot;POI_SEARCH_CITY&amp;quot;);&#xA;        String key = intent.getStringExtra(&amp;quot;POI_SEARCH_KEY&amp;quot;);&#xA;        // 自动搜索&#xA;        searchButtonProcess(city, key);&#xA;        /**&#xA;         * 当输入关键字变化时，动态更新建议列表&#xA;         */&#xA;//        keyWorldsView.addTextChangedListener(new TextWatcher() {&#xA;//&#xA;//            @Override&#xA;//            public void afterTextChanged(Editable arg0) {&#xA;//&#xA;//            }&#xA;//&#xA;//            @Override&#xA;//            public void beforeTextChanged(CharSequence arg0, int arg1,&#xA;//                                          int arg2, int arg3) {&#xA;//&#xA;//            }&#xA;//&#xA;//            @Override&#xA;//            public void onTextChanged(CharSequence cs, int arg1, int arg2,&#xA;//                                      int arg3) {&#xA;//                if (cs.length() &amp;lt;= 0) {&#xA;//                    return;&#xA;//                }&#xA;//                String city = ((EditText) findViewById(R.id.city)).getText()&#xA;//                        .toString();&#xA;//                /**&#xA;//                 * 使用建议搜索服务获取建议列表，结果在onSuggestionResult()中更新&#xA;//                 */&#xA;//                mSuggestionSearch&#xA;//                        .requestSuggestion((new SuggestionSearchOption())&#xA;//                                .keyword(cs.toString()).city(city));&#xA;//            }&#xA;//        });&#xA;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onPause() {&#xA;        super.onPause();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onResume() {&#xA;        super.onResume();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onDestroy() {&#xA;        mPoiSearch.destroy();&#xA;        mSuggestionSearch.destroy();&#xA;        super.onDestroy();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onSaveInstanceState(Bundle outState) {&#xA;        super.onSaveInstanceState(outState);&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onRestoreInstanceState(Bundle savedInstanceState) {&#xA;        super.onRestoreInstanceState(savedInstanceState);&#xA;    }&#xA;&#xA;    /**&#xA;     * 影响搜索按钮点击事件&#xA;     */&#xA;    public void searchButtonProcess(String city, String searchkey) {&#xA;//        EditText editCity = (EditText) findViewById(R.id.city);&#xA;//        EditText editSearchKey = (EditText) findViewById(R.id.searchkey);&#xA;//        mPoiSearch.searchInCity((new PoiCitySearchOption())&#xA;//                .city(editCity.getText().toString())&#xA;//                .keyword(editSearchKey.getText().toString())&#xA;//                .pageNum(load_Index));&#xA;            // 城市内检索&#xA;            mPoiSearch.searchInCity((new PoiCitySearchOption())&#xA;                    .city(city)&#xA;                    .keyword(searchkey)&#xA;                    .pageNum(load_Index));&#xA;            // 范围内检索&#xA;            mPoiSearch.searchInBound(...);&#xA;            // 周边检索&#xA;            mPoiSearch.searchNearby(...);&#xA;            // POI 详情检索&#xA;            mPoiSearch.searchPoiDetail(...);&#xA;    }&#xA;&#xA;    public void goToNextPage(View v) {&#xA;        load_Index++;&#xA;        // searchButtonProcess();&#xA;    }&#xA;&#xA;    public void onGetPoiResult(PoiResult result) {&#xA;        if (result == null&#xA;                || result.error == SearchResult.ERRORNO.RESULT_NOT_FOUND) {&#xA;            Toast.makeText(PoiSearchActivity.this, &amp;quot;未找到结果&amp;quot;, Toast.LENGTH_LONG)&#xA;                    .show();&#xA;            return;&#xA;        }&#xA;        if (result.error == SearchResult.ERRORNO.NO_ERROR) {&#xA;            mBaiduMap.clear();&#xA;            PoiOverlay overlay = new MyPoiOverlay(mBaiduMap);&#xA;            mBaiduMap.setOnMarkerClickListener(overlay);&#xA;            overlay.setData(result);&#xA;            overlay.addToMap();&#xA;            overlay.zoomToSpan();&#xA;            return;&#xA;        }&#xA;        if (result.error == SearchResult.ERRORNO.AMBIGUOUS_KEYWORD) {&#xA;&#xA;            // 当输入关键字在本市没有找到，但在其他城市找到时，返回包含该关键字信息的城市列表&#xA;            String strInfo = &amp;quot;在&amp;quot;;&#xA;            for (CityInfo cityInfo : result.getSuggestCityList()) {&#xA;                strInfo += cityInfo.city;&#xA;                strInfo += &amp;quot;,&amp;quot;;&#xA;            }&#xA;            strInfo += &amp;quot;找到结果&amp;quot;;&#xA;            Toast.makeText(PoiSearchActivity.this, strInfo, Toast.LENGTH_LONG)&#xA;                    .show();&#xA;        }&#xA;    }&#xA;&#xA;    public void onGetPoiDetailResult(PoiDetailResult result) {&#xA;        if (result.error != SearchResult.ERRORNO.NO_ERROR) {&#xA;            Toast.makeText(PoiSearchActivity.this, &amp;quot;抱歉，未找到结果&amp;quot;, Toast.LENGTH_SHORT)&#xA;                    .show();&#xA;        } else {&#xA;            Toast.makeText(PoiSearchActivity.this, result.getName() + &amp;quot;: &amp;quot; + result.getAddress(), Toast.LENGTH_SHORT)&#xA;                    .show();&#xA;        }&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onGetSuggestionResult(SuggestionResult res) {&#xA;        if (res == null || res.getAllSuggestions() == null) {&#xA;            return;&#xA;        }&#xA;        sugAdapter.clear();&#xA;        for (SuggestionResult.SuggestionInfo info : res.getAllSuggestions()) {&#xA;            if (info.key != null)&#xA;                sugAdapter.add(info.key);&#xA;        }&#xA;        sugAdapter.notifyDataSetChanged();&#xA;    }&#xA;&#xA;    private class MyPoiOverlay extends PoiOverlay {&#xA;&#xA;        public MyPoiOverlay(BaiduMap baiduMap) {&#xA;            super(baiduMap);&#xA;        }&#xA;&#xA;        @Override&#xA;        public boolean onPoiClick(int index) {&#xA;            super.onPoiClick(index);&#xA;            PoiInfo poi = getPoiResult().getAllPoi().get(index);&#xA;            // if (poi.hasCaterDetails) {&#xA;            mPoiSearch.searchPoiDetail((new PoiDetailSearchOption())&#xA;                    .poiUid(poi.uid));&#xA;            // }&#xA;            return true;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充, 自定义位置图标及显示位置数量&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;百度地图在新版本中开放了 OverlayManager 和 PoiOverlay &#xA;&#xA;自V3.6.0起，原内置覆盖物相关类代码开源&#xA;&#xA;（OverlayManager/PoiOverlay/TransitRouteOverlay/WalkingRouteOverlay/BusLineOverlay）&#xA;&#xA;源码可在BaiduMapsApiDemo工程中找到。&#xA;&#xA;// ...&#xA;&#xA;新增的聚合功能和内置覆盖物源码包com.baidu.mapapi.overlayutil开放&#xA;&#xA;包括: &#xA;&#xA;    BusLineOverlay, &#xA;    DrivingRouteOverlay, &#xA;    OverlayManager, &#xA;    PoiOverlay, &#xA;    TransitRouteOverlay, &#xA;    WalkingRouteOverlay，&#xA;&#xA;开发者使用到这些功能可从官方Demo中src目录下获取源码，SDK中的jar包将不再包含这部分。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class PoiOverlay extends OverlayManager {&#xA;&#xA;    // 设置最大显示兴趣点数量&#xA;    private static final int MAX_POI_SIZE = 1;&#xA;&#xA;    @Override&#xA;    public final List&amp;lt;OverlayOptions&amp;gt; getOverlayOptions() {&#xA;        if (mPoiResult == null || mPoiResult.getAllPoi() == null) {&#xA;            return null;&#xA;        }&#xA;        List&amp;lt;OverlayOptions&amp;gt; markerList = new ArrayList&amp;lt;OverlayOptions&amp;gt;();&#xA;        int markerSize = 0;&#xA;        for (int i = 0; i &amp;lt; mPoiResult.getAllPoi().size()&#xA;                &amp;amp;&amp;amp; markerSize &amp;lt; MAX_POI_SIZE; i++) {&#xA;            if (mPoiResult.getAllPoi().get(i).location == null) {&#xA;                continue;&#xA;            }&#xA;            markerSize++;&#xA;            Bundle bundle = new Bundle();&#xA;            bundle.putInt(&amp;quot;index&amp;quot;, i);&#xA;// 默认设置&#xA;//            markerList.add(new MarkerOptions()&#xA;//                    .icon(BitmapDescriptorFactory.fromAssetWithDpi(&amp;quot;Icon_mark&amp;quot;&#xA;//                            + markerSize + &amp;quot;.png&amp;quot;)).extraInfo(bundle)&#xA;//                    .position(mPoiResult.getAllPoi().get(i).location));&#xA;// 自定义设置&#xA;            markerList.add(new MarkerOptions()&#xA;                    .icon(BitmapDescriptorFactory.fromResource(R.drawable.default_icon_baidu)).extraInfo(bundle)&#xA;                    .position(mPoiResult.getAllPoi().get(i).location));&#xA;&#xA;        }&#xA;        return markerList;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之锁和线程安全的Map</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E9%94%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84Map/</link>
      <pubDate>2015-07-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Golang的包sync实现了两种类型的锁： sync.Mutex 和 sync.RWMutex。&#xA;&#xA;通过阅读源代码我们可以知道sync.RWMutex是基于sync.Mutex实现的，其中的只读锁的实现使用类似引用计数的方式。&#xA;&#xA;对于任意 sync.Mutex 或 sync.RWMutex 变量l。&#xA;         如果 n &amp;lt; m ，那么第n次 l.Unlock() 调用在第 m次 l.Lock()调用返回前发生。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下面代码来自：&#xA;// https://github.com/astaxie/beego/blob/master/safemap.go&#xA;// 用读写锁实现了安全的map&#xA;package beego&#xA;&#xA;import (&#xA;    &amp;quot;sync&amp;quot;&#xA;)&#xA;&#xA;type BeeMap struct {&#xA;    lock *sync.RWMutex&#xA;    bm   map[interface{}]interface{}&#xA;}&#xA;&#xA;func NewBeeMap() *BeeMap {&#xA;    return &amp;amp;BeeMap{&#xA;        lock: new(sync.RWMutex),&#xA;        bm:   make(map[interface{}]interface{}),&#xA;    }&#xA;}&#xA;&#xA;//Get from maps return the k&#39;s value&#xA;func (m *BeeMap) Get(k interface{}) interface{} {&#xA;    m.lock.RLock()&#xA;    defer m.lock.RUnlock()&#xA;    if val, ok := m.bm[k]; ok {&#xA;        return val&#xA;    }&#xA;    return nil&#xA;}&#xA;&#xA;// Maps the given key and value. Returns false&#xA;// if the key is already in the map and changes nothing.&#xA;func (m *BeeMap) Set(k interface{}, v interface{}) bool {&#xA;    m.lock.Lock()&#xA;    defer m.lock.Unlock()&#xA;    if val, ok := m.bm[k]; !ok {&#xA;        m.bm[k] = v&#xA;    } else if val != v {&#xA;        m.bm[k] = v&#xA;    } else {&#xA;        return false&#xA;    }&#xA;    return true&#xA;}&#xA;&#xA;// Returns true if k is exist in the map.&#xA;func (m *BeeMap) Check(k interface{}) bool {&#xA;    m.lock.RLock()&#xA;    defer m.lock.RUnlock()&#xA;    if _, ok := m.bm[k]; !ok {&#xA;        return false&#xA;    }&#xA;    return true&#xA;}&#xA;&#xA;func (m *BeeMap) Delete(k interface{}) {&#xA;    m.lock.Lock()&#xA;    defer m.lock.Unlock()&#xA;    delete(m.bm, k)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之传参和传引用介绍</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E4%BC%A0%E5%8F%82%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-07-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;对Golang传参和传引用的一些试验&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;传参之MAP&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;m := make(map[string]string)&#xA;fmt.Println(&amp;quot;src&amp;quot;, m)&#xA;change(m)&#xA;fmt.Println(&amp;quot;-&amp;gt;&amp;quot;, m)&#xA;&#xA;// 改变MAP&#xA;func change(m map[string]string) {&#xA;    m[&amp;quot;nljb&amp;quot;] = &amp;quot;www.nljb.net&amp;quot;&#xA;}&#xA;&#xA;// 输出&#xA;src map[]&#xA;-&amp;gt;  map[nljb:www.nljb.net]&#xA;&#xA;// 疑点&#xA;Go在传递MAP的时候通过指针或引用方式&#xA;其数据在传递到函数内修改，原数据也随之改变&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 继续证实&#xA;m := make(map[string]string)&#xA;m[&amp;quot;a&amp;quot;] = &amp;quot;b&amp;quot;&#xA;fmt.Println(m)&#xA;change(m)&#xA;fmt.Println(m)&#xA;&#xA;// 改变&#xA;func change(m map[string]string) {&#xA;    // 情况一&#xA;    // m = nil  &#xA;    // 情况二&#xA;    m[&amp;quot;x&amp;quot;] = &amp;quot;n&amp;quot;&#xA;}&#xA;&#xA;// 输出&#xA;情况一：&#xA;    map[a:b]&#xA;    map[a:b]&#xA;情况二：&#xA;    map[a:b]&#xA;    map[a:b x:n]&#xA;&#xA;// 理解&#xA;MAP也是按值传递的，因为将传递过来的M赋值空不会对原数据有任何影响&#xA;修改传递的数据，元数据也随之改变使用M里面存储的是指向目标数据的指针&#xA;&#xA;// 不解   &#xA;在MAP的时候并没有告诉TA初始化值的数量，所以应该没有默认初始化值&#xA;但是为什么在传递值中增加KEY的时候，原数据也跟着改变 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;传参之Slice&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s := make([]string, 1)&#xA;fmt.Println(&amp;quot;src&amp;quot;, s)&#xA;change(s)&#xA;fmt.Println(&amp;quot;-&amp;gt;&amp;quot;, s)&#xA;&#xA;// 改变Slice&#xA;func change(s []string) {&#xA;    s[0] = &amp;quot;www.nljb.net&amp;quot;&#xA;}&#xA;&#xA;// 疑点&#xA;Go在传递Slice的时候通过指针或引用方式&#xA;其数据在传递到函数内修改，原数据也随之改变&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 继续证实&#xA;a := []int{1, 2, 3, 0}&#xA;fmt.Println(a)&#xA;change(a)&#xA;fmt.Println(a)&#xA;&#xA;// 改变&#xA;func change(data []int) {&#xA;    // 情况一&#xA;    data = nil&#xA;    // 情况二&#xA;    // data[0] = 5&#xA;}&#xA;&#xA;// 输出&#xA;情况一：&#xA;    [1 2 3 0]&#xA;    [1 2 3 0]&#xA;情况二：&#xA;    [1 2 3 0]&#xA;    [5 2 3 0]&#xA;&#xA;// 解说&#xA;在将Slice修改为空的时候原数据并没有受到影响&#xA;但是在修改里面的数据的时候，原数据却改变了&#xA;&#xA;// 理解&#xA;Slice是按值传递的&#xA;Slice中的Values是指针,可以修改指向内容的值&#xA;Slice只能修改Values指向的数据, 其他都不能修改&#xA;&#xA;// 空想&#xA;有时候会想到，那传递的是值，为什么我添加数据的时候&#xA;原数据也跟着改变了，其实make的时候已经初始化了所有的值 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之表单验证框架</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E6%A1%86%E6%9E%B6/</link>
      <pubDate>2015-07-28 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android Saripaar&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;下载地址：https://github.com/ragunathjawahar/android-saripaar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Saripaar特性：&#xA;&#xA;    使用Annotation标注的生命性规则&#xA;    可扩展性&#xA;    支持同步/异步验证，无线担心线程问题&#xA;    使用简单，只需下载 jar包，放到项目的libs目录下即可&#xA;    使用规则来隔离验证逻辑&#xA;    兼容其他Annotation框架，例如  AndroidAnnotations, RoboGuice,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用android-saripaar提供的Annotation来标注验证规则&#xA;&#xA;@Required(order = 1)&#xA;@Email(order = 2)&#xA;private EditText emailEditText;&#xA;&#xA;@Password(order = 3)&#xA;@TextRule(order = 4, minLength = 6, message = &amp;quot;Enter at least 6 characters.&amp;quot;)&#xA;private EditText passwordEditText;&#xA;&#xA;@ConfirmPassword(order = 5)&#xA;private EditText confirmPasswordEditText;&#xA;&#xA;@Checked(order = 6, message = &amp;quot;You must agree to the terms.&amp;quot;)&#xA;private CheckBox iAgreeCheckBox;&#xA;&#xA;// 每个规则都是顾名思义的，其中 order 属性 是必须的，用来告诉Saripaar这些输入规则的验证顺序。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 初始化一个Validator&#xA;public void onCreate() {&#xA;    super.onCreate();&#xA;    // Code…&#xA;&#xA;    validator = new Validator(this);&#xA;    validator.setValidationListener(this);&#xA;&#xA;    // More code…&#xA;}&#xA;&#xA;// 需要一个Validator 和 ValidationListener。后者用来接收验证结果通知。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 实现一个ValidationListener&#xA;public class RegistrationActivity implements ValidationListener {&#xA;&#xA;    public void onValidationSucceeded() {&#xA;        Toast.makeText(this, &amp;quot;Yay! we got it right!&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;    }&#xA;&#xA;    public void onValidationFailed(View failedView, Rule&amp;lt;?&amp;gt; failedRule) {&#xA;        String message = failedRule.getFailureMessage();&#xA;&#xA;        if (failedView instanceof EditText) {&#xA;            failedView.requestFocus();&#xA;            ((EditText) failedView).setError(message);&#xA;        } else {&#xA;            Toast.makeText(this, message, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&#xA;// onValidationSucceeded() - 当所有验证规则都通过时调用该函数&#xA;// onValidationFailed(View, Rule&amp;lt;?&amp;gt;) - 当验证失败时调用该函数，View为失败的控件，Rule为具体的规则.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 发起验证 &#xA;registerButton.setOnClickListener(new OnClickListener() {&#xA;    public void onClick(View v) {&#xA;        validator.validate();&#xA;    }&#xA;});&#xA;&#xA;// Validator.validate() 发起验证，并通过 ValidationListener 来通知验证结果。&#xA;// 调用函数 Validator.validateAsync()  可以在一个AsyncTask中发起验证。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之从其它线程访问UI线程</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E4%BB%8E%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AEUI%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>2015-07-28 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;从其它线程访问UI线程&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解决这个问题有几种方法&#xA;1, Activity.runOnUiThread (Runnable)&#xA;2, View.post (Runable)&#xA;3, View.postDelayed (Runable,long)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// UI线程操作注意事项&#xA;1, 不要阻塞UI线程&#xA;2, 不要在UI线程之外访问Android的UI线程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;View.post&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过View.post方法更新UI线程数据&#xA;public void onClick(View v) {&#xA;    new Thread(new Runnable() {&#xA;        @Override&#xA;        public void run() {&#xA;            final Bitmap bitmap = loadImageFromNetwork(&amp;quot;http://www.baidu.com/logo.png&amp;quot;);&#xA;            mImageView.post(new Runnable() {&#xA;                @Override&#xA;                public void run() {&#xA;                    mImageView.setImageBitmap(bitmap);&#xA;                }&#xA;            });&#xA;        }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意事项&#xA;随着操作变得越来越复杂，这类代码也会变得很复杂, 很难维护, 为了用工作线程完成复杂的交互处理&#xA;可以考虑在工作线程中使用Handler来处理UI线程分发过来的消息&#xA;当然最好的解决方案也许是, 继承使用异步任务类AsyncTask来处理UI线程分发过来的消息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;异步任务类&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;异步任务类(AsyncTask)能够适当地，简单地用于UI线程，这个类不需要操作线程(Thread)就可以完成后台任务并将结果返回UI&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;异步任务的定义：&#xA;        一个在后台线程上运行，而其结果实在UI线程上发布的任务，异步任务必须被继承使用&#xA;        子类至少覆盖一个方法(doInBackground), 但也常覆盖应外一个方法(onPostExecute)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一个异步任务要用到以下三个泛型类型:&#xA;        Params  : 启动任务执行的输入参数&#xA;        Progress: 后台任务执行的百分比&#xA;        Result  : 后台计算的结果类型&#xA;        // Void : 当一个类型不被使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// AsyncTask 具体使用方法请看 AsyncTask 篇&#xA;private calss MyTask extends AsyncTask&amp;lt;Void, Void, Void&amp;gt; { ... }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 异步方式下载任务&#xA;public void onClick(View v) {&#xA;    new DownloadImageTask().execute(&amp;quot;http://www.baidu.com/image.png&amp;quot;);&#xA;}&#xA;&#xA;// ...&#xA;private class DownloadImageTask extends AsyncTask&amp;lt;String, Void, Bitmap&amp;gt; {&#xA;    // ...&#xA;    protected Bitmap doInBackground(String... urls) {&#xA;        return loadImageFromNetwork(urls[0])&#xA;    }&#xA;    // ...&#xA;    protected void onPostExecute(Bitmap result) {&#xA;        mImageView.setImageBitmap(result)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之网络框架volley和async的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6volley%E5%92%8Casync%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-07-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;volley和async&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;什么是Voley?汉语译过来就是:齐射;迸发的意思。&#xA;&#xA;可以看出来,Voley特别适合数据量 不大但是通信频繁的场景。&#xA;&#xA;Voley是GoogleI/O2013上Google官方发布的一款Android平台上的网络通信库。&#xA;&#xA;以前的网络请求,要考虑开启线程、内存泄漏、性能等等复杂的问题。&#xA;&#xA;但是Voley框架已 经帮我们把这些问题处理好了,对外提供了相应的完善的请求API,我们只需要按照要求使 用即可。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Async-http是一款国外的开源框架,作者是loopj。是基于ApacheHtpClient库的。&#xA;&#xA;可以方便快速高效的进行网络数据请求和发送,文件下载和上传。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;也就是，网络小数据请求使用Voley，当下载或上传文件时使用Async-http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：&#xA;&#xA;使用JsonObjectRequest或继承自JsonObjectRequest类的对象提交一个post请求时&#xA;&#xA;如果有参数需要提交,就必须以JSONObject的json串方式提交.&#xA;&#xA;否则通过重写getParams()方法的方式提交不管用，getParams()方法中提交post参数只适用于Request对象。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;volley&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * &#xA; * Volley是Android平台网络通信库：更快。更简单。更健壮 &#xA; * &#xA; * volley提供的功能： &#xA; * 1.JSON、图片（异步） &#xA; * 2.网络请求的排序&#xA; * 3.网络请求的优先级处理 &#xA; * 4.缓存 &#xA; * 5.多级别的取消请求&#xA; * 6.与Activity生命周期联动&#xA; * &#xA; * 获取Volley git clone&#xA; * https://android.googlesource.com/platform/frameworks/volley&#xA; * &#xA; */&#xA;&#xA;public class MainActivity extends Activity {&#xA;&#xA;    private ImageView iv1;&#xA;    private NetworkImageView iv2;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        init();&#xA;        getJSONVolley();&#xA;    }&#xA;&#xA;    public void init() {&#xA;        iv1 = (ImageView) findViewById(R.id.iv);&#xA;        iv2 = (NetworkImageView) findViewById(R.id.imageView1);&#xA;        loadImageVolley();&#xA;        NetWorkImageViewVolley();&#xA;    }&#xA;&#xA;    // 获取json字符串&#xA;    public void getJSONVolley() {&#xA;        RequestQueue requestQueue = Volley.newRequestQueue(this);&#xA;        String JSONDateUrl = &amp;quot;http://www.wwtliu.com/jsondata.html&amp;quot;;&#xA;        JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(&#xA;                Request.Method.GET, JSONDateUrl, null,&#xA;                new Response.Listener&amp;lt;JSONObject&amp;gt;() {&#xA;                    public void onResponse(JSONObject response) {&#xA;                        System.out.println(&amp;quot;response=&amp;quot; + response);&#xA;                    }&#xA;                }, new Response.ErrorListener() {&#xA;                    public void onErrorResponse(&#xA;                            com.android.volley.VolleyError arg0) {&#xA;                        System.out.println(&amp;quot;对不起，有问题&amp;quot;);&#xA;                    }&#xA;                });&#xA;        requestQueue.add(jsonObjectRequest);&#xA;    }&#xA;&#xA;    // http://localhost/lesson-img.png&#xA;    public void loadImageVolley() {&#xA;        String imageurl = &amp;quot;http://10.0.0.52/lesson-img.png&amp;quot;;&#xA;        RequestQueue requestQueue = Volley.newRequestQueue(this);&#xA;        final LruCache&amp;lt;String, Bitmap&amp;gt; lurcache = new LruCache&amp;lt;String, Bitmap&amp;gt;(&#xA;                20);&#xA;        ImageCache imageCache = new ImageCache() {&#xA;&#xA;            @Override&#xA;            public void putBitmap(String key, Bitmap value) {&#xA;                lurcache.put(key, value);&#xA;            }&#xA;&#xA;            @Override&#xA;            public Bitmap getBitmap(String key) {&#xA;&#xA;                return lurcache.get(key);&#xA;            }&#xA;        };&#xA;        ImageLoader imageLoader = new ImageLoader(requestQueue, imageCache);&#xA;        ImageListener listener = imageLoader.getImageListener(iv1,&#xA;                R.drawable.ic_launcher, R.drawable.ic_launcher);&#xA;        imageLoader.get(imageurl, listener);&#xA;    }&#xA;&#xA;    public void NetWorkImageViewVolley(){&#xA;        String imageUrl = &amp;quot;http://10.0.0.52/lesson-img.png&amp;quot;;&#xA;        RequestQueue requestQueue = Volley.newRequestQueue(this);&#xA;        final LruCache&amp;lt;String, Bitmap&amp;gt; lruCache = new LruCache&amp;lt;String, Bitmap&amp;gt;(20);&#xA;        ImageCache imageCache = new ImageCache() {&#xA;&#xA;            @Override&#xA;            public void putBitmap(String key, Bitmap value) {&#xA;                lruCache.put(key, value);&#xA;            }&#xA;&#xA;            @Override&#xA;            public Bitmap getBitmap(String key) {&#xA;                return lruCache.get(key);&#xA;            }&#xA;        };&#xA;        ImageLoader imageLoader = new ImageLoader(requestQueue, imageCache);&#xA;        iv2.setTag(&amp;quot;url&amp;quot;);&#xA;        iv2.setImageUrl(imageUrl, imageLoader);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// MyApplication.java&#xA;public class MyApplication extends Application {&#xA;    public static RequestQueue queue;&#xA;&#xA;    @Override&#xA;    public void onCreate() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onCreate();&#xA;        queue = Volley.newRequestQueue(getApplicationContext());&#xA;    }&#xA;&#xA;    public static RequestQueue getHttpQueue() {&#xA;        return queue;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * 1、Volley的Get和Post请求方式的使用&#xA; * &#xA; * 2、Volley的网络请求队列建立和取消队列请求及Activity周期关联&#xA; * &#xA; * @author Administrator&#xA; * &#xA; */&#xA;&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        // volley_Get();&#xA;        volley_Post();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onStop() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onStop();&#xA;        MyApplication.getHttpQueue().cancelAll(&amp;quot;abcPost&amp;quot;);&#xA;        MyApplication.getHttpQueue().cancelAll(&amp;quot;abcGet&amp;quot;);&#xA;    }&#xA;&#xA;    private void volley_Post() {&#xA;        String url = &amp;quot;http://apis.juhe.cn/mobile/get?&amp;quot;;&#xA;        StringRequest request = new StringRequest(Method.POST, url,&#xA;                new Listener&amp;lt;String&amp;gt;() {&#xA;&#xA;                    @Override&#xA;                    public void onResponse(String arg0) {&#xA;                        Toast.makeText(MainActivity.this, arg0,&#xA;                                Toast.LENGTH_LONG).show();&#xA;                    }&#xA;                }, new Response.ErrorListener() {&#xA;&#xA;                    @Override&#xA;                    public void onErrorResponse(VolleyError arg0) {&#xA;                        Toast.makeText(MainActivity.this, &amp;quot;网络请求失败&amp;quot;,&#xA;                                Toast.LENGTH_LONG).show();&#xA;                    }&#xA;                }) {&#xA;            @Override&#xA;            protected Map&amp;lt;String, String&amp;gt; getParams() throws AuthFailureError {&#xA;                HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();&#xA;                map.put(&amp;quot;phone&amp;quot;, &amp;quot;13666666666&amp;quot;);&#xA;                map.put(&amp;quot;key&amp;quot;, &amp;quot;335adcc4e891ba4e4be6d7534fd54c5d&amp;quot;);&#xA;                return map;&#xA;            }&#xA;        };&#xA;        request.setTag(&amp;quot;abcPost&amp;quot;);&#xA;        MyApplication.getHttpQueue().add(request);&#xA;    }&#xA;&#xA;    private void volley_Get() {&#xA;        String url = &amp;quot;http://apis.juhe.cn/mobile/get?phone=13666666666&amp;amp;key=335adcc4e891ba4e4be6d7534fd54c5d&amp;quot;;&#xA;        StringRequest request = new StringRequest(Method.GET, url,&#xA;                new Listener&amp;lt;String&amp;gt;() {&#xA;&#xA;                    @Override&#xA;                    public void onResponse(String arg0) {&#xA;                        Toast.makeText(MainActivity.this, arg0,&#xA;                                Toast.LENGTH_LONG).show();&#xA;                    }&#xA;                }, new Response.ErrorListener() {&#xA;&#xA;                    @Override&#xA;                    public void onErrorResponse(VolleyError arg0) {&#xA;                        Toast.makeText(MainActivity.this, &amp;quot;网络请求失败&amp;quot;,&#xA;                                Toast.LENGTH_LONG).show();&#xA;                    }&#xA;                });&#xA;        request.setTag(&amp;quot;abcGet&amp;quot;);&#xA;        MyApplication.getHttpQueue().add(request);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;async&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public abstract class NetCallBack extends AsyncHttpResponseHandler {&#xA;&#xA;    @Override&#xA;    public void onStart() {&#xA;        Log.i(&amp;quot;info&amp;quot;, &amp;quot;请求开始，弹出进度条框&amp;quot;);&#xA;        super.onStart();&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onSuccess(String arg0) {&#xA;        Log.i(&amp;quot;info&amp;quot;, &amp;quot;请求成功，隐藏进度条框：&amp;quot; + arg0);&#xA;        onMySuccess(arg0);&#xA;        super.onSuccess(arg0);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onFailure(Throwable arg0) {&#xA;        Log.i(&amp;quot;info&amp;quot;, &amp;quot;请求失败，隐藏进度条框：&amp;quot; + arg0);&#xA;        super.onFailure(arg0);&#xA;        onMyFailure(arg0);&#xA;    }&#xA;&#xA;    public abstract void onMySuccess(String result);&#xA;&#xA;    public abstract void onMyFailure(Throwable arg0);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class RequestUtils {&#xA;    public static AsyncHttpClient client = new AsyncHttpClient();&#xA;&#xA;    public static void ClientGet(String url, NetCallBack cb) {&#xA;        client.get(url, cb);&#xA;    }&#xA;&#xA;    public static void ClientPost(String url, RequestParams params,&#xA;            NetCallBack cb) {&#xA;        client.post(url, params, cb);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * 1. Android-async-http的Get和Post请求方式的使用&#xA; * &#xA; * 2.Android-async-http回调逻辑的二次封装&#xA; * &#xA; * @author Administrator&#xA; * &#xA; */&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        // asynchttpGet();&#xA;        asynchttpPost();&#xA;    }&#xA;&#xA;    private void asynchttpPost() {&#xA;        String url = &amp;quot;http://apis.juhe.cn/mobile/get?&amp;quot;;&#xA;        RequestParams params = new RequestParams();&#xA;        params.put(&amp;quot;phone&amp;quot;, &amp;quot;13666666666&amp;quot;);&#xA;        params.put(&amp;quot;key&amp;quot;, &amp;quot;335adcc4e891ba4e4be6d7534fd54c5d&amp;quot;);&#xA;        RequestUtils.ClientPost(url, params, new NetCallBack() {&#xA;&#xA;            @Override&#xA;            public void onMySuccess(String result) {&#xA;                Toast.makeText(MainActivity.this, result, Toast.LENGTH_LONG)&#xA;                        .show();&#xA;            }&#xA;&#xA;            @Override&#xA;            public void onMyFailure(Throwable arg0) {&#xA;                Toast.makeText(MainActivity.this, &amp;quot;请求失败&amp;quot;, Toast.LENGTH_LONG)&#xA;                        .show();&#xA;            }&#xA;        });&#xA;    }&#xA;&#xA;    private void asynchttpGet() {&#xA;        AsyncHttpClient client = new AsyncHttpClient();&#xA;        String url = &amp;quot;http://apis.juhe.cn/mobile/get?phone=13666666666&amp;amp;key=335adcc4e891ba4e4be6d7534fd54c5d&amp;quot;;&#xA;        client.get(url, new AsyncHttpResponseHandler() {&#xA;            @Override&#xA;            public void onSuccess(String arg0) {&#xA;                // TODO Auto-generated method stub&#xA;                super.onSuccess(arg0);&#xA;                Toast.makeText(MainActivity.this, arg0, Toast.LENGTH_LONG)&#xA;                        .show();&#xA;            }&#xA;&#xA;            @Override&#xA;            public void onFailure(Throwable arg0) {&#xA;                Toast.makeText(MainActivity.this, &amp;quot;网络请求失败&amp;quot;, Toast.LENGTH_LONG)&#xA;                        .show();&#xA;                super.onFailure(arg0);&#xA;            }&#xA;        });&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>openSUSE之Broadwell-U的Graphics驱动方法</title>
      <link>http://www.nljb.net/default/openSUSE%E4%B9%8BBroadwell-U%E7%9A%84Graphics%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-07-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;VGA -&amp;gt; Intel Corporation Broadwell-U Integrated Graphics (&lt;a href=&#34;https://01.org/zh/linuxgraphics&#34;&gt;https://01.org/zh/linuxgraphics&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;支持列表的核显型号有Broadwell-U处理器的HD Graphics 5500/6000/6100&#xA;&#xA;Intel Graphics 驱动支持从 2014Q2 开始支持 Broadwell-U 处理器&#xA;&#xA;Intel Graphics 驱动 2014Q2 驱动安装内核要求 Linux Kernel - 3.15 +&#xA;&#xA;Intel Graphics 驱动最新 2015Q1 兼容内核 Linux Kernel - 3.19.2 &#xA;&#xA;Intel Graphics 2015Q1 兼容显卡与 2014Q2 无区别，主要是修复BUG&#xA;&#xA;openSUSE 13.1 -&amp;gt; libva info: va_getDriverName() returns -1  (3.11.6-4-desktop) (内核不匹配)&#xA;&#xA;openSUSE 13.2 -&amp;gt; 内核 (3.16.6-2-desktop) 匹配 Intel Graphics for Linux* - 2014Q3 Intel Graphics Stack Release&#xA;&#xA;源码安装一下驱动相关软件时所需配套软件几乎都可以在YAST中找到 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;安装 libva -&amp;gt; Libva - 1.4.0 升级到 Libva - 1.5.1 (./configure &amp;ndash;prefix=/usr)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/openSUSE之Broadwell-U的Graphics驱动方法/1.png&#34; alt=&#34;&#34; width=&#34;600&#34; hight=&#34;200&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;安装 -&amp;gt; xf86-video-intel - 2.99.911 升级到 xf86-video-intel - 2.99.917&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/openSUSE之Broadwell-U的Graphics驱动方法/2.png&#34; alt=&#34;&#34; width=&#34;600&#34; hight=&#34;120&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;安装 -&amp;gt; vaapi intel-driver - 1.4.0 升级到 vaapi intel-driver - 1.5.1&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/openSUSE之Broadwell-U的Graphics驱动方法/3.png&#34; alt=&#34;&#34; width=&#34;600&#34; hight=&#34;600&#34; &gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之如何安全的存储密码</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%AF%86%E7%A0%81/</link>
      <pubDate>2015-07-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;如何安全的存储密码&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;过去一段时间以来，许多网站遭遇用户密码泄漏事件，诸多社区有可能成为&#xA;下一个目标，层出不穷的类似事件给用户的网上生活造成巨大影响人人自危&#xA;因为人们往往习惯不同网站使用相同密码，所以一家暴露，全部遭殃 ...&#xA;&#xA;那么如何选择用户密码存储方案，才能避免这些陷阱呢 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;单向哈希&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;目前用得最多的密码存储方案是将明文密码做单向哈希后存储，单向哈希算法有一个特征：&#xA;    无法通过哈希后的摘要(digest)恢复原始数据，这也是单向二字的来源&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;常用的单向哈希算法包括 SHA-256, SHA-1, MD5 等&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Go语言对这三种加密算法的实现如下:&#xA;&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;crypto/md5&amp;quot;&#xA;    &amp;quot;crypto/sha1&amp;quot;&#xA;    &amp;quot;crypto/sha256&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    // crypto/sha256&#xA;    a := sha256.New()&#xA;    io.WriteString(a, &amp;quot;www.nljb.net&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%x\n&amp;quot;, a.Sum(nil))&#xA;&#xA;    // crypto/sha1&#xA;    b := sha1.New()&#xA;    io.WriteString(b, &amp;quot;www.nljb.net&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%x\n&amp;quot;, b.Sum(nil))&#xA;&#xA;    // crypto/md5&#xA;    c := md5.New()&#xA;    io.WriteString(c, &amp;quot;www.nljb.net&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%x\n&amp;quot;, c.Sum(nil))&#xA;&#xA;}&#xA;&#xA;// 输出&#xA;2ff738c6cd2bc6fc76c6b75a5caa5edccef3aca2803fa9838ad75d61aa06b6f6&#xA;fa26f560a87db90e666f8b3c6e5df413e3370b89&#xA;d30f05c05f1b6b6000bd6ce450348fc2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 单向哈希有两个特性：&#xA;1，同一个密码进行单向哈希，得到的总是唯一确定的摘要&#xA;2，计算速度快，随着技术进步，一秒钟能够完成数十亿次单向哈希计算&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 随之而来的问题&#xA;结合上面两个特点，考虑到多数人所使用的密码为常见的组合，攻击者可以将所有&#xA;密码的常见组合进行单向哈希，得到一个摘要组合，然后与数据库中的摘要进行对比&#xA;可以获得对应密码，这个摘要组合也被称为，rainbow table&#xA;因此通过单向加密之后存储的数据，和明文存储没有多大区别, 因此一旦网站的数据库泄露&#xA;所有用户的密码就大白于天下&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解决 rainbow table 问题的方案&#xA;现在比较好的网站，都会用一种叫做加盐的方式来存储密码，也就是常说的salt&#xA;他们通常的做法是先将用户输入的密码进行一次MD5加密，然后在MD5值前后加上&#xA;一些只有管理员自己知道的随机串，再进行一次MD5加密，这个随机串中可以包括&#xA;某些固定的串，比如用户名（用来保证每个用户加密使用的密钥都不一样)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;bytes&amp;quot;&#xA;    &amp;quot;crypto/md5&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    // 计算密码MD5&#xA;    c := md5.New()&#xA;    io.WriteString(c, &amp;quot;www.nljb.net&amp;quot;)&#xA;    spw := fmt.Sprintf(&amp;quot;%x\n&amp;quot;, c.Sum(nil))&#xA;&#xA;    // 指定两个(salt)&#xA;    salt1 := &amp;quot;@#$%&amp;quot;&#xA;    salt2 := &amp;quot;^&amp;amp;*()&amp;quot;&#xA;&#xA;    // 拼接密码MD5&#xA;    buf := bytes.NewBufferString(&amp;quot;&amp;quot;)&#xA;&#xA;    // 拼接密码&#xA;    io.WriteString(buf, salt1)&#xA;    io.WriteString(buf, spw)&#xA;    io.WriteString(buf, salt2)&#xA;&#xA;    // 拼接密码计算MD5&#xA;    t := md5.New()&#xA;    io.WriteString(t, buf.String())&#xA;&#xA;    // 输出&#xA;    fmt.Printf(&amp;quot;%x\n&amp;quot;, t.Sum(nil))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 针对 rainbow table 这一类方案有一个特点&#xA;算法中都有个因子，用于指明计算密码摘要所需要的资源和时间&#xA;也就是计算强度，计算强度越大，攻击者建立rainbow table越困难&#xA;以至于不可继续&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;这里推荐scrypt方案，scrypt是由著名的FerrBSD黑客Colin Percival&#xA;为他的备份服务Tarsnap开发的.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 获取地址&#xA;https://code.google.com/p/go/source/browse/scrypt?repo=crypto&#xA;&#xA;// 该方法可以获取唯一的相应密码值，这是目前为止最难破解的&#xA;dk := scrypt.Key([]byte(&amp;quot;www.nljb.net&amp;quot;), []byte(salt), 16384, 8, 1, 32)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之JSON处理器FastJson</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BJSON%E5%A4%84%E7%90%86%E5%99%A8FastJson/</link>
      <pubDate>2015-07-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FastJson&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;fastjson 是一个性能很好的 Java 语言实现的 JSON 解析器和生成器，来自阿里巴巴的工程师开发&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;主要特点：&#xA;&#xA;快速FAST (比其它任何基于Java的解析器和生成器更快，包括jackson）&#xA;强大（支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum）&#xA;零依赖（没有依赖其它任何类库除了JDK）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/alibaba/fastjson&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import com.alibaba.fastjson.JSON;&#xA;&#xA;Group group = new Group();&#xA;group.setId(0L);&#xA;group.setName(&amp;quot;admin&amp;quot;);&#xA;&#xA;User guestUser = new User();&#xA;guestUser.setId(2L);&#xA;guestUser.setName(&amp;quot;guest&amp;quot;);&#xA;&#xA;User rootUser = new User();&#xA;rootUser.setId(3L);&#xA;rootUser.setName(&amp;quot;root&amp;quot;);&#xA;&#xA;group.getUsers().add(guestUser);&#xA;group.getUsers().add(rootUser); &#xA;String jsonString = JSON.toJSONString(group); &#xA;System.out.println(jsonString);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android Data Binding Library</title>
      <link>http://www.nljb.net/default/Android-Data-Binding-Library/</link>
      <pubDate>2015-07-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android Data Binding Library&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Data Binding即数据绑定,Data Binding 库实现在布局文件中实现数据绑定申明&#xA;使数据的变化引起视图的自动更新，减少了逻辑代码，在Android中可以很方便的实现MVVM的开发模式。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;了解MVVM之前，我们先简单说一下MVC、MVP模式。&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MVC是Model(模型)---View(视图)---(Controller)控制器的缩写&#xA;它用一种将业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面&#xA;在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。&#xA;将系统进行MVC分层的核心思路就是分离组件，降低组件耦合性，组件独立演化。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MVP是Model--View--Presenter的缩写，MVP与MVC的主要区别是在MVP中View并不直接使用Model&#xA;它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部&#xA;而在MVC中View会从直接Model中读取数据而不是通过 Controller。&#xA;模型与视图完全分离，我们可以修改视图而不影响模型，可以更高效地使用模型，因为所有的交互在Presenter里面。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;MVVM&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MVVM是Model-View-ViewModel的缩写,Model提供数据、View负责显示、ViewModel负责逻辑的处理&#xA;与MVP的区别是，ViewModel与View之间采用双向绑定（data-binding）：&#xA;    View的变动，自动反映在 ViewModel，反之ViewModel的变化自动引起View的改变 。&#xA;ViewModel作为View的数据映射，通常View上有什么属性，ViewModel上也会存在相应的一个属性&#xA;这两个属性通过事件实现了双向的绑定，Data Binding Library 替我们完成了这样的绑定过程。 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 低耦合: 视图（View）可以独立于Model变化和修改&#xA;    一个ViewModel可以绑定到不同的&amp;quot;View&amp;quot;上，当View变 化的时候Model可以不变，当Model变化的时候View也可以不变。&#xA;2. 可重用性: 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。&#xA;3. 可测试: 界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;环境配置&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Data Binding 插件需要Gradle 1.3以上及Android Studio 1.3.&#xA;&#xA;配置Guide文件：添加Data binding 包路径&#xA;&#xA;buildscript {  &#xA;    repositories {  &#xA;        jcenter()  &#xA;    }  &#xA;    dependencies {  &#xA;        classpath &amp;quot;com.android.tools.build:gradle:1.3.0-beta1&amp;quot;  &#xA;        classpath &amp;quot;com.android.databinding:dataBinder:1.0-rc0&amp;quot;  &#xA;&#xA;    }  &#xA;} &#xA;&#xA;然后确保jcenter是在子项目的库列表中       &#xA;&#xA;allprojects {&#xA;   repositories {&#xA;    jcenter()&#xA;   }&#xA;}&#xA;&#xA;在android插件后面添加dataBinding插件&#xA;apply plugin: ‘com.android.application&#39;&#xA;apply plugin: &#39;com.android.databinding&#39; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;如何使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// activity_main.xml&#xA;&amp;lt;layout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:bind=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&amp;gt;&#xA;    &amp;lt;data class=&amp;quot;com.jikexueyuan.databinding.JiKeUserBinding&amp;quot;&amp;gt;&#xA;        &amp;lt;import type=&amp;quot;android.view.View&amp;quot;/&amp;gt;&#xA;        &amp;lt;import type=&amp;quot;java.util.List&amp;quot;/&amp;gt;&#xA;        &amp;lt;variable&#xA;            name=&amp;quot;user&amp;quot;&#xA;            type=&amp;quot;com.jikexueyuan.jikedatabinding.JikeUser&amp;quot;/&amp;gt;&#xA;        &amp;lt;variable&#xA;            name=&amp;quot;sex&amp;quot;&#xA;            type=&amp;quot;String&amp;quot;/&amp;gt;&#xA;        &amp;lt;variable&#xA;            name=&amp;quot;list&amp;quot;&#xA;            type=&amp;quot;List&amp;amp;lt;String&amp;gt;&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;/data&amp;gt;&#xA;    &amp;lt;LinearLayout&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;        android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:text=&amp;quot;@{user.name}&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:text=&amp;quot;Iwen是男人&amp;quot;&#xA;            android:visibility=&amp;quot;@{user.isMan==0?View.VISIBLE:View.GONE}&amp;quot;/&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:text=&amp;quot;@{sex}&amp;quot; /&amp;gt;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:text=&amp;quot;@{list[1]}&amp;quot; /&amp;gt;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:text=&amp;quot;@{user.isMan==0?@string/man:@string/woman}&amp;quot;&#xA;            /&amp;gt;&#xA;        &amp;lt;include&#xA;            layout=&amp;quot;@layout/phone_layout&amp;quot;&#xA;            bind:user=&amp;quot;@{user}&amp;quot;/&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&amp;lt;/layout&amp;gt;&#xA;&#xA;// phone_layout.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;layout&amp;gt;&#xA;    &amp;lt;data&amp;gt;&#xA;        &amp;lt;variable&#xA;            name=&amp;quot;user&amp;quot;&#xA;            type=&amp;quot;com.jikexueyuan.jikedatabinding.JikeUser&amp;quot;/&amp;gt;&#xA;    &amp;lt;/data&amp;gt;&#xA;    &amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:text=&amp;quot;@{user.phone}&amp;quot;/&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&amp;lt;/layout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// MainActivity.java&#xA;public class MainActivity extends AppCompatActivity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        //setContentView(R.layout.activity_main);&#xA;        JiKeUserBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);&#xA;        JikeUser user = new JikeUser();&#xA;        user.name = &amp;quot;Iwen&amp;quot;;&#xA;        user.phone = &amp;quot;110&amp;quot;;&#xA;        user.isMan=1;&#xA;&#xA;        binding.setSex(&amp;quot;男&amp;quot;);&#xA;        binding.setUser(user);&#xA;&#xA;        List&amp;lt;String&amp;gt; mlist=new ArrayList&amp;lt;&amp;gt;();&#xA;        mlist.add(&amp;quot;eoeAndroid&amp;quot;);&#xA;        mlist.add(&amp;quot;极客学院&amp;quot;);&#xA;        mlist.add(&amp;quot;Iwen&amp;quot;);&#xA;&#xA;        binding.setList(mlist);&#xA;&#xA;    }&#xA;&#xA;}&#xA;&#xA;// JikeUser.java&#xA;public class JikeUser {&#xA;    public String name;&#xA;    public String phone;&#xA;    public int isMan;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之各分辨率定义的图片规格</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%90%84%E5%88%86%E8%BE%A8%E7%8E%87%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9B%BE%E7%89%87%E8%A7%84%E6%A0%BC/</link>
      <pubDate>2015-07-21 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;各种规格总结&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 首先阐释一些术语和概念&#xA;&#xA;屏幕尺寸（screen size）: 屏幕的对角线测量。&#xA;    为了方便，Android把所有的屏幕尺寸分为了4个广义的大小：小、正常、大、更大&#xA;&#xA;屏幕密度（screen density）: 屏幕占据的物理区域所含像素的个数&#xA;    通常被称为dpi（dots per inch）即每英寸的像素点数&#xA;&#xA;分辨率（resolution）: 屏幕上物理像素的点数&#xA;    例如，有一个240px*400px的屏幕，可以理解为在这个屏幕上横着有400条线，每条线上有240个像素点&#xA;&#xA;像素（px）: 屏幕上的点&#xA;&#xA;dip(dp)：Density-independent pixel---&amp;gt;与密度无关的像素（下面将详细讲解）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;由于JPG容易失真, 在Android开发中尽量避免使用.jpg图片, 应该使用.png图片, 它采用了从LZ77派生的无损数据压缩算法.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;屏幕：尺寸5.1，分辨率1920X1080&#xA;DPI：1920^2+1080^2(v)/5.1=2202/5.1=431&#xA;&#xA;mdpi        120dpi ~ 160dpi&#xA;hdpi        160dpi ~ 240dpi&#xA;xhdpi       240dpi ~ 320dpi&#xA;xxhdpi      320dpi ~ 480dpi&#xA;xxxhdpi     480dpi ~ 640dpi&#xA;&#xA;在设计图标时：&#xA;对于五种主流像素密度（MDIP, HDPI, XHDPI, XXHDPI, XXXHDPI) &#xA;应按照(2:3:4:6:8)的比例进行缩放，(1x, 1.5x, 2x, 3x, 4x)&#xA;&#xA;例如：&#xA;尺寸为48x48dp的图标，表示在MDPI的屏幕上其尺寸应为48x48px&#xA;在HDPI的屏幕上其实际大小是MDPI的1.5倍（72x72px）… 依此类推&#xA;&#xA;字体：&#xA;对于字体的使用，官方不建议使用低于12号字体大小值&#xA;&#xA;图片内存占用：&#xA;drawable-xxhdpi 11.65M&#xA;drawable        74.97M&#xA;drawable-mhdpi  74.95M&#xA;drawable-hdpi   35.38M&#xA;在图片密度不匹配的情况下，低分辨率图片会被拉伸到高分辨率图片&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;密度陷阱&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;虽然说dp可以去除不同像素密度的问题，使得1dp在不同像素密度上面的显示效果相同，但是还是由于Android屏幕设备的多样性&#xA;&#xA;如果使用dp来作为度量单位，并不是所有的屏幕的宽度都是相同的dp长度&#xA;&#xA;比如说:&#xA;&#xA;Nexus S和Nexus One   属于hdpi      屏幕宽度是320dp&#xA;Nexus 5             属于xxhdpi        屏幕宽度是360dp&#xA;Galaxy Nexus        属于xhdpi     屏幕宽度是384dp&#xA;Nexus 6             属于xxxhdpi       屏幕宽度是410dp&#xA;&#xA;所以说，光Google自己一家的产品就已经有这么多的标准，而且屏幕宽度和像素密度没有任何关联关系&#xA;&#xA;即使我们使用dp，在320dp宽度的设备和410dp的设备上，还是会有90dp的差别。&#xA;&#xA;当然，我们尽量使用match_parent和wrap_content，尽可能少的用dp来指定控件的具体长宽&#xA;    再结合上权重，大部分的情况我们都是可以做到适配的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;此外还有一个解决办法，也就是指定所有分辨率密度对应关系&#xA;&#xA;// 下面是生成的一个320*480分辨率的文件&#xA;// 因为宽高分割之后总分数和像素数相同&#xA;// 所以x1就是1px，以此类推&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;resources&amp;gt;&amp;lt;dimen name=&amp;quot;x1&amp;quot;&amp;gt;1.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x2&amp;quot;&amp;gt;2.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x3&amp;quot;&amp;gt;3.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x4&amp;quot;&amp;gt;4.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x5&amp;quot;&amp;gt;5.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x6&amp;quot;&amp;gt;6.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x7&amp;quot;&amp;gt;7.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x8&amp;quot;&amp;gt;8.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x9&amp;quot;&amp;gt;9.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x10&amp;quot;&amp;gt;10.0px&amp;lt;/dimen&amp;gt;&#xA;...省略好多行&#xA;&amp;lt;dimen name=&amp;quot;x300&amp;quot;&amp;gt;300.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x301&amp;quot;&amp;gt;301.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x302&amp;quot;&amp;gt;302.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x303&amp;quot;&amp;gt;303.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x304&amp;quot;&amp;gt;304.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x305&amp;quot;&amp;gt;305.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x306&amp;quot;&amp;gt;306.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x307&amp;quot;&amp;gt;307.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x308&amp;quot;&amp;gt;308.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x309&amp;quot;&amp;gt;309.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x310&amp;quot;&amp;gt;310.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x311&amp;quot;&amp;gt;311.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x312&amp;quot;&amp;gt;312.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x313&amp;quot;&amp;gt;313.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x314&amp;quot;&amp;gt;314.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x315&amp;quot;&amp;gt;315.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x316&amp;quot;&amp;gt;316.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x317&amp;quot;&amp;gt;317.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x318&amp;quot;&amp;gt;318.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x319&amp;quot;&amp;gt;319.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x320&amp;quot;&amp;gt;320px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;/resources&amp;gt;&#xA;&#xA;// 那么1080*1960分辨率下是什么样子呢？&#xA;// 我们可以看下，由于1080和320是3.37倍的关系&#xA;// 所以x1=3.37px&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;resources&amp;gt;&amp;lt;dimen name=&amp;quot;x1&amp;quot;&amp;gt;3.37px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x2&amp;quot;&amp;gt;6.75px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x3&amp;quot;&amp;gt;10.12px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x4&amp;quot;&amp;gt;13.5px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x5&amp;quot;&amp;gt;16.87px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x6&amp;quot;&amp;gt;20.25px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x7&amp;quot;&amp;gt;23.62px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x8&amp;quot;&amp;gt;27.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x9&amp;quot;&amp;gt;30.37px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x10&amp;quot;&amp;gt;33.75px&amp;lt;/dimen&amp;gt;&#xA;...省略好多行&#xA;&amp;lt;dimen name=&amp;quot;x300&amp;quot;&amp;gt;1012.5px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x301&amp;quot;&amp;gt;1015.87px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x302&amp;quot;&amp;gt;1019.25px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x303&amp;quot;&amp;gt;1022.62px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x304&amp;quot;&amp;gt;1026.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x305&amp;quot;&amp;gt;1029.37px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x306&amp;quot;&amp;gt;1032.75px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x307&amp;quot;&amp;gt;1036.12px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x308&amp;quot;&amp;gt;1039.5px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x309&amp;quot;&amp;gt;1042.87px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x310&amp;quot;&amp;gt;1046.25px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x311&amp;quot;&amp;gt;1049.62px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x312&amp;quot;&amp;gt;1053.0px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x313&amp;quot;&amp;gt;1056.37px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x314&amp;quot;&amp;gt;1059.75px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x315&amp;quot;&amp;gt;1063.12px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x316&amp;quot;&amp;gt;1066.5px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x317&amp;quot;&amp;gt;1069.87px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x318&amp;quot;&amp;gt;1073.25px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x319&amp;quot;&amp;gt;1076.62px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;dimen name=&amp;quot;x320&amp;quot;&amp;gt;1080px&amp;lt;/dimen&amp;gt;&#xA;&amp;lt;/resources&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import java.io.File;&#xA;import java.io.FileNotFoundException;&#xA;import java.io.FileOutputStream;&#xA;import java.io.PrintWriter;&#xA;&#xA;public class MakeXml {&#xA;&#xA;    private final static String rootPath = &#xA;            &amp;quot;C:\\Users\\Administrator\\Desktop\\layoutroot\\values-{0}x{1}\\&amp;quot;;&#xA;&#xA;    private final static float dw = 320f;&#xA;    private final static float dh = 480f;&#xA;&#xA;    private final static String WTemplate = &amp;quot;&amp;lt;dimen name=\&amp;quot;x{0}\&amp;quot;&amp;gt;{1}px&amp;lt;/dimen&amp;gt;\n&amp;quot;;&#xA;    private final static String HTemplate = &amp;quot;&amp;lt;dimen name=\&amp;quot;y{0}\&amp;quot;&amp;gt;{1}px&amp;lt;/dimen&amp;gt;\n&amp;quot;;&#xA;&#xA;    public static void main(String[] args) {&#xA;        makeString(320, 480);&#xA;        makeString(480,800);&#xA;        makeString(480, 854);&#xA;        makeString(540, 960);&#xA;        makeString(600, 1024);&#xA;        makeString(720, 1184);&#xA;        makeString(720, 1196);&#xA;        makeString(720, 1280);&#xA;        makeString(768, 1024);&#xA;        makeString(800, 1280);&#xA;        makeString(1080, 1812);&#xA;        makeString(1080, 1920);&#xA;        makeString(1440, 2560);&#xA;    }&#xA;&#xA;    public static void makeString(int w, int h) {&#xA;&#xA;        StringBuffer sb = new StringBuffer();&#xA;        sb.append(&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;utf-8\&amp;quot;?&amp;gt;\n&amp;quot;);&#xA;        sb.append(&amp;quot;&amp;lt;resources&amp;gt;&amp;quot;);&#xA;        float cellw = w / dw;&#xA;        for (int i = 1; i &amp;lt; 320; i++) {&#xA;            sb.append(WTemplate.replace(&amp;quot;{0}&amp;quot;, i + &amp;quot;&amp;quot;).replace(&amp;quot;{1}&amp;quot;,&#xA;                    change(cellw * i) + &amp;quot;&amp;quot;));&#xA;        }&#xA;        sb.append(WTemplate.replace(&amp;quot;{0}&amp;quot;, &amp;quot;320&amp;quot;).replace(&amp;quot;{1}&amp;quot;, w + &amp;quot;&amp;quot;));&#xA;        sb.append(&amp;quot;&amp;lt;/resources&amp;gt;&amp;quot;);&#xA;&#xA;        StringBuffer sb2 = new StringBuffer();&#xA;        sb2.append(&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;utf-8\&amp;quot;?&amp;gt;\n&amp;quot;);&#xA;        sb2.append(&amp;quot;&amp;lt;resources&amp;gt;&amp;quot;);&#xA;        float cellh = h / dh;&#xA;        for (int i = 1; i &amp;lt; 480; i++) {&#xA;            sb2.append(HTemplate.replace(&amp;quot;{0}&amp;quot;, i + &amp;quot;&amp;quot;).replace(&amp;quot;{1}&amp;quot;,&#xA;                    change(cellh * i) + &amp;quot;&amp;quot;));&#xA;        }&#xA;        sb2.append(HTemplate.replace(&amp;quot;{0}&amp;quot;, &amp;quot;480&amp;quot;).replace(&amp;quot;{1}&amp;quot;, h + &amp;quot;&amp;quot;));&#xA;        sb2.append(&amp;quot;&amp;lt;/resources&amp;gt;&amp;quot;);&#xA;&#xA;        String path = rootPath.replace(&amp;quot;{0}&amp;quot;, h + &amp;quot;&amp;quot;).replace(&amp;quot;{1}&amp;quot;, w + &amp;quot;&amp;quot;);&#xA;        File rootFile = new File(path);&#xA;        if (!rootFile.exists()) {&#xA;            rootFile.mkdirs();&#xA;        }&#xA;        File layxFile = new File(path + &amp;quot;lay_x.xml&amp;quot;);&#xA;        File layyFile = new File(path + &amp;quot;lay_y.xml&amp;quot;);&#xA;        try {&#xA;            PrintWriter pw = new PrintWriter(new FileOutputStream(layxFile));&#xA;            pw.print(sb.toString());&#xA;            pw.close();&#xA;            pw = new PrintWriter(new FileOutputStream(layyFile));&#xA;            pw.print(sb2.toString());&#xA;            pw.close();&#xA;        } catch (FileNotFoundException e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    public static float change(float a) {&#xA;        int temp = (int) (a * 100);&#xA;        return temp / 100f;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;应用程序图标 （Icon）应当是一个 Alpha 通道透明的32位 PNG 图片。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;由于安卓设备众多，一个应用程序图标需要设计几种不同大小，如：&#xA;LDPI (Low Density Screen，120 DPI)，其图标大小为 36 x 36 px。&#xA;MDPI (Medium Density Screen, 160 DPI)，其图标大小为 48 x 48 px。&#xA;HDPI (High Density Screen, 240 DPI)，其图标大小为 72 x 72 px。&#xA;xhdpi (Extra-high density screen, 320 DPI)，其图标大小为 96 x 96 px。&#xA;&#xA;建议在设计过程中，在四周空出几个像素点使得设计的图标与其他图标在视觉上一致，例如，&#xA;96 x 96 px 图标可以画图区域大小可以设为 88 x 88 px， 四周留出4个像素用于填充（无底色）。&#xA;72 x 72 px 图标可以画图区域大小可以设为 68 x 68 px， 四周留出2个像素用于填充（无底色）。&#xA;48 x 48 px 图标可以画图区域大小可以设为 46 x 46 px， 四周留出1个像素用于填充（无底色）。&#xA;36 x 36 px 图标可以画图区域大小可以设为 34 x 34 px， 四周留出1个像素用于填充（无底色）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;每英寸像素数, 可以反映屏幕的清晰度，用于缩放UI的&#xA;ldpi (low)                          ~120dpi&#xA;mdpi (medium)                       ~160dpi&#xA;hdpi (high)                         ~240dpi&#xA;xhdpi (extra-high)                  ~320dpi&#xA;xxhdpi (extra-extra-high)           ~480dpi&#xA;xxxhdpi (extra-extra-extra-high)    ~640dpi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;drawable-ldpi   放低分辨率的图片，即QVGA(240×320)&#xA;drawable-mdpi   放中分辨率的图片，即HVGA(320×480)&#xA;drawable-hdpi   放高分辨率的图片，如WVGA(480x800),FWVGA (480x854)。&#xA;drawable-xhdpi  放高分辨率的图片，即720p(1280×720)&#xA;drawable-xxhdpi 放高分辨率的图片，即1080p(1920×1080)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android设备屏幕尺寸分布&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/3.png&#34; alt=&#34;&#34; width=&#34;500&#34; hight=&#34;200&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;上图可以看出&#xA;&#xA;对应normal尺寸的屏幕范围集中在常见的3到5寸屏之间&#xA;    large尺寸对应的就主要是5到7寸的nottpad之类的设备，例如三星的Note和Nexus7平板等&#xA;&#xA;接下来是屏幕密度（dpi），需要说明的是，平时所说的屏幕分辨率其实不能作为屏幕适配的依据&#xA;     应该依据屏幕密度和屏幕尺寸来换算，屏幕密度是指每英寸屏幕内容纳的像素数&#xA;&#xA;屏幕密度从ldpi到xhdpi分别对应为120dpi、160dpi、240dpi、320dpi&#xA;    屏幕密度越高、分辨率越高、屏幕尺寸越小就产生了视网膜屏幕。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;DIP单位详解&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/4.jpeg&#34; alt=&#34;&#34; width=&#34;200&#34; hight=&#34;200&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Android规定一个dip的大小相当于160dpi屏幕上的一个像素&#xA;    它是系统为“中等的”密度屏设定的基准密度，在不同dpi屏幕上dp对应的像素数是不同的&#xA;&#xA;需要时，基于当前屏的实际密度，系统会透明地放缩dip单。&#xA;    dip单位根据公式像素值 = [dip*(dpi/160)](px)（其中px是单位）转化为屏幕像素。&#xA;    根据此公式可以计算出一个dip分别在120dpi、160dpi、240dpi、320dpi&#xA;    屏幕中对应的像素数分别为0.75、1、1.5、2.0，比例为3:4:6:8。&#xA;    因此，在不同屏幕密度上，以mdpi作为基准，对位图进行3:4:6:8比例的放缩会达到适配的效果。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dip与一般的px不太一样，它是独立于屏幕密度的。什么是独立于密度？&#xA;&#xA;先来说下一般的px，如果将一个相同长宽像素的图片放在不同屏幕密度大小的屏幕中&#xA;    那么，在低密度屏幕中图片会显示的很大，在高密度屏幕中则会显示的很小；&#xA;    但是，如果使用dip为单位的图片显示的效果则是，屏幕密度越大的手机，图片显示的像素也相应增大&#xA;    这样在屏幕密度大的手机和屏幕密度小的手机上，图片看上去大小基本相同。&#xA;    有了上文对dip的讲解，是否对这个现象有所理解呢？&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;举个例子来说一下：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;现在有三个物理长宽分别为3寸、4寸，屏幕密度分别为120dpi、160dpi、240dpi的手机&#xA;    则三个屏幕的分辨率分别为360px*480px、480px*640px、&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/5.jpeg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;将三个手机屏幕的宽分为三等份，则根据dpi的定义，三个屏幕中每等份分别容纳120px、160px、240px。&#xA;    现在假设有一个控件imageview 它的长宽分别为160px、160px，还有一个160px*160px的图片资源&#xA;    当程序运行时，该图片在三个屏幕上会呈现以下效果：&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/6.png&#34; alt=&#34;&#34; width=&#34;550&#34; hight=&#34;250&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如果将imageview的长宽分别改为160dip、160dip，图片将在三个屏幕上呈现以下效果:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/7.png&#34; alt=&#34;&#34; width=&#34;550&#34; hight=&#34;250&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;上文提到在这三种屏幕密度下一个dip分别对应0.75px、1px、1.5px&#xA;    所以在三种屏幕上该图片占据120px、160px、240px,各自占屏幕的三分之一，所以看起来是一样大的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;由上文可总结出Android在适配不同屏幕密度时，可以用dip作为控件的单位，视情况放缩dip单位。&#xA;&#xA;当应用没有指出图片对应的控件的大小，Android是如何让图片适配不同屏幕的呢？&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在Android2.1之前，开发应用时只有一个放图片资源的drawable文件夹，这样程序在不同屏幕密度的手机上运行时&#xA;    系统只会从drawable这个文件夹下调图片资源，并且系统会默认认为这个文件夹下的所有资源是为mdpi屏幕提供的&#xA;    所以在hdpi屏幕上系统会按比例将drawable下的图片扩大为原来的1.5倍&#xA;    在ldpi屏幕上系统会按比例将drawable下的图片缩小为原来的0.75倍&#xA;    这样会大大降低页面效果。&#xA;&#xA;在Android2.1以及之后，出现了drawable-ldpi、drawable-mdpi、drawable-hdpi、drawable-xhdpi、drawable-xxhdpi。&#xA;    在这些文件下提供的图片大小最好是3:4:6:8:12。&#xA;    程序在不同的屏幕密度下运行时，会首先去符合当前屏幕密度的文件夹下找对应的资源&#xA;    如果没有，系统会以最省力为前提去别的文件夹下找对应的资源并对其进行相应的缩放&#xA;    如果还没有，就回去默认的drawable文件夹下找，然后按照2.1之前的规则缩放&#xA;    如果还没有找到，应用就会报错或者直接crash掉了。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;举个例子&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;现在有一个ldpi的手机屏幕，有一个应用在其上运行(假如只有ldpi、mdpi、hdpi还有drawable四个存放图片的文件夹)&#xA;    并需要调用一个图片a.png（在下文中用a来代替a.png）。Android系统会经历以下流程：&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/8.png&#34; alt=&#34;&#34; width=&#34;600&#34; hight=&#34;700&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;将hdpi中的图片大小缩小为原来的一半相比将mdpi中的图片大小缩小为原来的3/4，计算机要省力，只需进行简单地右移一位操作。&#xA;    所以系统在ldpi下找不到a的时候会首先去hdpi下去找。当存在xhdpi、xxhdpi时，系统会按相同的规则去调用资源。&#xA;&#xA;   Drawable-ldpi 3、Drawable-mdpi  4、Drawable-hdpi  6中的3、4、6指的是同一个图片在三个文件夹下的大小之比。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Android开发者在做图片适配时需要注意一下两点&#xA;&#xA;盛放图片的控件要用dip单位来定义其长宽。&#xA;&#xA;最好在ldpi、mdpi、hdpi、xhdpi、xxhdpi文件夹下提供大小比例为3:4:6:8:12的图片。&#xA;    当然如果有质量好的.9.png图片的话，提供一个也可以。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/1.gif&#34; alt=&#34;&#34; width=&#34;500&#34; hight=&#34;300&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之各分辨率定义的图片规格/2.gif&#34; alt=&#34;&#34; width=&#34;600&#34; hight=&#34;250&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;笔记&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Google 提供的 PX 转 DP 的公式 ( px * 160 ) / PPI 获取 DP 值&#xA;&#xA;通过测试，Android 系统是使用默认 DP 来作为基数，而不是使用实际手机中的 DPI ，只是取相近的像素值&#xA;&#xA;比如 5寸手机 1920X1080 分辨率 DP 为 440 ，但是 Android 手机使用是 480 的 DP &#xA;&#xA;1920X1080 为基数 3倍数 而 1280X720 为基数 2倍数 &#xA;&#xA;所以现在遇到两个问题，一个设计给的PX我转换成DP则使用 &#xA;&#xA;PX * 160 / 480 后的值作为 像素间距大小 等值&#xA;&#xA;另外一个就是发现非XML文件中设置DP即使进行了转换也与设计效果相差很多&#xA;&#xA;所以在这种情况下使用 百分比进行计算&#xA;&#xA;读取手机真是分辨率 宽 / 百分比 和 高 / 百分比&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dip ： device independent pixels 设备无关像素（dp就是dip）&#xA;&#xA;dpi ：dots per inch ，密度（一英寸多少个点）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之自定义AdapterView的空视图</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89AdapterView%E7%9A%84%E7%A9%BA%E8%A7%86%E5%9B%BE/</link>
      <pubDate>2015-07-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;自定义AdapterView的空视图&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;要在AdapterView(ListView, GridView, 诸如此类视图)没有数据时显示自定义的视图&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;// 通过 AdapterView.setEmptyView 方法配置空视图&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;把要显示的视图跟AdapterView放在同一个布局树中，然后通过函数进行设置。&#xA;AdapterView会根据ListAdapter的isEmpty方法的返回值选择显示自身还是空视图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;AdapterView仅仅只是变换两者是否可见的参数，而绝不会在布局树中插入或者删除视图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState)&#xA;    ListView list = (ListView) findViewById(R.id.mylist);&#xA;    TextView empty = (TextView) findViewById(R.id.myempty);&#xA;    // ... 这里设置空视图&#xA;    list.setEmptyView(empty);&#xA;    // ...&#xA;    // 随后可以继续添加Adapter和数据&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之ActionMode的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BActionMode%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-07-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android的menu有多种实现方式，这里介绍一种新的menu实现方式：ActionMode。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;ActionMode是Android 3.0以后出现的，我们可以使用AppCompat库使ActionMode兼容至Android 2.1。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android 3.0以前，我们处理列表的长按事件经常使用Context Menu&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android3.0以后，我们有了新的选择：ActionMode。下图左边效果为Context Menu右边效果为ActionMode。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之ActionMode的使用/1.jpg&#34; alt=&#34;&#34; width=&#34;350&#34; hight=&#34;420&#34; &gt;&#xA;&lt;img src=&#34;/assets/media/Android之ActionMode的使用/2.jpg&#34; alt=&#34;&#34; width=&#34;350&#34; hight=&#34;420&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android开发者应该都熟悉Context Menu了，Context Menu是悬浮在操作项之上的视图。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;ActionMode是临时占据了ActionBar的位置。下面给出ActionMode的实现方法。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用ActionMode需要两步骤：&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;1、实现ActionMode.Callback接口，并处理ActionMode的生命周期，ActionMode的生命周期如下图:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private ActionMode.Callback mCallback = new ActionMode.Callback() {  &#xA;&#xA;        @Override  &#xA;        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {  &#xA;            return false;  &#xA;        }  &#xA;&#xA;        @Override  &#xA;        public void onDestroyActionMode(ActionMode mode) {  &#xA;            // TODO Auto-generated method stub  &#xA;        }  &#xA;&#xA;        @Override  &#xA;        public boolean onCreateActionMode(ActionMode mode, Menu menu) {  &#xA;            MenuInflater inflater = mode.getMenuInflater();  &#xA;            inflater.inflate(R.menu.actionmode, menu);  &#xA;            return true;  &#xA;        }&#xA;&#xA;        @Override  &#xA;        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {  &#xA;            boolean ret = false;  &#xA;            if (item.getItemId() == R.id.actionmode_cancel) {  &#xA;                mode.finish();  &#xA;                ret = true;  &#xA;            }  &#xA;            return ret;  &#xA;        } &#xA;&#xA;}; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;2、事件触发时，调用startActionMode()方法。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;someView.setOnLongClickListener(new View.OnLongClickListener() {  &#xA;    // Called when the user long-clicks on someView  &#xA;    public boolean onLongClick(View view) {  &#xA;        if (mActionMode != null) {  &#xA;            return false;  &#xA;        }  &#xA;&#xA;        // Start the CAB using the ActionMode.Callback defined above  &#xA;        mActionMode = getActivity().startActionMode(mActionModeCallback);  &#xA;        view.setSelected(true);  &#xA;        return true;  &#xA;    }  &#xA;&#xA;});  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之zxing扫描二维码画面拉伸问题</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8Bzxing%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%BB%E9%9D%A2%E6%8B%89%E4%BC%B8%E9%97%AE%E9%A2%98/</link>
      <pubDate>2015-07-15 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;zxing扫描二维码画面拉伸&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;解决方法：修改 CameraConfigurationManager.java 文件&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  /**&#xA;   * Reads, one time, values from the camera that are needed by the app.&#xA;   */&#xA;  void initFromCameraParameters(Camera camera) {&#xA;    Camera.Parameters parameters = camera.getParameters();&#xA;    previewFormat = parameters.getPreviewFormat();&#xA;    previewFormatString = parameters.get(&amp;quot;preview-format&amp;quot;);&#xA;    Log.d(TAG, &amp;quot;Default preview format: &amp;quot; + previewFormat + &#39;/&#39; + previewFormatString);&#xA;    WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);&#xA;    Display display = manager.getDefaultDisplay();&#xA;    screenResolution = new Point(display.getWidth(), display.getHeight());&#xA;    Log.d(TAG, &amp;quot;Screen resolution: &amp;quot; + screenResolution);&#xA;    Point screenResolutionForCamera = new Point();&#xA;    screenResolutionForCamera.x = screenResolution.x;&#xA;    screenResolutionForCamera.y = screenResolution.y;&#xA;    // preview size is always something like 480*320, other 320*480&#xA;    if (screenResolution.x &amp;lt; screenResolution.y) {&#xA;        screenResolutionForCamera.x = screenResolution.y;&#xA;        screenResolutionForCamera.y = screenResolution.x;&#xA;    }&#xA;    // cameraResolution = getCameraResolution(parameters, screenResolution);&#xA;    cameraResolution = getCameraResolution(parameters, screenResolutionForCamera);&#xA;    Log.d(TAG, &amp;quot;Camera resolution: &amp;quot; + screenResolution);&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;修改扫描窗口大小&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在CameraManager.java这个类中进行调整&#xA;&#xA;默认的大小是 以下这4个参数 &#xA;//  private static final int MIN_FRAME_WIDTH = 240;&#xA;//  private static final int MIN_FRAME_HEIGHT = 240;&#xA;//  private static final int MAX_FRAME_WIDTH = 480;&#xA;//  private static final int MAX_FRAME_HEIGHT = 360;&#xA;&#xA;参数实际在 getFramingRect() 方法中起作用&#xA;原始：&#xA;&#xA;/** &#xA;  * Calculates the framing rect which the UI should draw to show the user where to place the &#xA;  * barcode. This target helps with alignment as well as forces the user to hold the device &#xA;  * far enough away to ensure the image will be in focus. &#xA;  * &#xA;  * @return The rectangle to draw on screen in window coordinates. &#xA;  */  &#xA; public Rect getFramingRect() {  &#xA;   Point screenResolution = configManager.getScreenResolution();  &#xA;   if (framingRect == null) {  &#xA;     if (camera == null) {  &#xA;       return null;  &#xA;     }  &#xA;&#xA;     //原生  &#xA;     int width = screenResolution.x * 3 / 4;  &#xA;     if (width &amp;lt; MIN_FRAME_WIDTH) {  &#xA;       width = MIN_FRAME_WIDTH;  &#xA;     } else if (width &amp;gt; MAX_FRAME_WIDTH) {  &#xA;       width = MAX_FRAME_WIDTH;  &#xA;     }  &#xA;     int height = screenResolution.y * 3 / 4;  &#xA;     if (height &amp;lt; MIN_FRAME_HEIGHT) {  &#xA;       height = MIN_FRAME_HEIGHT;  &#xA;     } else if (height &amp;gt; MAX_FRAME_HEIGHT) {  &#xA;       height = MAX_FRAME_HEIGHT;  &#xA;     }  &#xA;     int leftOffset = (screenResolution.x - width) / 2;  &#xA;     int topOffset = (screenResolution.y - height) / 2;  &#xA;     framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);  &#xA;     Log.d(TAG, &amp;quot;Calculated framing rect: &amp;quot; + framingRect);  &#xA;   }  &#xA;   return framingRect;  &#xA; }  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;改为:&#xA;&#xA;public Rect getFramingRect() {  &#xA;  Point screenResolution = configManager.getScreenResolution();  &#xA;  if (framingRect == null) {  &#xA;    if (camera == null) {  &#xA;      return null;  &#xA;    }  &#xA;&#xA;  //修改之后    &#xA;  int width = screenResolution.x * 7 / 10;  &#xA;  int height = screenResolution.y * 7 / 10;  &#xA;&#xA;  int leftOffset = (screenResolution.x - width) / 2;  &#xA;  int topOffset = (screenResolution.y - height) / 3;  &#xA;  framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);  &#xA;&#xA;&#xA;    Log.d(TAG, &amp;quot;Calculated framing rect: &amp;quot; + framingRect);  &#xA;  }  &#xA;  return framingRect;  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之SlidingDrawer的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BSlidingDrawer%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-07-14 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SlidingDrawer&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;SlidingDrawer是自SDK 1.5才新加入的，实现Launcher的抽屉效果。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;SlidingDrawer配置上采用了水平展开或垂直展开两种（android:orientation）方式&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在XML里必须指定其使用的android:handle与android:content，前者委托要展开的图片（Layout配置），后者则是要展开的Layout Content。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之SlidingDrawer的使用方法/1.gif&#34; alt=&#34;&#34; width=&#34;300&#34; hight=&#34;480&#34; &gt;&#xA;&lt;img src=&#34;/assets/media/Android之SlidingDrawer的使用方法/2.gif&#34; alt=&#34;&#34; width=&#34;300&#34; hight=&#34;480&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;android:allowSingleTap      Indicates whether the drawer can be opened/closed by a single tap on the handle. &#xA;android:animateOnClick      Indicates whether the drawer should be opened/closed with an animation when the user clicks the handle. &#xA;android:bottomOffset        Extra offset for the handle at the bottom of the SlidingDrawer. &#xA;android:content             Identifier for the child that represents the drawer&#39;s content. &#xA;android:handle              Identifier for the child that represents the drawer&#39;s handle. &#xA;android:orientation         Orientation of the SlidingDrawer. &#xA;android:topOffset           Extra offset for the handle at the top of the SlidingDrawer. &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;SlidingDrawer xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:id=&amp;quot;@+id/drawer&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:content=&amp;quot;@+id/content&amp;quot;&#xA;    android:handle=&amp;quot;@+id/handle&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;        android:id=&amp;quot;@id/handle&amp;quot;&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:src=&amp;quot;@mipmap/ic_launcher&amp;quot;&amp;gt;&amp;lt;/ImageView&amp;gt;&#xA;&#xA;    &amp;lt;ListView&#xA;        android:id=&amp;quot;@id/content&amp;quot;&#xA;        android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;        android:background=&amp;quot;#ff00ff&amp;quot;&amp;gt;&amp;lt;/ListView&amp;gt;&#xA;&#xA;&amp;lt;/SlidingDrawer&amp;gt;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import android.app.Activity;  &#xA;import android.os.Bundle;  &#xA;import android.view.View;  &#xA;import android.widget.AdapterView;  &#xA;import android.widget.AdapterView.OnItemClickListener;  &#xA;import android.widget.ArrayAdapter;  &#xA;import android.widget.ImageView;  &#xA;import android.widget.ListView;  &#xA;import android.widget.SlidingDrawer;  &#xA;import android.widget.SlidingDrawer.OnDrawerCloseListener;  &#xA;import android.widget.SlidingDrawer.OnDrawerOpenListener;  &#xA;import android.widget.Toast;  &#xA;&#xA;public class SlidingDemo extends Activity implements OnItemClickListener,  &#xA;        OnDrawerOpenListener, OnDrawerCloseListener {  &#xA;    private SlidingDrawer drawer;  &#xA;    private ImageView handle;  &#xA;    private ListView content;  &#xA;&#xA;    @Override  &#xA;    public void onCreate(Bundle savedInstanceState) {  &#xA;        super.onCreate(savedInstanceState);  &#xA;        setContentView(R.layout.sliding);  &#xA;&#xA;        drawer = (SlidingDrawer) this.findViewById(R.id.drawer);  &#xA;        handle = (ImageView) this.findViewById(R.id.handle);  &#xA;        content = (ListView) this.findViewById(R.id.content);  &#xA;        content.setAdapter(new ArrayAdapter&amp;lt;String&amp;gt;(this,  &#xA;                android.R.layout.simple_list_item_1, new String[] { &amp;quot;one&amp;quot;,  &#xA;                        &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot; }));  &#xA;        content.setOnItemClickListener(this);  &#xA;&#xA;        // 设置SlidingDrawer打开或者关闭时的监听器  &#xA;        drawer.setOnDrawerOpenListener(this);  &#xA;        drawer.setOnDrawerCloseListener(this);  &#xA;    }  &#xA;&#xA;    @Override  &#xA;    public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position,  &#xA;            long id) {  &#xA;        Toast.makeText(this, &amp;quot;you clicked position &amp;quot; + (position + 1),  &#xA;                Toast.LENGTH_SHORT).show();  &#xA;    }  &#xA;&#xA;    // SlidingDrawer关闭时回调  &#xA;    @Override  &#xA;    public void onDrawerClosed() {  &#xA;        handle.setImageResource(R.drawable.up);  &#xA;    }  &#xA;&#xA;    // SlidingDrawer打开时回调  &#xA;    @Override  &#xA;    public void onDrawerOpened() {  &#xA;        handle.setImageResource(R.drawable.down);  &#xA;    }  &#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void    setOnDrawerCloseListener(SlidingDrawer.OnDrawerCloseListener onDrawerCloseListener)&#xA;    Sets the listener that receives a notification when the drawer becomes close.&#xA;void    setOnDrawerOpenListener(SlidingDrawer.OnDrawerOpenListener onDrawerOpenListener)&#xA;    Sets the listener that receives a notification when the drawer becomes open.  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;转载来自：http://blog.csdn.net/moreevan/article/details/6741083 （感谢）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之BSON与JSON的区别</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BBSON%E4%B8%8EJSON%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;BSON与JSON&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;BSON是由10gen开发的一个数据格式，目前主要用于MongoDB中，是MongoDB的数据存储格式。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;BSON基于JSON格式，选择JSON进行改造的原因主要是JSON的通用性及JSON的schemaless的特性。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://labix.org/gobson&#xA;&#xA;go get gopkg.in/mgo.v2/bson&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;        &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;gopkg.in/mgo.v2/bson&amp;quot;&#xA;)&#xA;&#xA;type Person struct {&#xA;    Name string&#xA;    Phone string &amp;quot;,omitempty&amp;quot;&#xA;}&#xA;&#xA;func main() {&#xA;        data, err := bson.Marshal(&amp;amp;Person{Name:&amp;quot;Bob&amp;quot;})&#xA;        if err != nil {&#xA;                panic(err)&#xA;        }&#xA;        fmt.Printf(&amp;quot;%q&amp;quot;, data)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;1.更快的遍历速度&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;对JSON格式来说，太大的JSON结构会导致数据遍历非常慢。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在JSON中，要跳过一个文档进行数据读取，需要对此文档进行扫描才行，需要进行麻烦的数据结构匹配&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如括号的匹配，而BSON对JSON的一大改进就是，它会将JSON的每一个元素的长度存在元素的头部&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;2.操作更简易&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;对JSON来说，数据存储是无类型的，比如你要修改基本一个值，从9到10，由于从一个字符变成了两个&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以可能其后面的所有内容都需要往后移一位才可以。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而使用BSON，你可以指定这个列为数字列，那么无论数字从9长到10还是100，我们都只是在存储数字的那一位上进行修改&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不会导致数据总长变大。当然，在MongoDB中，如果数字从整形增大到长整型，还是会导致数据总长变大的。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;3.增加了额外的数据类型&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;JSON是一个很方便的数据交换格式，但是其类型比较有限。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;BSON在其基础上增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成JSON。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大大减少了计算开销和数据大小。当然，在有的时候，BSON相对JSON来说也并没有空间上的优势&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如对{“field”:7}，在JSON的存储上7只使用了一个字节，而如果用BSON，那就是至少4个字节（32位）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目前在10gen的努力下，BSON已经有了针对多种语言的编码解码包。并且都是Apache 2 license下开源的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;并且还在随着MongoDB进一步地发展&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之添加快捷方式到手机桌面</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%88%B0%E6%89%8B%E6%9C%BA%E6%A1%8C%E9%9D%A2/</link>
      <pubDate>2015-07-06 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;添加快捷方式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;权限&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;要在手机桌面上添加快捷方式，首先需要在manifest中添加权限。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 添加快捷方式 --&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;com.android.launcher.permission.INSTALL_SHORTCUT&amp;quot; /&amp;gt;&#xA;&amp;lt;!-- 移除快捷方式 --&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;com.android.launcher.permission.UNINSTALL_SHORTCUT&amp;quot; /&amp;gt;&#xA;&amp;lt;!-- 查询快捷方式 --&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;com.android.launcher.permission.READ_SETTINGS&amp;quot; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;添加快捷方式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;添加快捷方式，是向桌面应用(launcher)发送相关action的广播，相关的action如下：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static final String ACTION_ADD_SHORTCUT = &amp;quot;com.android.launcher.action.INSTALL_SHORTCUT&amp;quot;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;添加快捷方式：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void addShortcut(Context context, int appName, int appIcon) {&#xA;&#xA;    String ACTION_INSTALL_SHORTCUT = &amp;quot;com.android.launcher.action.INSTALL_SHORTCUT&amp;quot;;&#xA;&#xA;    // 快捷方式要启动的包&#xA;    Intent intent = new Intent(context, context.getClass());&#xA;&#xA;    // 设置快捷方式的参数&#xA;    Intent shortcutIntent = new Intent(ACTION_INSTALL_SHORTCUT);&#xA;&#xA;    // 设置名称&#xA;    shortcutIntent.putExtra(&#xA;            Intent.EXTRA_SHORTCUT_NAME, context.getResources().getString(appName)); // 设置启动 Intent&#xA;    shortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, intent);&#xA;&#xA;    // 设置图标&#xA;    shortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,&#xA;            Intent.ShortcutIconResource.fromContext(context, appIcon));&#xA;&#xA;    // 只创建一次快捷方式&#xA;    shortcutIntent.putExtra(&amp;quot;duplicate&amp;quot;, false);&#xA;&#xA;    // 创建&#xA;    context.sendBroadcast(shortcutIntent);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;移除快捷方式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;移除快捷方式的action：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static final String ACTION_REMOVE_SHORTCUT = &amp;quot;com.android.launcher.action.UNINSTALL_SHORTCUT&amp;quot;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;移除快捷方式的方法：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void removeShortcut(String name) {&#xA;    // remove shortcut的方法在小米系统上不管用，在三星上可以移除&#xA;    Intent intent = new Intent(ACTION_REMOVE_SHORTCUT);&#xA;&#xA;    // 名字&#xA;    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name);&#xA;&#xA;    // 设置关联程序&#xA;    Intent launcherIntent = new Intent(MainActivity.this,&#xA;            MainActivity.class).setAction(Intent.ACTION_MAIN);&#xA;&#xA;    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, launcherIntent);&#xA;&#xA;    // 发送广播&#xA;    sendBroadcast(intent);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;查询快捷方式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;查询快捷方式是否存在的方法是从网上其他资料那里查来的，但是测试查询的时候失败了，两个手机(小米、三星)都查不到。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private boolean hasInstallShortcut(String name) {&#xA;&#xA;    boolean hasInstall = false;&#xA;&#xA;    final String AUTHORITY = &amp;quot;com.android.launcher2.settings&amp;quot;;&#xA;    Uri CONTENT_URI = Uri.parse(&amp;quot;content://&amp;quot; + AUTHORITY&#xA;            + &amp;quot;/favorites?notify=true&amp;quot;);&#xA;&#xA;    // 这里总是failed to find provider info&#xA;    // com.android.launcher2.settings和com.android.launcher.settings都不行&#xA;    Cursor cursor = this.getContentResolver().query(CONTENT_URI,&#xA;            new String[] { &amp;quot;title&amp;quot;, &amp;quot;iconResource&amp;quot; }, &amp;quot;title=?&amp;quot;,&#xA;            new String[] { name }, null);&#xA;&#xA;    if (cursor != null &amp;amp;&amp;amp; cursor.getCount() &amp;gt; 0) {&#xA;        hasInstall = true;&#xA;    }&#xA;&#xA;    return hasInstall;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;转自: &lt;a href=&#34;http://www.cnblogs.com/mengdd/p/3837592.html&#34;&gt;http://www.cnblogs.com/mengdd/p/3837592.html&lt;/a&gt; (感谢)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之abstract和interface介绍</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8Babstract%E5%92%8Cinterface%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-07-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;abstract , interface&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 抽象类&#xA;abstract class Abc {&#xA;&#xA;    // 抽象类中的抽象方法&#xA;    public abstract void setData(int i);&#xA;&#xA;    public void Print() {&#xA;        // 调用了抽象方法&#xA;        setData(100);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 该类继承抽象类&#xA;class Bcd extends Abc {&#xA;&#xA;    @Override&#xA;    public void setData(int i) {&#xA;        System.out.print(i);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 主类&#xA;class Main {&#xA;&#xA;    // 主方法&#xA;    public Main() {&#xA;        // 继承抽象类的类必须实现抽象方法&#xA;        // 除非继承抽象类的类型也是抽象类&#xA;        Bcd bcd = new Bcd();&#xA;        bcd.Print();&#xA;    }&#xA;&#xA;    // 另外一种情况&#xA;    // 实现抽象类的时,必须实现类中抽象方法&#xA;    Abc abc = new Abc() {&#xA;        @Override&#xA;        public void setData(int i) {&#xA;            System.out.print(i);&#xA;        }&#xA;    };&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 抽象类&#xA;abstract class Server {&#xA;&#xA;    private int port;&#xA;&#xA;    // 抽象类中的抽象方法&#xA;    public abstract void failure(String data);&#xA;    public abstract void success(int code);&#xA;&#xA;    public void start() {&#xA;        // ... start ...&#xA;        if (true | false) {&#xA;            success(String data);&#xA;        } else {&#xA;            failuer(int code);&#xA;        }&#xA;    }&#xA;&#xA;} &#xA;&#xA;// 主类&#xA;class Main {&#xA;    public Main() {&#xA;        Server server = new Server() {&#xA;            @Override&#xA;            public void success(String data) {&#xA;                System.out.print(data)&#xA;            }&#xA;            @Override&#xA;            public void failure(int code) {&#xA;                System.out.print(code)&#xA;            }&#xA;        };&#xA;        server.start();&#xA;    }&#xA;}   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;abstract class和interface在Java语言中都是用来进行抽象类定义.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;使用abstract class的方式定义Demo抽象类的方式如下：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;abstract class Demo ｛&#xA;    abstract void method1();&#xA;    abstract void method2();&#xA;    …&#xA;｝&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;使用interface的方式定义Demo抽象类的方式如下：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;interface Demo {&#xA;    void method1();&#xA;    void method2();&#xA;    …&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而在interface方式的实现中，Demo只能够有静态的不能被修改的数据成员（也就是必须是static final的）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract class。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;考虑这样一个例子，假设在我们的问题领域中有一个关于Door的抽象概念，该Door具有执行两个动作open和close&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时我们可以通过abstract class或者interface来定义一个表示该抽象概念的类型，定义方式分别如下所示：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;使用abstract class方式定义Door：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;abstract class Door {&#xA;        abstract void open();&#xA;        abstract void close()；&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;使用interface方式定义Door：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;interface Door {&#xA;    void open();&#xA;    void close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;其他具体的Door类型可以extends使用abstract class方式定义的Door或者implements使用interface方式定义的Door。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看起来好像使用abstract class和interface没有大的区别。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;如果现在要求Door还要具有报警的功能。我们该如何设计针对该例子的类结构呢&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;解决方案一：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;简单的在Door的定义中增加一个alarm方法，如下：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;abstract class Door {&#xA;        abstract void open();&#xA;        abstract void close()；&#xA;        abstract void alarm();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;或者&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;interface Door {&#xA;        void open();&#xA;    void close();&#xA;    void alarm();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;那么具有报警功能的AlarmDoor的定义方式如下：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class AlarmDoor extends Door {&#xA;        void open() { … }&#xA;        void close() { … }&#xA;        void alarm() { … }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;或者&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class AlarmDoor implements Door ｛&#xA;    void open() { … }&#xA;    void close() { … }&#xA;    void alarm() { … }&#xA;｝&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这种方法违反了面向对象设计中的一个核心原则ISP（Interface Segregation Priciple）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Door的定义中把Door概念本身固有的行为方法和另外一个概念&amp;rdquo;报警器&amp;rdquo;的行为方法混在了一起。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为&amp;rdquo;报警器&amp;rdquo;这个概念的改变而改变，反之依然。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;解决方案二：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;既然open、close和alarm属于两个不同的概念，根据ISP原则应该把它们分别定义在代表这两个概念的抽象类中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;定义方式有：这两个概念都使用abstract class方式定义；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;两个概念都使用interface方式定义；一个概念使用abstract class方式定义，另一个概念使用interface方式定义。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;方式定义。如下所示：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;abstract class Door {&#xA;        abstract void open();&#xA;        abstract void close()；&#xA;}&#xA;&#xA;interface Alarm {&#xA;    void alarm();&#xA;}&#xA;&#xA;class AlarmDoor extends Door implements Alarm {&#xA;    void open() { … }&#xA;    void close() { … }&#xA;    void alarm() { … }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实abstract class表示的是&amp;rdquo;is a&amp;rdquo;关系, interface表示的是&amp;rdquo;like a&amp;rdquo;关系，大家在选择时可以作为一个依据&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;abstract class和interface是Java语言中的两种定义抽象类的方式，它们之间有很大的相似性。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是对于它们的选择却又往往反映出对于问题领域中的概念本质的理解&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于设计意图的反映是否正确、合理，因为它们表现了概念间的不同的关系（虽然都能够实现需求的功能）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这其实也是语言的一种的惯用法，希望读者朋友能够细细体会。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之委托模式开发</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%E5%BC%80%E5%8F%91/</link>
      <pubDate>2015-07-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;委托模式&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;也就是将本类中定义调用的方法委托给另外一个类实现&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 委托&#xA;public class Abc {&#xA;&#xA;    private AbcDelegate mAbcDelegate;&#xA;&#xA;    // 委托方法&#xA;    public static interface AbcDelegate {&#xA;        String getData();&#xA;    }&#xA;&#xA;    // 初始化&#xA;    public Abc(AbcDelegate mAbcDelegate) {&#xA;        this.mAbcDelegate = mAbcDelegate;&#xA;    }&#xA;&#xA;    public void start() {&#xA;        String str = mAbcDelegate.getData();&#xA;        Log.i(&amp;quot;INFO&amp;quot;, str);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 使用&#xA;public class Cde implements Abc.AbcDelegate {&#xA;&#xA;    private Abc abc = new Abc(this);&#xA;&#xA;    public Cde() {&#xA;        abc.start();&#xA;    }&#xA;&#xA;    @Override&#xA;    public String getData() {&#xA;        return &amp;quot;Hello&amp;quot;;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java之Map的各种锁的使用</title>
      <link>http://www.nljb.net/default/Java%E4%B9%8BMap%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-06-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Java之Map的各种锁的使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;1.使用 synchronized 关键字，这也是最原始的方法&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;synchronized(anObject)  {   &#xA;    value = map.get(key);&#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;2.使用 JDK1.5 提供的锁（java.util.concurrent.locks.Lock）&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lock.lock();   &#xA;value = map.get(key);   &#xA;lock.unlock();  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这样处理时对于hashmap的读写都加锁了，但是如果涉及到少量插入及频繁的查找&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么上面两种的效率不是很高，这时候最好的方式是加读写锁&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以下为构造读写锁包装map的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import java.util.Map;&#xA;import java.util.concurrent.locks.Lock;&#xA;import java.util.concurrent.locks.ReadWriteLock;&#xA;import java.util.concurrent.locks.ReentrantReadWriteLock;&#xA;&#xA;public class ReadWriteMap&amp;lt;K, V&amp;gt; {&#xA;&#xA;    private final Map&amp;lt;K, V&amp;gt; map;&#xA;    private final ReadWriteLock lock = new ReentrantReadWriteLock();&#xA;    private final Lock r = lock.readLock();&#xA;    private final Lock w = lock.writeLock();&#xA;&#xA;    public ReadWriteMap(Map&amp;lt;K, V&amp;gt; map) {&#xA;        this.map = map;&#xA;    }&#xA;&#xA;    public V put(K key, V value) {&#xA;        w.lock();&#xA;        try {&#xA;            return map.put(key, value);&#xA;        } finally {&#xA;            w.unlock();&#xA;        }&#xA;    }&#xA;&#xA;    public V get(Object key) {&#xA;        r.lock();&#xA;        try {&#xA;            return map.get(key);&#xA;        } finally {&#xA;            r.unlock();&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;使用 JDK1.5 提供的 java.util.concurrent.ConcurrentHashMap 类。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该类将 Map 的存储空间分为若干块，每块拥有自己的锁，大大减少了多个线程争夺同一个锁的情况。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;value = map.get(key); //同步机制内置在 get 方法中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;1、如果 ConcurrentHashMap 够用，则使用 ConcurrentHashMap。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、如果需自己实现同步，则使用 JDK1.5 提供的锁机制，避免使用 synchronized 关键字。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之编码的使用</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E7%BC%96%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-06-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;AES 与 DEA 高级加密解密方法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;crypto/aes 是美国联邦政府采用的一种区块加密标准&#xA;crypto/des 一种对称加密算法，是目前使用最广泛的密钥系统&#xA;            特别是在保护金融数据安全中...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// AES 与 DES 实现方法类似, 下面是 AES 介绍&#xA;&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;crypto/aes&amp;quot;&#xA;    &amp;quot;crypto/cipher&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;// 数据操作的偏移量&#xA;var IV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}&#xA;&#xA;func main() {&#xA;&#xA;    // 要加密的内容&#xA;    content := []byte(&amp;quot;my name is nljb&amp;quot;)&#xA;&#xA;    // KEY, 必须是16,24,32位的[]byte&#xA;    // 分别对应AES_128,AES_192,AES_256&#xA;    key := &amp;quot;B8XKCA7IVW6WB7GX76V771RN8LJCY2H0&amp;quot;       &#xA;&#xA;    // 通过密钥生成一个新的密码块&#xA;    c, err := aes.NewCipher([]byte(key))&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;    // 加密模式 (ECB、CBC、CFB、OFB)&#xA;    // IV是initialization vector的意思&#xA;    // 就是加密的初始话矢量，初始化加密函数的变量&#xA;    // 也就是加密动作中的 数据操作的偏移量&#xA;    cfb := cipher.NewCFBEncrypter(c, IV)&#xA;&#xA;    // 存储密码, 必须与块体的长度相同&#xA;    ciphertext := make([]byte, len(content))&#xA;&#xA;    // 流化, 必须与块体的长度相同&#xA;    cfb.XORKeyStream(ciphertext, content)&#xA;&#xA;    // 输出&#xA;    fmt.Println(string(content), ciphertext)&#xA;&#xA;    // ------------------------------------- //&#xA;&#xA;    // 解密模式 (ECB、CBC、CFB、OFB)&#xA;    // 也就是说，解密的时候也需要加密时的密钥与偏移量&#xA;    cfbdec := cipher.NewCFBDecrypter(c, IV)&#xA;&#xA;    // 存储数据, 必须与块体的长度相同&#xA;    plaintextCopy := make([]byte, len(content))&#xA;&#xA;    // 流化, 必须与块体的长度相同&#xA;    cfbdec.XORKeyStream(plaintextCopy, ciphertext)&#xA;&#xA;    // 输出&#xA;    fmt.Println(ciphertext, string(plaintextCopy))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Base64/Base32编码&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。&#xA;Base64编码可用于在HTTP环境下传递较长的标识信息。例如在Java Persistence系统Hibernate中&#xA;就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串用作HTTP表单和HTTP GET URL中的参数。&#xA;在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。&#xA;此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Base64编码说明&#xA;Base64编码要求把3个8位字节(3*8=24)转化为4个6位的字节(4*6=24)之后在6位的前面补两个0,形成8位一个字节的形式。&#xA;如果剩下的字符不足3个字节,则用0填充,输出字符使用&#39;=&#39;,因此编码后输出的文本末尾可能会出现1或2个&#39;=&#39;。&#xA;为了保证所输出的编码位可读字符,Base64制定了一个编码表,以便进行统一转换.编码表的大小为2^6=64,这也是Base64名称的由来。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;0   A   16  Q   32  g   48  w&#xA;1   B   17  R   33  h   49  x&#xA;2   C   18  S   34  i   50  y&#xA;3   D   19  T   35  j   51  z&#xA;4   E   20  U   36  k   52  0&#xA;5   F   21  V   37  l   53  1&#xA;6   G   22  W   38  m   54  2&#xA;7   H   23  X   39  n   55  3&#xA;8   I   24  Y   40  o   56  4&#xA;9   J   25  Z   41  p   57  5&#xA;10  K   26  a   42  q   58  6&#xA;11  L   27  b   43  r   59  7&#xA;12  M   28  c   44  s   60  8&#xA;13  N   29  d   45  t   61  9&#xA;14  O   30  e   46  u   62  +&#xA;15  P   31  f   47  v   63  /&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;编码内容: `&amp;quot;&#39;www.baidu.com&#39;,&#39;www.sina.com&#39;&amp;quot;`,!@#$%^&amp;amp;*(){}[]?&amp;lt;&amp;gt;.&#xA;编码结果: YCInd3d3LmJhaWR1LmNvbScsJ3d3dy5zaW5hLmNvbSciYCwhQCMkJV4mKigpe31bXT88Pi4=&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    // &amp;quot;encoding/base32&amp;quot;&#xA;    &amp;quot;encoding/base64&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func base64Encode(src []byte) []byte {&#xA;    return []byte(base64.StdEncoding.EncodeToString(src))&#xA;}&#xA;&#xA;func base64Decode(src []byte) ([]byte, error) {&#xA;    return base64.StdEncoding.DecodeString(string(src))&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    nljb := &amp;quot;www.nljb.net&amp;quot;&#xA;    debyte := base64Encode([]byte(nljb))&#xA;    fmt.Println(string(debyte))&#xA;&#xA;    srbyte, err := base64Decode(debyte)&#xA;    fmt.Println(string(srbyte), err)&#xA;&#xA;}&#xA;&#xA;// 输出&#xA;d3d3Lm5samIubmV0&#xA;www.nljb.net &amp;lt;nil&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Gob编码&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gob是Golang包自带的一个数据结构序列化的编码/解码工具。&#xA;编码使用Encoder，解码使用Decoder。&#xA;一种典型的应用场景就是RPC(remote procedure calls)。&#xA;gob和json的pack之类的方法一样，由发送端使用Encoder对数据结构进行编码。&#xA;在接收端收到消息之后，接收端使用Decoder将序列化的数据变化成本地变量。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;bytes&amp;quot;&#xA;    &amp;quot;encoding/gob&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;type P struct {&#xA;    X, Y, Z int&#xA;    Name    string&#xA;}&#xA;&#xA;type Q struct {&#xA;    X, Y *int32&#xA;    Name string&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    var network bytes.Buffer       &#xA;    enc := gob.NewEncoder(&amp;amp;network)&#xA;    dec := gob.NewDecoder(&amp;amp;network)&#xA;    // Encode (send) the value.&#xA;    err := enc.Encode(P{3, 4, 5, &amp;quot;Pythagoras&amp;quot;})&#xA;    if err != nil {&#xA;        log.Fatal(&amp;quot;encode error:&amp;quot;, err)&#xA;    }&#xA;    // Decode (receive) the value.&#xA;    var q Q&#xA;    err = dec.Decode(&amp;amp;q)&#xA;    if err != nil {&#xA;        log.Fatal(&amp;quot;decode error:&amp;quot;, err)&#xA;    }&#xA;    fmt.Println(q)&#xA;    fmt.Printf(&amp;quot;%q: {%d,%d}\n&amp;quot;, q.Name, *q.X, *q.Y)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;UrlEncode编码&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;将字符串以 URL 编码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;编码内容: http://www.baidu.com/p/home/index.html&#xA;编码结果: http%3a%2f%2fwww.baidu.com%2fp%2fhome%2findex.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Hex编码/十六进制编码&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;将字符串以 十六进制 编码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;编码内容: www.baidu.com&#xA;编码结果: 7777772e62616964752e636f6d20&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android的Activity切换动画特效库SwitchLayout</title>
      <link>http://www.nljb.net/default/Android%E7%9A%84Activity%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88%E5%BA%93SwitchLayout/</link>
      <pubDate>2015-06-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SwitchLayout&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.导入SwitchLayout1.0.jar或者下载开源库。&#xA;&#xA;2.每个Activity实现接口implements SwichLayoutInterFace。&#xA;&#xA;推荐这种用法；接口里分别实现2个方法：&#xA;&#xA;    setEnterSwichLayout();&#xA;    setExitSwichLayout();&#xA;    // 这两个方法分别是设置进入Activity动画和离开Activity的动画的。&#xA;&#xA;在onCreate()里调用setEnterSwichLayout();&#xA;&#xA;在关闭Activity操作里调用setExitSwichLayout();&#xA;&#xA;如果需要的话在onKeyDown里拦截返回按键，调用setExitSwichLayout();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;SwitchLayout 的1.0jar包下载地址和Demo下载地址：http://pan.baidu.com/s/1dD6baLV&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android的Activity切换动画特效库SwitchLayout/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之注解式框架及Butterknife的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8F%8AButterknife%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-06-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;注解式框架&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;什么是注解式开发:&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;JDK1.5后支持注解方式,想用注解式开发,就要自定义注解&#xA;&#xA;结构:&#xA;    @+注解名(也可以叫类名)+传递的属性值,key和value,&#xA;    可设置目标范围:方法(Method)、属性(Filed)、类(Type)&#xA;&#xA;自定义注解要用到&#xA;    @interface:用于定义注解;&#xA;    @Target:用于描述注解的使用范围;&#xA;    @Retention: 注解的生命周期,一般RetentionPolicy.RUNTIME&#xA;&#xA;在Android中使用一般是简化代码,提升开发效率,清晰简介&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;流的注解式框架有Dagger、ButerKnife、AndroidAnnotations。&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;AndroidAnnotations是一个利用注解方式来简化代码结构,提高开发效率的开源框架。&#xA;    一，配置麻烦,需要在项目清单里注册生成的子类。&#xA;    二，反射机制会占用资源内存和耗时。&#xA;&#xA;ButerKnife用起来方便,配置简单,强大的View注入绑定和简单的常用方法注解。&#xA;&#xA;Dagger采用预编译技术,高效,但是对View绑定操作注解不是很方便。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ButerKnife特点:&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;强大方便的处理View绑定和Click事件,简化代码,提升开发效率&#xA;&#xA;方便的处理ListView的Adapter里的ViewHolder绑定问题 &#xA;&#xA;运行时不会影响APP效率,使用配置方便&#xA;&#xA;代码思路清晰,可读性强&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;View绑定:&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;onCreate里注册:&#xA;    ButerKnife.inject(this);&#xA;&#xA;Activity声明绑定控件,例如:&#xA;    @InjectView(R.id.title)&#xA;    TextView title;&#xA;&#xA;onclick等事件处理: 例如:&#xA;    @OnClick(R.id.submit) &#xA;    public void sayHi(Button button){&#xA;        button.setText(&amp;quot;Hello!&amp;quot;);   &#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@InjectView(R.id.arc_progress)&#xA;ArcProgress arcProgress;&#xA;&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    // Init&#xA;    ButterKnife.inject(this);&#xA;}&#xA;&#xA;@OnClick(R.id.arc_progress)&#xA;public void initProgress() {&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;用ListView展示一个列表数据，每个Item里含有一个Button，可以点击&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@OnItemSelected(R.id.list_view)&#xA;void onItemSelected(int position) {&#xA;  // TODO ...&#xA;}&#xA;&#xA;@OnItemSelected(value = R.id.maybe_missing, callback = NOTHING_SELECTED)&#xA;void onNothingSelected() {&#xA;  // TODO ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@Override&#xA;public View getView(final int position, View convertView, ViewGroup parent) {&#xA;    ConfigViewHolder configViewHolder = null;&#xA;    if (convertView == null) {&#xA;        convertView = View.inflate(context, R.layout.adapter_config, null);&#xA;        configViewHolder = new ConfigViewHolder(convertView);&#xA;        convertView.setTag(configViewHolder);&#xA;    } else {&#xA;        configViewHolder = (ConfigViewHolder) convertView.getTag();&#xA;    }&#xA;    ......&#xA;} &#xA;&#xA;// ViewHolder&#xA;class ConfigViewHolder {&#xA;&#xA;    @InjectView(R.id.item_status)&#xA;    ImageView item_status;&#xA;&#xA;    @InjectView(R.id.item_description)&#xA;    TextView item_description;&#xA;&#xA;    public ConfigViewHolder(View view) {&#xA;        ButterKnife.inject(this, view);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;在Fragegment中使用, 注解框架&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class FancyFragment extends Fragment {&#xA;  @InjectView(R.id.button1) Button button1;&#xA;  @InjectView(R.id.button2) Button button2;&#xA;&#xA;  @Override View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {&#xA;    View view = inflater.inflate(R.layout.fancy_fragment, container, false);&#xA;    ButterKnife.inject(this, view);&#xA;    // TODO Use &amp;quot;injected&amp;quot; views...&#xA;    return view;&#xA;  }&#xA;}&#xA;&#xA;@Override void onDestroyView() {&#xA;    super.onDestroyView();&#xA;    ButterKnife.reset(this);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;By default, both @InjectView and listener injections are required. An exception will be thrown if the target view cannot be found.&#xA;&#xA;To suppress this behavior and create an optional injection, add the @Optional annotation to the field or method.&#xA;&#xA;@Optional @InjectView(R.id.might_not_be_there) TextView mightNotBeThere;&#xA;&#xA;@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() {&#xA;  // TODO ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Custom views can bind to their own listeners by not specifying an ID.&#xA;&#xA;public class FancyButton extends Button {&#xA;  @OnClick&#xA;  public void onClick() {&#xA;    // TODO do something!&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;butterknife-7.0.1 发布，有些使用方法变更&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class ExampleActivity extends Activity {&#xA;  @Bind(R.id.title) TextView title;&#xA;  @Bind(R.id.subtitle) TextView subtitle;&#xA;  @Bind(R.id.footer) TextView footer;&#xA;&#xA;  @Override public void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.simple_activity);&#xA;    ButterKnife.bind(this);&#xA;    // TODO Use fields...&#xA;  }&#xA;}&#xA;&#xA;public void bind(ExampleActivity activity) {&#xA;  activity.subtitle = (android.widget.TextView) activity.findViewById(2130968578);&#xA;  activity.footer = (android.widget.TextView) activity.findViewById(2130968579);&#xA;  activity.title = (android.widget.TextView) activity.findViewById(2130968577);&#xA;}&#xA;&#xA;public class FancyFragment extends Fragment {&#xA;  @Bind(R.id.button1) Button button1;&#xA;  @Bind(R.id.button2) Button button2;&#xA;&#xA;  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {&#xA;    View view = inflater.inflate(R.layout.fancy_fragment, container, false);&#xA;    ButterKnife.bind(this, view);&#xA;    // TODO Use fields...&#xA;    return view;&#xA;  }&#xA;}&#xA;&#xA;public class MyAdapter extends BaseAdapter {&#xA;  @Override public View getView(int position, View view, ViewGroup parent) {&#xA;    ViewHolder holder;&#xA;    if (view != null) {&#xA;      holder = (ViewHolder) view.getTag();&#xA;    } else {&#xA;      view = inflater.inflate(R.layout.whatever, parent, false);&#xA;      holder = new ViewHolder(view);&#xA;      view.setTag(holder);&#xA;    }&#xA;&#xA;    holder.name.setText(&amp;quot;John Doe&amp;quot;);&#xA;    // etc...&#xA;&#xA;    return view;&#xA;  }&#xA;&#xA;  static class ViewHolder {&#xA;    @Bind(R.id.title) TextView name;&#xA;    @Bind(R.id.job_title) TextView jobTitle;&#xA;&#xA;    public ViewHolder(View view) {&#xA;      ButterKnife.bind(this, view);&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之layout_weight介绍</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8Blayout_weight%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-06-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;追加&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;weightSum&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在LinearLayout的XML中，android:weightSum=“5”，表示这个LinearLayout总共平分成5块大小区域；&#xA;&#xA;然后再LinearLayout里面的控件，使用android:layout_wetght=“1”，这表示它占用整个布局的1/5。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;也就是，父容器使用android:weightSum平分块，然后在子容器中使用layout_wetght设置该容器占用的比例&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Layout_开头都是交给父容器，没有Layout_开头都是本身的属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;layout_weight&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;首先看一下Layout_weight属性的作用：它是用来分配剩余空间的一个属性，你可以设置他的权重。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;转自：&lt;a href=&#34;http://blog.csdn.net/xiechengfa/article/details/38334327&#34;&gt;http://blog.csdn.net/xiechengfa/article/details/38334327&lt;/a&gt; 有修正, 感谢&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;     &#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;     &#xA;    android:orientation=&amp;quot;vertical&amp;quot;     &#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;     &#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;     &#xA;    &amp;gt;     &#xA;&amp;lt;EditText     &#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;     &#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;     &#xA;    android:gravity=&amp;quot;left&amp;quot;     &#xA;    android:text=&amp;quot;one&amp;quot;/&amp;gt;     &#xA;&amp;lt;EditText     &#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;     &#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;     &#xA;    android:gravity=&amp;quot;center&amp;quot;     &#xA;    android:layout_weight=&amp;quot;1.0&amp;quot;     &#xA;    android:text=&amp;quot;two&amp;quot;/&amp;gt;     &#xA;    &amp;lt;EditText     &#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;     &#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;     &#xA;    android:gravity=&amp;quot;right&amp;quot;     &#xA;    android:text=&amp;quot;three&amp;quot;/&amp;gt;     &#xA;&amp;lt;/LinearLayout&amp;gt;   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之layout_weight介绍/1.png&#34; alt=&#34;&#34; width=&#34;500&#34; hight=&#34;800&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;看上面代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;只有Button2使用了Layout_weight属性，并赋值为了1，而Button1和Button3没有设置Layout_weight这个属性，根据API，可知，他们默认是0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;下面我就来讲，Layout_weight这个属性的真正的意思：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Android系统先按照你设置的3个Button高度Layout_height值wrap_content,给你分配好他们3个的高度&#xA;&#xA;然后会把剩下来的屏幕空间全部赋给Button2,因为只有他的权重值是1，这也是为什么Button2占了那么大的一块空间。&#xA;&#xA;有了以上的理解我们就可以对网上关于Layout_weight这个属性更让人费解的效果有一个清晰的认识了。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;？xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;？&amp;gt;   &#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;   &#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;   &#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;   &#xA;    android:orientation=&amp;quot;horizontal&amp;quot; &amp;gt;   &#xA;    &amp;lt;TextView   &#xA;    android:background=&amp;quot;＃ff0000&amp;quot;   &#xA;    android:layout_width=&amp;quot;**&amp;quot;   &#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;   &#xA;    android:text=&amp;quot;1&amp;quot;   &#xA;    android:textColor=&amp;quot;＠android:color/white&amp;quot;   &#xA;    android:layout_weight=&amp;quot;1&amp;quot;/&amp;gt;   &#xA;    &amp;lt;TextView   &#xA;    android:background=&amp;quot;＃cccccc&amp;quot;   &#xA;    android:layout_width=&amp;quot;**&amp;quot;   &#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;   &#xA;    android:text=&amp;quot;2&amp;quot;   &#xA;    android:textColor=&amp;quot;＠android:color/black&amp;quot;   &#xA;    android:layout_weight=&amp;quot;2&amp;quot; /&amp;gt;   &#xA;     &amp;lt;TextView   &#xA;    android:background=&amp;quot;＃ddaacc&amp;quot;   &#xA;    android:layout_width=&amp;quot;**&amp;quot;   &#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;   &#xA;    android:text=&amp;quot;3&amp;quot;   &#xA;    android:textColor=&amp;quot;＠android:color/black&amp;quot;   &#xA;    android:layout_weight=&amp;quot;3&amp;quot; /&amp;gt;   &#xA;&amp;lt;/LinearLayout&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;三个文本框的都是 layout_width=“wrap_content ”时，会得到以下效果&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之layout_weight介绍/2.jpg&#34; alt=&#34;&#34; width=&#34;400&#34; hight=&#34;100&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;按照上面的理解，系统先给3个TextView分配他们的宽度值wrap_content（宽度足以包含他们的内容1,2,3即可）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后会把剩下来的屏幕空间按照1:2:3的比列分配给3个textview，所以就出现了上面的图像。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;而当layout_width=“fill_parent”时，如果分别给三个TextView设置他们的Layout_weight为1、2、2的话，就会出现下面的效果：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之layout_weight介绍/3.jpg&#34; alt=&#34;&#34; width=&#34;400&#34; hight=&#34;100&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;你会发现1的权重小，反而分的多了，这是为什么呢？？？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;网上很多人说是当layout_width=“fill_parent”时，weighth值越小权重越大，优先级越高，就好像在背口诀&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之android:padding和android:layout_margin的区别</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8Bandroid-padding%E5%92%8Candroid-layout_margin%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2015-06-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;android:padding和android:layout_margin&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之android:padding和android:layout_margin的区别/2.jpg&#34; alt=&#34;&#34; width=&#34;400&#34; hight=&#34;300&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;android:layout_margin就是设置view的上下左右边框的额外空间&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;android:padding是设置内容相对view的边框的距离&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在LinearLayout、RelativeLayout、TableLayout中，这2个属性都是设置都是有效的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在FrameLayout中，android:layout_margin是无效的，因为FrameLayout里面的元素都是从左上角开始绘制的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在AbsoluteLayout中，没有android:layout_margin属性&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之android:padding和android:layout_margin的区别/1.png&#34; alt=&#34;&#34; width=&#34;300&#34; hight=“500” &gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;padding是站在父view的角度描述问题 [ ˈpædɪŋ ]&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;它规定它里面的内容必须与这个父view边界的距离。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;margin则是站在自己的角度描述问题 [ˈmɑ:dʒɪn]&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;规定自己和其他（上下左右）的view之间的距离，如果同一级只有一个view，那么它的效果基本上就和padding一样了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;gravity&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;属性是对该view 内容的限定．比如一个button 上面的text. 你可以设置该text 在view的靠左，靠右等位置．该属性就干了这个．&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;layout_gravity&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;是用来设置该view相对与起父view 的位置．比如一个button 在linearlayout里，你想把该button放在靠左, 靠右等位置就可以通过该属性设置．&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这样就解释了，有什么我们弄个最外布局，然后里面包了几个布局，如果要使这几个布局都靠底&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就可以在最外布局的属性里设置gravity=”botton” 因为gravity是对里面的内容起作用．&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之动态生成View的ID</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90View%E7%9A%84ID/</link>
      <pubDate>2015-06-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;动态生成View-ID&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;为什么需要ID, 因为在replaceFragment等操作时需要使用ID&#xA;// 设置的ID与R.id.xxx相同，代表这个View的唯一标识&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // 初始化&#xA;    layout = new MySwipeRefreshLayout(getActivity());&#xA;// 这里需要设置一个ID给该View对象&#xA;    layout.setId(this.generateViewId());&#xA;    ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(&#xA;            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);&#xA;    layout.setLayoutParams(layoutParams);&#xA;    // 下拉更新&#xA;    layout.setColorSchemeResources(android.R.color.holo_blue_dark,&#xA;            android.R.color.holo_blue_light,&#xA;            android.R.color.holo_green_light,&#xA;            android.R.color.holo_green_light);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// replace Fragment&#xA;public void replaceFragment(int viewId, android.app.Fragment fragment) {&#xA;    FragmentTransaction transaction = getFragmentManager().beginTransaction();&#xA;    transaction.replace(viewId, fragment);&#xA;    transaction.commit();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    /**&#xA;     * An {@code int} value that may be updated atomically.&#xA;     */&#xA;    private static final AtomicInteger sNextGeneratedId = new AtomicInteger(1);&#xA;&#xA;    /**&#xA;     * 动态生成View ID&#xA;     * API LEVEL 17 以上View.generateViewId()生成&#xA;     * API LEVEL 17 以下需要手动生成&#xA;     */&#xA;    public static int generateViewId() {&#xA;&#xA;    if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.JELLY_BEAN_MR1) {&#xA;        for (; ; ) {&#xA;        final int result = sNextGeneratedId.get();&#xA;        // aapt-generated IDs have the high byte nonzero; clamp to the range under that.&#xA;        int newValue = result + 1;&#xA;        if (newValue &amp;gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.&#xA;        if (sNextGeneratedId.compareAndSet(result, newValue)) {&#xA;            return result;&#xA;        }&#xA;        }&#xA;    } else {&#xA;        return View.generateViewId();&#xA;    }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之圆形进度条-CircleProgress</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1-CircleProgress/</link>
      <pubDate>2015-06-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Android之圆形进度条-CircleProgress/show.png&#34; alt=&#34;&#34; width=&#34;500&#34; hight=&#34;300&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/lzyzsd/CircleProgress&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dependencies {&#xA;    compile &#39;com.github.lzyzsd:circleprogress:1.1.0@aar&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    &amp;lt;com.github.lzyzsd.circleprogress.DonutProgress&#xA;    android:layout_marginLeft=&amp;quot;50dp&amp;quot;&#xA;    android:id=&amp;quot;@+id/donut_progress&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    custom:donut_progress=&amp;quot;30&amp;quot;/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之上拉面板库-AndroidSlidingUpPanel</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E4%B8%8A%E6%8B%89%E9%9D%A2%E6%9D%BF%E5%BA%93-AndroidSlidingUpPanel/</link>
      <pubDate>2015-06-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Android之上拉面板库-AndroidSlidingUpPanel/show.png&#34; alt=&#34;&#34; width=&#34;700&#34; hight=&#34;300&#34; &gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;https://github.com/umano/AndroidSlidingUpPanel&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dependencies {&#xA;    repositories {&#xA;    mavenCentral()&#xA;    }&#xA;    compile &#39;com.sothree.slidinguppanel:library:3.0.0&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;SlidingUpPanelLayout slidingUpPanelLayout = (SlidingUpPanelLayout) findViewById(R.id.sliding_layout);&#xA;slidingUpPanelLayout.setPanelSlideListener(new SlidingUpPanelLayout.PanelSlideListener() {&#xA;    @Override&#xA;    public void onPanelSlide(View view, float v) {&#xA;&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onPanelCollapsed(View view) {&#xA;    // 向下移动，图标变成向下&#xA;    ImageView imageView = (ImageView) findViewById(R.id.menuUpward);&#xA;    imageView.setImageResource(R.drawable.directional_up);&#xA;&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onPanelExpanded(View view) {&#xA;    // 向下移动，图标变成向上&#xA;    ImageView imageView = (ImageView) findViewById(R.id.menuUpward);&#xA;    imageView.setImageResource(R.drawable.directional_down);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onPanelAnchored(View view) {&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onPanelHidden(View view) {&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:custom=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;0dp&amp;quot;&#xA;    android:layout_weight=&amp;quot;1&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;com.sothree.slidinguppanel.SlidingUpPanelLayout xmlns:sothree=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;        android:id=&amp;quot;@+id/sliding_layout&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;        android:gravity=&amp;quot;bottom&amp;quot;&#xA;        sothree:umanoDragView=&amp;quot;@+id/dragView&amp;quot;&#xA;        sothree:umanoOverlay=&amp;quot;true&amp;quot;&#xA;        sothree:umanoPanelHeight=&amp;quot;68dp&amp;quot;&#xA;        sothree:umanoParalaxOffset=&amp;quot;100dp&amp;quot;&#xA;        sothree:umanoShadowHeight=&amp;quot;4dp&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;!-- MAIN CONTENT --&amp;gt;&#xA;        &amp;lt;LinearLayout&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_weight=&amp;quot;1&amp;quot;&#xA;        android:background=&amp;quot;#2b6cb8&amp;quot;&#xA;        android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;com.github.lzyzsd.circleprogress.ArcProgress&#xA;            android:id=&amp;quot;@+id/arc_progress&amp;quot;&#xA;            android:layout_width=&amp;quot;200dp&amp;quot;&#xA;            android:layout_height=&amp;quot;200dp&amp;quot;&#xA;            android:layout_centerHorizontal=&amp;quot;true&amp;quot;&#xA;            android:layout_centerVertical=&amp;quot;true&amp;quot;&#xA;            android:background=&amp;quot;#00ffffff&amp;quot;&#xA;            custom:arc_bottom_text=&amp;quot;德纳科技&amp;quot;&#xA;            custom:arc_finished_color=&amp;quot;#FFFFFFFF&amp;quot;&#xA;            custom:arc_progress=&amp;quot;0&amp;quot;&#xA;            custom:arc_text_color=&amp;quot;#FFFFFFFF&amp;quot;&#xA;            custom:arc_unfinished_color=&amp;quot;#5576B6&amp;quot;&#xA;            android:layout_gravity=&amp;quot;center_horizontal&amp;quot;&#xA;            android:layout_margin=&amp;quot;50dp&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;ListView&#xA;            android:id=&amp;quot;@+id/list_keys&amp;quot;&#xA;            android:background=&amp;quot;#ffffff&amp;quot;&#xA;            android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;            android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;            android:layout_gravity=&amp;quot;center_horizontal|top&amp;quot;&amp;gt;&amp;lt;/ListView&amp;gt;&#xA;&#xA;        &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;        &amp;lt;!-- SLIDING LAYOUT --&amp;gt;&#xA;        &amp;lt;LinearLayout&#xA;        android:id=&amp;quot;@+id/dragView&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;        android:background=&amp;quot;#ffffff&amp;quot;&#xA;        android:clickable=&amp;quot;true&amp;quot;&#xA;        android:focusable=&amp;quot;false&amp;quot;&#xA;        android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;            android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;            android:layout_height=&amp;quot;68dp&amp;quot;&#xA;            android:background=&amp;quot;@drawable/menu_mask&amp;quot;&#xA;            android:gravity=&amp;quot;center&amp;quot;&#xA;            android:text=&amp;quot;正在检查 ...&amp;quot;&#xA;            android:textSize=&amp;quot;16sp&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;ListView&#xA;            android:id=&amp;quot;@+id/list_values&amp;quot;&#xA;            android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;            android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&amp;lt;/ListView&amp;gt;&#xA;&#xA;        &amp;lt;/LinearLayout&amp;gt;&#xA;    &amp;lt;/com.sothree.slidinguppanel.SlidingUpPanelLayout&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之Reflect使用介绍</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BReflect%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-05-27 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;reflect&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;reflect库的godoc在&lt;a href=&#34;http://golang.org/pkg/reflect/&#34;&gt;http://golang.org/pkg/reflect/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;reflect包有两个数据类型我们必须知道，一个是Type，一个是Value。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Type就是定义的类型的一个数据类型，Value是值的类型&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;)&#xA;&#xA;type MyStruct struct {&#xA;    name string&#xA;}&#xA;&#xA;func (this *MyStruct) GetName(str string) string {&#xA;    this.name = str&#xA;    return this.name&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    // 备注: reflect.Indirect -&amp;gt; 如果是指针则返回 Elem()&#xA;    // 首先，reflect包有两个数据类型我们必须知道，一个是Type，一个是Value。&#xA;    // Type就是定义的类型的一个数据类型，Value是值的类型&#xA;&#xA;    // 对象&#xA;    s := &amp;quot;this is string&amp;quot;&#xA;&#xA;    // 获取对象类型 (string)&#xA;    fmt.Println(reflect.TypeOf(s))&#xA;&#xA;    // 获取对象值 (this is string)&#xA;    fmt.Println(reflect.ValueOf(s))&#xA;&#xA;    // 对象&#xA;    var x float64 = 3.4&#xA;&#xA;    // 获取对象值 (&amp;lt;float64 Value&amp;gt;)&#xA;    fmt.Println(reflect.ValueOf(x))&#xA;&#xA;    // 对象&#xA;    a := &amp;amp;MyStruct{name: &amp;quot;nljb&amp;quot;}&#xA;&#xA;    // 返回对象的方法的数量 (1)&#xA;    fmt.Println(reflect.TypeOf(a).NumMethod())&#xA;&#xA;    // 遍历对象中的方法&#xA;    for m := 0; m &amp;lt; reflect.TypeOf(a).NumMethod(); m++ {&#xA;        method := reflect.TypeOf(a).Method(m)&#xA;        fmt.Println(method.Type)         // func(*main.MyStruct) string&#xA;        fmt.Println(method.Name)         // GetName&#xA;        fmt.Println(method.Type.NumIn()) // 参数个数&#xA;        fmt.Println(method.Type.In(1))   // 参数类型&#xA;    }&#xA;&#xA;    // 获取对象值 (&amp;lt;*main.MyStruct Value&amp;gt;)&#xA;    fmt.Println(reflect.ValueOf(a))&#xA;&#xA;    // 获取对象名称&#xA;    fmt.Println(reflect.Indirect(reflect.ValueOf(a)).Type().Name())&#xA;&#xA;    // 参数&#xA;    i := &amp;quot;Hello&amp;quot;&#xA;    v := make([]reflect.Value, 0)&#xA;    v = append(v, reflect.ValueOf(i))&#xA;&#xA;    // 通过对象值中的方法名称调用方法 ([nljb]) (返回数组因为Go支持多值返回)&#xA;    fmt.Println(reflect.ValueOf(a).MethodByName(&amp;quot;GetName&amp;quot;).Call(v))&#xA;&#xA;    // 通过对值中的子对象名称获取值 (nljb)&#xA;    fmt.Println(reflect.Indirect(reflect.ValueOf(a)).FieldByName(&amp;quot;name&amp;quot;))&#xA;&#xA;    // 是否可以改变这个值 (false)&#xA;    fmt.Println(reflect.Indirect(reflect.ValueOf(a)).FieldByName(&amp;quot;name&amp;quot;).CanSet())&#xA;&#xA;    // 是否可以改变这个值 (true)&#xA;    fmt.Println(reflect.Indirect(reflect.ValueOf(&amp;amp;(a.name))).CanSet())&#xA;&#xA;    // 不可改变 (false)&#xA;    fmt.Println(reflect.Indirect(reflect.ValueOf(s)).CanSet())&#xA;&#xA;    // 可以改变&#xA;    // reflect.Indirect(reflect.ValueOf(&amp;amp;s)).SetString(&amp;quot;jbnl&amp;quot;)&#xA;    fmt.Println(reflect.Indirect(reflect.ValueOf(&amp;amp;s)).CanSet())&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;获取 Struct 对象的 Tag&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Home struct {&#xA;    i int `nljb:&amp;quot;100&amp;quot;`&#xA;}&#xA;&#xA;func main() {&#xA;    home := new(Home)&#xA;    home.i = 5&#xA;    rcvr := reflect.ValueOf(home)&#xA;    typ := reflect.Indirect(rcvr).Type()&#xA;    fmt.Println(typ.Kind().String())&#xA;    x := typ.NumField()&#xA;    for i := 0; i &amp;lt; x; i++ {&#xA;        nljb := typ.Field(0).Tag.Get(&amp;quot;nljb&amp;quot;)&#xA;        fmt.Println(nljb)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;反射使用案例&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package server&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;&#xA;type Server struct {&#xA;    name    string&#xA;    rcvr    reflect.Value&#xA;    typ     reflect.Type&#xA;    methods map[string]*Method&#xA;}&#xA;&#xA;type Method struct {&#xA;    method reflect.Method&#xA;    json   bool&#xA;}&#xA;&#xA;func NewServer() *Server {&#xA;    server := new(Server)&#xA;    server.methods = make(map[string]*Method)&#xA;    return server&#xA;}&#xA;&#xA;func (this *Server) Start(port string) error {&#xA;    return http.ListenAndServe(port, this)&#xA;}&#xA;&#xA;func (this *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    for mname, mmethod := range this.methods {&#xA;        if strings.ToLower(&amp;quot;/&amp;quot;+this.name+&amp;quot;.&amp;quot;+mname) == r.URL.Path {&#xA;            if mmethod.json {&#xA;                returnValues := mmethod.method.Func.Call(&#xA;                    []reflect.Value{this.rcvr, reflect.ValueOf(w), reflect.ValueOf(r)})&#xA;                content := returnValues[0].Interface()&#xA;                if content != nil {&#xA;                    w.WriteHeader(500)&#xA;                    ...&#xA;                }&#xA;            } else {&#xA;                mmethod.method.Func.Call(&#xA;                    []reflect.Value{this.rcvr, reflect.ValueOf(w), reflect.ValueOf(r)})&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;/*&#xA;    func (this *Hello) JsonHello(r *http.Request) {}&#xA;    func (this *Hello) Hello(w http.ResponseWriter, r *http.Request) {}&#xA;*/&#xA;func (this *Server) Register(rcvr interface{}) error {&#xA;    this.typ = reflect.TypeOf(rcvr)&#xA;    this.rcvr = reflect.ValueOf(rcvr)&#xA;    this.name = reflect.Indirect(this.rcvr).Type().Name()&#xA;    if this.name == &amp;quot;&amp;quot; {&#xA;        return fmt.Errorf(&amp;quot;no service name for type &amp;quot;, this.typ.String())&#xA;    }&#xA;    for m := 0; m &amp;lt; this.typ.NumMethod(); m++ {&#xA;        method := this.typ.Method(m)&#xA;        mtype := method.Type&#xA;        mname := method.Name&#xA;        if strings.HasPrefix(mname, &amp;quot;Json&amp;quot;) {&#xA;            if mtype.NumIn() != 2 {&#xA;                return fmt.Errorf(&amp;quot;method %s has wrong number of ins: %d&amp;quot;, mname, mtype.NumIn())&#xA;            }&#xA;            arg := mtype.In(1)&#xA;            if arg.String() != &amp;quot;*http.Request&amp;quot; {&#xA;                return fmt.Errorf(&amp;quot;%s argument type not exported: %s&amp;quot;, mname, arg)&#xA;            }&#xA;            this.methods[mname] = &amp;amp;Method{method, true}&#xA;        } else {&#xA;            if mtype.NumIn() != 3 {&#xA;                return fmt.Errorf(&amp;quot;method %s has wrong number of ins: %d&amp;quot;, mname, mtype.NumIn())&#xA;            }&#xA;            reply := mtype.In(1)&#xA;            if reply.String() != &amp;quot;http.ResponseWriter&amp;quot; {&#xA;                return fmt.Errorf(&amp;quot;%s argument type not exported: %s&amp;quot;, mname, reply)&#xA;            }&#xA;            arg := mtype.In(2)&#xA;            if arg.String() != &amp;quot;*http.Request&amp;quot; {&#xA;                return fmt.Errorf(&amp;quot;%s argument type not exported: %s&amp;quot;, mname, arg)&#xA;            }&#xA;            this.methods[mname] = &amp;amp;Method{method, false}&#xA;        }&#xA;    }&#xA;    return nil&#xA;}&#xA;&#xA;// ... //&#xA;&#xA;type Hello struct {&#xA;}&#xA;&#xA;func (this *Hello) Print(w http.ResponseWriter, r *http.Request) map[string]interface{} {&#xA;    w.Write([]byte(&amp;quot;print&amp;quot;))&#xA;    return nil&#xA;}&#xA;&#xA;func (this *Hello) Hello(w http.ResponseWriter, r *http.Request) {&#xA;    w.Write([]byte(&amp;quot;hello&amp;quot;))&#xA;}&#xA;&#xA;func (this *Hello) JsonHello(r *http.Request) {&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    server := NewServer()&#xA;    fmt.Println(server.Register(new(Hello)))&#xA;    server.Start(&amp;quot;:8080&amp;quot;)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之RPC介绍</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BRPC%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-05-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;RPC&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;标准库的RPC&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;RPC是远程调用的简称, 简单的说就是要像调用本地函数一样调用服务器的函数.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Go语言的标准库已经提供了RPC框架和不同的RPC实现.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;下面是一个服务器的例子&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Echo int&#xA;&#xA;func (t *Echo) Hi(args string, reply *string) error {&#xA;    *reply = &amp;quot;echo:&amp;quot; + args&#xA;    return nil&#xA;}&#xA;&#xA;func main() {&#xA;    rpc.Register(new(Echo))&#xA;    rpc.HandleHTTP()&#xA;    l, e := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:1234&amp;quot;)&#xA;    if e != nil {&#xA;    log.Fatal(&amp;quot;listen error:&amp;quot;, e)&#xA;    }&#xA;    http.Serve(l, nil)&#xA;}&#xA;&#xA;其中 rpc.Register 用于注册RPC服务, 默认的名字是对象的类型名字(这里是Echo).&#xA;&#xA;如果需要指定特殊的名字, 可以用 rpc.RegisterName 进行注册.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;被注册对象的类型所有满足以下规则的方法会被导出到RPC服务接口:&#xA;&#xA;func (t *T) MethodName(argType T1, replyType *T2) error&#xA;&#xA;// 也就是一个方法带有两个参数(类或类型)，第一个是接收参数，第二个返回参数（类或类型的指针）+ error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;被注册对应至少要有一个方法满足这个特征, 否则可能会注册失败.&#xA;&#xA;然后 rpc.HandleHTTP 用于指定 RPC 的传输协议, 这里是采用 http 协议作为RPC调用的载体.&#xA;&#xA;用户也可以用rpc.ServeConn接口, 定制自己的传输协议.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;客户端可以这样调用Echo.Hi接口:&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    client, err := rpc.DialHTTP(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:1234&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(&amp;quot;dialing:&amp;quot;, err)&#xA;    }&#xA;&#xA;    var args = &amp;quot;hello rpc&amp;quot;&#xA;    var reply string&#xA;    err = client.Call(&amp;quot;Echo.Hi&amp;quot;, args, &amp;amp;reply)&#xA;    if err != nil {&#xA;    log.Fatal(&amp;quot;arith error:&amp;quot;, err)&#xA;    }&#xA;    fmt.Printf(&amp;quot;Arith: %d*%d=%d\n&amp;quot;, args.A, args.B, reply)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;客户端先用rpc.DialHTTP和RPC服务器进行一个链接(协议必须匹配).&#xA;&#xA;然后通过返回的client对象进行远程函数调用. &#xA;&#xA;函数的名字是由client.Call 第一个参数指定(是一个字符串).&#xA;&#xA;基于HTTP的RPC调用一般是在调试时使用, 默认可以通过浏览&amp;quot;127.0.0.1:1234/debug/rpc&amp;quot;页面查看RPC的统计信息.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;基于 JSON 的 RPC 调用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Go的标准库还提供了一个&amp;quot;net/rpc/jsonrpc&amp;quot;包, 用于提供基于JSON编码的RPC支持.&#xA;&#xA;服务器部分只需要用rpc.ServeCodec指定json编码协议就可以了:&#xA;&#xA;func main() {&#xA;    lis, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:1234&amp;quot;)&#xA;    if err != nil {&#xA;    return err&#xA;    }&#xA;    defer lis.Close()&#xA;&#xA;    srv := rpc.NewServer()&#xA;    if err := srv.RegisterName(&amp;quot;Echo&amp;quot;, new(Echo)); err != nil {&#xA;    return err&#xA;    }&#xA;&#xA;    for {&#xA;    conn, err := lis.Accept()&#xA;    if err != nil {&#xA;        log.Fatalf(&amp;quot;lis.Accept(): %v\n&amp;quot;, err)&#xA;    }&#xA;    go srv.ServeCodec(jsonrpc.NewServerCodec(conn))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;客户端部分值需要用 jsonrpc.Dial 代替 rpc.Dial 就可以了:&#xA;&#xA;func main() {&#xA;    client, err := jsonrpc.DialHTTP(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:1234&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(&amp;quot;dialing:&amp;quot;, err)&#xA;    }&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Go语言的RPC客户端是一个使用简单, 而且功能强大的RPC库.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;基于标准的RPC库我们可以方便的定制自己的RPC实现(传输协议和串行化协议都可以定制).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以后有时间，我会分析一下RPC这个库，来了解一下具体的实现，而且内部使用了很多反射&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之EventBus的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BEventBus%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-05-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;EventBus&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;EventBus是一款针对Android优化的发布/订阅事件总线。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;主要功能是替代(Intent,Handler,BroadCast)在(Fragment,Activity,Service)线程之间传递消息.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;优点是开销小，代码更优雅。以及将发送者和接收者解耦。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;当在开发一些庞大的的项目时，模块比较多，这个时候为了避免耦合度和保证 APP 的效率&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;会用到 EventBus 等类似的事件总线处理模型。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这样可以简化一些数据传输操作，保证APP的简洁，做到高内聚、低耦合。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之EventBus的使用/EventBus-Publish-Subscribe.png&#34; alt=&#34;&#34; width=&#34;600&#34; hight=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;EventBus&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;源码: https://github.com/greenrobot/EventBus&#xA;Gradle: compile &#39;de.greenrobot:eventbus:2.4.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;基本用法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 分订阅，注册，发布，取消注册&#xA;EventBus.getDefault().register(this);&#xA;EventBus.getDefault().register(new MyClass());&#xA;&#xA;// 三个参数分别是：消息订阅者（接收者），接收方法名，事件类&#xA;EventBus.getDefault().register(this, &amp;quot;setTextA&amp;quot;, SetTextAEvent.class);&#xA;&#xA;// 取消注册&#xA;EventBus.getDefault().unregister(this);&#xA;EventBus.getDefault().unregister(new MyClass());&#xA;&#xA;// 订阅处理数据&#xA;public void onEventMainThread{}&#xA;public void onEvent(AnyEventType event){}&#xA;onEventPostThread, onEventBackgroundThread, onEventAsync&#xA;&#xA;// 发布&#xA;EventBus.getDefault().postSticky(new SecondActivityEvent(&amp;quot;Message From SecondActivity&amp;quot;));&#xA;EventBus.getDefault().post(new ChangelmgEvent(1));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Event&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class Event extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    // 注册&#xA;    EventBus.getDefault().register(this);&#xA;    }&#xA;&#xA;    // 发送&#xA;    private void postData() {&#xA;        String str = &amp;quot;Hello World&amp;quot;;&#xA;        // 发送数据，可以是一个类型或者一个类&#xA;        EventBus.getDefault().post(str);&#xA;    }&#xA;&#xA;    // 接收&#xA;    public void onEvent(String str) {}&#xA;&#xA;    // 接收&#xA;    public void onEventMainThread(String str) {}&#xA;&#xA;    // 接收&#xA;    public void onEventPostThread(String str) {}&#xA;&#xA;    // 接收&#xA;    public void onEventBackgroundThread(String str) {}&#xA;&#xA;    // 接收&#xA;    public void onEventAsync(String str) {}&#xA;&#xA;    @Override&#xA;    protected void onDestroy() {&#xA;        super.onDestroy();&#xA;        // 取消注册&#xA;        EventBus.getDefault().unregister(this);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;使用方法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1、onEvent&#xA;2、onEventMainThread&#xA;3、onEventBackgroundThread&#xA;4、onEventAsync&#xA;&#xA;这四种订阅函数都是使用onEvent开头的，它们的功能稍有不同,在介绍不同之前先介绍两个概念：&#xA;&#xA;告知观察者事件发生时通过EventBus.post函数实现，这个过程叫做事件的发布&#xA;                    观察者被告知事件发生叫做事件的接收，是通过下面的订阅函数实现的。&#xA;&#xA;onEvent:&#xA;    如果使用onEvent作为订阅函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行&#xA;    也就是说发布事件和接收事件线程在同一个线程。&#xA;    使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。&#xA;&#xA;onEventMainThread:&#xA;    如果使用onEventMainThread作为订阅函数，那么不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行&#xA;    接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI&#xA;    所以在onEvnetMainThread方法中是不能执行耗时操作的。&#xA;&#xA;onEventBackground:&#xA;    如果使用onEventBackgrond作为订阅函数，那么如果事件是在UI线程中发布出来的&#xA;    那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的&#xA;    那么onEventBackground函数直接在该子线程中执行。&#xA;&#xA;onEventAsync：&#xA;    使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用重载机制进行收发不同对象&#xA;public void onEventMainThread(FirstEvent event) {  &#xA;    Log.d(&amp;quot;harvic&amp;quot;, &amp;quot;onEventMainThread收到了消息：&amp;quot; + event.getMsg());  &#xA;}  &#xA;&#xA;public void onEventMainThread(SecondEvent event) {  &#xA;    Log.d(&amp;quot;harvic&amp;quot;, &amp;quot;onEventMainThread收到了消息：&amp;quot; + event.getMsg());  &#xA;}  &#xA;&#xA;public void onEvent(ThirdEvent event) {  &#xA;    Log.d(&amp;quot;harvic&amp;quot;, &amp;quot;OnEvent收到了消息：&amp;quot; + event.getMsg());  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>mymysql与go-mysql-driver性能比较</title>
      <link>http://www.nljb.net/default/mymysql%E4%B8%8Ego-mysql-driver%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</link>
      <pubDate>2015-05-22 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;转自网络的比较文章&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;mymysql和go-mysql-driver是两个现在都很流行的go的mysql驱动&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 两个mysql驱动的下载地址：&#xA;https://github.com/ziutek/mymysql&#xA;http://code.google.com/p/go-mysql-driver/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;mymysql和go-mysql-driver的测试总结&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1 go-mysql-driver是实现了golang标准库database/sql的产物。底层实现比较有保证&#xA;2 go-mysql-driver虽然每个命令的运行时间比mymysql长，但是内存使用少得非常明显，这点两方算打平。&#xA;3 go-mysql-driver实现了database/sql，如果数据库换成其他的话，不需要更改应用逻辑的代码。&#xA;4 go-mysql-driver实现了database/sql，这个接口的设计也是非常好的，基本和php中的pdo一样，上手和学习成本低。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之动态代码布局的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-05-06 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;动态代码布局&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;所谓的动态代码布局，也就是不使用XML布局(或不完全使用XML布局)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // 动态代码布局&#xA;    @Override&#xA;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {&#xA;&#xA;    // 定义了一个 MySwipeRefreshLayout 的 Layout &#xA;    layout = new MySwipeRefreshLayout(getActivity());&#xA;&#xA;    // 设置ID &#xA;    layout.setId(this.generateViewId());&#xA;&#xA;    // 设置 LayoutParams&#xA;    ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(&#xA;        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);&#xA;    layout.setLayoutParams(layoutParams);&#xA;&#xA;    // 下拉更新&#xA;    layout.setColorScheme(android.R.color.holo_blue_dark,&#xA;        android.R.color.holo_blue_light,&#xA;        android.R.color.holo_green_light,&#xA;        android.R.color.holo_green_light);&#xA;&#xA;    return super.onCreateView(inflater, container, savedInstanceState);&#xA;&#xA;    }&#xA;&#xA;    // replace Fragment&#xA;    // 这里是个 Fragment 替换函数，想要替换 Fragment 就需要 View 的 ID&#xA;    // 所以上面使用了 generateViewId() 获取一个 ID 并且设置给 Fragment&#xA;    // 这里使用的时候只需要 Fragment.getID() 就可以了&#xA;    public void replaceFragment(int viewId, android.app.Fragment fragment) {&#xA;    FragmentTransaction transaction = getFragmentManager().beginTransaction();&#xA;    transaction.replace(viewId, fragment);&#xA;    transaction.commit();&#xA;    }&#xA;&#xA;    /**&#xA;     * An {@code int} value that may be updated atomically.&#xA;     */&#xA;    private static final AtomicInteger sNextGeneratedId = new AtomicInteger(1);&#xA;&#xA;    /**&#xA;     * 动态生成View ID&#xA;     * API LEVEL 17 以上View.generateViewId()生成&#xA;     * API LEVEL 17 以下需要手动生成&#xA;     */&#xA;    public static int generateViewId() {&#xA;&#xA;    if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.JELLY_BEAN_MR1) {&#xA;        for (; ; ) {&#xA;        final int result = sNextGeneratedId.get();&#xA;        // aapt-generated IDs have the high byte nonzero; clamp to the range under that.&#xA;        int newValue = result + 1;&#xA;        if (newValue &amp;gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.&#xA;        if (sNextGeneratedId.compareAndSet(result, newValue)) {&#xA;            return result;&#xA;        }&#xA;        }&#xA;    } else {&#xA;        return View.generateViewId();&#xA;    }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 简单布局LinearLayout&#xA;LinearLayout llayout = new LinearLayout(mContext);&#xA;llayout.setOrientation(LinearLayout.VERTICAL);&#xA;LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(&#xA;    LinearLayout.LayoutParams.MATCH_PARENT,&#xA;    LinearLayout.LayoutParams.MATCH_PARENT&#xA;);&#xA;llayout.setLayoutParams(layoutParams);&#xA;&#xA;Button btn = new Button(mContext);&#xA;btn.setText(&amp;quot;This is Button&amp;quot;);&#xA;btn.setPadding(8, 8, 8, 8);&#xA;btn.setLayoutParams(lp);&#xA;&#xA;llayout.addView(btn);&#xA;&#xA;//这是在Activity的onCreate()中设置布局&#xA;setContentView(llayout);&#xA;&#xA;btn.setOnClickListener(new View.OnClickListener() {&#xA;    @Override&#xA;    public void onClick(View v) {&#xA;    Toast.makeText(mContext,&#xA;    &amp;quot;This is dynamic activity&amp;quot;, Toast.LENGTH_LONG).show();&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 复杂布局RelativeLayout &#xA;&#xA;//父控件&#xA;RelativeLayout myLayout = new RelativeLayout(this);&#xA;myLayout.setBackgroundColor(Color.BLUE); &#xA;&#xA;//两个子控件&#xA;Button myButton = new Button(this);&#xA;EditText myEditText = new EditText(this);&#xA;&#xA;//重点:生成对应的ID&#xA;myButton.setId(generateViewId());&#xA;myEditText.setId(generateViewId());&#xA;&#xA;//子控件位置&#xA;RelativeLayout.LayoutParams buttonParams =&#xA;    new RelativeLayout.LayoutParams(&#xA;        RelativeLayout.LayoutParams.WRAP_CONTENT,&#xA;        RelativeLayout.LayoutParams.WRAP_CONTENT);&#xA;buttonParams.addRule(RelativeLayout.CENTER_HORIZONTAL);&#xA;buttonParams.addRule(RelativeLayout.CENTER_VERTICAL);&#xA;&#xA;RelativeLayout.LayoutParams textParams =&#xA;    new RelativeLayout.LayoutParams(&#xA;        RelativeLayout.LayoutParams.WRAP_CONTENT,&#xA;        RelativeLayout.LayoutParams.WRAP_CONTENT);&#xA;textParams.addRule(RelativeLayout.CENTER_HORIZONTAL);&#xA;textParams.setMargins(0, 0, 0, 80);&#xA;//重点在这里&#xA;textParams.addRule(RelativeLayout.ABOVE, myButton.getId());&#xA;&#xA;//添加布局&#xA;myLayout.addView(myButton, buttonParams);&#xA;myLayout.addView(myEditText, textParams);&#xA;setContentView(myLayout);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之多点触摸坐标获取</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%91%B8%E5%9D%90%E6%A0%87%E8%8E%B7%E5%8F%96/</link>
      <pubDate>2015-05-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;多点触摸坐标&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// activity_main.xml&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&#xA;    android:id=&amp;quot;@+id/activity_main&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&#xA;    tools:context=&amp;quot;.MainActivity&amp;quot;&#xA;    tools:ignore=&amp;quot;MergeRootFrame&amp;quot;&amp;gt;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&#xA;// MainActivity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    RelativeLayout layout = null;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    layout = (RelativeLayout) findViewById(R.id.activity_main);&#xA;    layout.setOnTouchListener(new View.OnTouchListener() {&#xA;        @Override&#xA;        public boolean onTouch(View v, MotionEvent event) {&#xA;        switch (event.getAction()) {&#xA;            case MotionEvent.ACTION_DOWN: // 点击&#xA;            break;&#xA;            case MotionEvent.ACTION_MOVE: // 移动&#xA;            // 触摸点数量&#xA;            // event.getPointerCount();&#xA;            // 触摸点坐标 0&#xA;            // event.getX(0); event.getY(0);&#xA;            // 触摸点坐标 1&#xA;            // event.getX(1); event.getY(1);&#xA;            // ...&#xA;            break;&#xA;            case MotionEvent.ACTION_UP: // 抬起&#xA;            break;&#xA;        }&#xA;        return true;&#xA;        }&#xA;    });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Context的理解及使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BContext%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-05-05 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Context&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Context在android中的作用不言而喻，当我们访问当前应用的资源，启动一个新的activity的时候&#xA;&#xA;都需要提供Context而这个Context到底是什么呢，这个问题好像很好回答又好像难以说清楚。&#xA;&#xA;从字面意思，Context的意思是“上下文”，或者也可以叫做环境、场景等，尽管如此，还是有点抽象。&#xA;&#xA;从类的继承来说，Context作为一个抽象的基类，它的实现子类有三种：Application、Activity和Service &#xA;&#xA;那么这三种有没有区别呢？为什么通过任意的Context访问资源都得到的是同一套资源呢？&#xA;&#xA;getApplication和getApplicationContext有什么区别呢？应用中到底有多少个Context呢？&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之Context的理解及使用/1.gif&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;什么是Context&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Context是一个抽象基类，我们通过它访问当前包的资源（getResources、getAssets）和&#xA;&#xA;启动其他组件（Activity、Service、Broadcast）以及得到各种服务（getSystemService）&#xA;&#xA;当然，通过Context能得到的不仅仅只有上述这些内容。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;对Context的理解可以来说：Context提供了一个应用的运行环境，在Context的大环境里，应用才可以访问资源&#xA;&#xA;才能完成和其他组件、服务的交互，Context定义了一套基本的功能接口，我们可以理解为一套规范&#xA;&#xA;而Activity和Service是实现这套规范的子类，这么说也许并不准确&#xA;&#xA;因为这套规范实际是被ContextImpl类统一实现的，Activity和Service只是继承并有选择性地重写了某些规范的实现。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;可以看到 Activity 继承 Context 向上转型，获取父类对象&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    // 标签&#xA;    public String ContextLabel = &amp;quot;Hello World&amp;quot;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        // FragmentTransaction&#xA;        replaceFragment(R.id.main, new MainFragment());&#xA;    }&#xA;}&#xA;&#xA;// Fragment&#xA;public class MainFragment extends Fragment {&#xA;&#xA;    // MainActivity&#xA;    private MainActivity activity = null;&#xA;&#xA;    // 构造   &#xA;    public MainFragment() {&#xA;        // 实际情况&#xA;        activity = (MainActivity) getActivity()&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        // 这样就可以获取父类对象内容了&#xA;        // activity.ContextLabel&#xA;    }&#xA;}&#xA;&#xA;// BaseAdapter&#xA;class EvolverBaseAdapter extends BaseAdapter {&#xA;&#xA;    // 上下文&#xA;    private Context context;&#xA;&#xA;    // Activity&#xA;    public MainActivity activity = null;&#xA;&#xA;    // 构造&#xA;    public EvolverBaseAdapter(Context context, ArrayList&amp;lt;EvolverData&amp;gt; evolver) {&#xA;        this.context = context;&#xA;        activity = (MainActivity) context;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 定义了一个 TextView 并且传入 MainActivity.this&#xA;// 由于 MainActivity.this 是继承 Activity 继承 Context&#xA;// 所以 传入 MainActivity.this 就是传入 Context&#xA;TextView text = new TextView(MainActivity.this);&#xA;&#xA;// 设置内容，则是通过 Context 找到 getResources 设置&#xA;text.setText(R.string.app_name);&#xA;&#xA;// TextView 构造&#xA;public TextView(Context context) {&#xA;    this(context, null);&#xA;}&#xA;&#xA;// TextView setText &#xA;@android.view.RemotableViewMethod&#xA;public final void setText(int resid) {&#xA;    setText(getContext().getResources().getText(resid));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之启动活动的最佳写法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%86%99%E6%B3%95/</link>
      <pubDate>2015-05-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;启动活动的最佳写法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;启动活动的方法常用的无非两种:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;startActivity()&#xA;startActivityForResult()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;如果需要传输数据无非使用:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Intent intent = new Intent(this, ClassName.class);&#xA;intent.putExtra(&amp;quot;param1&amp;quot;, &amp;quot;data1&amp;quot;);&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;问题随之产生&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;如果需要启动另外一个活动，则需要知道启动时所需传入的参数或数据&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一，去看要启动活动的代码&#xA;二，去问实现该活动的码农&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;更好的办法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在你实现活动的同时，实现一个静态方法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void actionStart(Context context, String data1, ...) {&#xA;    Intent intent = new Intent(context, ClassName.class);&#xA;    intent.putExtra(&amp;quot;param1&amp;quot;, &amp;quot;data1&amp;quot;);&#xA;    ...&#xA;    context.startActivity(intent)&#xA;    // 在原函数监听返回&#xA;    // context.startActivityForResult()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这样，需要启动一个活动的时候，调用该类的actionStart即可，而且知道了需要的参数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ClassName.actionStart(this, data1, ...)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之DP和SP来帮忙</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BDP%E5%92%8CSP%E6%9D%A5%E5%B8%AE%E5%BF%99/</link>
      <pubDate>2015-05-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;DP和SP&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;为了让程序拥有更好的屏幕适配能力，在指定控件和布局大小的时候&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最好使用match_parent和wrap_content尽量避免将控件指定一个固定值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过在有些时候紧紧使用match_parent和wrap_content确实无法满足需求&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这时候必须给控件的宽或高指定一个固定值时，DP和SP应运而生&amp;hellip;..&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;PX和PT&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;PX 是像素的意思，既屏幕中可以显示的最小元素单位&#xA;PT 是磅数，1磅等于1/72英寸，一般PT都会作为字体的单位来使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;出现的问题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;手机上像素各不相同，一个200PX宽的按钮在低分辨率的手机上面可能&#xA;    将近占据满屏，而到了高分辨的手机上可能只占据屏幕的一半&#xA;&#xA;可以看出，同样的PX和PT在不同分辨率的屏幕上显示的效果是完全不同的&#xA;    这导致这两个单位在手机领域上面很难有所发挥&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;解决方案&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;谷歌当然也意识到了这个令人头疼的问题，于是Android引入了一套新的单位DP和SP&#xA;&#xA;DP是密度无关像素的意思，也被称作DIP，和PX相比，它在不同密度的屏幕中显示比例保持一致&#xA;&#xA;SP是可伸缩像素的意思，它采用了和DP同样的设计理念，解决了文字大小适配的问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;获取密度&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;float xdpi = getResources().getDisplayMetrics().xdpi;&#xA;float ydpi = getResources().getDisplayMetrics().ydpi;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之类型断言的使用方法</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-04-30 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;类型断言&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;接口类型的一个极端重要的例子是空接口：&#xA;&#xA;    interface{},它表示空的方法集合，由于任何值都有零个或者多个方法，所以任何值都可以满足它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;也有人说 Go 的接口是动态类型的，不过这是一种误解。&#xA;&#xA;    它们是静态类型的：接口类型的变量总是有着相同的静态类型，这个值总是满足空接口，只是存储在接口变量中的值运行时可能被改变。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;// 自定义类型&#xA;type Hello struct {&#xA;    Print interface{}&#xA;}&#xA;&#xA;// 类型断言必须真对interface{}类型进行&#xA;// value, ok := Interface.(T)&#xA;func main() {&#xA;&#xA;    // 接口类型&#xA;    var Interface interface{}&#xA;&#xA;    // 赋值(自定义类型)&#xA;    // Interface = Hello{&amp;quot;World&amp;quot;}&#xA;&#xA;    // 赋值(内置类型)&#xA;    // Interface = 2&#xA;&#xA;    // 赋值(内置类型)&#xA;    // Interface = &amp;quot;3&amp;quot;&#xA;&#xA;    // 输出&#xA;    switch Interface.(type) {&#xA;    case Hello:&#xA;        fmt.Println(Interface.(Hello).Print.(string))&#xA;    case int:&#xA;        fmt.Println(Interface.(int))&#xA;    case string:&#xA;        fmt.Println(Interface.(string))&#xA;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之FragmentManager介绍</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BFragmentManager%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-04-30 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FragmentManager&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;为了管理Activity中的fragments，需要使用FragmentManager.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;为了得到它，需要调用Activity中的getFragmentManager()方法。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;因为FragmentManager的API是在Android 3.0，也即API level 11开始引入的&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;所以对于之前的版本，需要使用support library中的FragmentActivity，并且使用getSupportFragmentManager()方法。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FragmentManager 可以做的工作有：&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;可以得到Activity中存在的fragment：&#xA;&#xA;可以使用findFragmentById()或findFragmentByTag()方法。&#xA;&#xA;可以将fragment弹出back stack(popBackStack)&#xA;&#xA;可以将back stack中最后一次的fragment转换弹出, 没有可以出栈时则返回false。&#xA;&#xA;可以为back stack加上监听器：addOnBackStackChangedListener()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Performing Fragment Transactions&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用Fragment时，可以通过用户交互来执行一些动作，比如增加、移除、替换等。&#xA;&#xA;所有这些改变构成一个集合，这个集合被叫做一个transaction, 通过FragmentTransaction来处理&#xA;&#xA;可以将transaction存进由activity管理的back stack中，这样就可以进行fragment变化的回退操作。&#xA;&#xA;可以这样得到FragmentTransaction类的实例：　&#xA;&#xA;FragmentManager fragmentManager = getFragmentManager();&#xA;FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Transaction 是一组同时执行的变化的集合&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;用add(), remove(), replace()方法，把所有需要的变化加进去，然后调用commit()方法，将这些变化应用。&#xA;&#xA;在commit()方法之前，你可以调用addToBackStack()，把这个transaction加入back stack中去&#xA;&#xA;这个back stack是由activity管理的，当用户按返回键时，就会回到上一个fragment的状态。&#xA;&#xA;比如下面的代码就是用一个新的fragment取代之前的fragment，并且将前次的状态存储在back stack中。&#xA;&#xA;// Create new fragment and transaction&#xA;Fragment newFragment = new ExampleFragment();&#xA;FragmentTransaction transaction = getFragmentManager().beginTransaction();&#xA;&#xA;// Replace whatever is in the fragment_container view with this fragment,&#xA;// and add the transaction to the back stack&#xA;transaction.replace(R.id.fragment_container, newFragment);&#xA;transaction.addToBackStack(null);&#xA;&#xA;// Commit the transaction&#xA;transaction.commit();&#xA;&#xA;// R.id.fragment_container&#xA;&amp;lt;FrameLayout&#xA;    android:id=&amp;quot;@+id/fragment_container&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&amp;lt;/FrameLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在这个例子中，newFragment将取代在R.id.fragment_container容器中的fragment&#xA;&#xA;    如果没有，将直接添加新的fragment。&#xA;&#xA;通过调用addToBackStack()，commit()的一系列转换作为一个transaction被存储在back stack中&#xA;&#xA;    用户按Back键可以返回上一个转换前的状态。&#xA;&#xA;当你移除一个fragment的时候:&#xA;&#xA;    如果commit()之前没有调用 addToBackStack()，那个fragment将会是destroyed；&#xA;&#xA;    如果调用了addToBackStack()，这个fragment 会是stopped，可以通过返回键来恢复。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;关于commit()方法&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;调用commit()方法并不能立即执行transaction中包含的改变动作，commit()方法把transaction加入activity的UI线程队列中。&#xA;&#xA;但是，如果觉得有必要的话，可以调用executePendingTransactions()方法来立即执行commit()提供的transaction。&#xA;&#xA;这样做通常是没有必要的，除非这个transaction被其他线程依赖。&#xA;&#xA;注意：你只能在activity存储它的状态（当用户要离开activity时）之前调用commit()，在存储状态之后调用将会抛出一个异常。&#xA;&#xA;这是因为当activity再次被恢复时commit之后的状态将丢失。如果丢失也没关系，那么使用commitAllowingStateLoss()方法。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之替代ListView的RecyclerView</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E6%9B%BF%E4%BB%A3ListView%E7%9A%84RecyclerView/</link>
      <pubDate>2015-04-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;RecyclerView&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;RecyclerView是android-support-v7-21版本中新增的一个Widgets&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;官方介绍RecyclerView是ListView的升级版本，更加先进和灵活。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;我们写一个简单的实例例，来看一下究竟有多先进和灵活。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 支持库&#xA;com.android.support:recyclerview-v7:22.0.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之替代ListView的RecyclerView/1.png&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;500&#34;&gt;&#xA;&lt;img src=&#34;/assets/media/Android之替代ListView的RecyclerView/2.png&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;500&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;RecyclerView 首先的一个特点就是，将 layout 抽象成了一个 LayoutManager&#xA;&#xA;RecylerView 不负责子 View 的布局，我们可以自定义 LayoutManager 来实现不同的布局效果&#xA;&#xA;目前只提供了LinearLayoutManager可以指定方向，默认是垂直，可指定水平，实现了水平的ListView。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;RecyclerView 的另一个特点是标准化了 ViewHolde&#xA;&#xA;编写 Adapter 面向的是 ViewHoder 而不在是View 了， 复用的逻辑被封装了， 写起来更加简单。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;RecyclerView作为替代ListView使用，RecyclerView标准化了ViewHolder，ListView中convertView是复用的&#xA;&#xA;在RecyclerView中，是把ViewHolder作为缓存的单位了，然后convertView作为ViewHolder的成员变量保持在ViewHolder中&#xA;&#xA;也就是说，假设没有屏幕显示10个条目，则会创建10个ViewHolder缓存起来，每次复用的是ViewHolder&#xA;&#xA;所以他把getView这个方法变为了onCreateViewHolder。 ViewHolder更适合多种子布局的列表，尤其IM的对话列表。&#xA;&#xA;RecyclerView不提供setOnItemClickListener方法，你可以在ViewHolder中添加事件。RecyclerView的使用可以参考&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 一个定义了RecyclerView的(Layout)XML&#xA;// recycler.xml&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&#xA;android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;tools:context=&amp;quot;.MyActivity&amp;quot;&amp;gt;&#xA;&#xA;// RecyclerView &#xA;&amp;lt;android.support.v7.widget.RecyclerView&#xA;    android:id=&amp;quot;@+id/recyclerView&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:scrollbars=&amp;quot;vertical&amp;quot; /&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// recycler_adapter_item(Layout-XML)&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:orientation=&amp;quot;horizontal&amp;quot;&#xA;    android:padding=&amp;quot;10dp&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;    android:id=&amp;quot;@+id/linearLayout&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;TextView&#xA;        android:id=&amp;quot;@+id/item_name&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;Name&amp;quot;&#xA;        android:textSize=&amp;quot;18sp&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;TextView&#xA;        android:id=&amp;quot;@+id/item_description&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_marginTop=&amp;quot;2dp&amp;quot;&#xA;        android:text=&amp;quot;Description&amp;quot;&#xA;        android:textColor=&amp;quot;#888&amp;quot;&#xA;        android:textSize=&amp;quot;12sp&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在Activity中使用RecyclerView&#xA;public class MyRecyclerView extends Activity {&#xA;&#xA;    private RecyclerView recycler;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;&#xA;        // 定义方法一&#xA;        setContentView(R.layout.recycler);&#xA;        recycler = (RecyclerView) findViewById(R.id.recyclerView);&#xA;&#xA;        // 定义方法二&#xA;        recycler = new RecyclerView(this);&#xA;        setContentView(recycler);&#xA;&#xA;        // 通过LinearLayoutManager设置方向&#xA;        LinearLayoutManager manager = new new LinearLayoutManager(this);&#xA;&#xA;        // 设置方向&#xA;        manager.setOrientation(LinearLayoutManager.HORIZONTAL);&#xA;&#xA;        // 设置 LayoutManager&#xA;        recycler.setLayoutManager(manager);&#xA;&#xA;        // 通过ViewHoder设置内容&#xA;        recycler.setAdapter(new RecyclerAdapter());&#xA;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// RecyclerView.Adapter&#xA;class RecyclerAdapter extends RecyclerView.Adapter {&#xA;&#xA;    // RecyclerView.ViewHolder&#xA;    class ViewHolder extends RecyclerView.ViewHolder {&#xA;&#xA;        private TextView item_name;&#xA;        private TextView item_description;&#xA;&#xA;        public ViewHolder(View itemView) {&#xA;            super(itemView);&#xA;            item_name = (TextView) itemView.findViewById(R.id.item_name);&#xA;            item_description = (TextView) itemView.findViewById(R.id.item_description);&#xA;        }&#xA;&#xA;        public TextView getItem_description() {&#xA;            return item_description;&#xA;        }&#xA;&#xA;        public TextView getItem_name() {&#xA;            return item_name;&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    @Override&#xA;    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {&#xA;        // 这里在onCreate的ViewHolder时加载一个View&#xA;        return new ViewHolder(LayoutInflater.from(parent.getContext()).&#xA;                                        inflate(R.layout.recycler_adapter_item, null));&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {&#xA;        // 这里通过操作载入的View来进行设置内容及事件等&#xA;        ViewHolder vh = (ViewHolder) holder;&#xA;        vh.getItem_name().setText(&amp;quot;标题 +&amp;quot; + String.valueOf(position));&#xA;        vh.getItem_description().setText(&amp;quot;说明 +&amp;quot; + String.valueOf(position));&#xA;    }&#xA;&#xA;    @Override&#xA;    public int getItemCount() {&#xA;        // 内容的数量&#xA;        return 10;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Ripple按钮水波纹效果</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BRipple%E6%8C%89%E9%92%AE%E6%B0%B4%E6%B3%A2%E7%BA%B9%E6%95%88%E6%9E%9C/</link>
      <pubDate>2015-04-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Ripple&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;注：代码摘抄自网络&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在Layout中使用水波纹效果的View对象&#xA;&amp;lt;com.example.nljb.surpass.RippleImageView&#xA;android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;android:background=&amp;quot;@drawable/guide_0&amp;quot; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 集成需要实现水波纹效果的View对象类(ImageButton)&#xA;public class RippleImageButton extends ImageButton {&#xA;&#xA;    // 起始点&#xA;    private int mInitX;&#xA;    private int mInitY;&#xA;&#xA;    // 高度和宽度&#xA;    private int mWidth;&#xA;    private int mHeight;&#xA;&#xA;    // 绘制的半径&#xA;    private int mRadius;&#xA;    private int mStep;&#xA;    private int mDrawRadius;&#xA;&#xA;    private boolean mDrawFinish;&#xA;&#xA;    private boolean mDrawBack;&#xA;&#xA;    private final int DURATION = 240;&#xA;    private final int FREQUENCY = 10;&#xA;    private int mCycle;&#xA;    private final Rect mRect = new Rect();&#xA;&#xA;    private Paint mRevealPaint = new Paint(Paint.ANTI_ALIAS_FLAG);&#xA;&#xA;    public RippleImageButton(Context context) {&#xA;    super(context);&#xA;    initView(context);&#xA;    }&#xA;&#xA;    public RippleImageButton(Context context, AttributeSet attrs) {&#xA;    super(context, attrs);&#xA;    initView(context);&#xA;    }&#xA;&#xA;    public RippleImageButton(Context context, AttributeSet attrs, int defStyleAttr) {&#xA;    super(context, attrs, defStyleAttr);&#xA;    initView(context);&#xA;    }&#xA;&#xA;    private void initView(Context context) {&#xA;    mRevealPaint.setColor(0x10000000);&#xA;    mCycle = DURATION / FREQUENCY;&#xA;    mDrawFinish = true;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onDraw(Canvas canvas) {&#xA;    if (mDrawFinish) {&#xA;        super.onDraw(canvas);&#xA;        return;&#xA;    }&#xA;    canvas.drawColor(0x08000000);&#xA;    super.onDraw(canvas);&#xA;    if (mStep == 0) {&#xA;        return;&#xA;    }&#xA;    mDrawRadius = mDrawRadius + mStep;&#xA;&#xA;&#xA;    if (mDrawRadius &amp;gt; mRadius) {&#xA;        mDrawRadius = 0;&#xA;        canvas.drawCircle(mInitX, mInitY, mRadius, mRevealPaint);&#xA;        mDrawFinish = true;&#xA;        invalidate();&#xA;        return;&#xA;    }&#xA;&#xA;    canvas.drawCircle(mInitX, mInitY, mDrawRadius, mRevealPaint);&#xA;    invalidate();&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {&#xA;    super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#xA;    mRect.set(0, 0, getMeasuredWidth(), getMeasuredHeight());&#xA;    }&#xA;&#xA;    private void updateDrawData() {&#xA;    int radiusLeftTop = (int) Math.sqrt((mRect.left - mInitX) * (mRect.left - mInitX) +&#xA;        (mRect.top - mInitY) * (mRect.top - mInitY));&#xA;    int radiusRightTop = (int) Math.sqrt((mRect.right - mInitX) * (mRect.right - mInitX) +&#xA;        (mRect.top - mInitY) * (mRect.top - mInitY));&#xA;    int radiusLeftBottom = (int) Math.sqrt((mRect.left - mInitX) * (mRect.left - mInitX) +&#xA;        (mRect.bottom - mInitY) * (mRect.bottom - mInitY));&#xA;    int radiusRightBottom = (int) Math.sqrt((mRect.right - mInitX) * (mRect.right - mInitX) +&#xA;        (mRect.bottom - mInitY) * (mRect.bottom - mInitY));&#xA;    mRadius = getMax(radiusLeftTop, radiusRightTop, radiusLeftBottom, radiusRightBottom);&#xA;    mStep = mRadius / mCycle;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onTouchEvent(MotionEvent event) {&#xA;    final int action = MotionEventCompat.getActionMasked(event);&#xA;    switch (action) {&#xA;        case MotionEvent.ACTION_DOWN: {&#xA;        mDrawFinish = false;&#xA;        int index = MotionEventCompat.getActionIndex(event);&#xA;        int eventId = MotionEventCompat.getPointerId(event, index);&#xA;        if (eventId != -1) {&#xA;            mInitX = (int) MotionEventCompat.getX(event, index);&#xA;            mInitY = (int) MotionEventCompat.getY(event, index);&#xA;            updateDrawData();&#xA;            invalidate();&#xA;        }&#xA;        break;&#xA;        }&#xA;        case MotionEvent.ACTION_CANCEL:&#xA;        case MotionEvent.ACTION_UP:&#xA;        mStep = (int) (2.5f * mStep);&#xA;        mDrawBack = true;&#xA;        break;&#xA;    }&#xA;    return super.onTouchEvent(event);&#xA;    }&#xA;&#xA;    private int getMax(int... radius) {&#xA;    if (radius.length == 0) {&#xA;        return 0;&#xA;    }&#xA;    int max = radius[0];&#xA;    for (int m : radius) {&#xA;        if (m &amp;gt; max) {&#xA;        max = m;&#xA;        }&#xA;    }&#xA;    return max;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之CardView卡片布局使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BCardView%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-04-29 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;CardView&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;CardView继承至FrameLayout类，可以在一个卡片布局中一致性的显示内容，卡片可以包含圆角和阴影。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;CardView是一个Layout，可以布局其他View。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之CardView卡片布局使用方法/screenshot.png&#34; alt=&#34;&#34; width=&#34;400&#34; height=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 支持库&#xA;com.android.support:cardview-v7:22.0.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 需要导入 &#xA;// &amp;lt;android.support.v7.widget.CardView &#xA;//  xmlns:card_view=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;&#xA;CardView常用属性：&#xA;&#xA;// 阴影的大小&#xA;card_view:cardElevation&#xA;// 阴影最大高度&#xA;card_view:cardMaxElevation&#xA;// 卡片的背景色&#xA;card_view:cardBackgroundColor&#xA;// 卡片的圆角大小&#xA;card_view:cardCornerRadius&#xA;// 卡片内容于边距的间隔&#xA;card_view:contentPadding &#xA;    card_view:contentPaddingBottom&#xA;    card_view:contentPaddingTop&#xA;    card_view:contentPaddingLeft&#xA;    card_view:contentPaddingRight&#xA;    card_view:contentPaddingStart&#xA;    card_view:contentPaddingEnd&#xA;// 设置内边距，V21+的版本和之前的版本仍旧具有一样的计算方式&#xA;card_view:cardUseCompatPadding &#xA;// 在V20和之前的版本中添加内边距，这个属性为了防止内容和边角的重叠&#xA;card_view:cardPreventConrerOverlap&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- android:background=&amp;quot;@drawable/guide_0&amp;quot; --&amp;gt;&#xA;&#xA;&#xA;    &amp;lt;android.support.v7.widget.CardView xmlns:card_view=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;    android:layout_width=&amp;quot;200dp&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    card_view:cardBackgroundColor=&amp;quot;#303069&amp;quot;&#xA;    card_view:cardCornerRadius=&amp;quot;10dp&amp;quot;&#xA;    card_view:cardPreventCornerOverlap=&amp;quot;true&amp;quot;&#xA;    card_view:cardUseCompatPadding=&amp;quot;true&amp;quot;&#xA;    card_view:contentPadding=&amp;quot;10dp&amp;quot;&#xA;    android:layout_gravity=&amp;quot;right&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;TextView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;CardView&amp;quot;&#xA;        android:textSize=&amp;quot;26sp&amp;quot;&#xA;        android:textColor=&amp;quot;#fffffc31&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;/android.support.v7.widget.CardView&amp;gt;&#xA;&#xA;    &amp;lt;android.support.v7.widget.CardView xmlns:card_view=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;    android:layout_width=&amp;quot;200dp&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    card_view:cardBackgroundColor=&amp;quot;#FF0E63FF&amp;quot;&#xA;    card_view:cardCornerRadius=&amp;quot;10dp&amp;quot;&#xA;    card_view:cardPreventCornerOverlap=&amp;quot;true&amp;quot;&#xA;    card_view:cardUseCompatPadding=&amp;quot;true&amp;quot;&#xA;    card_view:contentPadding=&amp;quot;10dp&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;TextView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;CardView&amp;quot;&#xA;        android:textSize=&amp;quot;26sp&amp;quot;&#xA;        android:textColor=&amp;quot;#ff24ff60&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;/android.support.v7.widget.CardView&amp;gt;&#xA;&#xA;    &amp;lt;android.support.v7.widget.CardView xmlns:card_view=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;    android:layout_width=&amp;quot;200dp&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    card_view:cardBackgroundColor=&amp;quot;#FFFF015C&amp;quot;&#xA;    card_view:cardCornerRadius=&amp;quot;10dp&amp;quot;&#xA;    card_view:cardPreventCornerOverlap=&amp;quot;true&amp;quot;&#xA;    card_view:cardUseCompatPadding=&amp;quot;true&amp;quot;&#xA;    card_view:contentPadding=&amp;quot;10dp&amp;quot;&#xA;    android:layout_gravity=&amp;quot;right&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;TextView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;CardView&amp;quot;&#xA;        android:textSize=&amp;quot;26sp&amp;quot;&#xA;        android:textColor=&amp;quot;#ffffffff&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;/android.support.v7.widget.CardView&amp;gt;&#xA;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>矩阵设计图样</title>
      <link>http://www.nljb.net/default/%E7%9F%A9%E9%98%B5%E8%AE%BE%E8%AE%A1%E5%9B%BE%E6%A0%B7/</link>
      <pubDate>2015-04-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/矩阵设计图样/约定-1.png&#34; alt=&#34;&#34; width=&#34;900&#34; height=&#34;1300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/矩阵设计图样/约定-2.png&#34; alt=&#34;&#34; width=&#34;900 height=&#34;1300&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之在Layout中自定义View</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%9C%A8Layout%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89View/</link>
      <pubDate>2015-04-28 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;在Layout中自定义View&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;经常会看到在XML文件中调用别人的View就可以显示出各种奇妙的页面&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;简单的学习了一下，下面说一下如何自定义一个View, 并设置背景色&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第一步，创建一个继承自View的类&#xA;public class MyView extends View {&#xA;&#xA;    //  背景颜色&#xA;    private int background;&#xA;&#xA;    // 默认背景颜色&#xA;    private final int default_background = Color.rgb(66, 145, 241);&#xA;&#xA;    // 构造&#xA;    public MyView(Context context) {&#xA;    // 这里确保每一级都会被触发&#xA;    this(context, null);&#xA;    }&#xA;&#xA;    // 构造&#xA;    public MyView(Context context, AttributeSet attrs) {&#xA;    // 这里确保每一级都会被触发&#xA;    this(context, attrs, R.attr.MyViewStyle);&#xA;    }&#xA;&#xA;    // 构造&#xA;    public MyView(Context context, AttributeSet attrs, int defStyle) {&#xA;    // 执行父类构造&#xA;    super(context, attrs, defStyle);&#xA;    // 初始化&#xA;    final TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs, R.styleable.MyView, defStyle, 0);&#xA;    // 获取设置的背景颜色&#xA;    background = attributes.getColor(R.styleable.MyView_background, default_background);&#xA;    // 设置&#xA;    this.setBackgroundColor(background);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第二步，在XML-Layout中使用&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:background=&amp;quot;@drawable/guide_0&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;    // 这里使用的就是自定义的View&#xA;    &amp;lt;com.example.nljb.surpass.MyView&#xA;    // 可以使用自定义的View的设置参数&#xA;    app:background=&amp;quot;#ffff5633&amp;quot;&#xA;    // 可以使用继承自View的设置参数&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;50dp&amp;quot;/&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 第三步，自定义View的参数(第一步已经讲了如何使用)&#xA;// values/attrs&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;resources&amp;gt;&#xA;&#xA;    &amp;lt;declare-styleable name=&amp;quot;MyView&amp;quot;&amp;gt;&#xA;    // format 类型有很多 ...&#xA;    &amp;lt;attr name=&amp;quot;background&amp;quot; format=&amp;quot;color&amp;quot;/&amp;gt;&#xA;        // &amp;lt;attr name=&amp;quot;...&amp;quot; format=&amp;quot;integer&amp;quot;/&amp;gt;&#xA;        // &amp;lt;attr name=&amp;quot;...&amp;quot; format=&amp;quot;dimension&amp;quot;/&amp;gt;&#xA;        // &amp;lt;attr name=&amp;quot;...&amp;quot; format=&amp;quot;enum&amp;quot;&amp;gt;&#xA;            //  &amp;lt;enum name=&amp;quot;...&amp;quot; value=&amp;quot;0&amp;quot;/&amp;gt;&#xA;            //  &amp;lt;enum name=&amp;quot;...&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;&#xA;        // &amp;lt;/attr&amp;gt;&#xA;    // &amp;lt;attr name=&amp;quot;...&amp;quot; format=&amp;quot;string&amp;quot;/&amp;gt;&#xA;    // &amp;lt;attr name=&amp;quot;...&amp;quot; format=&amp;quot;boolean&amp;quot;/&amp;gt;&#xA;    ...&#xA;    &amp;lt;/declare-styleable&amp;gt;&#xA;&#xA;    &amp;lt;declare-styleable name=&amp;quot;Themes&amp;quot;&amp;gt;&#xA;    &amp;lt;attr name=&amp;quot;MyViewStyle&amp;quot; format=&amp;quot;reference&amp;quot;/&amp;gt;&#xA;    &amp;lt;/declare-styleable&amp;gt;&#xA;&amp;lt;/resources&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之SwipeLayout实现View侧滑菜单</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BSwipeLayout%E5%AE%9E%E7%8E%B0View%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95/</link>
      <pubDate>2015-04-27 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;AndroidSwipeLayout&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;一个很强大的SwipeLayout和SwipeListView相比它不局限于ListView&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之SwipeLayout实现View侧滑菜单/swipelayout.gif&#34; alt=&#34;&#34; width=&#34;300&#34; height=&#34;500&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;官方：&lt;a href=&#34;https://github.com/daimajia/AndroidSwipeLayout/wiki/usage&#34;&gt;https://github.com/daimajia/AndroidSwipeLayout/wiki/usage&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Jar：&lt;a href=&#34;https://github.com/daimajia/AndroidSwipeLayout/releases/download/v1.1.8/AndroidSwipeLayout-v1.1.8.jar&#34;&gt;https://github.com/daimajia/AndroidSwipeLayout/releases/download/v1.1.8/AndroidSwipeLayout-v1.1.8.jar&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Show Mode : 支持 LayDown 和 PullOut&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Drag edge : 支持 LEFT, RIGHT, TOP, BOTTOM&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// XML&#xA;// 一个SwipeLayou包含两个Layout&#xA;// 其中一个Layout是隐藏的(侧滑才会显示)&#xA;// 另外一个Layout是显示的&#xA;&amp;lt;com.daimajia.swipe.SwipeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;80dp&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- Bottom View Start--&amp;gt;   &#xA;     // 隐藏的&#xA;     &amp;lt;LinearLayout&#xA;    android:background=&amp;quot;#66ddff00&amp;quot;&#xA;    android:id=&amp;quot;@+id/bottom_wrapper&amp;quot;&#xA;    android:layout_width=&amp;quot;160dp&amp;quot;&#xA;    android:weightSum=&amp;quot;1&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;    &amp;lt;!--What you want to show--&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;    &amp;lt;!-- Bottom View End--&amp;gt;&#xA;&#xA;    &amp;lt;!-- Surface View Start --&amp;gt;&#xA;     // 显示的 &#xA;     &amp;lt;LinearLayout&#xA;    android:padding=&amp;quot;10dp&amp;quot;&#xA;    android:background=&amp;quot;#ffffff&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;    &amp;lt;!--What you want to show in SurfaceView--&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;    &amp;lt;!-- Surface View End --&amp;gt;&#xA;&amp;lt;/com.daimajia.swipe.SwipeLayout&amp;gt;&#xA;&#xA;&#xA;// 同时还可以进行一些事件监听&#xA;SwipeLayout swipeLayout =  (SwipeLayout)findViewById(R.id.sample1);&#xA;&#xA;//set show mode.&#xA;swipeLayout.setShowMode(SwipeLayout.ShowMode.LayDown);&#xA;&#xA;//add drag edge.(If the BottomView has &#39;layout_gravity&#39; attribute, this line is unnecessary)&#xA;swipeLayout.addDrag(SwipeLayout.DragEdge.Left, findViewById(R.id.bottom_wrapper));&#xA;&#xA;swipeLayout.addSwipeListener(new SwipeLayout.SwipeListener() {&#xA;        @Override&#xA;        public void onClose(SwipeLayout layout) {&#xA;        //when the SurfaceView totally cover the BottomView.&#xA;        }&#xA;&#xA;        @Override&#xA;        public void onUpdate(SwipeLayout layout, int leftOffset, int topOffset) {&#xA;           //you are swiping.&#xA;        }&#xA;&#xA;        @Override&#xA;        public void onStartOpen(SwipeLayout layout) {&#xA;&#xA;        }&#xA;&#xA;        @Override&#xA;        public void onOpen(SwipeLayout layout) {&#xA;           //when the BottomView totally show.&#xA;        }&#xA;&#xA;        @Override&#xA;        public void onStartClose(SwipeLayout layout) {&#xA;&#xA;        }&#xA;&#xA;        @Override&#xA;        public void onHandRelease(SwipeLayout layout, float xvel, float yvel) {&#xA;           //when user&#39;s hand released.&#xA;        }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java面向对象之继承</title>
      <link>http://www.nljb.net/default/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/</link>
      <pubDate>2015-04-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;继承 (extends)&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;扩展(子类)父类的功能&#xA;&#xA;不允许继承多个类, 但是可以多层继承&#xA;&#xA;子类不能直接访问父类的私有资源&#xA;&#xA;父类的构造方法先执行子类构造后执行&#xA;&#xA;重写需方法名相同，返回类型相同，参数相同&#xA;&#xA;被子类重写的方法不能拥有比父类更严格的访问权限&#xA;&#xA;private(当前类) &amp;lt; default(整个包) &amp;lt; public(可访问)&#xA;&#xA;super 强行调用父类的对象使用或方法执行&#xA;&#xA;重载，方法名称相同，参数的类型或个数不同&#xA;    发生在一个类中，对权限没有要求&#xA;&#xA;重写，方法名称，参数类型和个数，返回值类型，全部相同&#xA;    不能拥有比父类更加严格的权限，发生在继承中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Person {&#xA;&#xA;    public Person() {&#xA;    System.out.println(&amp;quot;父类构造先执行&amp;quot;);&#xA;    }&#xA;&#xA;    public void tell() {&#xA;&#xA;    }&#xA;&#xA;    // 公共&#xA;    public String name;&#xA;&#xA;    // 公共&#xA;    public String age;&#xA;&#xA;    public String getAge() {&#xA;    return age;&#xA;    }&#xA;&#xA;    public String getName() {&#xA;    return name;&#xA;    }&#xA;&#xA;}&#xA;&#xA;class JD extends Person {&#xA;&#xA;    public JD() {&#xA;    System.out.println(&amp;quot;子类构造后执行&amp;quot;);&#xA;    }&#xA;&#xA;    // 重载&#xA;    public void Print() {&#xA;&#xA;    }&#xA;&#xA;    // 重载&#xA;    public void Print(String name) {&#xA;&#xA;    }&#xA;&#xA;    // 继承了父类的公共对象&#xA;    // ...&#xA;&#xA;    // 私有，不可以子类访问&#xA;    private String phone;&#xA;&#xA;    public String getPhone() {&#xA;    return phone;&#xA;    }&#xA;&#xA;    // 子类可以直接修改父类的公共对象&#xA;    public void reSetName(String name) {&#xA;    // super 关键字作用&#xA;    super.name = name;&#xA;    }&#xA;&#xA;    // 重写方法&#xA;    public void tell() {&#xA;    // 如果不强制调用父类重写方法，默认是不会调用的&#xA;    // 强制调用父类方法&#xA;    super.tell();&#xA;    System.out.println(&amp;quot;重写父类方法&amp;quot;);&#xA;    }&#xA;&#xA;}&#xA;&#xA;public class Demo {&#xA;&#xA;    public void main() {&#xA;    JD jd = new JD();&#xA;    jd.getAge();&#xA;    jd.getName();&#xA;    jd.getPhone();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java面向对象之多态</title>
      <link>http://www.nljb.net/default/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/</link>
      <pubDate>2015-04-23 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Java面向对象之多态&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;向上转型：程序会自动完成&#xA;    父类 父类对象 = 子类实例&#xA;&#xA;向下转型：强制类型转换&#xA;    子类 子类对象 = (子类)父类实例&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;instanceof关键字可以判断一个对象是不是一个类的实例&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class A {&#xA;&#xA;    public void printA() {&#xA;    System.out.println(&amp;quot;A - print&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;&#xA;class B extends A {&#xA;&#xA;    public void printB() {&#xA;    System.out.println(&amp;quot;B - print&amp;quot;);&#xA;    }&#xA;&#xA;}&#xA;&#xA;class C extends A {&#xA;&#xA;    public void printC() {&#xA;    System.out.println(&amp;quot;C - print&amp;quot;);&#xA;    }&#xA;&#xA;}&#xA;&#xA;public class Demo {&#xA;&#xA;    public void main() {&#xA;    A a  = new A();&#xA;    System.out.println(a instanceof A);&#xA;    A a1 = new B();&#xA;    System.out.println(a1 instanceof A);&#xA;    System.out.println(a1 instanceof B);&#xA;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java之抽象类Abstract与接口Interface</title>
      <link>http://www.nljb.net/default/Java%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BBAbstract%E4%B8%8E%E6%8E%A5%E5%8F%A3Interface/</link>
      <pubDate>2015-04-22 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;final 完结器(最终)&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;final关键字在JAVA中被称为完结器，表示最终的意思.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;final能声明，类，方法，属性&lt;/p&gt;&#xA;&#xA;&lt;p&gt;final声明的对象，不能够被继承&lt;/p&gt;&#xA;&#xA;&lt;p&gt;final声明的方法，不能够被重写&lt;/p&gt;&#xA;&#xA;&lt;p&gt;final声明的变量，会变成常量，不可以被修改&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 不能够被继承的类&#xA;final class Hello {}&#xA;&#xA;class Hello {&#xA;    // 不能够被继承的方法&#xA;    public final void print() {&#xA;    }&#xA;    // 被变成常量的变量&#xA;    final String HOME = &amp;quot;bj&amp;quot;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;抽象类和接口的区别&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;abstract class ClassName 抽象类&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;声明而未被实现的方法，必须使用abstract抽象关键字声明&lt;/p&gt;&#xA;&#xA;&lt;p&gt;抽象类不能直接实例化，需要子类进行实例化&lt;/p&gt;&#xA;&#xA;&lt;p&gt;抽象类被子类继承，子类(如果不是抽象类)，必需重写抽象类中的所有抽象方法&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;abstract class Abs {&#xA;    public void hello() {&#xA;    System.out.println(&amp;quot;Hello&amp;quot;);&#xA;    }&#xA;    // 抽象方法&#xA;    public abstract void print();&#xA;}&#xA;&#xA;class AbsDemo extends Abs {&#xA;&#xA;    // 子类必须复写抽象类中所有抽象方法&#xA;    @Override&#xA;    public void print() {&#xA;    System.out.println(&amp;quot;World&amp;quot;);&#xA;    }&#xA;&#xA;}&#xA;&#xA;public class xxx {&#xA;&#xA;    public void main() {&#xA;    AbsDemo demo = new AbsDemo();&#xA;    demo.hello();&#xA;    demo.print();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;interface InterfaceName 接口&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;接口内全部是由全局常量和公共抽象方法组成&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 接口 1&#xA;interface Inter {&#xA;    public static final int TAG = 100;&#xA;&#xA;    public boolean print();&#xA;}&#xA;&#xA;// 接口 2&#xA;interface Inter2 {&#xA;    public static final int TAG2 = 100;&#xA;&#xA;    public boolean println2();&#xA;}&#xA;&#xA;// 接口 3 继承 接口 1 + 2&#xA;interface Inter3 extends Inter, Inter2 {&#xA;}&#xA;&#xA;// 类 B 实现接口 3 = 1 + 2&#xA;class B implements Inter3 {&#xA;&#xA;    @Override&#xA;    public boolean print() {&#xA;    System.out.print(&amp;quot;Hello&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean println() {&#xA;    System.out.print(&amp;quot;World&amp;quot;);&#xA;    return false;&#xA;    }&#xA;}&#xA;&#xA;// 类 A 实现接口 1 + 2&#xA;class A implements Inter, Inter2 {&#xA;&#xA;    @Override&#xA;    public boolean print() {&#xA;    System.out.print(&amp;quot;Hello&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean println() {&#xA;    System.out.print(&amp;quot;World&amp;quot;);&#xA;    return false;&#xA;    }&#xA;}&#xA;*/&#xA;&#xA;public class xxx {&#xA;&#xA;    public void main() {&#xA;    A a = new A();&#xA;    // Inter.TAG;&#xA;    a.print();&#xA;    a.println();&#xA;    B b = new B();&#xA;    b.print();&#xA;    b.println();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java之Static全局属性的使用</title>
      <link>http://www.nljb.net/default/Java%E4%B9%8BStatic%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-04-22 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;static 全局属性&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用Static关键字声明的属性，为全局属性&#xA;&#xA;使用Static关键字声明的属性，可以直接通过类名调用&#xA;&#xA;使用Static方法的时候，只能访问使用Static关键字声明的属性&#xA;&#xA;静态变量可以通过类名调用&#xA;&#xA;静态在实例化之前就会被调用, 与实例化无关(NEW)&#xA;&#xA;使用Static声明的方法只能访问Static声明的变量与方法&#xA;&#xA;也就是说，非静态方法可以访问静态属性的变量或方法&#xA;&#xA;但是，静态方法无法调用，非静态的变量或方法&#xA;&#xA;理解：因为静态变量或方法是在实例化之前的&#xA;&#xA;也就是在实力后的方法中调用静态变量或者方法是没问题的&#xA;&#xA;因为TA们很早之前就被实例化了。&#xA;&#xA;但是为什么静态方法不能调用非静态的变量或者方法呢&#xA;&#xA;因为静态方法在实例化的时候，非晶态方法还没出生呢...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Home {&#xA;    public  static String name = &amp;quot;World&amp;quot;;&#xA;    public String addr;&#xA;    public String phone;&#xA;    public void print() {&#xA;    System.out.println(&amp;quot;Hello&amp;quot;);&#xA;    }&#xA;    public static void println() {&#xA;    // 这样是可以的, 因为TA与本函数一起存在&#xA;    System.out.println(name);&#xA;    // 这样是不可以的, 还没出生&#xA;    System.out.println(addr);&#xA;    // 这样是不可以的, 因为TA还没出生呢&#xA;    baidu();&#xA;    }&#xA;    public void baidu() {&#xA;    // 这样是可以的, 因为TA早就存在了&#xA;    println()&#xA;    };&#xA;}&#xA;&#xA;public class Demo {&#xA;&#xA;    public void main() {&#xA;    System.out.println(Home.name);&#xA;    Home.name = &amp;quot;BeiJing&amp;quot;;&#xA;    System.out.println(Home.name);&#xA;    Home.name = &amp;quot;China&amp;quot;;&#xA;    System.out.println(Home.name);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java之Extends和Implements的区别</title>
      <link>http://www.nljb.net/default/Java%E4%B9%8BExtends%E5%92%8CImplements%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2015-04-22 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Extends 继承&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;只要类被定义为(final)就是不能被继承的&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Extends继承一个已有的类,被继承的类称为父类(超类,基类),新的类称为子类(派生类)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. public继承&#xA;    明显父类public成员在子类中仍然是public，所以子类对象可以调用父类的接口&#xA;&#xA;2. protected继承&#xA;    protected继承后，父类public和protected成员都变成子类的protected成员了&#xA;    也就是说子类对象无法调用父类的接口，只能将父类的函数当作子类的内部实现&#xA;&#xA;3. private继承&#xA;    private继承后，父类public和protected成员都变成子类的private了，它比protected继承更严格。&#xA;    也就说这些父类的成员只能被继承一次，再继续继承，父类的成员就不可见了。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class A {&#xA;    int i;&#xA;    void f() {}&#xA;    void A() {} // 构造&#xA;}&#xA;&#xA;// B 继承 A&#xA;class B extends A {&#xA;    int j;  &#xA;    void f() {} // 重写&#xA;    void g() {}&#xA;    void B() {  // 构造&#xA;        // 调用父类的构造方法&#xA;        super();&#xA;    }&#xA;}&#xA;&#xA;B b = new B();&#xA;b.i   // 继承的&#xA;b.f() // 重写后的&#xA;b.j   // 自有的&#xA;b.g() // 自有的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Implements 接口实现&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Implements是一个类实现一个接口用的关键字，它是用来实现接口中定义的抽象方法&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;interface接口内部全部是由全局常量和公共抽象方法所组成&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;对于class而言，extends用于(单)继承一个类(class)，而implements用于实现一个接口(interface)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Implements，实现父类，子类不可以覆盖父类的方法或者变量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即使子类定义与父类相同的变量或者函数，也会被父类取代掉&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;interface定义一些方法,并没有实现,需要implements来实现才可用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;extend可以继承一个接口,但仍是一个接口,也需要implements之后才可用&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这样的好处是：架构师定义好接口，让工程师实现就可以了。整个项目开发效率和开发成本大大降低。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 接口&#xA;public interface People {&#xA;    public void say();&#xA;}&#xA;&#xA;public interface People2 {&#xA;    public void say2();&#xA;}&#xA;&#xA;// 等着被实现&#xA;public class Chinese implements People, People2 {&#xA;    public void say() {&#xA;        System.out.println(&amp;quot; 你好！&amp;quot;);&#xA;    }&#xA;    public void say2() {&#xA;        System.out.println(&amp;quot; 你好！&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;People chinese = new Chinese() ;&#xA;chinese.say();&#xA;chinese.say();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之OnTouchListener与OnGestureListener的区别</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BOnTouchListener%E4%B8%8EOnGestureListener%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2015-04-22 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android事件处理机制是基于Listener实现的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如: 触摸屏相关事件，通过OnTouchListener实现的；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而: 手势是通过OnGestureListener实现的;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么这两者有什么关联呢？&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OnTouchListener&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OnTouchListener接口中包含一个onTouch()方法，直接看一个例子：&#xA;public class MainActivity extends Activity implements OnTouchListener {&#xA;    public void onCreate(Bundle outState) {&#xA;    super.onCreate(outState);&#xA;    setContentView(R.layout.main);&#xA;    TextView tv = (TextView) findViewById(R.id.tv);&#xA;    tv.setOnTouchListener(this);&#xA;    }&#xA;&#xA;    public boolean onTouch(View v, MotionEvent event) {&#xA;    Toast.makeText(this,  &amp;quot;Touch Touch&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        return false ; &#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;我们可以通过MotionEvent的getAction()方法来获取Touch事件的类型, 包括:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ACTION_DOWN（按下触摸屏)&#xA;ACTION_MOVE（按下触摸屏后移动受力点）&#xA;ACTION_UP（松开触摸屏）&#xA;ACTION_CANCEL（不会由用户直接触发）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;借助对于用户不同操作的判断，可以实现诸如拖动按钮，拖动滚动条等功能&lt;/p&gt;&#xA;&#xA;&lt;p&gt;结合getRawX(),getRawY(),getX()和getY()等方法来获取坐标&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以看到OnTouchListener只能监听到三种触摸事件，即按下，移动，松开&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果想要监听到双击、滑动、长按等复杂的手势操作，这个时候就必须得用到OnGestureListener了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OnGestureListener&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity implements OnTouchListener, OnGestureListener {&#xA;&#xA;private  GestureDetector mGestureDetector; &#xA;&#xA;public void onCreate(Bundle outState) {&#xA;    super.onCreate(outState);&#xA;    setContentView(R.layout.main);&#xA;&#xA;mGestureDetector = new GestureDetector(this);&#xA;    TextView tv = (TextView) findViewById(R.id.tv);&#xA;    tv.setOnTouchListener(this);&#xA;}&#xA;&#xA;public boolean onTouch(View v, MotionEvent event) {&#xA;    return mGestureDetector.onTouchEvent(event);&#xA;}&#xA;&#xA;// 用户轻触触摸屏，由1个MotionEvent ACTION_DOWN触发  &#xA;public boolean onDown(MotionEvent arg0) {&#xA;    Log.i(&amp;quot;MyGesture&amp;quot;, &amp;quot;onDown&amp;quot;);&#xA;    Toast.makeText(this, &amp;quot;onDown&amp;quot;, Toast.LENGTH_SHORT).show();      &#xA;    return true;&#xA;}&#xA;&#xA;// 用户轻触触摸屏，尚未松开或拖动，由一个1个MotionEvent ACTION_DOWN触发, 注意和onDown()的区别，强调的是没有松开或者拖动的状态&#xA;public void onShowPress(MotionEvent e) {&#xA;    Log.i(&amp;quot;MyGesture&amp;quot;,  &amp;quot;onShowPress&amp;quot;);           &#xA;    Toast.makeText(this, &amp;quot;onShowPress&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;}&#xA;&#xA;// 用户（轻触触摸屏后）松开，由一个1个MotionEvent ACTION_UP触发&#xA;public boolean onSingleTapUp(MotionEvent e) {&#xA;    Log.i(&amp;quot;MyGesture&amp;quot;, &amp;quot;onSingleTapUp&amp;quot;);&#xA;    Toast.makeText(this, &amp;quot;onSingleTapUp&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;    return true;&#xA;}&#xA;&#xA;// 用户按下触摸屏、快速移动后松开，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE, 1个ACTION_UP触发        &#xA;public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {    &#xA;    Log.i(&amp;quot;MyGesture&amp;quot;, &amp;quot;onFling&amp;quot;);&#xA;    Toast.makeText(this, &amp;quot;onFling&amp;quot;, Toast.LENGTH_LONG).show();     &#xA;    return true;&#xA;}&#xA;&#xA;// 用户按下触摸屏，并拖动，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE触发&#xA;public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {            &#xA;    Log.i(&amp;quot;MyGesture&amp;quot;, &amp;quot;onScroll&amp;quot;);&#xA;    Toast.makeText(this, &amp;quot;onScroll&amp;quot;, Toast.LENGTH_LONG).show();&#xA;    return true;&#xA;}&#xA;&#xA;// 用户长按触摸屏，由多个MotionEvent ACTION_DOWN触发&#xA;public void onLongPress(MotionEvent e) {&#xA;    Log.i(&amp;quot;MyGesture&amp;quot;, &amp;quot;onLongPress&amp;quot;);&#xA;    Toast.makeText(this, &amp;quot;onLongPress&amp;quot;, Toast.LENGTH_LONG).show();&#xA;}&#xA;}&#xA;&#xA;... 另一篇文章已经讲解，此处不在重复&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux巨大变革之Systemd取代SysV的Init</title>
      <link>http://www.nljb.net/default/Linux%E5%B7%A8%E5%A4%A7%E5%8F%98%E9%9D%A9%E4%B9%8BSystemd%E5%8F%96%E4%BB%A3SysV%E7%9A%84Init/</link>
      <pubDate>2015-04-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html&#34;&gt;http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;target 取代 runlevel&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在systemd的管理体系里面，以前的运行级别（runlevel）的概念被新的运行目标（target）所取代。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：tartget的命名类似于multi-user.target等这种形式&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如原来的(runlevel3)就对应新的多用户目标(multi-user.target),(runlevel5)就相当于(graphical.target)。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 0 关闭系统。&#xA;runlevel0.target, poweroff.target&#xA;// 1, s, single 单用户模式。&#xA;runlevel1.target, rescue.target &#xA;// 2,4 用户定义/域特定运行级别。默认等同于 3。&#xA;runlevel2.target, runlevel4.target, multi-user.target&#xA;// 3 多用户，非图形化。用户可以通过多个控制台或网络登录。&#xA;runlevel3.target, multi-user.target&#xA;// 5 多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。&#xA;runlevel5.target, graphical.target&#xA;// 6 重启&#xA;runlevel6.target, reboot.target&#xA;// emergency 紧急 Shell&#xA;emergency.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;注意：也就是(/etc/systemd/system)目录下(default.target -&amp;gt; /usr/lib/systemd/system/runlevel3.target)&#xA;所以：runlevel3.target 对应 /etc/systemd/system/multi-user.target.wants 目录的 cron.service &#xA;同时：multi-user.target.wants/cron.service 也就是 cron.service -&amp;gt; /usr/lib/systemd/system/cron.service&#xA;同样：runlevel5.target 对应 /etc/systemd/system/graphical.target.wants &#xA;备注：在openSUSE系统下可以使用 systemd 的主要命令行工具 systemctl 来管理。&#xA;注意：在 systemd 下，有些系统服务器，service、chkconfig 兼容，有些系统则无法继续使用&#xA;比如：在 chkconfig 运行级别3下执行 chkconfig sshd on 时，系统会自动在 multi-user.* 建立 sshd.service 连接&#xA;原理：也就是将 /usr/lib/systemd/system/ 下对应的服务连接到 /etc/systemd/system/ 对应等级的目录中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;由于不再使用运行级别概念，所以/etc/inittab也不再被系统使用 &#xA;而在systemd的管理体系里面，默认的target（相当于以前的默认运行级别）是通过软链来实现。如：&#xA;ln -s /lib/systemd/system/runlevel3.target /etc/systemd/system/default.target&#xA;在/lib/systemd/system/ 下面定义runlevelX.target文件目的主要是为了能够兼容以前的运行级别level的管理方法。&#xA;事实上/lib/systemd/system/runlevel3.target，同样是被软连接到multi-user.target。&#xA;注：opensuse下是在/usr/lib/systemd/system/目录下。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Systemd 命令和 sysvinit 命令的对照表&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Sysvinit 命令         Systemd 命令                  备注&#xA;service foo start   systemctl start foo.service 用来启动一个服务 (并不会重启现有的)&#xA;service foo stop    systemctl stop foo.service  用来停止一个服务 (并不会重启现有的)。&#xA;service foo restart systemctl restart foo.service   用来停止并启动一个服务。&#xA;service foo reload  systemctl reload foo.service    当支持时，重新装载配置文件而不中断等待操作。&#xA;service foo condrestart systemctl condrestart foo.service   如果服务正在运行那么重启它。&#xA;service foo status  systemctl status foo.service            汇报服务是否正在运行。&#xA;ls /etc/rc.d/init.d/    systemctl list-unit-files --type=service    用来列出可以启动或停止的服务列表。&#xA;chkconfig foo on    systemctl enable foo.service    在下次启动时或满足其他触发条件时设置服务为启用&#xA;chkconfig foo off   systemctl disable foo.service   在下次启动时或满足其他触发条件时设置服务为禁用&#xA;chkconfig foo       systemctl is-enabled foo.service    用来检查一个服务在当前环境下被配置为启用还是禁用。&#xA;chkconfig –list     systemctl list-unit-files --type=service    输出在各个运行级别下服务的启用和禁用情况&#xA;chkconfig foo –list ls /etc/systemd/system/*.wants/foo.service  用来列出该服务在哪些运行级别下启用和禁用。&#xA;chkconfig foo –add  systemctl daemon-reload                         当您创建新服务文件或者变更设置时使用。&#xA;telinit 3       systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3) 改变至多用户运行级别。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Systemd 电源管理命令&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;systemctl reboot    重启机器&#xA;systemctl poweroff  关机&#xA;systemctl suspend   待机&#xA;systemctl hibernate 休眠&#xA;systemctl hybrid-sleep  混合休眠模式（同时休眠到硬盘并待机）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Systemd 物理文件组成&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Systemd是一个完整的软件包，安装完成后有很多物理文件组成.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大致分布为，配置文件位于/etc/systemd这个目录下，配置工具命令位于/bin，和/sbin这两个目录下&lt;/p&gt;&#xA;&#xA;&lt;p&gt;预先准备的备用配置文件位于/lib/systemd目录下，还有库文件和帮助手册等等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是一个庞大的软件包。详情使用rpm -ql systemd即可查看。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Systemd 运行原理&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;配置单元(unit)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;系统初始化要做很多工作，如挂载文件系统，启动服务，配置交换分区，都可以看做是一个配置单元，安装功能不同把配置单元分成多种类型。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;service &#xA;// 后台服务进程，如httpd，mysqld等&#xA;soket &#xA;// 对应一个套接字，之后对应到一个service，类似于xinetd的功能&#xA;device &#xA;// 对应udev规则标记的一个设备&#xA;mount &#xA;// 系统中的一个挂载点，systemd据此进行自动挂载，为了与SystemV兼容，目前systemd自动处理/etc/fstab并转化为mount&#xA;automount &#xA;// 自动挂载点&#xA;swap &#xA;// 配置交换分区&#xA;target &#xA;// 配置单元的逻辑分组，包含多个相关的配置单元，可以当成是SystemV中的运行级。&#xA;timer &#xA;// 定时器。用来定时触发用户定义的操作，它可以用来取代传统的atd，crond等。&#xA;snapshot &#xA;// 与target类似，表示当前的运行状态&#xA;&#xA;注意：每一个配置单元都有一个对应的配置文件，系统管理员的任务就是处理这些不同的文件，比如一个MySql服务对应一个mysql.service文件。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Journald&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Journald是systemd独有的日志系统，替换了sysVinit中的syslog守护进程。命令journalctl用来读取日志。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 所有引导日志&#xA;journalctl -b&#xA;// 系统时时日志（tail -f)&#xA;journalctl -f&#xA;// 指定查看程序日志&#xA;journalctl /usr/sbin/dnsmasq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;hostnamectl&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Systemd带来了一整套与操作系统交互的新途径，并且极具特色。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举个栗子，你可以用hostnamectl命令来获得你的linux机器的hostname和其它有用的独特信息。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   Static hostname: danooplayer&#xA;     Icon name: computer-desktop&#xA;       Chassis: desktop&#xA;    Machine ID: 0635b925bb7b4b7d9ad909b98374199d&#xA;       Boot ID: be2f99093bd3442c9c9516b938389c16&#xA;  Operating System: openSUSE 13.1 (Bottle) (i586)&#xA;       CPE OS Name: cpe:/o:opensuse:opensuse:13.1&#xA;        Kernel: Linux 3.11.6-4-desktop&#xA;      Architecture: i686&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Systemctl&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 列出当前目标&#xA;systemctl list-units --type=target&#xA;    // 输出&#xA;    basic.target         loaded active active Basic System&#xA;    cryptsetup.target    loaded active active Encrypted Volumes&#xA;    getty.target         loaded active active Login Prompts&#xA;    local-fs-pre.target  loaded active active Local File Systems (Pre)&#xA;    local-fs.target      loaded active active Local File Systems&#xA;    multi-user.target    loaded active active Multi-User System&#xA;    network.target       loaded active active Network&#xA;    nss-lookup.target    loaded active active Host and Network Name Lookups&#xA;    paths.target         loaded active active Paths&#xA;    remote-fs-pre.target loaded active active Remote File Systems (Pre)&#xA;    remote-fs.target     loaded active active Remote File Systems&#xA;    slices.target        loaded active active Slices&#xA;    sockets.target       loaded active active Sockets&#xA;    swap.target          loaded active active Swap&#xA;    sysinit.target       loaded active active System Initialization&#xA;    timers.target        loaded active active Timers&#xA;// 改变当前目标&#xA;systemctl isolate graphical.target&#xA;    // 查看支持的 target &#xA;    ll /usr/lib/systemd/system/*.target&#xA;// 默认目标&#xA;systemctl get-default&#xA;    // 输出&#xA;    runlevel3.target&#xA;// 设置默认目标&#xA;systemctl set-default graphical.target / multi-user.target&#xA;// 使某服务自动启动 &#xA;systemctl enable httpd.service&#xA;// 使某服务不自动启动    &#xA;systemctl disable httpd.service&#xA;// 检查服务状态   &#xA;systemctl status httpd.service （服务详细信息） &#xA;systemctl is-active httpd.service （仅显示是否 Active)&#xA;// 显示所有已启动的服务   &#xA;systemctl list-units --type=service&#xA;systemctl list-units --type=target&#xA;// 启动某服务&#xA;systemctl start httpd.service&#xA;// 停止某服务&#xA;systemctl stop httpd.service&#xA;// 重启某服务&#xA;systemctl restart httpd.service&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Systemd 的使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;下面针对技术人员的不同角色来简单地介绍一下 systemd 的使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本文只打算给出简单的描述，让您对 systemd 的使用有一个大概的理解。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体的细节内容太多，即无法在一篇短文内写全，本人也没有那么强大的能力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还需要读者自己去进一步查阅 systemd 的文档。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;系统软件开发人员&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开发人员需要了解 systemd 的更多细节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如您打算开发一个新的系统服务，就必须了解如何让这个服务能够被 systemd 管理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这需要您注意以下这些要点：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;后台服务进程代码不需要执行两次派生来实现后台精灵进程，只需要实现服务本身的主循环即可。&#xA;不要调用 setsid()，交给 systemd 处理&#xA;不再需要维护 pid 文件。&#xA;Systemd 提供了日志功能，服务进程只需要输出到 stderr 即可，无需使用 syslog。&#xA;处理信号 SIGTERM，这个信号的唯一正确作用就是停止当前服务，不要做其他的事情。&#xA;SIGHUP 信号的作用是重启服务。&#xA;需要套接字的服务，不要自己创建套接字，让 systemd 传入套接字。&#xA;使用 sd_notify()函数通知 systemd 服务自己的状态改变。一般地，当服务初始化结束，进入服务就绪状态时，可以调用它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Unit 文件的编写&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于开发者来说，工作量最大的部分应该是编写配置单元文件，定义所需要的单元。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举例来说，开发人员开发了一个新的服务程序&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如 httpd，就需要为其编写一个配置单元文件以便该服务可以被 systemd 管理&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类似 UpStart 的工作配置文件。在该文件中定义服务启动的命令行语法，以及和其他服务的依赖关系等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此外我们之前已经了解到，systemd 的功能繁多，不仅用来管理服务，还可以管理挂载点，定义定时任务等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些工作都是由编辑相应的配置单元文件完成的。我在这里给出几个配置单元文件的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是 SSH 服务的配置单元文件，服务配置单元文件以.service 为文件名后缀。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  #cat /etc/system/system/sshd.service&#xA;  [Unit]&#xA;  Description=OpenSSH server daemon&#xA;  [Service]&#xA;  EnvironmentFile=/etc/sysconfig/sshd&#xA;  ExecStartPre=/usr/sbin/sshd-keygen&#xA;  ExecStart=/usrsbin/sshd –D $OPTIONS&#xA;  ExecReload=/bin/kill –HUP $MAINPID&#xA;  KillMode=process&#xA;  Restart=on-failure&#xA;  RestartSec=42s&#xA;  [Install]&#xA;  WantedBy=multi-user.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;文件分为三个小节。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;第一个是[Unit]部分，这里仅仅有一个描述信息。&#xA;第二部分是 Service 定义，其中:&#xA;    ExecStartPre 定义启动服务之前应该运行的命令；&#xA;    ExecStart 定义启动服务的具体命令行语法。&#xA;第三部分是[Install]，WangtedBy 表明这个服务是在多用户模式下所需要的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;那我们就来看下 multi-user.target 吧：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  #cat multi-user.target&#xA;  [Unit]&#xA;  Description=Multi-User System&#xA;  Documentation=man.systemd.special(7)&#xA;  Requires=basic.target&#xA;  Conflicts=rescue.service rescure.target&#xA;  After=basic.target rescue.service rescue.target&#xA;  AllowIsolate=yes&#xA;  [Install]&#xA;  Alias=default.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;第一部分中的 Requires 定义表明 multi-user.target 启动的时候 basic.target 也必须被启动；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外 basic.target 停止的时候，multi-user.target 也必须停止。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果您接着查看 basic.target 文件，会发现它又指定了 sysinit.target 等其他的单元必须随之启动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样 sysinit.target 也会包含其他的单元。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;采用这样的层层链接的结构，最终所有需要支持多用户模式的组件服务都会被初始化启动好。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;此外在/etc/systemd/system 目录下还可以看到诸如*.wants 的目录&lt;/p&gt;&#xA;&#xA;&lt;p&gt;放在该目录下的配置单元文件等同于在[Unit]小节中的 wants 关键字&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即本单元启动时，还需要启动这些单元。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如您可以简单地把您自己写的 foo.service 文件放入 multi-user.target.wants 目录下，这样每次都会被默认启动了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;最后，让我们来看看 sys-kernel-debug.mout 文件，这个文件定义了一个文件挂载点：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#cat sys-kernel-debug.mount&#xA;[Unit]&#xA;Description=Debug File Syste&#xA;DefaultDependencies=no&#xA;ConditionPathExists=/sys/kernel/debug&#xA;Before=sysinit.target&#xA;[Mount]&#xA;What=debugfs&#xA;Where=/sys/kernel/debug&#xA;Type=debugfs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个配置单元文件定义了一个挂载点。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;挂载配置单元文件有一个[Mount]配置小节，里面配置了 What，Where 和 Type 三个数据项。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这都是挂载命令所必须的，例子中的配置等同于下面这个挂载命令：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;mount –t debugfs /sys/kernel/debug debugfs&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置单元文件的编写需要很多的学习，必须参考 systemd 附带的 man 等文档进行深入学习。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;希望通过上面几个小例子，大家已经了解配置单元文件的作用和一般写法了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h1&gt;补充&lt;/h1&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;关于通过 getty.target 终端启动与守护进程&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建终端配置文件&#xA;/usr/lib/systemd/system/getty@xxx.service&#xA;&#xA;// 内容&#xA;    #  This file is part of systemd.&#xA;    #&#xA;    #  systemd is free software; you can redistribute it and/or modify it&#xA;    #  under the terms of the GNU Lesser General Public License as published by&#xA;    #  the Free Software Foundation; either version 2.1 of the License, or&#xA;    #  (at your option) any later version.&#xA;&#xA;    [Unit]&#xA;    Description=Getty on %I&#xA;    Documentation=man:agetty(8) man:systemd-getty-generator(8)&#xA;    Documentation=http://0pointer.de/blog/projects/serial-console.html&#xA;    Conflicts=rescue.service&#xA;    After=systemd-user-sessions.service plymouth-quit-wait.service&#xA;    After=rc-local.service&#xA;&#xA;    # If additional gettys are spawned during boot then we should make&#xA;    # sure that this is synchronized before getty.target, even though&#xA;    # getty.target didn&#39;t actually pull it in.&#xA;    Before=getty.target&#xA;    IgnoreOnIsolate=yes&#xA;&#xA;    # On systems without virtual consoles, don&#39;t start any getty. Note&#xA;    # that serial gettys are covered by serial-getty@.service, not this&#xA;    # unit.&#xA;    // 终端 ...&#xA;    ConditionPathExists=/dev/tty0&#xA;&#xA;    [Service]&#xA;    # the VT is cleared by TTYVTDisallocate&#xA;    // 这里就是需要通过终端启动的进程&#xA;    ExecStart=/usr/bin/startx_run&#xA;    Type=idle&#xA;    Restart=always&#xA;    RestartSec=0&#xA;    UtmpIdentifier=%I&#xA;    TTYPath=/dev/%I&#xA;    TTYReset=yes&#xA;    TTYVHangup=yes&#xA;    TTYVTDisallocate=yes&#xA;    KillMode=process&#xA;    IgnoreSIGPIPE=no&#xA;    SendSIGHUP=yes&#xA;&#xA;    # Unset locale for the console getty since the console has problems&#xA;    # displaying some internationalized messages.&#xA;    Environment=LANG= LANGUAGE= LC_CTYPE= LC_NUMERIC= LC_TIME= LC_COLLATE= LC_MONETARY= LC_MESSAGES= LC_PAPER= LC_NAME= LC_ADDRESS= LC_TELEPHONE= LC_MEASUREMENT= LC_IDENTIFICATION=&#xA;&#xA;    [Install]&#xA;    WantedBy=getty.target&#xA;&#xA;// 进入终端启动的进程目录&#xA;/etc/systemd/system/getty.target.wants &#xA;&#xA;// 连接需要启动的进程配置文件&#xA;getty@tty1.service -&amp;gt; /usr/lib/systemd/system/getty@.service&#xA;getty@tty2.service -&amp;gt; /usr/lib/systemd/system/getty@...&#xA;getty@tty3.service -&amp;gt; /usr/lib/systemd/system/getty@...&#xA;getty@tty4.service -&amp;gt; /usr/lib/systemd/system/getty@...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之Interface接口使用</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BInterface%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-04-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Interface&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    // 创建一个Struct对象并赋值给Interface生成接口对象&#xA;    // 只有Struct与Interface存在共性函数才可以生成对象&#xA;    // 而该接口对象只保留Struct与Interface的共性函数&#xA;    // 多个接口对象来一不同Struct但赋值给同一Interface&#xA;    // 它们相互间Interface相同，只是接口相同，实现不同&#xA;    var a Interface = new(A)&#xA;    var b Interface = new(B)&#xA;    Print(a)&#xA;    Print(b)&#xA;&#xA;}&#xA;&#xA;// Interface&#xA;type Interface interface {&#xA;    Close()&#xA;}&#xA;&#xA;// A&#xA;type A struct {&#xA;}&#xA;&#xA;// A Function&#xA;func (this *A) Open() {&#xA;&#xA;}&#xA;&#xA;// A Function&#xA;func (this *A) Close() {&#xA;    fmt.Println(&amp;quot;Close is A&amp;quot;)&#xA;}&#xA;&#xA;// B&#xA;type B struct {&#xA;}&#xA;&#xA;// B Function&#xA;func (this *B) Close() {&#xA;    fmt.Println(&amp;quot;Close is B&amp;quot;)&#xA;}&#xA;&#xA;// Print&#xA;func Print(i Interface) {&#xA;    i.Close()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之华为手机Logcat开启方式</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BALogcat%E5%BC%80%E5%90%AF%E6%96%B9%E5%BC%8F/</link>
      <pubDate>2015-04-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Logcat&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;华为手机默认Logcat是关闭的，当需要真机调试的时候，可以通过工程模式开启&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在拨打电话界面，录入&lt;em&gt;#&lt;/em&gt;#2846579#&lt;em&gt;#&lt;/em&gt; 即可进入工程模式&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之华为手机Logcat开启方式/1.jpeg&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;1000&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之华为手机Logcat开启方式/2.jpeg&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;1000&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之华为手机Logcat开启方式/3.jpeg&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;1000&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>网络流量实时监控工具</title>
      <link>http://www.nljb.net/default/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</link>
      <pubDate>2015-04-14 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;NLoad是个很好用的一个工具,功能也很强.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;只是相对单一,只能查看总的流量,不能像iptraf那样,可针对IP,协议等&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以实时地监控网卡的流量,分Incoming,Outgoing两部分,也就是流入与流出的流量&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同时统计当前,平均,最小,最大,总流量的值,使人看了一目了然,如下图&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/网络流量实时监控工具/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;官网 &lt;a href=&#34;http://www.roland-riegel.de/nload/index.html&#34;&gt;http://www.roland-riegel.de/nload/index.html&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之ZXing从相册扫描二维码</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BZXing%E4%BB%8E%E7%9B%B8%E5%86%8C%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81/</link>
      <pubDate>2015-04-14 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;### ZXing&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 监听按钮触发选择相册图片&#xA;    photoCameraButton = (Button) this.findViewById(R.id.btn_photo_camera);&#xA;    photoCameraButton.getBackground().setAlpha(50);&#xA;    photoCameraButton.setOnClickListener(new OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;            Intent innerIntent = new Intent();&#xA;            innerIntent.setAction(Intent.ACTION_GET_CONTENT);&#xA;            innerIntent.setType(&amp;quot;image/*&amp;quot;);&#xA;            Intent wrapperIntent = Intent.createChooser(innerIntent, &amp;quot;选择二维码图片&amp;quot;);&#xA;            CaptureActivity.this&#xA;                    .startActivityForResult(wrapperIntent, 1001);&#xA;        }&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  // 监听返回&#xA;  @Override&#xA;    protected void onActivityResult(int requestCode, int resultCode, Intent data) {&#xA;    super.onActivityResult(requestCode, resultCode, data);&#xA;    if (resultCode == RESULT_OK) {&#xA;        switch (requestCode) {&#xA;        case 1001:&#xA;&#xA;            // 图片&#xA;            Bitmap bitmap = null;&#xA;&#xA;            String[] proj = {MediaStore.Images.Media.DATA};&#xA;&#xA;            // 获取选中图片的路径&#xA;            Cursor cursor = getContentResolver().query(data.getData(), proj, null, null, null);&#xA;            if (cursor.moveToFirst()) {&#xA;            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);&#xA;            try {&#xA;                bitmap = RGBLuminanceSource.loadBitmap(cursor.getString(column_index));&#xA;            } catch (FileNotFoundException e) {&#xA;                Log.e(&amp;quot;Err&amp;quot;, e.toString());&#xA;                e.printStackTrace();&#xA;            }&#xA;            }&#xA;&#xA;            Hashtable&amp;lt;EncodeHintType, String&amp;gt; hints = new Hashtable&amp;lt;EncodeHintType, String&amp;gt;();&#xA;            hints.put(EncodeHintType.CHARACTER_SET, &amp;quot;utf-8&amp;quot;);&#xA;            RGBLuminanceSource source = new RGBLuminanceSource(bitmap);&#xA;            BinaryBitmap bitmap1 = new BinaryBitmap(new HybridBinarizer(source));&#xA;            QRCodeReader reader2 = new QRCodeReader();&#xA;            Result result = null;&#xA;            try {&#xA;            try {&#xA;                result = reader2.decode(bitmap1, hints);&#xA;            } catch (ChecksumException e) {&#xA;                // TODO Auto-generated catch block&#xA;                Toast.makeText(getApplicationContext(), &amp;quot;失败&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;            } catch (FormatException e) {&#xA;                // TODO Auto-generated catch block&#xA;                Toast.makeText(getApplicationContext(), &amp;quot;失败&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;            }&#xA;            // 成功&#xA;            if (result != null) {&#xA;                // System.out.println(&amp;quot;Result:&amp;quot; + result.getText());&#xA;                Intent resultIntent = new Intent();&#xA;                Bundle bundle = new Bundle();&#xA;                bundle.putString(&amp;quot;result&amp;quot;, result.getText());&#xA;                resultIntent.putExtras(bundle);&#xA;                this.setResult(RESULT_OK, resultIntent);&#xA;                CaptureActivity.this.finish();&#xA;            } else {&#xA;                Toast.makeText(getApplicationContext(), &amp;quot;失败&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;            }&#xA;            } catch (NotFoundException e) {&#xA;            // TODO Auto-generated catch block&#xA;            Toast.makeText(getApplicationContext(), &amp;quot;失败&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;            }&#xA;            break;&#xA;        }&#xA;    }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 除了jar包，这里还要用到一个类就是&#xA;/*&#xA; * Copyright 2009 ZXing authors&#xA; *&#xA; * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);&#xA; * you may not use this file except in compliance with the License.&#xA; * You may obtain a copy of the License at&#xA; *&#xA; *      http://www.apache.org/licenses/LICENSE-2.0&#xA; *&#xA; * Unless required by applicable law or agreed to in writing, software&#xA; * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,&#xA; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA; * See the License for the specific language governing permissions and&#xA; * limitations under the License.&#xA; */&#xA;&#xA;package ;&#xA;&#xA;import java.io.FileNotFoundException;&#xA;&#xA;import android.graphics.Bitmap;&#xA;import android.graphics.BitmapFactory;&#xA;&#xA;import com.google.zxing.LuminanceSource;&#xA;&#xA;/**&#xA; * This class is used to help decode images from files which arrive as RGB data&#xA; * from Android bitmaps. It does not support cropping or rotation.&#xA; * &#xA; * @author dswitkin@google.com (Daniel Switkin)&#xA; */&#xA;public final class RGBLuminanceSource extends LuminanceSource {&#xA;    private final byte[] luminances;&#xA;&#xA;    public RGBLuminanceSource(String path) throws FileNotFoundException {&#xA;    this(loadBitmap(path));&#xA;    }&#xA;&#xA;    public RGBLuminanceSource(Bitmap bitmap) {&#xA;    super(bitmap.getWidth(), bitmap.getHeight());&#xA;    int width = bitmap.getWidth();&#xA;    int height = bitmap.getHeight();&#xA;    int[] pixels = new int[width * height];&#xA;    bitmap.getPixels(pixels, 0, width, 0, 0, width, height);&#xA;    // In order to measure pure decoding speed, we convert the entire image&#xA;    // to a greyscale array&#xA;    // up front, which is the same as the Y channel of the&#xA;    // YUVLuminanceSource in the real app.&#xA;    luminances = new byte[width * height];&#xA;    for (int y = 0; y &amp;lt; height; y++) {&#xA;        int offset = y * width;&#xA;        for (int x = 0; x &amp;lt; width; x++) {&#xA;        int pixel = pixels[offset + x];&#xA;        int r = (pixel &amp;gt;&amp;gt; 16) &amp;amp; 0xff;&#xA;        int g = (pixel &amp;gt;&amp;gt; 8) &amp;amp; 0xff;&#xA;        int b = pixel &amp;amp; 0xff;&#xA;        if (r == g &amp;amp;&amp;amp; g == b) {&#xA;            // Image is already greyscale, so pick any channel.&#xA;            luminances[offset + x] = (byte) r;&#xA;        } else {&#xA;            // Calculate luminance cheaply, favoring green.&#xA;            luminances[offset + x] = (byte) ((r + g + g + b) &amp;gt;&amp;gt; 2);&#xA;        }&#xA;        }&#xA;    }&#xA;    }&#xA;&#xA;    @Override&#xA;    public byte[] getRow(int y, byte[] row) {&#xA;    if (y &amp;lt; 0 || y &amp;gt;= getHeight()) {&#xA;        throw new IllegalArgumentException(&#xA;            &amp;quot;Requested row is outside the image: &amp;quot; + y);&#xA;    }&#xA;    int width = getWidth();&#xA;    if (row == null || row.length &amp;lt; width) {&#xA;        row = new byte[width];&#xA;    }&#xA;    System.arraycopy(luminances, y * width, row, 0, width);&#xA;    return row;&#xA;    }&#xA;&#xA;    // Since this class does not support cropping, the underlying byte array&#xA;    // already contains&#xA;    // exactly what the caller is asking for, so give it to them without a copy.&#xA;    @Override&#xA;    public byte[] getMatrix() {&#xA;    return luminances;&#xA;    }&#xA;&#xA;    private static Bitmap loadBitmap(String path) throws FileNotFoundException {&#xA;    Bitmap bitmap = BitmapFactory.decodeFile(path);&#xA;    if (bitmap == null) {&#xA;        throw new FileNotFoundException(&amp;quot;Couldn&#39;t open &amp;quot; + path);&#xA;    }&#xA;    return bitmap;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;但是可能由于版本问题，QRCodeReader.decode()方法的参数有点变化，可以参考&#xA;http://blog.csdn.net/cgwcgw_/article/details/10817121&#xA;&#xA;Map&amp;lt;DecodeHintType, String&amp;gt; map = new HashMap&amp;lt;DecodeHintType, String&amp;gt;();  &#xA;    map.put(DecodeHintType.CHARACTER_SET, &amp;quot;utf-8&amp;quot;);&#xA;&#xA;HashMap&amp;lt;DecodeHintType, String&amp;gt; hints = new HashMap&amp;lt;DecodeHintType, String&amp;gt;();  &#xA;hints.put(DecodeHintType.CHARACTER_SET, &amp;quot;utf-8&amp;quot;);&#xA;&#xA;Hashtable&amp;lt;EncodeHintType, String&amp;gt; hints = new Hashtable&amp;lt;EncodeHintType, String&amp;gt;();&#xA;hints.put(EncodeHintType.CHARACTER_SET, &amp;quot;utf-8&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之SwipeRefreshLayout手势刷新</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BSwipeRefreshLayout%E6%89%8B%E5%8A%BF%E5%88%B7%E6%96%B0/</link>
      <pubDate>2015-04-07 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SwipeRefreshLayout&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;SwipeRefreshLayout组件是由SDK提供，已经被用于一些Android自己的应用程序（比如Gmail）的实现。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;SwipeRefreshLayout组件只接受一个子组件：即需要刷新的那个组件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它使用一个侦听机制来通知拥有该组件的监听器有刷新事件发生&lt;/p&gt;&#xA;&#xA;&lt;p&gt;换句话说我们的Activity必须实现通知的接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该Activity负责处理事件刷新和刷新相应的视图。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一旦监听者接收到该事件，就决定了刷新过程中应处理的地方。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果要展示一个“刷新动画”，它必须调用setRefrshing（true），否则取消动画就调用setRefreshing（false）。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ...&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;android.support.v4.widget.SwipeRefreshLayout&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:id=&amp;quot;@+id/proxy&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;FrameLayout&#xA;    android:id=&amp;quot;@+id/preference&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&amp;lt;/FrameLayout&amp;gt;&#xA;&#xA;&amp;lt;/android.support.v4.widget.SwipeRefreshLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@Override&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    final SwipeRefreshLayout swipeView = (SwipeRefreshLayout) findViewById(R.id.swipe);&#xA;    final TextView rndNum = (TextView) findViewById(R.id.rndNum);&#xA;    // PS: setColorScheme 已经被弃用，使用setColorSchemeResources()来设置颜色。&#xA;    // swipeView.setColorScheme(android.R.color.holo_blue_dark,&#xA;             android.R.color.holo_blue_light, &#xA;             android.R.color.holo_green_light, &#xA;             android.R.color.holo_green_light);&#xA;    swipeView.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {&#xA;    @Override&#xA;    public void onRefresh() {&#xA;        swipeView.setRefreshing(true);&#xA;        Log.d(&amp;quot;Swipe&amp;quot;, &amp;quot;Refreshing Number&amp;quot;);&#xA;        ( new Handler()).postDelayed(new Runnable() {&#xA;        @Override&#xA;        public void run() {&#xA;            swipeView.setRefreshing(false);&#xA;            double f = Math.random();&#xA;            rndNum.setText(String.valueOf(f));&#xA;        }&#xA;        }, 3000);&#xA;    }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;解决，下拉刷新时手势与其它下拉控件冲突问题&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// XML&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;com.example.nljb.surpass.MySwipeRefreshLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:id=&amp;quot;@+id/fragment_preference&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;FrameLayout&#xA;    android:id=&amp;quot;@+id/preference&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&amp;lt;/FrameLayout&amp;gt;&#xA;&#xA;&amp;lt;/com.example.nljb.surpass.MySwipeRefreshLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 控制下拉距离来实现大距离刷新，小距离忽略&#xA;public class MySwipeRefreshLayout extends SwipeRefreshLayout {&#xA;&#xA;    private float mPrev;&#xA;&#xA;    public MySwipeRefreshLayout(Context context, AttributeSet attrs) {&#xA;    super(context, attrs);&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onInterceptTouchEvent(MotionEvent event) {&#xA;&#xA;    switch (event.getAction()) {&#xA;        case MotionEvent.ACTION_DOWN:&#xA;        mPrev = MotionEvent.obtain(event).getY();&#xA;        break;&#xA;&#xA;        case MotionEvent.ACTION_MOVE:&#xA;        final float e = event.getY();&#xA;        float diff = Math.abs(e - mPrev);&#xA;        if (diff &amp;lt; 200) {&#xA;            return false;&#xA;        }&#xA;    }&#xA;&#xA;    return super.onInterceptTouchEvent(event);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;下拉刷新时切换重影问题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这个没找到什么好办法&#xA;// 网上说的设置背景之类的都无效&#xA;// 解决办法时，当发现用户离开当前页面&#xA;// 的意图时，停止刷新&#xA;&#xA;// Refresh&#xA;public void startRefresh() {&#xA;    refreshStatus = true;&#xA;    layout.setRefreshing(true);&#xA;}&#xA;&#xA;// Refresh&#xA;public void stopRefresh() {&#xA;    layout.setRefreshing(false);&#xA;    refreshStatus = false;&#xA;}&#xA;&#xA;// 比如我这里是，当用户点击侧滑箭头时停止刷新&#xA;@Override&#xA;public boolean onOptionsItemSelected(MenuItem item) {&#xA;    int id = item.getItemId();&#xA;    switch (id) {&#xA;        // 判断是否为主按钮点击&#xA;        case android.R.id.home:&#xA;        // 拦截刷新状态&#xA;        if (refreshStatus) {&#xA;            // 停止刷新&#xA;            stopRefresh();&#xA;        }&#xA;    }&#xA;    return super.onOptionsItemSelected(item);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之WebSocket使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BWebSocket%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-31 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;WebSocket&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;WebSocket protocol 是HTML5一种新的协议。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它实现了浏览器与服务器全双工通信(full-duplex)。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android下支持WebSocket的库&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 试了很多的库，只有一个可以使用&#xA;支持 https://github.com/codebutler/android-websockets&#xA;失败 https://github.com/tavendo/AutobahnAndroid&#xA;失败 https://github.com/koush/AndroidAsync&#xA;失败 https://github.com/anismiles/websocket-android-phonegap&#xA;失败 https://github.com/TooTallNate/Java-WebSocket&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方案例&#xA;List&amp;lt;BasicNameValuePair&amp;gt; extraHeaders = Arrays.asList(&#xA;    new BasicNameValuePair(&amp;quot;Cookie&amp;quot;, &amp;quot;session=abcd&amp;quot;);&#xA;);&#xA;&#xA;WebSocketClient client = new WebSocketClient(URI.create(&amp;quot;wss://irccloud.com&amp;quot;), new WebSocketClient.Handler() {&#xA;    @Override&#xA;    public void onConnect() {&#xA;    Log.d(TAG, &amp;quot;Connected!&amp;quot;);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onMessage(String message) {&#xA;    Log.d(TAG, String.format(&amp;quot;Got string message! %s&amp;quot;, message));&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onMessage(byte[] data) {&#xA;    Log.d(TAG, String.format(&amp;quot;Got binary message! %s&amp;quot;, toHexString(data));&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onDisconnect(int code, String reason) {&#xA;    Log.d(TAG, String.format(&amp;quot;Disconnected! Code: %d Reason: %s&amp;quot;, code, reason));&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onError(Exception error) {&#xA;    Log.e(TAG, &amp;quot;Error!&amp;quot;, error);&#xA;    }&#xA;}, extraHeaders);&#xA;&#xA;client.connect();&#xA;&#xA;// Later… &#xA;client.send(&amp;quot;hello!&amp;quot;);&#xA;client.send(new byte[] { 0xDE, 0xAD, 0xBE, 0xEF });&#xA;client.disconnect();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之蓝牙设备的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-27 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// &#xA;public class MainActivity extends Activity {&#xA;&#xA;    private BluetoothAdapter bluet;&#xA;&#xA;    private final static int REQUEST_ENABLE_BT = 1;&#xA;&#xA;    // Create a BroadcastReceiver for ACTION_FOUND&#xA;    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {&#xA;    @Override&#xA;    public void onReceive(Context context, Intent intent) {&#xA;        // 获取 Action&#xA;        String action = intent.getAction();&#xA;        // 查找到设备&#xA;        if (BluetoothDevice.ACTION_FOUND.equals(action)) {&#xA;        // 蓝牙设备&#xA;        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);&#xA;        Log.i(&amp;quot;INFO&amp;quot;, device.getName() + &amp;quot;,&amp;quot; + device.getAddress());&#xA;        // 搜索完成&#xA;        } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {&#xA;        Toast.makeText(MainActivity.this, &amp;quot;搜索完毕&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;    }&#xA;    };&#xA;&#xA;    @Override&#xA;    public void onDestroy() {&#xA;    super.onDestroy();&#xA;    // 关闭服务查找&#xA;    if (bluet != null) {&#xA;        bluet.cancelDiscovery();&#xA;    }&#xA;    // 注销接收器&#xA;    unregisterReceiver(mReceiver);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    // 获取蓝牙适配器 bluetoothadapter&#xA;    bluet = BluetoothAdapter.getDefaultAdapter();&#xA;    if (bluet == null) { // 是否支持&#xA;&#xA;    } else if (!bluet.isEnabled()) { // 是否开启&#xA;        // 开启蓝牙&#xA;        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);&#xA;        startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#xA;    }&#xA;&#xA;    // 注册接收查找到设备action接收器&#xA;    IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);&#xA;    registerReceiver(mReceiver, filter);&#xA;&#xA;    // 注册查找结束action接收器&#xA;    filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);&#xA;    registerReceiver(mReceiver, filter);&#xA;&#xA;    // ...&#xA;    Button button = (Button) findViewById(R.id.start);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        // 关闭再进行的服务查找&#xA;        if (bluet.isDiscovering()) {&#xA;            bluet.cancelDiscovery();&#xA;        }&#xA;        bluet.startDiscovery();&#xA;        }&#xA;    });&#xA;&#xA;    // ...&#xA;    Button stop = (Button) findViewById(R.id.stop);&#xA;    stop.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        bluet.cancelDiscovery();&#xA;        }&#xA;    });&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux之dhcpcd永远等待租约方法</title>
      <link>http://www.nljb.net/default/Linux%E4%B9%8Bdhcpcd%E6%B0%B8%E8%BF%9C%E7%AD%89%E5%BE%85%E7%A7%9F%E7%BA%A6%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;dhcpcd 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;dhcpcd 是一个符合RFC1541 标准的DHCP 客户端程序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它可以从相应的DHCP服务器获得IP 地址和其他信息&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以自动配置网络，并可以按照RFC1541 标准进行超时重试。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dhcpcd [-bdeknpqABDEGKLTV] [-c, --script script] [-f, --config file]&#xA;    [-h, --hostname hostname] [-i, --vendorclassid vendorclassid]&#xA;    [-l, --leasetime seconds] [-m, --metric metric]&#xA;    [-o, --option option] [-r, --request address]&#xA;    [-s, --inform address[/cidr]] [-t, --timeout seconds]&#xA;    [-u, --userclass class] [-v, --vendor code, value]&#xA;    [-y, --reboot seconds] [-z, --allowinterfaces pattern]&#xA;    [-C, --nohook hook] [-F, --fqdn FQDN] [-I, --clientid clientid]&#xA;    [-O, --nooption option] [-Q, --require option]&#xA;    [-S, --static value] [-X, --blacklist address[/cidr]]&#xA;    [-Z, --denyinterfaces pattern] [interface] [...]&#xA;dhcpcd -k, --release [interface]&#xA;dhcpcd -x, --exit [interface]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;TIMEOUT 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;当系统启动时，没有接入网线，又需要连接网络时DHCP获取IP等网络信息.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时就需要使用TIMEOUT设置延时时间，否则会在30秒后为系统配置默认IP&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是说明介绍，当TIMEOUT时间为0时，则会一直等待请求该租约地址&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-t, --timeout seconds&#xA;     Timeout after seconds, instead of the default 30.  A setting of 0&#xA;     seconds causes dhcpcd to wait forever to get a lease.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-b, --background&#xA;     Background immediately.  This is useful for startup scripts which&#xA;     don&#39;t disable link messages for carrier status.&#xA;&#xA;-c, --script script&#xA;     Use this script instead of the default /libexec/dhcpcd-run-hooks.&#xA;&#xA;-d, --debug&#xA;     Echo debug and informational messages to the console.  Subsequent&#xA;     debug options stop dhcpcd from daemonising.&#xA;&#xA;-e, --reconfigure&#xA;     dhcpcd will re-apply IP address, routing and run&#xA;     dhcpcd-run-hooks(8) for each interface.  This is useful so that a&#xA;     3rd party such as PPP or VPN can change the routing table and /&#xA;     or DNS, etc and then instruct dhcpcd to put things back after-&#xA;     wards.  dhcpcd does not read a new configuration when this hap-&#xA;     pens - you should rebind if you need that functionality.&#xA;&#xA;-f, --config file&#xA;     Specify a config to load instead of /etc/dhcpcd.conf.  dhcpcd&#xA;     always processes the config file before any command line options.&#xA;&#xA;-h, --hostname hostname&#xA;     By default, dhcpcd sends the current hostname to the DHCP server&#xA;     so it can register in DNS.  You can use this option to specify&#xA;     the hostname sent, or an empty string to stop any hostname from&#xA;     being sent.&#xA;&#xA;-i, --vendorclassid vendorclassid&#xA;     Override the vendorclassid field sent. The default is dhcpcd&#xA;     &amp;lt;version&amp;gt;.  If not set then none is sent.&#xA;&#xA;-k, --release&#xA;     This causes an existing dhcpcd process running on the interface&#xA;     to release its lease, deconfigure the interface and then exit.&#xA;     dhcpcd then waits until this process has exited.&#xA;&#xA;-l, --leasetime seconds&#xA;     Request a specific lease time in seconds.  By default dhcpcd does&#xA;     not request any lease time and leaves the it in the hands of the&#xA;     DHCP server.&#xA;&#xA;-m, --metric metric&#xA;     Metrics are used to prefer an interface over another one, lowest&#xA;     wins.  dhcpcd will supply a default metic of 200 +&#xA;     if_nametoindex(3).  An extra 100 will be added for wireless&#xA;     interfaces.&#xA;&#xA;-o, --option option&#xA;     Request the DHCP option variable for use in&#xA;     /libexec/dhcpcd-run-hooks.&#xA;&#xA;-n, --rebind&#xA;     Notifies an existing dhcpcd process running on the interface to&#xA;     rebind it&#39;s lease.  dhcpcd will not re-configure itself or use&#xA;     any other command line arguments.  dhcpcd will timeout the rebind&#xA;     after 30 seconds at which point the lease will be expired and&#xA;     dhcpcd will enter the discovery state to obtain a new lease.  Use&#xA;     the -t, --timeout option to change this.  If dhcpcd is not run-&#xA;     ning, then it starts up as normal.  This option used to be renew,&#xA;     but rebind is more accurate as we need to broadcast the request&#xA;     instead of unicasting.&#xA;&#xA;-p, --persistent&#xA;     dhcpcd normally deconfigures the interface and configuration when&#xA;     it exits.  Sometimes, this isn&#39;t desirable if for example you&#xA;     have root mounted over NFS.  You can use this option to stop this&#xA;     from happening.&#xA;&#xA;-r, --request [address]&#xA;     dhcpcd normally sends a DHCP DISCOVER to find servers to offer an&#xA;     address.  dhcpcd then requests the address used.  You can use&#xA;     this option to skip the BROADCAST step and just request the&#xA;     address.  The downside is if you request an address the DHCP&#xA;     server does not know about or the DHCP server is not authorative,&#xA;     it will remain silent.  In this situation, we go back to the init&#xA;     state and DISCOVER again.  If no address is given then the first&#xA;     address currently assigned to the interface is used.&#xA;&#xA;-s, --inform [address[/cidr]]&#xA;     Behaves like -r, --request as above, but sends a DHCP INFORM&#xA;     instead of a REQUEST.  This does not get a lease as such, just&#xA;     notifies the DHCP server of the address in use.  You should also&#xA;     include the optional cidr network number in-case the address is&#xA;     not already configured on the interface.  dhcpcd remains running&#xA;     and pretends it has an infinite lease.  dhcpcd will not de-con-&#xA;     figure the interface when it exits.  If dhcpcd fails to contact a&#xA;     DHCP server then it returns a failure instead of falling back on&#xA;     IPv4LL.&#xA;&#xA;-t, --timeout seconds&#xA;     Timeout after seconds, instead of the default 30.  A setting of 0&#xA;     seconds causes dhcpcd to wait forever to get a lease.&#xA;&#xA;-u, --userclass class&#xA;     Tags the DHCP message with the userclass class.  DHCP servers use&#xA;     this give members of the class DHCP options other than the&#xA;     default, without having to know things like hardware address or&#xA;     hostname.&#xA;&#xA;-v, --vendor code,value&#xA;     Add an enscapulated vendor option.  code should be between 1 and&#xA;     254 inclusive.  Examples.&#xA;&#xA;     Set the vendor option 01 with an IP address.&#xA;       dhcpcd -v 01,192.168.0.2 eth0&#xA;     Set the vendor option 02 with a hex code.&#xA;       dhcpcd -v 02,01:02:03:04:05 eth0&#xA;     Do the above and set a third option with a string and not an IP&#xA;     address.&#xA;       dhcpcd -v 01,192.168.0.2 -v 02,01:02:03:04:05 -v&#xA;       03,\&amp;quot;192.168.0.2\&amp;quot; eth0&#xA;&#xA;-x, --exit&#xA;     This will signal an existing dhcpcd process running on the&#xA;     interface to deconfigure the interface and exit.  dhcpcd then&#xA;     waits until this process has exited.&#xA;&#xA;-y, --reboot seconds&#xA;     Allow reboot seconds before moving to the discover phase if we&#xA;     have an old lease to use.  The default is 10 seconds.  A setting&#xA;     if 0 seconds causes dhcpcd to skip the reboot phase and go&#xA;     straight into discover.&#xA;&#xA;-D, --duid&#xA;     Generate an RFC 4361 compliant clientid.  This requires persis-&#xA;     tent storage and not all DHCP servers work with it so it&#39;s not&#xA;     enabled by default.  dhcpcd generates the DUID and stores in it&#xA;     /etc/dhcpcd.duid This file should not be copied to other hosts.&#xA;&#xA;-E, --lastlease&#xA;     If dhcpcd cannot obtain a lease, then try to use the last lease&#xA;     acquired for the interface.  If the -p, --persistent option is&#xA;     not given then the lease is used if it hasn&#39;t expired.&#xA;&#xA;-F, --fqdn fqdn&#xA;     Requests that the DHCP server updates DNS using FQDN instead of&#xA;     just a hostname.  Valid values for fqdn are disable, none, ptr&#xA;     and both.  dhcpcd itself never does any DNS updates.  dhcpcd&#xA;     encodes the FQDN hostname as specified in RFC1035.&#xA;&#xA;-I, --clientid clientid&#xA;     Send the clientid.  If the string is of the format 01:02:03 then&#xA;     it is encoded as hex.  For interfaces whose hardware address is&#xA;     longer than 8 bytes, or if the clientid is an empty string then&#xA;     dhcpcd sends a default clientid of the hardware family and the&#xA;     hardware address.&#xA;&#xA;Restricting behaviour&#xA;dhcpcd will try to do as much as it can by default.  However, there are&#xA;sometimes situations where you don&#39;t want the things to be configured&#xA;exactly how the the DHCP server wants.  Here are some options that deal&#xA;with turning these bits off.&#xA;&#xA;-q, --quiet&#xA;     Quiet dhcpcd on the command line, only warnings and errors will&#xA;     be displayed.  The messages are still logged though.&#xA;&#xA;-z, --allowinterfaces pattern&#xA;     When discovering interfaces, the interface name must match&#xA;     pattern which is a space or comma separated list of patterns&#xA;     passed to fnmatch(3).  If the same interface is matched in -Z,&#xA;     --denyinterfaces then it is still denied.&#xA;&#xA;-A, --noarp&#xA;     Don&#39;t request or claim the address by ARP.  This also disables&#xA;     IPv4LL.&#xA;&#xA;-B, --nobackground&#xA;     Don&#39;t run in the background when we acquire a lease.  This is&#xA;     mainly useful for running under the control of another process,&#xA;     such as a debugger or a network manager.&#xA;&#xA;-C, --nohook script&#xA;     Don&#39;t run this hook script.  Matches full name, or prefixed with&#xA;     2 numbers optionally ending with .sh.&#xA;&#xA;     So to stop dhcpcd from touching your DNS or MTU settings you&#xA;     would do:-&#xA;       dhcpcd -C resolv.conf -C mtu eth0&#xA;&#xA;-G, --nogateway&#xA;     Don&#39;t set any default routes.&#xA;&#xA;-K, --nolink&#xA;     Don&#39;t receive link messages for carrier status.  You should only&#xA;     have to use this with buggy device drivers or running dhcpcd&#xA;     through a network manager.&#xA;&#xA;-L, --noipv4ll&#xA;     Don&#39;t use IPv4LL (aka APIPA, aka Bonjour, aka ZeroConf).&#xA;&#xA;-O, --nooption option&#xA;     Don&#39;t request the specified option.  If no option given, then&#xA;     don&#39;t request any options other than those to configure the&#xA;     interface and routing.&#xA;&#xA;-Q, --require option&#xA;     Requires the option to be present in all DHCP messages, otherwise&#xA;     the message is ignored.  To enforce that dhcpcd only responds to&#xA;     DHCP servers and not BOOTP servers, you can -Q dhcp_message_type.&#xA;&#xA;-S, --static value&#xA;     Configures a static value.  If you set ip_address then dhcpcd&#xA;     will not attempt to obtain a lease and just use the value for the&#xA;     address with an infinite lease time.&#xA;&#xA;     Here is an example which configures a static address, routes and&#xA;     dns.&#xA;       dhcpcd -S ip_address=192.168.0.10/24 \&#xA;       -S routers=192.168.0.1 \&#xA;       -S domain_name_servers=192.168.0.1 \&#xA;       eth0&#xA;&#xA;-T, --test&#xA;     On receipt of OFFER messages just call /libexec/dhcpcd-run-hooks&#xA;     with the reason of TEST which echo&#39;s the DHCP variables found in&#xA;     the message to the console.  The interface configuration isn&#39;t&#xA;     touched and neither are any configuration files.&#xA;&#xA;-V, --variables&#xA;     Display a list of option codes and the associated variable for&#xA;     use in dhcpcd-run-hooks(8).  Variables are prefixed with new_ and&#xA;     old_ unless the option number is -.  Variables without an option&#xA;     are part of the DHCP message and cannot be directly requested.&#xA;&#xA;-X, --blacklist address[/cidr]&#xA;     Ignore all packets from address[/cidr].&#xA;&#xA;-Z, --denyinterfaces pattern&#xA;     When discovering interfaces, the interface name must not match&#xA;     pattern which is a space or comma separated list of patterns&#xA;     passed to fnmatch(3).&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Vibrator振动器的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BVibrator%E6%8C%AF%E5%8A%A8%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-03-25 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Vibrator&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android手机中的震动由Vibrator实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设置震动事件，需要知道其震动的时间长短、震动的周期等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Android Vibrator中，震动的时间一毫秒计算（1/1000秒）&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// AndroidManifest.xml&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.VIBRATE&amp;quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&#xA;&#xA;// Activity 控制振动器&#xA;public class MainActivity extends Activity {&#xA;&#xA;    // 振动器&#xA;    Vibrator vibrator;&#xA;&#xA;    @Override&#xA;    public void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    // 获取震动服务&#xA;    vibrator = (Vibrator) getSystemService(Service.VIBRATOR_SERVICE);&#xA;    Button button = (Button) findViewById(R.id.start);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        // 震动一秒&#xA;        vibrator.vibrate(1000);&#xA;        Intent intent;&#xA;        intent = new Intent(MainActivity.this, MainActivity2Activity.class);&#xA;        startActivity(intent);&#xA;        }&#xA;    });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之ViewPagerAdapter使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BViewPagerAdapter%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;PagerAdapter 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;属于：android.support.v4.view.PagerAdapter;&#xA;扩展：com.android.support:support-v4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// activity_main.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;android.support.v4.view.ViewPager&#xA;    android:id=&amp;quot;@+id/viewpager&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:background=&amp;quot;#00000000&amp;quot;&amp;gt;&#xA;    &amp;lt;/android.support.v4.view.ViewPager&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&#xA;// one.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:background=&amp;quot;@drawable/guide_1&amp;quot;&#xA;    /&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;// two.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:background=&amp;quot;@drawable/guide_2&amp;quot;&#xA;    /&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;// three.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:background=&amp;quot;@drawable/guide_3&amp;quot;&#xA;    /&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    private ViewPager vp;&#xA;    private ViewPagerAdapter vpa;&#xA;    private List&amp;lt;View&amp;gt; views;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    // 获取 LayoutInflater&#xA;    LayoutInflater inflater = LayoutInflater.from(this);&#xA;&#xA;    // 获取 View 并加入 List&#xA;    views = new ArrayList&amp;lt;View&amp;gt;();&#xA;    views.add(inflater.inflate(R.layout.one, null));&#xA;    views.add(inflater.inflate(R.layout.two, null));&#xA;    views.add(inflater.inflate(R.layout.three, null));&#xA;&#xA;    // 将 ViewList 传入 ViewPagerAdapter&#xA;    vpa = new ViewPagerAdapter(views, this);&#xA;&#xA;    // 获取 android.support.v4.view.ViewPager&#xA;    vp = (ViewPager) findViewById(R.id.viewpager);&#xA;&#xA;    // 设置 Adapter&#xA;    vp.setAdapter(vpa);&#xA;    }&#xA;&#xA;}&#xA;&#xA;//  ViewPagerAdapter&#xA;public class ViewPagerAdapter extends PagerAdapter {&#xA;&#xA;    /*&#xA;    理解：PagerAdapter&#xA;    一，调用 getCount() 获取需要初始化的 ViewGroup 数量&#xA;    二，调用 instantiateItem() 实例化页卡，按顺序&#xA;    三，调用 destroyItem() 销毁，按顺序&#xA;     */&#xA;&#xA;    // 所有 View&#xA;    private List&amp;lt;View&amp;gt; views;&#xA;&#xA;    // 上下文&#xA;    private Context context;&#xA;&#xA;    // 构造&#xA;    public ViewPagerAdapter(List&amp;lt;View&amp;gt; views, Context context) {&#xA;    this.views = views;&#xA;    this.context = context;&#xA;    }&#xA;&#xA;    // 销毁时被调用&#xA;    @Override&#xA;    public void destroyItem(ViewGroup container, int position, Object object) {&#xA;    // ViewGroup 所有的View&#xA;    // position 位置,第几个&#xA;    // 销毁时删除 View&#xA;    container.removeView(views.get(position));&#xA;    // super.destroyItem(container, position, object);&#xA;    }&#xA;&#xA;    // 实例化页卡&#xA;    @Override&#xA;    public Object instantiateItem(ViewGroup container, int position) {&#xA;    // 添加 View&#xA;    container.addView(views.get(position));&#xA;    // 返回添加的 View 对象&#xA;    return views.get(position);&#xA;    // return super.instantiateItem(container, position);&#xA;    }&#xA;&#xA;    // 所包含的 Item 总个数&#xA;    @Override&#xA;    public int getCount() {&#xA;    // 返回 views 总数&#xA;    return views.size();&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean isViewFromObject(View view, Object o) {&#xA;    return (view == o);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;设置启动页&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 正常情况下 AndroidManifest.xml&#xA;    &amp;lt;application&#xA;    android:allowBackup=&amp;quot;true&amp;quot;&#xA;    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;&#xA;    android:label=&amp;quot;@string/app_name&amp;quot;&#xA;    android:theme=&amp;quot;@style/AppTheme&amp;quot; &amp;gt;&#xA;    &amp;lt;activity&#xA;        android:name=&amp;quot;.MainActivity&amp;quot;&#xA;        android:label=&amp;quot;@string/app_name&amp;quot; &amp;gt;&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;activity&#xA;        android:name=&amp;quot;.MainActivity2Activity&amp;quot;&#xA;        android:label=&amp;quot;@string/title_activity_main_activity2&amp;quot; &amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;/application&amp;gt;&#xA;&#xA;// 作为启动页 AndroidManifest.xml&#xA;    &amp;lt;application&#xA;    android:allowBackup=&amp;quot;true&amp;quot;&#xA;    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;&#xA;    android:label=&amp;quot;@string/app_name&amp;quot;&#xA;    android:theme=&amp;quot;@style/AppTheme&amp;quot; &amp;gt;&#xA;    &amp;lt;activity&#xA;        android:name=&amp;quot;.MainActivity&amp;quot;&#xA;        android:label=&amp;quot;@string/app_name&amp;quot; &amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;activity android:name=&amp;quot;.MainActivity2Activity&amp;quot;&amp;gt;&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;/application&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;添加导航点&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// activity_main.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;android.support.v4.view.ViewPager&#xA;    android:id=&amp;quot;@+id/viewpager&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:background=&amp;quot;#00000000&amp;quot;&amp;gt;&#xA;    &amp;lt;/android.support.v4.view.ViewPager&amp;gt;&#xA;&#xA;    // 添加一排导航点 ImageView&#xA;    &amp;lt;LinearLayout&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_alignParentBottom=&amp;quot;true&amp;quot;&#xA;    android:gravity=&amp;quot;center_horizontal&amp;quot;&#xA;    android:orientation=&amp;quot;horizontal&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;        android:id=&amp;quot;@+id/iv1&amp;quot;&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:src=&amp;quot;@drawable/login_point_selected&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;        android:id=&amp;quot;@+id/iv2&amp;quot;&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:src=&amp;quot;@drawable/login_point&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;        android:id=&amp;quot;@+id/iv3&amp;quot;&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:src=&amp;quot;@drawable/login_point&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Activity&#xA;public class MainActivity extends Activity implements ViewPager.OnPageChangeListener {&#xA;&#xA;    private ViewPager vp;&#xA;    private ViewPagerAdapter vpa;&#xA;    private List&amp;lt;View&amp;gt; views;&#xA;    private ImageView[] dots;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    // 获取 LayoutInflater&#xA;    LayoutInflater inflater = LayoutInflater.from(this);&#xA;&#xA;    // 获取 View 并加入 List&#xA;    views = new ArrayList&amp;lt;View&amp;gt;();&#xA;    views.add(inflater.inflate(R.layout.one, null));&#xA;    views.add(inflater.inflate(R.layout.two, null));&#xA;    views.add(inflater.inflate(R.layout.three, null));&#xA;&#xA;    // 将 ViewList 传入 ViewPagerAdapter&#xA;    vpa = new ViewPagerAdapter(views, this);&#xA;&#xA;    // 获取 android.support.v4.view.ViewPager&#xA;    vp = (ViewPager) findViewById(R.id.viewpager);&#xA;&#xA;    // 设置 Adapter&#xA;    vp.setAdapter(vpa);&#xA;&#xA;    // 回调&#xA;    // vp.setOnPageChangeListener(new ViewPager.OnPageChangeListener() { ... };&#xA;    // 新版本改变: vPager.addOnPageChangeListener(this);&#xA;    vp.setOnPageChangeListener(this);&#xA;&#xA;    // 添加 ImageView 对象到 ImageView[]&#xA;    dots = new ImageView[views.size()];&#xA;    dots[0] = (ImageView) findViewById(R.id.iv1);&#xA;    dots[1] = (ImageView) findViewById(R.id.iv2);&#xA;    dots[2] = (ImageView) findViewById(R.id.iv3);&#xA;&#xA;    }&#xA;&#xA;    // 当页面被滑动时&#xA;    @Override&#xA;    public void onPageScrolled(int i, float v, int i2) {&#xA;&#xA;    }&#xA;&#xA;    // 当前新的页面被选中时调用&#xA;    @Override&#xA;    public void onPageSelected(int i) {&#xA;    // 获取当前选择页&#xA;    // 修改 Image 图片&#xA;    for (int n = 0; n &amp;lt; dots.length; n++) {&#xA;        if (i == n) {&#xA;        // R.drawable.login_point_selected 黑色&#xA;        dots[n].setImageResource(R.drawable.login_point_selected);&#xA;        } else {&#xA;        // R.drawable.login_point 白色&#xA;        dots[n].setImageResource(R.drawable.login_point);&#xA;        }&#xA;    }&#xA;    }&#xA;&#xA;    // 当滑动页面改变时&#xA;    @Override&#xA;    public void onPageScrollStateChanged(int i) {&#xA;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;添加进入按钮&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// three.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;ImageView&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:background=&amp;quot;@drawable/guide_3&amp;quot;&#xA;    /&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_alignParentBottom=&amp;quot;true&amp;quot;&#xA;    android:gravity=&amp;quot;center_horizontal&amp;quot;&#xA;    android:orientation=&amp;quot;horizontal&amp;quot;&amp;gt;&#xA;&#xA;    // 添加一个按钮&#xA;    &amp;lt;Button&#xA;        android:id=&amp;quot;@+id/start_but&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;        android:text=&amp;quot;进入&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity implements ViewPager.OnPageChangeListener {&#xA;&#xA;    private ViewPager vp;&#xA;    private ViewPagerAdapter vpa;&#xA;    private List&amp;lt;View&amp;gt; views;&#xA;    private ImageView[] dots;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.gulde);&#xA;&#xA;    ......&#xA;&#xA;    // 添加 ImageView 对象到 ImageView[]&#xA;    dots = new ImageView[views.size()];&#xA;    dots[0] = (ImageView) findViewById(R.id.iv1);&#xA;    dots[1] = (ImageView) findViewById(R.id.iv2);&#xA;    dots[2] = (ImageView) findViewById(R.id.iv3);&#xA;&#xA;    // 这里注意，按钮是属于 R.id.iv3 的&#xA;    Button button = (Button) views.get(2).findViewById(R.id.start_but);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        Intent intent = new Intent(MainActivity.this, MainActivity2.class);&#xA;        startActivity(intent);&#xA;        finish();&#xA;        }&#xA;    });&#xA;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之OnClickListener使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BOnClickListener%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OnClickListener&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ...  &#xA;    TextView text1 = (TextView)findViewById(R.id.text1);&#xA;    text1.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;            // ...&#xA;        }&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OnClickListener&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ...&#xA;    TextView text1 = (TextView)findViewById(R.id.text1);&#xA;    OnItemClickListener onClickListener = new OnItemClickListener();&#xA;    text1.setOnClickListener(onClickListener);&#xA;&#xA;// ...&#xA;class OnItemClickListener implements View.OnClickListener {&#xA;&#xA;    @Override&#xA;    public void onClick(View v) {&#xA;        // TODO Auto-generated method stub&#xA;        if(v.getId() == R.id.text1){&#xA;        showDetail(1);&#xA;        }&#xA;        else if(v.getId() == R.id.text2){&#xA;        showDetail(2);&#xA;        }&#xA;        else if(v.getId() == R.id.text3){&#xA;        showDetail(3);&#xA;        }&#xA;        else if(v.getId() == R.id.text4){&#xA;        showDetail(4);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Handler消息传递机制使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BHandler%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-03-24 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Handler 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;出于性能优化考虑，Android的UI操作并不是线程安全的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Android定制了一条简单的规则，只允许UI线程修改Activity里的UI组件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Handler存在的意义就是一个消息机制, 可以在一个线程中创建并在另一个线程中触发&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Handler 类的主要作用有两个：&#xA;一，在新启动的线程中发送消息&#xA;二，在主线程中获取，处理消息&#xA;// 可以在 Thread 或 AsyncTask 中发送消息&#xA;&#xA;// Handler中常用的四个方法：&#xA;sendMessage(Message msg)&#xA;sendEmptyMessage()&#xA;sendMessageDelayed(Message msg, long delayMillis)&#xA;post(Runnable r)&#xA;postDelayed(Runnable r, long delayMillis)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Handler负责发送消息&#xA;Looper负责接收Handler发送的消息，并且把消息回传给Handler自己&#xA;MessageQueue就是一个存储消息的容器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 在UI线程中创建一个android.os.Handler&#xA;private android.os.Handler handler = new android.os.Handler() {&#xA;    @Override&#xA;    public void handleMessage(Message msg) {&#xA;        switch (msg.what){&#xA;        case 1000:&#xA;            showToast(&amp;quot;开始&amp;quot;);&#xA;            break;&#xA;        case 1001:&#xA;            showToast(&amp;quot;你好&amp;quot;);&#xA;            break;&#xA;        case 1002:&#xA;            showToast(&amp;quot;再见&amp;quot;);&#xA;            break;&#xA;        }&#xA;        super.handleMessage(msg);&#xA;    }&#xA;};&#xA;&#xA;// 通过 Handler 显示 Toast&#xA;public void showToast(String str) {&#xA;    Toast.makeText(MainActivity2Activity.this, str, Toast.LENGTH_SHORT).show();&#xA;}&#xA;&#xA;// 在另外一个线程中出发消息机制&#xA;new Thread() {&#xA;    @Override&#xA;    public void run() {&#xA;        // 触发 Handler，发送信息&#xA;        // 这时 Handler, 会通过系统消息机制通知到UI线程中的Handler&#xA;        // 这是 Handler, 消息机制会在UI线程中回掉handleMessage方法&#xA;        handler.sendEmptyMessage(1000);&#xA;    }&#xA;}.start();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Handler 消息处理&#xA;private Handler handler = new Handler() {&#xA;    @Override&#xA;    public void handleMessage(Message msg) {&#xA;        switch (msg.what) {&#xA;            // 消息ID&#xA;            case 0x1001:&#xA;                // 得到数据&#xA;                Object obj = msg.obj;&#xA;                break;&#xA;        }&#xA;        super.handleMessage(msg);&#xA;    }&#xA;};&#xA;&#xA;// 通过Handle发送数据消息&#xA;Message msg = new Message();&#xA;msg.obj = obj; // Object obj;&#xA;msg.what = 0x1001; // int what;&#xA;// 发送消息&#xA;handler.sendMessage(msg);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// HandlerThread&#xA;HandlerThread继承于Thread，所以它本质就是个Thread。&#xA;与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列&#xA;有了自己的looper,可以让我们在自己的线程中分发和处理消息。&#xA;&#xA;// 创建一个 HandlerThread&#xA;HandlerThread thread = new HandlerThread(“handler thread”)&#xA;&#xA;// 创建一个 属于 HandlerThread 的 Handler&#xA;Handler handler = new Handler(thread.getLooper()) {&#xA;    // 重写, handleMessage&#xA;    // 说明, 这个handleMessage是在一个完全独立的线程中运行的&#xA;    public void handleMessage(Message msg){&#xA;        // …&#xA;    }&#xA;}&#xA;// 发送消息&#xA;handler.sendEmptyMessage(1)&#xA;&#xA;// 这样相当于创建了一个独立的Handler消息队列，且不是在UI线程中运行的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之样式和主题的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E6%A0%B7%E5%BC%8F%E5%92%8C%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;样式和主题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android style 可以配置给各种布局对象, 进行分组配置&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 样式文件 styles.xml&#xA;&amp;lt;resources&amp;gt;&#xA;&#xA;    &amp;lt;!-- Base application theme. --&amp;gt;&#xA;    &amp;lt;style name=&amp;quot;AppTheme&amp;quot; parent=&amp;quot;android:Theme.Holo.Light.DarkActionBar&amp;quot;&amp;gt;&#xA;    &amp;lt;!-- Customize your theme here. --&amp;gt;&#xA;    &amp;lt;/style&amp;gt;&#xA;&#xA;    &amp;lt;style name=&amp;quot;MyTheme&amp;quot;&amp;gt;&#xA;    &amp;lt;item name=&amp;quot;android:text&amp;quot;&amp;gt;aaa&amp;lt;/item&amp;gt;&#xA;    &amp;lt;item name=&amp;quot;android:textSize&amp;quot;&amp;gt;18pt&amp;lt;/item&amp;gt;&#xA;    &amp;lt;/style&amp;gt;&#xA;&#xA;    &amp;lt;style name=&amp;quot;MyView&amp;quot;&amp;gt;&#xA;    &amp;lt;item name=&amp;quot;android:background&amp;quot;&amp;gt;#ff0&amp;lt;/item&amp;gt;&#xA;    &amp;lt;/style&amp;gt;&#xA;&#xA;&amp;lt;/resources&amp;gt;&#xA;&#xA;// 配置给 Button&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;Button&#xA;    android:id=&amp;quot;@+id/a&amp;quot;&#xA;    style=&amp;quot;@style/MyTheme&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;Button&#xA;    style=&amp;quot;@style/MyTheme&amp;quot;&#xA;    android:id=&amp;quot;@+id/b&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;/&amp;gt;&#xA;...&#xA;&#xA;// 配置给 Layout&#xA;&amp;lt;FrameLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot; tools:context=&amp;quot;.MainActivity&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&#xA;    style=&amp;quot;@style/MyView&amp;quot;&amp;gt;&#xA;...&#xA;&#xA;// 配置给 APP&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    package=&amp;quot;com.example.nljb.nljb&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;application&#xA;    android:allowBackup=&amp;quot;true&amp;quot;&#xA;    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;&#xA;    android:label=&amp;quot;@string/app_name&amp;quot;&#xA;    android:theme=&amp;quot;@style/AppTheme&amp;quot; &amp;gt;&#xA;    &amp;lt;activity&#xA;        android:name=&amp;quot;.MainActivity&amp;quot;&#xA;        android:label=&amp;quot;@string/app_name&amp;quot; &amp;gt;&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;/application&amp;gt;&#xA;&#xA;    &amp;lt;uses-permission&#xA;    android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot;&amp;gt;&#xA;    &amp;lt;/uses-permission&amp;gt;&#xA;&#xA;&amp;lt;/manifest&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Camera使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BCamera%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-20 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Camera 使用方法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// AndroidManifest.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    package=&amp;quot;com.example.nljb.nljb&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;application&#xA;    android:allowBackup=&amp;quot;true&amp;quot;&#xA;    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;&#xA;    android:label=&amp;quot;@string/app_name&amp;quot;&#xA;    android:theme=&amp;quot;@style/AppTheme&amp;quot; &amp;gt;&#xA;    &amp;lt;activity&#xA;        android:name=&amp;quot;.MainActivity&amp;quot;&#xA;        android:label=&amp;quot;@string/app_name&amp;quot; &amp;gt;&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;/application&amp;gt;&#xA;&#xA;    &amp;lt;uses-permission&#xA;    android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot;&amp;gt;&#xA;    &amp;lt;/uses-permission&amp;gt;&#xA;    &amp;lt;uses-permission&#xA;    android:name=&amp;quot;android.permission.CAMERA&amp;quot;&amp;gt;&#xA;    &amp;lt;/uses-permission&amp;gt;&#xA;&amp;lt;/manifest&amp;gt;&#xA;&#xA;&#xA;// activity_main.xml&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&#xA;    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    tools:context=&amp;quot;.MainActivity&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;SurfaceView&#xA;    android:id=&amp;quot;@+id/camera&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_alignParentTop=&amp;quot;true&amp;quot;&#xA;    android:layout_alignParentStart=&amp;quot;true&amp;quot;&#xA;    android:layout_above=&amp;quot;@+id/button&amp;quot; /&amp;gt;&#xA;&#xA;&#xA;    &amp;lt;Button&#xA;    android:id=&amp;quot;@+id/button&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_gravity=&amp;quot;center_horizontal|bottom&amp;quot;&#xA;    android:text=&amp;quot;拍照&amp;quot;&#xA;    android:layout_alignParentBottom=&amp;quot;true&amp;quot;&#xA;    android:layout_alignParentStart=&amp;quot;true&amp;quot; /&amp;gt;&#xA;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    private SurfaceView cameraPreview;&#xA;&#xA;    Camera camera;&#xA;&#xA;    Camera.Parameters parameters;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    // ...&#xA;    cameraPreview = (SurfaceView) findViewById(R.id.camera);&#xA;    cameraPreview.getHolder().addCallback(new SurfaceHolder.Callback() {&#xA;        @Override&#xA;        public void surfaceCreated(SurfaceHolder holder) {&#xA;        camera = Camera.open();&#xA;        try {&#xA;            // 设置 SurfaceView&#xA;            camera.setPreviewDisplay(cameraPreview.getHolder());&#xA;            // 获取 Parameters&#xA;            parameters = camera.getParameters();&#xA;            // 闪光灯&#xA;            parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);&#xA;            // 用于拍照的连续自动对焦模式&#xA;            parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);&#xA;            // 方向判断 ORIENTATION_LANDSCAPE 横屏&#xA;            if(getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE){&#xA;            // 90°&#xA;            camera.setDisplayOrientation(90);&#xA;            }else {&#xA;            // 0°&#xA;            camera.setDisplayOrientation(0);&#xA;            }&#xA;            // 设置 Parameters&#xA;            camera.setParameters(parameters);&#xA;            // 预览&#xA;            camera.startPreview();&#xA;            // 自动对焦&#xA;            camera.cancelAutoFocus();&#xA;        } catch (IOException e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;        }&#xA;&#xA;        @Override&#xA;        public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {&#xA;        }&#xA;&#xA;        @Override&#xA;        public void surfaceDestroyed(SurfaceHolder holder) {&#xA;        // 停止预览&#xA;        camera.stopPreview();&#xA;        // 释放&#xA;        camera.release();&#xA;        }&#xA;    });&#xA;&#xA;    // ...&#xA;    Button button = (Button) findViewById(R.id.button);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        camera.takePicture(null, null, new Camera.PictureCallback() {&#xA;            @Override&#xA;            public void onPictureTaken(byte[] data, Camera camera) {&#xA;            File dir = Environment.getExternalStorageDirectory();&#xA;            File file = new File(dir, &amp;quot;image.jpg&amp;quot;);&#xA;            try {&#xA;                if (!file.exists()) { file.createNewFile(); }&#xA;                FileOutputStream fos = new FileOutputStream(file);&#xA;                fos.write(data);&#xA;                fos.flush();&#xA;                fos.close();&#xA;            } catch (java.io.IOException e) {&#xA;                e.printStackTrace();&#xA;            }&#xA;            }&#xA;        });&#xA;        }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之内部存储与外部存储的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E4%B8%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-19 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;内部存储&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android提供了openFileOutput和openFileInput方法读取设备上的文件&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    //确定要操作文件的文件名&#xA;    String FILE_NAME = &amp;quot;tempfile.tmp&amp;quot;;&#xA;&#xA;    // 初始化，如果调用FileOutputStream时指定的文件不存在，&#xA;    // Android会自动创建它（在data/包名/files/目录下会创建txtme.txt文件)&#xA;    // 在默认情况下，写入的时候会覆盖原文件内容，&#xA;    // 如果想把新写入的内容附加到原文件内容后，则应指定其模式为Context.MODE_APPEND&#xA;&#xA;    // MODE_PRIVATE的文件是应用程序私有的 ，&#xA;    // MODE_WORLD_READABLE则所有应用程序都可以访问的，&#xA;    // MODE_WORLD_WRITEABLE所以应用程序都可以写&#xA;&#xA;    // 创建写入流&#xA;    try {&#xA;        FileOutputStream fos = openFileOutput(&amp;quot;nljb&amp;quot; , Context.MODE_PRIVATE);&#xA;        fos.write(&amp;quot;nljb&amp;quot;.toString().getBytes());&#xA;        fos.flush();&#xA;        fos.close();&#xA;    } catch (java.io.IOException e) {&#xA;        e.printStackTrace();&#xA;    }&#xA;&#xA;    // 创建读取流&#xA;    try {&#xA;        FileInputStream fis = openFileInput(&amp;quot;nljb&amp;quot;);&#xA;        byte[] bytes = new byte[fis.available()];&#xA;        fis.read(bytes);&#xA;        fis.close();&#xA;    } catch (java.io.IOException e) {&#xA;        e.printStackTrace();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;外部存储&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 写入文件&#xA;File dir = Environment.getExternalStorageDirectory();&#xA;File file = new File(dir, &amp;quot;nljb&amp;quot;);&#xA;Log.i(&amp;quot;INFO&amp;quot;, dir.toString());&#xA;try {&#xA;    if (!file.exists())&#xA;    {&#xA;    file.createNewFile();&#xA;    }&#xA;    FileOutputStream fos = new FileOutputStream(file);&#xA;    fos.write(&amp;quot;nljb&amp;quot;.toString().getBytes());&#xA;    fos.flush();&#xA;    fos.close();&#xA;} catch (java.io.IOException e) {&#xA;    e.printStackTrace();&#xA;}&#xA;&#xA;// 读取文件&#xA;File dir = Environment.getExternalStorageDirectory();&#xA;File file = new File(dir, &amp;quot;nljb&amp;quot;);&#xA;try {&#xA;    if (!file.exists())&#xA;    {&#xA;    file.createNewFile();&#xA;    }&#xA;    FileInputStream fis = openFileInput(file);&#xA;    byte[] bytes = new byte[fis.available()];&#xA;    fis.read(bytes);&#xA;    fis.close();&#xA;} catch (java.io.IOException e) {&#xA;    e.printStackTrace();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h1&gt;Assets 目录介绍&lt;/h1&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Assets 这个目录保存的文件可以打包在程序里&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/res和/assets的不同点是，android不为/assets下的文件生成ID。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果使用/assets下的文件，需要指定文件的路径和文件名。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;android中的资源文件，这些资源文件主要分为两类，一种出于asset目录下，称为原生文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这类文件在被打包成apk文件时是不会进行压缩的；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一类则是res下的文件，这类文件在打包成apk文件时，会进行小内存优化&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;AssetManager assetManager = this.getResources().getAsset();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在activity中可以通过如下方法进行访问&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;InputStream inputStream = Resources.openRawResource(int id);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;asset和res下的文件都是只能读不能写&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之SharedPreferences使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BSharedPreferences%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SharedPreferences 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;SharedPreferences 是一种轻型的数据存储方式&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它的本质是基于XML文件存储Key-Value键值对数据, 通常用来存储一些简单的配置信息&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其存储位置在/data/data/&amp;lt;包名&amp;gt;/shared_prefs目录下&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 支持的类型&#xA;boolean&#xA;int&#xA;float&#xA;long&#xA;String&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;SharedPreferences 对象本身只能获取数据而不支持存储和修改, 存储修改是通过Editor对象实现。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SharedPreferences 使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// activity_main&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot; tools:context=&amp;quot;.MainActivity&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;EditText&#xA;        android:id=&amp;quot;@+id/edit_key&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:inputType=&amp;quot;none&amp;quot; /&amp;gt;&#xA;&#xA;&#xA;    &amp;lt;EditText&#xA;        android:id=&amp;quot;@+id/edit_val&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:inputType=&amp;quot;none&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;Button&#xA;        android:id=&amp;quot;@+id/button_write&amp;quot;&#xA;        android:text=&amp;quot;添加&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;Button&#xA;        android:id=&amp;quot;@+id/button_read&amp;quot;&#xA;        android:text=&amp;quot;获取&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_gravity=&amp;quot;center_horizontal|bottom&amp;quot; /&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    private EditText edit_key;&#xA;    private EditText edit_val;&#xA;    private Button but_read;&#xA;    private Button but_write;&#xA;&#xA;    SharedPreferences preferences;&#xA;    SharedPreferences.Editor editor;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    // 获取 Preferences&#xA;    preferences = getPreferences(Activity.MODE_PRIVATE);&#xA;    // 编辑 preferences&#xA;    editor = preferences.edit();&#xA;    edit_key = (EditText) findViewById(R.id.edit_key);&#xA;    edit_val = (EditText) findViewById(R.id.edit_val);&#xA;    but_read = (Button) findViewById(R.id.button_read);&#xA;    but_write = (Button) findViewById(R.id.button_write);&#xA;    but_write.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        if (!edit_key.getText().toString().isEmpty() &amp;amp;&amp;amp; !edit_val.getText().toString().isEmpty())&#xA;        {&#xA;            // 使用 editor.putString 增加数据&#xA;            editor.putString(edit_key.getText().toString(), edit_val.getText().toString());&#xA;            // Commit 保存&#xA;            if (editor.commit()){&#xA;            Toast.makeText(MainActivity.this, &amp;quot;写入成功&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;            }&#xA;        } else {&#xA;            Toast.makeText(MainActivity.this, &amp;quot;值不能为空&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;        }&#xA;    });&#xA;    but_read.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        if (!edit_key.getText().toString().isEmpty()){&#xA;            // 读取 preferences.getString &#xA;            String val = preferences.getString(edit_key.getText().toString(), &amp;quot;default&amp;quot;);&#xA;            edit_val.setText(val);&#xA;        } else {&#xA;            Toast.makeText(MainActivity.this, &amp;quot;值不能为空&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;        }&#xA;    });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;getSharedPreferences 与 getPreferences&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;getSharedPreferences是Context类中的方法, 可以指定filename以及mode.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;getPreferences是Activity类中的方法, 只需指定mode.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;getSharedPreferences 与 getDefaultSharedPreferences&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 自定义的一些偏好设置用getSharedPreferences来获取，例如定义一个loginpref.xml的偏好文件&#xA;SharedPreferences sharedPreferences = getSharedPreferences(&amp;quot;loginpref&amp;quot;, Context.MODE_PRIVATE);&#xA;System.out.println(&amp;quot;set_location = &amp;quot;+sharedPreferences.getBoolean(&amp;quot;islogin&amp;quot;, false));&#xA;Editor editor =  sharedPreferences.edit();&#xA;editor.putBoolean(&amp;quot;islogin&amp;quot;, false);&#xA;editor.commit();&#xA;&#xA;// 每个应用有一个默认的偏好文件preferences.xml，使用getDefaultSharedPreferences获取&#xA;SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);&#xA;System.out.println(&amp;quot;set_location = &amp;quot;+preferences.getBoolean(&amp;quot;if_set_location&amp;quot;, false));&#xA;Editor editor =  preferences.edit();&#xA;editor.putBoolean(&amp;quot;if_set_location&amp;quot;, false);&#xA;editor.commit();&#xA;// &amp;quot;if_set_location&amp;quot;可能对应的是CheckBoxPreference或者其它，但是通用get***来获取值&#xA;&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;&#xA;    &amp;lt;PreferenceCategory android:title=&amp;quot;位置信息设置&amp;quot;&amp;gt;&#xA;    &amp;lt;CheckBoxPreference&#xA;    android:key=&amp;quot;set_location&amp;quot;&#xA;    android:title=&amp;quot;打开或关闭位置信息&amp;quot;&#xA;    android:summary=&amp;quot;更改您的位置设置，打开或者关闭位置共享&amp;quot;&#xA;    android:defaultValue=&amp;quot;true&amp;quot;&#xA;    /&amp;gt;&#xA;&#xA;    &amp;lt;Preference&#xA;    android:key=&amp;quot;set_sys_location&amp;quot;&#xA;    android:title=&amp;quot;系统位置功能设置&amp;quot;&#xA;    android:summary=&amp;quot;点击到系统设置页面打开或关闭GPS位置功能&amp;quot;&#xA;    /&amp;gt; &#xA;    &amp;lt;/PreferenceCategory&amp;gt;&#xA;&amp;lt;/PreferenceScreen&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之PreferenceFragment使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BPreferenceFragment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-18 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;PreferenceFragment&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Android应用程序通常要提供首选项，以允许用户定制应用程序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例如，可以允许用户保存那些用于访问Web资源的登录凭据, 等等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Android中，可以使用PreferenceActivity基类为用户显示一个用于编辑首选项的活动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Android 3.0和更高版本中，可以使用PreferenceFragment类实现相同的功能。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// XML&#xA;// 新建 (res/xml/preferences.xml)&#xA;&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; &amp;gt;&#xA;    &amp;lt;CheckBoxPreference&#xA;    android:key=&amp;quot;child_checkbox_preference&amp;quot;&#xA;    android:summary=&amp;quot;这是一个可见的子类&amp;quot;&#xA;    android:title=&amp;quot;子类复选框首选项&amp;quot;&#xA;    android:summaryOn=&amp;quot;已开启&amp;quot;&#xA;    android:summaryOff=&amp;quot;已关闭&amp;quot;&#xA;    android:onClick=&amp;quot;onClick&amp;quot;/&amp;gt;&#xA;&amp;lt;/PreferenceScreen&amp;gt;     &#xA;&#xA;// Activit&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;            // 替换 Fragment&#xA;    getFragmentManager().beginTransaction()&#xA;            .replace(R.id.xxx, new MyPreference())&#xA;            .commit();&#xA;    }&#xA;&#xA;  // PreferenceFragment&#xA;  class MyPreference extends PreferenceFragment {&#xA;&#xA;    // 监听 Preference Click&#xA;    @Override&#xA;    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {&#xA;        Log.i(&amp;quot;INFO&amp;quot;, preference.getKey());&#xA;        // 也可以通过 KEY 获取&#xA;        // findPreference(&amp;quot;child_checkbox_preference&amp;quot;)&#xA;        if (preference.getKey().equals(&amp;quot;child_checkbox_preference&amp;quot;)) {&#xA;        CheckBoxPreference child_checkbox_preference = (CheckBoxPreference) preference;&#xA;        Toast.makeText(MainActivity.this, String.valueOf(child_checkbox_preference.isChecked()), Toast.LENGTH_SHORT).show();&#xA;        }&#xA;        return super.onPreferenceTreeClick(preferenceScreen, preference);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onCreate(Bundle savedInstanceState) {&#xA;        // TODO Auto-generated method stub&#xA;        super.onCreate(savedInstanceState);&#xA;        // 添加 Preferences XML&#xA;        addPreferencesFromResource(R.xml.preferences);&#xA;        // 选项监听 ...&#xA;        // findPreference(&amp;quot;child_checkbox_preference&amp;quot;).setOnPreferenceClickListener(...);&#xA;        // 选项监听 当 Preference 的值发生改变时触发该事件，true则以新值更新控件的状态，false 则 不保存&#xA;        findPreference(&amp;quot;child_checkbox_preference&amp;quot;).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {&#xA;        @Override&#xA;        public boolean onPreferenceChange(Preference preference, Object newValue) {&#xA;            // 返回 false 修改不会生效&#xA;            return false;&#xA;        }&#xA;        });&#xA;        /*&#xA;        // 获取 Preferences Manager&#xA;        PreferenceManager manager = getPreferenceManager();&#xA;        // 获取 选项状态&#xA;        CheckBoxPreference child_checkbox_preference = (CheckBoxPreference) manager.findPreference(&amp;quot;child_checkbox_preference&amp;quot;);&#xA;        // ...&#xA;        Toast.makeText(MainActivity.this, String.valueOf(child_checkbox_preference.isChecked()), Toast.LENGTH_SHORT).show();&#xA;        */&#xA;    }&#xA;    public void onClick() {&#xA;        Toast.makeText(MainActivity.this, &amp;quot;成功&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android之PreferenceFragment使用方法/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;  &#xA;&amp;lt;PreferenceScreen  &#xA;    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;  &#xA;&#xA;    &amp;lt;PreferenceCategory  &#xA;        android:title=&amp;quot;显示一排偏好&amp;quot;&amp;gt;  &#xA;    &amp;lt;CheckBoxPreference  &#xA;        android:key=&amp;quot;checkbox_preference&amp;quot;  &#xA;        android:title=&amp;quot;开关偏好&amp;quot;  &#xA;        android:summary=&amp;quot;这是一个开关按钮&amp;quot; /&amp;gt;  &#xA;    &amp;lt;/PreferenceCategory&amp;gt;  &#xA;    &amp;lt;PreferenceCategory  &#xA;        android:title=&amp;quot;基于对话框的偏好&amp;quot;&amp;gt;  &#xA;    &amp;lt;EditTextPreference  &#xA;        android:key=&amp;quot;edittext_preference&amp;quot;  &#xA;        android:title=&amp;quot;文本输入偏好&amp;quot;  &#xA;        android:summary=&amp;quot;使用一个文本框对话框&amp;quot;  &#xA;        android:dialogTitle=&amp;quot;输入你的宠物&amp;quot; /&amp;gt;  &#xA;    &amp;lt;ListPreference  &#xA;        android:key=&amp;quot;list_preference&amp;quot;  &#xA;        android:title=&amp;quot;列表偏好&amp;quot;  &#xA;        android:summary=&amp;quot;使用一个列表对话框&amp;quot;  &#xA;        android:entries=&amp;quot;@array/entries_list_preference&amp;quot;  &#xA;        android:entryValues=&amp;quot;@array/entryvalues_list_preference&amp;quot;  &#xA;        android:dialogTitle=&amp;quot;选择一个&amp;quot; /&amp;gt;  &#xA;    &amp;lt;/PreferenceCategory&amp;gt;  &#xA;    &amp;lt;PreferenceCategory  &#xA;        android:title=&amp;quot;启动偏好&amp;quot;&amp;gt;  &#xA;    &amp;lt;PreferenceScreen  &#xA;        android:key=&amp;quot;screen_preference&amp;quot;  &#xA;        android:title=&amp;quot;屏幕&amp;quot;  &#xA;        android:summary=&amp;quot;显示另一个偏好屏幕&amp;quot;&amp;gt;  &#xA;&#xA;        &amp;lt;!-- You can place more preferences here that will be shown on the next screen. --&amp;gt;  &#xA;&#xA;        &amp;lt;CheckBoxPreference  &#xA;            android:key=&amp;quot;next_screen_checkbox_preference&amp;quot;  &#xA;            android:title=&amp;quot;开关偏好&amp;quot;  &#xA;            android:summary=&amp;quot;另一个屏幕上的偏好&amp;quot; /&amp;gt;  &#xA;    &amp;lt;/PreferenceScreen&amp;gt;  &#xA;&#xA;    &amp;lt;PreferenceScreen  &#xA;        android:title=&amp;quot;意图偏好&amp;quot;  &#xA;        android:summary=&amp;quot;通过意图启动一个Activity&amp;quot;&amp;gt;  &#xA;        &amp;lt;intent android:action=&amp;quot;android.intent.action.VIEW&amp;quot;  &#xA;            android:data=&amp;quot;http://www.android.com&amp;quot; /&amp;gt;  &#xA;    &amp;lt;/PreferenceScreen&amp;gt;  &#xA;    &amp;lt;/PreferenceCategory&amp;gt;  &#xA;    &amp;lt;PreferenceCategory  &#xA;        android:title=&amp;quot;偏好属性&amp;quot;&amp;gt;  &#xA;    &amp;lt;CheckBoxPreference  &#xA;        android:key=&amp;quot;parent_checkbox_preference&amp;quot;  &#xA;        android:title=&amp;quot;父开关&amp;quot;  &#xA;        android:summary=&amp;quot;这是一个父开关&amp;quot; /&amp;gt;  &#xA;    &amp;lt;CheckBoxPreference  &#xA;        android:key=&amp;quot;child_checkbox_preference&amp;quot;  &#xA;        android:dependency=&amp;quot;parent_checkbox_preference&amp;quot;  &#xA;        android:layout=&amp;quot;?android:attr/preferenceLayoutChild&amp;quot;  &#xA;        android:title=&amp;quot;子开关&amp;quot;  &#xA;        android:summary=&amp;quot;这是一个子开关&amp;quot; /&amp;gt;  &#xA;    &amp;lt;/PreferenceCategory&amp;gt;  &#xA;&amp;lt;/PreferenceScreen&amp;gt;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    &amp;lt;SwitchPreference&#xA;    android:summaryOff=&amp;quot;已关闭&amp;quot;&#xA;    android:summaryOn=&amp;quot;已开启&amp;quot;&#xA;    android:title=&amp;quot;无线状态(WIFI)&amp;quot; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充 + 动态修改 PreferenceFragment 内容&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// preferences_evolver_fragment&#xA;&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:key=&amp;quot;evolver_screen_preference&amp;quot;&amp;gt;&#xA;&amp;lt;/PreferenceScreen&amp;gt;&#xA;&#xA;// EvolverPreference&#xA;public class EvolverPreference extends PreferenceFragment {&#xA;&#xA;    // 标签&#xA;    private static final String TAG = &amp;quot;EvolverPreference&amp;quot;;&#xA;&#xA;    // PreferenceScreen&#xA;    PreferenceScreen evolver_screen_preference = null;&#xA;&#xA;    // Handler 消息处理&#xA;    private Handler handler = new Handler() {&#xA;    @Override&#xA;    public void handleMessage(Message msg) {&#xA;        switch (msg.what) {&#xA;        case 0x1001:&#xA;            JSONObject json = (JSONObject) msg.obj;&#xA;            try {&#xA;            JSONObject params = json.getJSONObject(&amp;quot;params&amp;quot;);&#xA;            evolver_screen_preference.removeAll();&#xA;            for (Iterator iter = params.keys(); iter.hasNext(); ) {&#xA;                String key = (String) iter.next();&#xA;                JSONObject software = params.getJSONObject(key);&#xA;                Preference preference = new Preference(getActivity());&#xA;                preference.setTitle(software.getString(&amp;quot;name&amp;quot;));&#xA;                preference.setSummary(&amp;quot;版本：&amp;quot; + software.getString(&amp;quot;version&amp;quot;) + &amp;quot; - &amp;quot; + software.getString(&amp;quot;date&amp;quot;));&#xA;                evolver_screen_preference.addItemFromInflater(preference);&#xA;            }&#xA;            } catch (JSONException e) {&#xA;            e.printStackTrace();&#xA;            }&#xA;        }&#xA;    }&#xA;    };&#xA;&#xA;    // 获取 Handler&#xA;    public Handler getHandler() {&#xA;    return handler;&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    addPreferencesFromResource(R.xml.preferences_evolver_fragment);&#xA;    evolver_screen_preference = (PreferenceScreen) getPreferenceManager().findPreference(&amp;quot;evolver_screen_preference&amp;quot;);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之ZXing扫描二维码</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BZXing%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81/</link>
      <pubDate>2015-03-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;安装 ZXing 环境&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载 ZXing 项目源码&#xA;http://www.jikexueyuan.com/course/134_2.html&#xA;&#xA;// 解压得到 ZXingBarCode 目录&#xA;ZXingBarCode.zip&#xA;&#xA;// 在你项目的根目录创建一个lib目录&#xA;[PATH]&#xA;[app]&#xA;    [src]&#xA;    [res]&#xA;    [build]&#xA;    build.gradle&#xA;    ...&#xA;[build]&#xA;[gradle]&#xA;[lib]&#xA;    // 将 ZXingBarCode 重名名为 barcode&#xA;    [barcode]&#xA;    [src]&#xA;    [res]&#xA;    [build]&#xA;    ... &#xA;build.gradle&#xA;settings.gradle&#xA;...&#xA;&#xA;// 修改 settings.gradle &#xA;include &#39;:app&#39;, &#39;:lib:barcode&#39;&#xA;&#xA;// 修改 [app]/build.gradle&#xA;dependencies {&#xA;    // Library&#xA;    compile project(&#39;:lib:barcode&#39;)&#xA;}&#xA;&#xA;// 创建 [lib]/[barcode]/build.gradle&#xA;apply plugin: &#39;android-library&#39;&#xA;android {&#xA;    compileSdkVersion 17&#xA;    buildToolsVersion &amp;quot;21.1.2&amp;quot;&#xA;    sourceSets {&#xA;    main {&#xA;    manifest.srcFile &#39;AndroidManifest.xml&#39;&#xA;    java.srcDirs = [&#39;src&#39;]&#xA;    resources.srcDirs = [&#39;src&#39;]&#xA;    aidl.srcDirs = [&#39;aidl&#39;]&#xA;    renderscript.srcDirs = [&#39;src&#39;]&#xA;    res.srcDirs = [&#39;res&#39;]&#xA;    assets.srcDirs = [&#39;assets&#39;]&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;遇到的一些问题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 权限不足问题&#xA;W/FlashlightManager﹕ Unexpected error while invoking &#xA;public void android.os.IHardwareService$Stub$Proxy.setFlashlightEnabled(boolean) &#xA;throws android.os.RemoteException&#xA;java.lang.SecurityException: Requires FLASHLIGHT or HARDWARE_TEST permission&#xA;&#xA;// 在 AndroidManifest.xml 增加一项&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.FLASHLIGHT&amp;quot; /&amp;gt;&#xA;&#xA;// navbar.9.png 问题&#xA;// 使用 draw9patch 编辑 navbar.9.png 增加边界坐标&#xA;&#xA;// 找不到 com.google.zxing.*&#xA;// 在项目 -&amp;gt; Settings -&amp;gt; 选择 barcode -&amp;gt; Dependencies -&amp;gt; + File dependency -&amp;gt; 选择 barcode/libs/zxing.jar &#xA;&#xA;// 两个软件启动图标问题&#xA;// 修改 [barcode]/AndroidManifest.xml 去掉 &amp;lt;application&amp;gt;...&amp;lt;/application&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;使用方法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 修改 AndroidManifest.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    package=&amp;quot;com.example.nljb.nljb&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;!-- zxing library --&amp;gt;&#xA;    &amp;lt;uses-permission android:name=&amp;quot;android.permission.VIBRATE&amp;quot; /&amp;gt;&#xA;    &amp;lt;uses-permission android:name=&amp;quot;android.permission.CAMERA&amp;quot; /&amp;gt;&#xA;    &amp;lt;uses-permission android:name=&amp;quot;android.permission.FLASHLIGHT&amp;quot; /&amp;gt;&#xA;    &amp;lt;uses-feature android:name=&amp;quot;android.hardware.camera&amp;quot; /&amp;gt;&#xA;    &amp;lt;uses-feature android:name=&amp;quot;android.hardware.camera.autofocus&amp;quot; /&amp;gt;&#xA;    &amp;lt;!-- zxing library --&amp;gt;&#xA;&#xA;    &amp;lt;application&#xA;    android:allowBackup=&amp;quot;true&amp;quot;&#xA;    android:icon=&amp;quot;@drawable/ic_launcher&amp;quot;&#xA;    android:label=&amp;quot;@string/app_name&amp;quot;&#xA;    android:theme=&amp;quot;@style/AppTheme&amp;quot; &amp;gt;&#xA;    &amp;lt;activity&#xA;        android:name=&amp;quot;.MainActivity&amp;quot;&#xA;        android:label=&amp;quot;@string/app_name&amp;quot; &amp;gt;&#xA;        &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;&#xA;        &amp;lt;/intent-filter&amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;!-- zxing library --&amp;gt;&#xA;    &amp;lt;activity&#xA;        android:configChanges=&amp;quot;orientation|keyboardHidden&amp;quot;&#xA;        android:name=&amp;quot;com.zxing.activity.CaptureActivity&amp;quot;&#xA;        android:screenOrientation=&amp;quot;portrait&amp;quot;&#xA;        android:theme=&amp;quot;@android:style/Theme.NoTitleBar.Fullscreen&amp;quot;&#xA;        android:windowSoftInputMode=&amp;quot;stateAlwaysHidden&amp;quot; &amp;gt;&#xA;    &amp;lt;/activity&amp;gt;&#xA;    &amp;lt;!-- zxing library --&amp;gt;&#xA;    &amp;lt;/application&amp;gt;&#xA;&#xA;&amp;lt;/manifest&amp;gt;&#xA;&#xA;// 在 Activity 使用 Intent 使用 ZXing&#xA;public class MainActivity extends Activity {&#xA;&#xA;    // ...&#xA;    Button button;&#xA;&#xA;    // 获取 zxing 返回结果&#xA;    @Override&#xA;    protected void onActivityResult(int requestCode, int resultCode, Intent data) {&#xA;    super.onActivityResult(requestCode, resultCode, data);&#xA;    if (resultCode == RESULT_OK &amp;amp;&amp;amp; requestCode == 0)&#xA;    {&#xA;        String result = data.getExtras().getString(&amp;quot;result&amp;quot;);&#xA;        button.setText(result);&#xA;    }&#xA;    }&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    // 通过按钮触发 zxing Activity 摄像头扫描&#xA;    button = (Button) findViewById(R.id.button);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        Intent intent = new Intent(MainActivity.this, CaptureActivity.class);&#xA;        startActivityForResult(intent, 0);&#xA;&#xA;        }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;生成二维码&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ...&#xA;public class MainActivity extends Activity {&#xA;&#xA;    // ...&#xA;    Button button;&#xA;&#xA;    ImageView imageView;&#xA;&#xA;    Bitmap qrcode;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;        Button button2 = (Button) findViewById(R.id.button2);&#xA;&#xA;    imageView = (ImageView) findViewById(R.id.imageView);&#xA;&#xA;    button2.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;&#xA;        try {&#xA;            // 生成 EncodingHandler.createQRCode , 内容及大小&#xA;            qrcode = EncodingHandler.createQRCode(&amp;quot;www.baidu.com&amp;quot;, 400);&#xA;        } catch (WriterException e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;        imageView.setImageBitmap(qrcode);&#xA;        }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之SlidingMenu使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BSlidingMenu%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SlidingMenu 开源项目之侧滑菜单&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载 ZXing 项目源码&#xA;https://github.com/jfeinstein10/SlidingMenu&#xA;&#xA;// 解压得到 SlidingMenu-master -&amp;gt; library 目录&#xA;SlidingMenu-master.zip&#xA;&#xA;// 在你项目的根目录创建一个lib目录&#xA;[PATH]&#xA;[app]&#xA;    [src]&#xA;    [res]&#xA;    [build]&#xA;    build.gradle&#xA;    ...&#xA;[build]&#xA;[gradle]&#xA;[lib]&#xA;    // 将 SlidingMenu-master -&amp;gt; library 重名名为 sliding&#xA;    [sliding]&#xA;    [src]&#xA;    [res]&#xA;    [build]&#xA;    ... &#xA;build.gradle&#xA;settings.gradle&#xA;...&#xA;&#xA;// 修改 settings.gradle &#xA;include &#39;:app&#39;, &#39;:lib:sliding&#39;&#xA;&#xA;// 修改 [app]/build.gradle&#xA;dependencies {&#xA;    // Library&#xA;    compile project(&#39;:lib:sliding&#39;)&#xA;}&#xA;&#xA;// 修改 [lib]/[sliding]/build.gradle&#xA;...&#xA;buildscript {&#xA;    repositories {&#xA;    mavenCentral()&#xA;    }&#xA;    dependencies {&#xA;    classpath &#39;com.android.tools.build:gradle:0.4.+&#39;&#xA;    }&#xA;}&#xA;apply plugin: &#39;android-library&#39;&#xA;&#xA;dependencies {&#xA;    compile &#39;com.android.support:support-v4:13.0.0&#39;&#xA;}&#xA;&#xA;android {&#xA;    compileSdkVersion 17&#xA;    buildToolsVersion &amp;quot;21.1.2&amp;quot;&#xA;&#xA;    defaultConfig {&#xA;    minSdkVersion 7&#xA;    targetSdkVersion 17&#xA;    }&#xA;&#xA;    sourceSets {&#xA;    main {&#xA;        java.srcDirs = [&#39;src&#39;]&#xA;        resources.srcDirs = [&#39;src&#39;]&#xA;        aidl.srcDirs = [&#39;src&#39;]&#xA;        renderscript.srcDirs = [&#39;src&#39;]&#xA;        res.srcDirs = [&#39;res&#39;]&#xA;        assets.srcDirs = [&#39;assets&#39;]&#xA;&#xA;        manifest.srcFile &#39;AndroidManifest.xml&#39;&#xA;    }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;SlidingMenu 使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 设置左滑菜单&#xA;menu.setMode(SlidingMenu.LEFT); &#xA;// 设置滑动的屏幕范围，该设置为全屏区域都可以滑动&#xA;menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN); &#xA;// 设置阴影图片&#xA;menu.setShadowDrawable(R.drawable.shadow);&#xA;// 设置阴影图片的宽度&#xA;menu.setShadowWidthRes(R.dimen.shadow_width); &#xA;// SlidingMenu划出时主页面显示的剩余宽度&#xA;menu.setBehindOffsetRes(R.dimen.slidingmenu_offset); &#xA;// 设置SlidingMenu菜单的宽度&#xA;menu.setBehindWidth(400);&#xA;// SlidingMenu滑动时的渐变程度&#xA;menu.setFadeDegree(0.35f); &#xA;// 使SlidingMenu附加在Activity上&#xA;menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT); &#xA;// 设置menu的布局文件&#xA;menu.setMenu(R.layout.menu_layout); &#xA;// 动态判断自动关闭或开启SlidingMenu&#xA;menu.toggle(); &#xA;// 显示SlidingMenu&#xA;menu.showMenu(); &#xA;// 显示内容&#xA;menu.showContent(); &#xA;// 监听slidingmenu打开&#xA;menu.setOnOpenListener(onOpenListener); &#xA;&#xA;// 监听slidingmenu关闭时事件&#xA;menu.OnClosedListener(OnClosedListener); &#xA;// 监听slidingmenu关闭后事件&#xA;menu.OnClosedListener(OnClosedListener); &#xA;&#xA;// 属性，然后设置右侧菜单的布局文件&#xA;menu.setMode(SlidingMenu.LEFT_RIGHT); &#xA;// 右侧菜单的阴影图片&#xA;menu.setSecondaryShadowDrawable(R.drawable.shadowright); &#xA;&#xA;&#xA;// sliding_main.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:background=&amp;quot;#ff000000&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;com.jeremyfeinstein.slidingmenu.lib.SlidingMenu&#xA;    android:id=&amp;quot;@+id/sliding&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&amp;gt;&#xA;    &amp;lt;/com.jeremyfeinstein.slidingmenu.lib.SlidingMenu&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    SlidingMenu slidingMenu;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    // 创建 SlidingMenu&#xA;    slidingMenu = new SlidingMenu(MainActivity.this);&#xA;    // 附加 SlidingMenu 到 MainActivity&#xA;    // SLIDING_WINDOW会在SlidingMenu的内容部分包含ActionBar，而SLIDING_CONTENT不会&#xA;    slidingMenu.attachToActivity(MainActivity.this, SlidingMenu.SLIDING_CONTENT);&#xA;    // 设置左滑菜单&#xA;    slidingMenu.setMode(SlidingMenu.LEFT);&#xA;    //设置滑动的屏幕范围，该设置为全屏区域都可以滑动&#xA;    slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);&#xA;    //设置 menu 的布局文件&#xA;    slidingMenu.setMenu(R.layout.sliding_main);&#xA;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之AsyncTask的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BAsyncTask%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-17 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;AsyncTask,是android提供的轻量级的异步类&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;AsyncTask与Thread的区别是：&#xA;    Thread不可以在线程中直接操作UI对象，而需要使用消息机制&#xA;    AsyncTask可以在线程中直接操作UI对象，onPostExecute()&#xA;    其实AsyncTask是Thread的一个高级封装，拆分了主线程与子线程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;可以直接继承AsyncTask,在类中实现异步操作&#xA;并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新)&#xA;最后反馈执行的结果给UI主线程.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;内部会创建一个进程作用域的线程池来管理要运行的任务&#xA;也就就是说当你调用了 AsyncTask#execute()后，AsyncTask会把任务交给线程池&#xA;由线程池来管理创建Thread和运行Therad。&#xA;对于内部的线程 池不同版本的Android的实现方式是不一样的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Params 启动任务执行的输入参数，比如HTTP请求的URL。&#xA;// Progress 后台任务执行的百分比。&#xA;// Result 后台执行任务最终返回的结果，比如String。&#xA;new AsyncTask&amp;lt;String, Void, String&amp;gt;() {&#xA;&#xA;    // 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。&#xA;    @Override&#xA;    protected String doInBackground(String... params) {&#xA;    try {&#xA;        Thread.sleep(1000);&#xA;    } catch (InterruptedException e) {&#xA;        e.printStackTrace();&#xA;    }&#xA;    return null;&#xA;    }&#xA;&#xA;    // 这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。&#xA;    @Override&#xA;    protected void onPreExecute() {&#xA;    super.onPreExecute();&#xA;    }&#xA;&#xA;    // 相当于Handler 处理UI的方式，在这里面可以使用在 doInBackground 得到的结果处理操作UI。&#xA;    // 此方法在主线程执行，任务执行的结果作为此方法的参数返回&#xA;    @Override&#xA;    protected void onPostExecute(String s) {&#xA;    super.onPostExecute(s);&#xA;    }&#xA;&#xA;    // 可以使用进度条增加用户体验度。&#xA;    // 此方法在主线程执行，用于显示任务执行的进度。&#xA;    @Override&#xA;    protected void onProgressUpdate(Void... values) {&#xA;    super.onProgressUpdate(values);&#xA;    }&#xA;&#xA;    // 用户调用取消时，要做的操作&#xA;    @Override&#xA;    protected void onCancelled(String s) {&#xA;    super.onCancelled(s);&#xA;    }&#xA;&#xA;    // 用户调用取消时，要做的操作&#xA;    @Override&#xA;    protected void onCancelled() {&#xA;    super.onCancelled();&#xA;    }&#xA;&#xA;}.execute();&#xA;&#xA;// Thread&#xA;new Thread() {&#xA;    @Override&#xA;    public void run() {&#xA;    super.run();&#xA;    }&#xA;}.start();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之PullToRefresh的使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BPullToRefresh%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;PullToRefresh 是一套实现非常好的下拉刷新库&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 支持：&#xA;1.ListView&#xA;2.ExpandableListView&#xA;3.GridView&#xA;4.WebView&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充 setMode &amp;hellip;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BOTH:上拉刷新和下拉刷新都支持&lt;/li&gt;&#xA;&lt;li&gt;DISABLED：禁用上拉下拉刷新&lt;/li&gt;&#xA;&lt;li&gt;PULL_FROM_START:仅支持下拉刷新（默认）&lt;/li&gt;&#xA;&lt;li&gt;PULL_FROM_END：仅支持上拉刷新&lt;/li&gt;&#xA;&lt;li&gt;MANUAL_REFRESH_ONLY：只允许手动触发&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;android studio 导入 PullToRefresh&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载&#xA;https://github.com/chrisbanes/Android-PullToRefresh&#xA;&#xA;// 解压，得到 extras，sample，library(主要)&#xA;Android-PullToRefresh-master -&amp;gt; library&#xA;&#xA;// 在你项目的根目录创建一个lib目录&#xA;[PATH]&#xA;[app]&#xA;    [src]&#xA;    [res]&#xA;    [build]&#xA;    build.gradle&#xA;    ...&#xA;[build]&#xA;[gradle]&#xA;[lib]&#xA;    // 将 library 重名名为 pull&#xA;    [pull]&#xA;        [src]&#xA;        [res]&#xA;        [build]&#xA;        ... &#xA;build.gradle&#xA;settings.gradle&#xA;...&#xA;&#xA;// 修改 settings.gradle &#xA;include &#39;:app&#39;, &#39;:lib:pull&#39;&#xA;&#xA;// 修改 [app]/build.gradle&#xA;dependencies {&#xA;    // Library&#xA;    compile project(&#39;:lib:pull&#39;)&#xA;}&#xA;&#xA;// 创建 [lib]/[pull]/build.gradle&#xA;apply plugin: &#39;android-library&#39;&#xA;android {&#xA;    compileSdkVersion 17&#xA;    buildToolsVersion &amp;quot;21.1.2&amp;quot;&#xA;&#xA;    sourceSets {&#xA;    main {&#xA;        manifest.srcFile &#39;AndroidManifest.xml&#39;&#xA;        java.srcDirs = [&#39;src&#39;]&#xA;        resources.srcDirs = [&#39;src&#39;]&#xA;        aidl.srcDirs = [&#39;aidl&#39;]&#xA;        renderscript.srcDirs = [&#39;src&#39;]&#xA;        res.srcDirs = [&#39;res&#39;]&#xA;        assets.srcDirs = [&#39;assets&#39;]&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;// 完成   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;使用 PullToRefresh 刷新 ListView&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//  在 activity_main.xml 增加一个 PullToRefreshListView&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;com.handmark.pulltorefresh.library.PullToRefreshListView&#xA;    android:id=&amp;quot;@+id/left_drawer&amp;quot;&#xA;    android:layout_width=&amp;quot;240dp&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_gravity=&amp;quot;start&amp;quot;&#xA;    android:choiceMode=&amp;quot;singleChoice&amp;quot;&#xA;    android:dividerHeight=&amp;quot;1px&amp;quot;&#xA;    android:divider=&amp;quot;#ff000000&amp;quot;&#xA;    android:background=&amp;quot;#ffffffff&amp;quot;&#xA;    android:layout_alignParentTop=&amp;quot;true&amp;quot;&#xA;    android:layout_alignParentEnd=&amp;quot;true&amp;quot;&#xA;    android:layout_alignParentStart=&amp;quot;true&amp;quot; /&amp;gt;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&#xA;// 在 MainActivity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    PullToRefreshListView lv;&#xA;&#xA;    private String[] mListTitle = {&amp;quot;姓名&amp;quot;, &amp;quot;性别&amp;quot;, &amp;quot;年龄&amp;quot;, &amp;quot;居住地&amp;quot;, &amp;quot;邮箱&amp;quot;};&#xA;    private String[] mListStr = {&amp;quot;雨松MOMO&amp;quot;, &amp;quot;男&amp;quot;, &amp;quot;25&amp;quot;, &amp;quot;北京&amp;quot;,&#xA;        &amp;quot;xuanyusong@gmail.com&amp;quot;};&#xA;    ListView mListView = null;&#xA;    ArrayList&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; mData = new ArrayList&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;();&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    // 获取 PullToRefreshListView View&#xA;    lv = (PullToRefreshListView) findViewById(R.id.left_drawer);&#xA;&#xA;    // ....&#xA;    int lengh = mListTitle.length;&#xA;    for (int i = 0; i &amp;lt; lengh; i++) {&#xA;        Map&amp;lt;String, Object&amp;gt; item = new HashMap&amp;lt;String, Object&amp;gt;();&#xA;        item.put(&amp;quot;title&amp;quot;, mListTitle[i]);&#xA;        item.put(&amp;quot;text&amp;quot;, mListStr[i]);&#xA;        mData.add(item);&#xA;    }&#xA;&#xA;    // ...&#xA;    SimpleAdapter adapter = new SimpleAdapter(this, mData, android.R.layout.simple_list_item_2,&#xA;         new String[]{&amp;quot;title&amp;quot;, &amp;quot;text&amp;quot;}, new int[]{android.R.id.text1, android.R.id.text2});&#xA;&#xA;    // 将 SimpleAdapter 设置到 PullToRefreshListView&#xA;    lv.setAdapter(adapter);&#xA;&#xA;    // 刷新事件监听&#xA;    lv.setOnRefreshListener(new PullToRefreshBase.OnRefreshListener&amp;lt;ListView&amp;gt;() {&#xA;        @Override&#xA;        public void onRefresh(PullToRefreshBase&amp;lt;ListView&amp;gt; refreshView) {&#xA;&#xA;        // ...&#xA;        new AsyncTask&amp;lt;Void, Void, Void&amp;gt;() {&#xA;&#xA;            @Override&#xA;            protected Void doInBackground(Void... params) {&#xA;&#xA;            // 处理刷新任务&#xA;            try {&#xA;                Thread.sleep(3000);&#xA;            } catch (InterruptedException e) {&#xA;                e.printStackTrace();&#xA;            }&#xA;            return null;&#xA;            }&#xA;&#xA;            @Override&#xA;            protected void onPostExecute(Void reslst)&#xA;            {&#xA;            // 更行内容，通知 PullToRefresh 刷新结束&#xA;            lv.onRefreshComplete();&#xA;            }&#xA;&#xA;        }.execute();&#xA;&#xA;        }&#xA;    });&#xA;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // ---- 初始化（委托历史）----&#xA;    mProxyListView = (PullToRefreshListView) views.get(1).findViewById(R.id.listView);&#xA;    mProxyListView.getLoadingLayoutProxy(true, false).setPullLabel(&amp;quot;下拉刷新&amp;quot;);&#xA;    mProxyListView.getLoadingLayoutProxy(true, false).setReleaseLabel(&amp;quot;释放立即刷新&amp;quot;);&#xA;    mProxyListView.getLoadingLayoutProxy(true, false).setRefreshingLabel(&amp;quot;正在刷新 ...&amp;quot;);&#xA;    mProxyListView.getLoadingLayoutProxy(false, true).setPullLabel(&amp;quot;加载更多&amp;quot;);&#xA;    mProxyListView.getLoadingLayoutProxy(false, true).setReleaseLabel(&amp;quot;释放立即加载&amp;quot;);&#xA;    mProxyListView.getLoadingLayoutProxy(false, true).setRefreshingLabel(&amp;quot;正在加载 ...&amp;quot;);&#xA;    mProxyListView.getRefreshableView().setDivider(null);&#xA;    mProxyListView.setOnRefreshListener(new PullToRefreshBase.OnRefreshListener2&amp;lt;ListView&amp;gt;() {&#xA;        @Override&#xA;        public void onPullDownToRefresh(final PullToRefreshBase&amp;lt;ListView&amp;gt; pullToRefreshBase) {&#xA;            // ...&#xA;            updateProxy(false);&#xA;            // ...&#xA;            pullToRefreshBase.getRefreshableView().postDelayed(new Runnable() {&#xA;                @Override&#xA;                public void run() {&#xA;                    pullToRefreshBase.onRefreshComplete();&#xA;                }&#xA;            }, 1000);&#xA;        }&#xA;&#xA;        @Override&#xA;        public void onPullUpToRefresh(final PullToRefreshBase&amp;lt;ListView&amp;gt; pullToRefreshBase) {&#xA;            // ...&#xA;            updateProxy(true);&#xA;            // ...&#xA;            pullToRefreshBase.getRefreshableView().postDelayed(new Runnable() {&#xA;                @Override&#xA;                public void run() {&#xA;                    pullToRefreshBase.onRefreshComplete();&#xA;                }&#xA;            }, 1000);&#xA;        }&#xA;    });&#xA;    // 设置空View&#xA;    TextView empty_entrusts = Utils.getEmptyView(PreviewActivity.this, &amp;quot;还没有委托历史数据 !&amp;quot;);&#xA;    ((ViewGroup) mProxyListView.getRefreshableView().getParent()).addView(empty_entrusts);&#xA;    mProxyListView.getRefreshableView().setEmptyView(empty_entrusts);&#xA;    // 自定义适配器&#xA;    mProxyAdapter = new SuperBaseAdapter&amp;lt;ProxyData&amp;gt;(PreviewActivity.this, mProxyDatas) {&#xA;        @Override&#xA;        public View getView(int position, View convertView, ViewGroup parent) {&#xA;            ProxyData pd = mDatas.get(position);&#xA;            SuperViewHolder mSuperViewHolder = SuperViewHolder.make(getApplication(),&#xA;                                             R.layout.service_preview_proxy,&#xA;                                             convertView, parent);&#xA;            return mSuperViewHolder.getConvertView();&#xA;        }&#xA;    };&#xA;    // 设置适配器&#xA;    mProxyListView.getRefreshableView().setAdapter(mProxyAdapter);&#xA;    // Click 监听&#xA;    // mProxyListView.setOnItemClickListener(this);&#xA;    // ---- SuperPagerAdapter -----&#xA;    service_preview_pager.setAdapter(new SuperPagerAdapter(views));&#xA;    service_preview_pager.setOnPageChangeListener(this);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之ListView与Adapter使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BListView%E4%B8%8EAdapter%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ListView&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // ViewGroup -&amp;gt; AdapterView -&amp;gt; ... -&amp;gt; ListView&#xA;    // Adapter -&amp;gt; SpinnerAdapter -&amp;gt; BaseAdapter -&amp;gt;  ArrayAdapter ....&#xA;    // ListView，GridView，等都是容器，而Adapter负责提供每个“列表项”组件&#xA;    // AdapterView则负责采用合适的方式显示这些“列表项”&#xA;    // setAdapter(Adapter)是设置Adater的函数方法.&#xA;&#xA;    // 简单，易用，通常用于将数组或List集合的多个值包装成多个列表项&#xA;    ArrayAdapter&#xA;    // 并不简单，功能强大，可用于将List集合的多个对象包装成多个列表项&#xA;    SimpleAdapter&#xA;    // 与 SimpleAdapter 相似，只是用于包装 Cursor 提供的数据&#xA;    SimpleCursorAdapter&#xA;    // 通常用于被扩展，扩展可以对各列表项进行最大限度的定制.&#xA;    BaseAdapter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;关于 ListView 中 onItemClick 的 position 非 0 开始&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 主要遇到两种&#xA;//  一，插入 HeaderViews 造成 position 非 0&#xA;//  二，使用 PullToRefreshListView 造成 position 非 0&#xA;&#xA;// 解决办法&#xA;mRefreshable.getRefreshableView().setOnItemClickListener(new AdapterView.OnItemClickListener() {&#xA;    @Override&#xA;    public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {&#xA;        if (position - mRefreshable.getRefreshableView().getHeaderViewsCount() == -1) {&#xA;            ...&#xA;        } else if (position - mRefreshable.getRefreshableView().getHeaderViewsCount() &amp;gt;= 0) {&#xA;            ...&#xA;        }&#xA;}&#xA;&#xA;// ...&#xA;// 基数页&#xA;int page = 1;&#xA;// 基数&#xA;int base = 7;&#xA;// 更多&#xA;if (more) {&#xA;    int viewCount = mListView.getRefreshableView().getCount();&#xA;    int headerCound = mListView.getRefreshableView().getHeaderViewsCount();&#xA;    int footerCound = mListView.getRefreshableView().getFooterViewsCount();&#xA;    int count = viewCount - headerCound - footerCound;&#xA;    if (count % base == 0) {&#xA;        page = count / base + 1;&#xA;    } else {&#xA;        return;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;关于 ListView 支持长按事件&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // Long Click 监听&#xA;    service_listview.setOnItemLongClickListener(this);&#xA;&#xA;    // Long Click 监听&#xA;    @Override&#xA;    public boolean onItemLongClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {&#xA;        switch (position) {&#xA;            case 0:&#xA;                break;&#xA;            default:&#xA;                AlertDialog.Builder builder = new AlertDialog.Builder(this);&#xA;                builder.setMessage(&amp;quot;您确定要取消该预约?&amp;quot;);&#xA;                builder.setPositiveButton(&amp;quot;确定&amp;quot;, new DialogInterface.OnClickListener() {&#xA;                    @Override&#xA;                    public void onClick(DialogInterface dialog, int which) {&#xA;                    }&#xA;                });&#xA;                builder.setNegativeButton(&amp;quot;返回&amp;quot;, new DialogInterface.OnClickListener() {&#xA;                    @Override&#xA;                    public void onClick(DialogInterface dialog, int which) {&#xA;                    }&#xA;                });&#xA;                builder.create().show();&#xA;                break;&#xA;        }&#xA;        return false;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;关于 ListView 禁用回弹&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;不同的安卓厂商对ListView或ScrollView都做了一些动画效果，比如下拉时为了产生弹性美感而有大幅度回弹效果&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;再比如魅族的下拉悬停，有时做了一个下拉刷新的功能会与之冲突。其实该美化实为多此一举。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 实际上可以通过设置ListView的一个ScrollMode属性来禁用&#xA;listView.setOverScrollMode(View.OVER_SCROLL_NEVER);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;关于 ListView Item 焦点问题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;项目中的listview不仅仅是简单的文字，常常需要自己定义listview，自己的Adapter去继承BaseAdapter&#xA;可能会发生点击每一个item的时候没有反应，无法获取的焦点。&#xA;&#xA;原因多半是由于在你自己定义的Item中存在诸如ImageButton，Button，CheckBox等子控件&#xA;(也可以说是Button或者Checkable的子类控件)，此时这些子控件会将焦点获取到&#xA;所以常常当点击item时变化的是子控件，item本身的点击没有响应。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;这时候就可以使用descendantFocusability来解决啦，API描述如下：&#xA;&#xA;android:descendantFocusability&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;该属性是当一个为view获取焦点时，定义viewGroup和其子控件两者之间的关系。&#xA;&#xA;属性的值有三种：&#xA;&#xA;        beforeDescendants：viewgroup会优先其子类控件而获取到焦点&#xA;        afterDescendants： viewgroup只有当其子类控件不需要获取焦点时才获取焦点&#xA;        blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;关于 ListView 头部&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ListView 可以通过 setHeaderView 来设置一个头部View&#xA;View headerView = lif.inflate(R.layout.header, null);&#xA;mListView.addHeaderView(headerView);&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;关于 ListView 节头部&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ListView 可以通过 SimplerExpandableListAdapter &#xA;// ListView 可以通过 ExpandableListView &#xA;// 可以处理分节列表中的二维数据结构&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;禁用点击&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@Override&#xA;public boolean isEnabled(int position) {&#xA;    return false;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;抢占焦点&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;关于在ListView的Item里增加(例CheckBox对象)造成Item无法点击问题&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;此问题是因为CheckBox对象抢占了Item的焦点，只需要在将CheckBox对象&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;android:focusable属性值设置为false即可&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;BaseAdapter&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// BaseAdapter 类&#xA;class MenuBaseAdapter extends BaseAdapter {&#xA;&#xA;    // 上下文&#xA;    private Context context;&#xA;&#xA;    // Activity&#xA;    private MainActivity activity;&#xA;&#xA;    public MenuBaseAdapter(Context context) {&#xA;    this.context = context;&#xA;    this.activity = (MainActivity) context;&#xA;    }&#xA;&#xA;    // 这里代表这ListView的行数量&#xA;    // 也可以通过构造传入List或者其它办法&#xA;    @Override&#xA;    public int getCount() {&#xA;    // 项目数量&#xA;    return 7;&#xA;    }&#xA;&#xA;    @Override&#xA;    public Object getItem(int position) {&#xA;    return null;&#xA;    }&#xA;&#xA;    @Override&#xA;    public long getItemId(int position) {&#xA;    return 0;&#xA;    }&#xA;&#xA;    // 在这里会按照getCount()的数量获取View&#xA;    // 所以在这里定制View就可以了&#xA;    @Override&#xA;    public View getView(int position, View convertView, ViewGroup parent) {&#xA;    convertView = LayoutInflater.from(context).inflate(R.layout.menu_adapter_item, null);&#xA;    ImageView imageView = null;&#xA;    TextView textView = null;&#xA;    switch (position) {&#xA;        case 0:&#xA;        imageView = (ImageView) convertView.findViewById(R.id.imageView);&#xA;        textView = (TextView) convertView.findViewById(R.id.textView);&#xA;        imageView.setImageResource(R.drawable.menu_lock_icon);&#xA;        convertView.setBackground(new ColorDrawable(0xff0997F7));&#xA;        textView.setText(&amp;quot;登录系统&amp;quot;);&#xA;        break;&#xA;        case 1:&#xA;        imageView = (ImageView) convertView.findViewById(R.id.imageView);&#xA;        textView = (TextView) convertView.findViewById(R.id.textView);&#xA;        imageView.setImageResource(R.drawable.menu_bluetooth_icon);&#xA;        textView.setText(&amp;quot;连接蓝牙&amp;quot;);&#xA;        break;&#xA;    }&#xA;    // 返回&#xA;    return convertView;&#xA;    }&#xA;}&#xA;&#xA;// 创建一个自定义的BaseAdapter对象&#xA;mMenuBaseAdapter = new MenuBaseAdapter(MainActivity.this);&#xA;&#xA;// 获取一个ListView对象&#xA;ListView left_drawer = (ListView) findViewById(R.id.left_drawer);&#xA;&#xA;// 将BaseAdapter设置给ListView&#xA;left_drawer.setAdapter(mMenuBaseAdapter);&#xA;&#xA;// 为ListView设置监听&#xA;left_drawer.setOnItemClickListener(mMenuClickListener);&#xA;&#xA;// 监听&#xA;private AdapterView.OnItemClickListener mMenuClickListener = new AdapterView.OnItemClickListener() {&#xA;&#xA;    @Override&#xA;    public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {&#xA;        // position代表点击了ListView的第几个&#xA;        switch (position) {&#xA;        case 0:&#xA;            break;&#xA;        }&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充Adapter适配器内存优化&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在Android中Adapter使用十分广泛，特别是在list中。所以adapter是数据的 “集散地”&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;所以对其进行内存优化是很有必要的。主要使用convertView和ViewHolder来进行缓存处理&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ViewHolder&#xA;class MenuViewHolder {&#xA;    ImageView imageView;&#xA;    TextView textView;&#xA;}&#xA;&#xA;/**&#xA; * Created by nljb on 15/4/3.&#xA; */&#xA;class MenuBaseAdapter extends BaseAdapter {&#xA;&#xA;    // 上下文&#xA;    private Context context;&#xA;&#xA;    public MenuBaseAdapter(Context context) {&#xA;    this.context = context;&#xA;    }&#xA;&#xA;    @Override&#xA;    public int getCount() {&#xA;    // 项目数量&#xA;    return 7;&#xA;    }&#xA;&#xA;    @Override&#xA;    public Object getItem(int position) {&#xA;    return null;&#xA;    }&#xA;&#xA;    @Override&#xA;    public long getItemId(int position) {&#xA;    return 0;&#xA;    }&#xA;&#xA;    @Override&#xA;    public View getView(int position, View convertView, ViewGroup parent) {&#xA;    MenuViewHolder menuViewHolder = null;&#xA;    ImageView imageView = null;&#xA;    TextView textView = null;&#xA;    if (convertView == null) {&#xA;        convertView = LayoutInflater.from(context).inflate(R.layout.menu_adapter_item, null);&#xA;        imageView = (ImageView) convertView.findViewById(R.id.imageView);&#xA;        textView = (TextView) convertView.findViewById(R.id.textView);&#xA;        menuViewHolder = new MenuViewHolder();&#xA;        menuViewHolder.imageView = imageView;&#xA;        menuViewHolder.textView = textView;&#xA;        convertView.setTag(menuViewHolder);&#xA;    } else {&#xA;        menuViewHolder = (MenuViewHolder) convertView.getTag();&#xA;        imageView = menuViewHolder.imageView;&#xA;        textView = menuViewHolder.textView;&#xA;    }&#xA;    switch (position) {&#xA;        case 0:&#xA;        imageView.setImageResource(R.drawable.menu_lock_icon);&#xA;        convertView.setBackground(new ColorDrawable(0xff0997F7));&#xA;        textView.setText(&amp;quot;登录系统&amp;quot;);&#xA;        break;&#xA;        case 1:&#xA;        imageView.setImageResource(R.drawable.menu_bluetooth_icon);&#xA;        textView.setText(&amp;quot;连接蓝牙&amp;quot;);&#xA;        break;&#xA;        case 2:&#xA;        imageView.setImageResource(R.drawable.menu_tasks_icon);&#xA;        textView.setText(&amp;quot;命令列表&amp;quot;);&#xA;        break;&#xA;        case 3:&#xA;        imageView.setImageResource(R.drawable.menu_tasks_icon);&#xA;        textView.setText(&amp;quot;配置列表&amp;quot;);&#xA;        break;&#xA;        case 4:&#xA;        imageView.setImageResource(R.drawable.menu_qrcode_icon);&#xA;        textView.setText(&amp;quot;扫码配置&amp;quot;);&#xA;        break;&#xA;        case 5:&#xA;        imageView.setImageResource(R.drawable.menu_config_icon);&#xA;        textView.setText(&amp;quot;系统设置&amp;quot;);&#xA;        break;&#xA;        case 6:&#xA;        imageView.setImageResource(R.drawable.menu_conn_icon);&#xA;        textView.setText(&amp;quot;退出系统&amp;quot;);&#xA;        break;&#xA;    }&#xA;    // 返回&#xA;    return convertView;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Service使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BService%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-13 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;在 Service 通知 Activity 更新 UI&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;解决方法：将 Hander 传入 Service 由 Service 发送更新消息到 Activity&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 实例&#xA;public class UpdateService extends Service {&#xA;&#xA;    // ---------------------------------------&#xA;&#xA;    private static android.os.Handler mHandler;&#xA;&#xA;    // ---------------------------------------&#xA;&#xA;    // 启动Service并传入Handler&#xA;    public static void onStart(Context context, android.os.Handler handler) {&#xA;        mHandler = handler;&#xA;        context.startService(new Intent(context, UpdateService.class));&#xA;    }&#xA;&#xA;    // .... 随后就可以使用 mHandler 发送通知了 ...&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;每次 startService 都会被 执行的 onStartCommand&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在 Service 后台运行时，如果程序退出后需要再启动&#xA;    这时 Service 的 onCreate 是不会执行的.&#xA;    每次 startService 时 onStartCommand 都会被执行 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Service 之 stratService()&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 生命周期&#xA;stratService()&#xA;onCreate()&#xA;onStartCommand()&#xA;// Service 运行中 ... 被自己或者调用者停止&#xA;// 运行中可以通过 new Thread() ...&#xA;onDestroy()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建 Service 还需要添加 AndroidManifest.xml&#xA;&amp;lt;service&#xA;    android:name=&amp;quot;.MyService&amp;quot;&#xA;    android:enabled=&amp;quot;true&amp;quot;&#xA;    android:exported=&amp;quot;true&amp;quot; &amp;gt;&#xA;&amp;lt;/service&amp;gt;&#xA;&#xA;// 创建 Service&#xA;public class MyService extends Service {&#xA;&#xA;    public MyService() {}&#xA;&#xA;    // 该方法返回一个 IBinder 对象，应用程序可以通过该对象与 Service 交互&#xA;    @Override&#xA;    public IBinder onBind(Intent intent) {&#xA;        return null;&#xA;    }&#xA;&#xA;    // Service 被创建时回调该方法&#xA;    @Override&#xA;    public void onCreate() {&#xA;        super.onCreate();&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;    }&#xA;&#xA;    // Service 被启动时回调该方法&#xA;    @Override&#xA;    public int onStartCommand(Intent intent, int flags, int startId) {&#xA;        return START_STICKY;&#xA;    }&#xA;&#xA;    // Service 被关闭之前回调&#xA;    @Override&#xA;    public void onDestroy() {&#xA;        super.onDestroy();&#xA;    }&#xA;}&#xA;&#xA;// 在 Activity 中使用 Service&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        final Intent intent = new Intent(MainActivity.this, MyService.class);&#xA;        Button button = (Button) findViewById(R.id.button);&#xA;        button.setOnClickListener(new View.OnClickListener() {&#xA;            @Override&#xA;            public void onClick(View v) {&#xA;            // 启动 Service&#xA;            // startService(intent);&#xA;            // 关闭 Service&#xA;            // stopService(intent);&#xA;            }&#xA;        });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Service 之 bindService&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 生命周期&#xA;bindService()&#xA;onCreate()&#xA;onBind()&#xA;// 客户绑定到 Service ... unBindService() 取消绑定&#xA;onUnbind()&#xA;onDestroy()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;当一个Service程序启动后，如果没有出现意外且明确调用stopService()方法&#xA;    则它将会一直驻留在手机的服务之中。&#xA;&#xA;如果希望由Activity启动的Service程序可以在Activity程序结束后自动结束&#xA;    那么就应该将Activity和Service程序进行绑定。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;为此需要借助android.content.ServiceConnection接口&#xA;    此接口的主要功能是当一个Activity程序与Service建立连接之后&#xA;    执行Service连接或取消连接的处理操作&#xA;&#xA;在Activity连接到Service程序之后，会触发Service类中的onBind()方法&#xA;    在此方法中要返回一个android.os.IBinder接口的对象。&#xA;&#xA;默认情况下，当一个Activity程序启动Service之后，该Service程序就会在后台独自运行&#xA;    与前台的Activity不再有什么联系，但是如果使用ServiceConnection进行连接&#xA;    则这个Service就会和相应的Activity程序绑定在一起，而不再是独立运行了。&#xA;&#xA;// 当与一个Service建立连接时调用&#xA;public abstract void onServiceConnected(ComponenetName name, IBinderservice)&#xA;// 当与一个Service取消连接时调用&#xA;public abstract void onServiceDisconnected(ComponentName name)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 创建 Service 还需要添加 AndroidManifest.xml&#xA;&amp;lt;service&#xA;    android:name=&amp;quot;.MyService&amp;quot;&#xA;    android:enabled=&amp;quot;true&amp;quot;&#xA;    android:exported=&amp;quot;true&amp;quot; &amp;gt;&#xA;&amp;lt;/service&amp;gt;&#xA;&#xA;// 创建 Service&#xA;public class MyService extends Service {&#xA;&#xA;    // 线程停止标记&#xA;    private boolean quit;&#xA;&#xA;    // 计数器&#xA;    private int count;&#xA;&#xA;    // 数据对象&#xA;    private MyBinder binder = new MyBinder();&#xA;&#xA;    // 构造&#xA;    public MyService() {}&#xA;&#xA;    // 数据类&#xA;    public class MyBinder extends Binder {&#xA;        public int getCount() {&#xA;            return count;&#xA;        }&#xA;    }&#xA;&#xA;    // 该方法返回一个 IBinder 对象，应用程序可以通过该对象与 Service 交互&#xA;    @Override&#xA;    public IBinder onBind(Intent intent) {&#xA;        // 将数据对象返回&#xA;        return binder;&#xA;    }&#xA;&#xA;    // Service 被创建时回调该方法&#xA;    @Override&#xA;    public void onCreate() {&#xA;        super.onCreate();&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        // 启动一个线程，处理数据&#xA;        new Thread()&#xA;        {&#xA;            @Override&#xA;            public void run()&#xA;            {&#xA;            while(!quit)&#xA;            {&#xA;                try {&#xA;                Thread.sleep(1000);&#xA;                } catch (InterruptedException e) {&#xA;                e.printStackTrace();&#xA;                }&#xA;                count++;&#xA;            }&#xA;            }&#xA;        }.start();&#xA;    }&#xA;&#xA;    // Service 被启动时回调该方法&#xA;    @Override&#xA;    public int onStartCommand(Intent intent, int flags, int startId) {&#xA;        return START_STICKY;&#xA;    }&#xA;&#xA;    // Service 被关闭之前回调&#xA;    @Override&#xA;    public void onDestroy() {&#xA;        super.onDestroy();&#xA;        // 关闭时，结束线程&#xA;        this.quit = true;&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 在 Activity 中使用 Service&#xA;public class MainActivity extends Activity {&#xA;&#xA;    // 用户存储 Service 中的数据对象&#xA;    MyService.MyBinder binder;&#xA;&#xA;    // 与 Service 建立连接&#xA;    private ServiceConnection conn = new ServiceConnection() {&#xA;&#xA;        // 当 Activity 与 Service 连接时回调该方法&#xA;        @Override&#xA;        public void onServiceConnected(ComponentName name, IBinder service) {&#xA;            // 获取返回的 Service 数据对象&#xA;            binder = (MyService.MyBinder) service;&#xA;        }&#xA;&#xA;        // 当 Activity 与 Service 断开时回调该方法&#xA;        @Override&#xA;        public void onServiceDisconnected(ComponentName name) {}&#xA;&#xA;    };&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        final Intent intent = new Intent();&#xA;        intent.setAction(&amp;quot;org.crazyit.service.FIRST_SERVICE&amp;quot;);&#xA;        Button button = (Button) findViewById(R.id.button);&#xA;        button.setOnClickListener(new View.OnClickListener() {&#xA;            @Override&#xA;            public void onClick(View v) {&#xA;            // 绑定 Service&#xA;            bindService(intent, conn, Service.BIND_AUTO_CREATE);&#xA;            // 解除绑定 Service&#xA;            // unbindService(conn);&#xA;&#xA;            }&#xA;        });&#xA;        Button button2 = (Button) findViewById(R.id.button2);&#xA;        button2.setOnClickListener(new View.OnClickListener() {&#xA;            @Override&#xA;            public void onClick(View v) {&#xA;            Toast.makeText(getApplicationContext(), String.valueOf(binder.getCount()), Toast.LENGTH_SHORT).show();&#xA;            }&#xA;        });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Service 之 IntentService&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;IntentService继承Service,并在其创建了工作线程,用来处理耗时操作&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 添加 AndroidManifest.xml&#xA;&amp;lt;service&#xA;    android:name=&amp;quot;.MyIntentService&amp;quot;&#xA;    android:exported=&amp;quot;false&amp;quot; &amp;gt;&#xA;&amp;lt;/service&amp;gt;&#xA;&#xA;// 创建 IntentService&#xA;public class MyIntentService extends IntentService {&#xA;&#xA;    public MyIntentService() {&#xA;    super(&amp;quot;MyIntentService&amp;quot;);&#xA;    }&#xA;&#xA;    // 这里的运行，会在独立的线程内完成&#xA;    @Override&#xA;    protected void onHandleIntent(Intent intent) {&#xA;        Log.i(&amp;quot;into&amp;quot;, &amp;quot;xxx&amp;quot;);&#xA;    }&#xA;&#xA;}&#xA;&#xA;&#xA;// 在 Activity 中使用 Service&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        Button button = (Button) findViewById(R.id.button);&#xA;        button.setOnClickListener(new View.OnClickListener() {&#xA;            @Override&#xA;            public void onClick(View v) {&#xA;            Intent intent = new Intent(MainActivity.this, MyIntentService.class);&#xA;            startService(intent);&#xA;            stopService(intent);&#xA;            }&#xA;        });&#xA;    }   &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之DrawerLayout使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BDrawerLayout%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-13 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 定义一个 android.support.v4.widget.DrawerLayout &#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;android.support.v4.widget.DrawerLayout&#xA;    android:id=&amp;quot;@+id/drawer_layout&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;!-- The main content view --&amp;gt;&#xA;&#xA;    &amp;lt;FrameLayout&#xA;        android:id=&amp;quot;@+id/content_frame&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt;&#xA;&#xA;        &amp;lt;Button&#xA;        android:id=&amp;quot;@+id/btn&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;open&amp;quot;&#xA;        /&amp;gt;&#xA;    &amp;lt;/FrameLayout&amp;gt;&#xA;&#xA;    &amp;lt;!-- The navigation drawer --&amp;gt;&#xA;&#xA;    &amp;lt;ListView&#xA;        android:id=&amp;quot;@+id/left_drawer&amp;quot;&#xA;        android:layout_width=&amp;quot;240dp&amp;quot;&#xA;        android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_gravity=&amp;quot;start&amp;quot;&#xA;        android:background=&amp;quot;#111&amp;quot;&#xA;        android:choiceMode=&amp;quot;singleChoice&amp;quot;&#xA;        android:divider=&amp;quot;@android:color/transparent&amp;quot;&#xA;        android:dividerHeight=&amp;quot;0dp&amp;quot; /&amp;gt;&#xA;    &amp;lt;/android.support.v4.widget.DrawerLayout&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity&#xA;{&#xA;    private DrawerLayout mDrawerLayout = null;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState)&#xA;    {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.a);&#xA;&#xA;        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);&#xA;&#xA;        Button button = (Button) findViewById(R.id.btn);&#xA;        button.setOnClickListener(new View.OnClickListener()&#xA;        {&#xA;&#xA;        @Override&#xA;        public void onClick(View v)&#xA;        {&#xA;            // 按钮按下，将抽屉打开&#xA;            mDrawerLayout.openDrawer(Gravity.LEFT);&#xA;&#xA;        }&#xA;        });&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之使用Animation设置View动画</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E4%BD%BF%E7%94%A8Animation%E8%AE%BE%E7%BD%AEView%E5%8A%A8%E7%94%BB/</link>
      <pubDate>2015-03-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;View Animation&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 主要是向View对象设置动画效果&#xA;// 比如 Button, TextView ... 等 &#xA;AlphaAnimation 透明度动画效果&#xA;RotateAnimation 旋转动画效果&#xA;ScaleAnimation 缩放动画效果&#xA;TranslateAnimation 位移动画效果&#xA;AnimationSet 混合动画&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 处理 Activity 的 View&#xA;// 向 View 增加动画效果&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    Button button = (Button) findViewById(R.id.button);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        // AlphaAnimation 透明度动画效果&#xA;        // AlphaAnimation aa = new AlphaAnimation(0, 1);&#xA;        // RotateAnimation 旋转动画效果&#xA;        // RotateAnimation aa = new RotateAnimation(0, 360);&#xA;        // ScaleAnimation 缩放动画效果&#xA;        // ScaleAnimation aa = new ScaleAnimation(0, 1, 0, 1);&#xA;        // TranslateAnimation 位移动画效果&#xA;        // TranslateAnimation aa = new TranslateAnimation(0, 200, 0, 200);&#xA;        // AnimationSet 混合动画&#xA;        // AnimationSet as = new AnimationSet(true);&#xA;        // AlphaAnimation aa = new AlphaAnimation(0, 1);&#xA;        // aa.setDuration(1000);&#xA;        // as.addAnimation(aa);&#xA;        // TranslateAnimation ab = new TranslateAnimation(0, 200, 0, 200);&#xA;        // ab.setDuration(1000);&#xA;        // as.addAnimation(ab);&#xA;        // 持续时间&#xA;        // as.setDuration(1000);&#xA;        TranslateAnimation ab = new TranslateAnimation(0, 200, 0, 200);&#xA;        ab.setDuration(1000);&#xA;        // 监听动画&#xA;        ab.setAnimationListener(new Animation.AnimationListener() {&#xA;            @Override&#xA;            public void onAnimationStart(Animation animation) {&#xA;            // 动画开始&#xA;            }&#xA;&#xA;            @Override&#xA;            public void onAnimationEnd(Animation animation) {&#xA;            // 动画结束&#xA;            }&#xA;&#xA;            @Override&#xA;            public void onAnimationRepeat(Animation animation) {&#xA;            // ...&#xA;            }&#xA;        });&#xA;        // 为View设置开始动画&#xA;        // v.startAnimation(as);&#xA;        }&#xA;    });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;LayoutAnimationController&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 布局动画效果&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    // 获取 View&#xA;    LinearLayout v = (LinearLayout) this.getLayoutInflater().inflate(R.layout.activity_main, null);&#xA;    // 创建动画&#xA;    ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);&#xA;    sa.setDuration(5000);&#xA;    // 创建 Layout 动画&#xA;    LayoutAnimationController lac = new LayoutAnimationController(sa, 0.5f);&#xA;    // LayoutAnimationController.ORDER_NORMAL  正常顺序&#xA;    // LayoutAnimationController.ORDER_RANDOM  随机顺序&#xA;    // LayoutAnimationController.ORDER_REVERSE 倒序顺序&#xA;    lac.setOrder(LayoutAnimationController.ORDER_NORMAL);&#xA;    // 将 Layout 动画设置到 View&#xA;    v.setLayoutAnimation(lac);&#xA;    // 将 View 设置到 Activity&#xA;    setContentView(v);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;默认的布局转换动画&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果你要使用默认的动画&#xA;// 一个非常简单的方式是在View的XML布局文件中把android:animateLayoutchanges属性设置为true。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;　   // 这样就自动地按照默认方式来对要移除或添加的View，还有Group中的其他View进行动画。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;Button&#xA;    android:id=&amp;quot;@+id/addNewButton&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:text=&amp;quot;Add Button&amp;quot; /&amp;gt;&#xA;    &amp;lt;!--&#xA;    &amp;lt;GridLayout&#xA;    android:columnCount=&amp;quot;4&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:id=&amp;quot;@+id/gridContainer&amp;quot;&#xA;    // 默认的布局转换动画&#xA;    android:animateLayoutChanges=&amp;quot;true&amp;quot;&#xA;    /&amp;gt;&#xA;    --&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;    android:id=&amp;quot;@+id/gridContainer&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    // 默认的布局转换动画&#xA;    android:animateLayoutChanges=&amp;quot;true&amp;quot; &#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之ActionBar使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BActionBar%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-12 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ActionBar&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 同时隐藏图标与标题，TABS将覆盖标题栏.&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onCreateOptionsMenu(Menu menu) {&#xA;    // Inflate the menu; this adds items to the action bar if it is present.&#xA;    getMenuInflater().inflate(R.menu.menu_main, menu);&#xA;    // 获取 ActionBar&#xA;    final ActionBar actionBar = getActionBar();&#xA;    // 隐藏 ActionBar 标题&#xA;    actionBar.setDisplayShowTitleEnabled(false);&#xA;    // 隐藏 ActionBar 图标&#xA;    actionBar.setDisplayShowHomeEnabled(false);&#xA;    // 将应用程序图标设置为可点击&#xA;    actionBar.setHomeButtonEnabled(true);&#xA;    // 将应用程序图标设置为可点击，并在图标上添加向左箭头&#xA;    actionBar.setDisplayHomeAsUpEnabled(true);&#xA;    // MenuItem.SHOW_AS_ACTION_ALWAYS 总是将该MenuItem显示在ActionBar上&#xA;    // MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW 将该Action View折叠成普通菜单项&#xA;    // MenuItem.SHOW_AS_ACTION_IF_ROOM 当ActionBar位置足够时才显示在ActionBar上&#xA;    // MenuItem.SHOW_AS_ACTION_NEVER 不将该MenuItem显示在ActionBar上&#xA;    // MenuItem.SHOW_AS_ACTION_WITH_TEXT 将该MenuItem显示在ActionBar上，并显示该菜单的文本&#xA;    menu.add(0, 0x101, 0, &amp;quot;普通菜单&amp;quot;).setIcon(R.mipmap.ic_launcher).setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);&#xA;    menu.add(0, 0x102, 0, &amp;quot;普通菜单&amp;quot;).setIcon(R.mipmap.ic_launcher).setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);&#xA;    // 返回&#xA;    return true;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onOptionsItemSelected(MenuItem item) {&#xA;    // Handle action bar item clicks here. The action bar will&#xA;    // automatically handle clicks on the Home/Up button, so long&#xA;    // as you specify a parent activity in AndroidManifest.xml.&#xA;    int id = item.getItemId();&#xA;&#xA;    //noinspection SimplifiableIfStatement&#xA;    if (id == R.id.action_settings) {&#xA;        return true;&#xA;    }&#xA;&#xA;    switch (id)&#xA;    {&#xA;        // 判断是否为主按钮点击&#xA;        case android.R.id.home:&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        break;&#xA;        case 0x101:&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        break;&#xA;    }&#xA;&#xA;    return super.onOptionsItemSelected(item);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ActionBar 之 ActionBar.TabListener&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity implements  ActionBar.TabListener {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onCreateOptionsMenu(Menu menu) {&#xA;    // Inflate the menu; this adds items to the action bar if it is present.&#xA;    //getMenuInflater().inflate(R.menu.menu_main, menu);&#xA;    // 获取 ActionBar&#xA;    final ActionBar actionBar = getActionBar();&#xA;    // 隐藏 ActionBar 标题&#xA;    actionBar.setDisplayShowTitleEnabled(false);&#xA;    // 隐藏 ActionBar 图标&#xA;    // actionBar.setDisplayShowHomeEnabled(false);&#xA;    // ActionBar TABS 模式&#xA;    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);&#xA;    actionBar.addTab(actionBar.newTab().setText(&amp;quot;第一页&amp;quot;).setTabListener((ActionBar.TabListener) MainActivity.this));&#xA;    actionBar.addTab(actionBar.newTab().setText(&amp;quot;第二页&amp;quot;).setTabListener((ActionBar.TabListener) MainActivity.this));&#xA;    actionBar.addTab(actionBar.newTab().setText(&amp;quot;第三页&amp;quot;).setTabListener((ActionBar.TabListener) MainActivity.this));&#xA;    // 返回&#xA;    return true;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onOptionsItemSelected(MenuItem item) {&#xA;    // Handle action bar item clicks here. The action bar will&#xA;    // automatically handle clicks on the Home/Up button, so long&#xA;    // as you specify a parent activity in AndroidManifest.xml.&#xA;    int id = item.getItemId();&#xA;&#xA;    //noinspection SimplifiableIfStatement&#xA;    if (id == R.id.action_settings) {&#xA;        return true;&#xA;    }&#xA;&#xA;    return super.onOptionsItemSelected(item);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {&#xA;    // 自定义的 Fragment&#xA;    Fragment1 fragment;&#xA;    // 获取 TAB 编号，0, 1, 2, 3, .....&#xA;    if (tab.getPosition() == 1) {&#xA;        fragment = new Fragment1();&#xA;        // 传参&#xA;        Bundle args = new Bundle();&#xA;        args.putString(&amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;);&#xA;        fragment.setArguments(args);&#xA;        FragmentTransaction f = getFragmentManager().beginTransaction();&#xA;        // 替换，也可以 ADD &#xA;        f.replace(R.id.xxx, fragment);&#xA;        f.commit();&#xA;    }&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {&#xA;&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {&#xA;&#xA;    }&#xA;&#xA;    // 创建了一个(Fragment)并返回(Fragment)的(Layout)&#xA;    public static class Fragment1 extends Fragment {&#xA;&#xA;    public Fragment1() {&#xA;    }&#xA;&#xA;    @Override&#xA;    public View onCreateView(LayoutInflater inflater, ViewGroup container,&#xA;                 Bundle savedInstanceState) {&#xA;        // 初始化 View&#xA;        View rootView = inflater.inflate(R.layout.fragment_blank, container, false);&#xA;        TextView text = (TextView) rootView.findViewById(R.id.text);&#xA;        // 获取传值&#xA;        Bundle args = getArguments();&#xA;        text.setText(args.getString(&amp;quot;key&amp;quot;));&#xA;        return rootView;&#xA;    }&#xA;    }&#xA;&#xA;}&#xA;&#xA;// R.layout.fragment_blank&#xA;&amp;lt;FrameLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&#xA;    android:id=&amp;quot;@+id/xxx&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot; tools:context=&amp;quot;.MainActivity&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;TextView android:text=&amp;quot;@string/hello_world&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot; /&amp;gt;&#xA;&#xA;&amp;lt;/FrameLayout&amp;gt;&#xA;&#xA;// R.layout.activity_main&#xA;&amp;lt;FrameLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; tools:context=&amp;quot;com.example.nljb.nljb.BlankFragment&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;!-- TODO: Update blank fragment layout --&amp;gt;&#xA;    &amp;lt;TextView android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:text=&amp;quot;@string/hello_blank_fragment&amp;quot; /&amp;gt;&#xA;&#xA;&amp;lt;/FrameLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ActionBar 之 ActionBar.OnNavigationListener&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity implements  ActionBar.OnNavigationListener {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onCreateOptionsMenu(Menu menu) {&#xA;    // Inflate the menu; this adds items to the action bar if it is present.&#xA;    //getMenuInflater().inflate(R.menu.menu_main, menu);&#xA;    // 获取 ActionBar&#xA;    final ActionBar actionBar = getActionBar();&#xA;    // 隐藏 ActionBar 标题&#xA;    actionBar.setDisplayShowTitleEnabled(false);&#xA;    // 隐藏 ActionBar 图标&#xA;    actionBar.setDisplayShowHomeEnabled(false);&#xA;    // ActionBar LIST 模式&#xA;    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);&#xA;    actionBar.setListNavigationCallbacks(&#xA;        new ArrayAdapter&amp;lt;String&amp;gt;(MainActivity.this,&#xA;            android.R.layout.simple_list_item_1,&#xA;            android.R.id.text1, new String[]&#xA;            {&amp;quot;第一页&amp;quot;, &amp;quot;第二页&amp;quot;, &amp;quot;第三页&amp;quot;}), this);&#xA;    return true;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onOptionsItemSelected(MenuItem item) {&#xA;    // Handle action bar item clicks here. The action bar will&#xA;    // automatically handle clicks on the Home/Up button, so long&#xA;    // as you specify a parent activity in AndroidManifest.xml.&#xA;    int id = item.getItemId();&#xA;&#xA;    //noinspection SimplifiableIfStatement&#xA;    if (id == R.id.action_settings) {&#xA;        return true;&#xA;    }&#xA;&#xA;    return super.onOptionsItemSelected(item);&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onNavigationItemSelected(int itemPosition, long itemId) {&#xA;    // 获取选择&#xA;    return false;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ActionBar 自定义&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    // 自定义actionbar的布局&#xA;    setActionBarLayout(R.layout.menu);&#xA;    }&#xA;&#xA;    //&#xA;    public void setActionBarLayout(int layoutId) {&#xA;    // 获取 ActionBar&#xA;    ActionBar actionBar = getActionBar();&#xA;    if (null != actionBar) {&#xA;        // 隐藏 ActionBar 图标&#xA;        actionBar.setDisplayShowHomeEnabled(false);&#xA;        // 使自定义的普通View能在title栏显示&#xA;        actionBar.setDisplayShowCustomEnabled(true);&#xA;        // 载入 Layout&#xA;        View v = this.getLayoutInflater().inflate(layoutId, null);&#xA;        // 设置 Layout&#xA;        ActionBar.LayoutParams layout = new ActionBar.LayoutParams(ActionBar.LayoutParams.MATCH_PARENT, ActionBar.LayoutParams.MATCH_PARENT);&#xA;        // 将 Layout 赋值 ActionBar&#xA;        actionBar.setCustomView(v, layout);&#xA;    }&#xA;    }&#xA;&#xA;    public void onClick(View v) {&#xA;    switch (v.getId()) {&#xA;        case R.id.menuBtnId: {&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;        break;&#xA;        case R.id.noteBtnId: {&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;        break;&#xA;        case R.id.downloadBtnId: {&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;        break;&#xA;        case R.id.editBtnId: {&#xA;        Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        }&#xA;        break;&#xA;        default: {&#xA;        }&#xA;        break;&#xA;    }&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onCreateOptionsMenu(Menu menu) {&#xA;    // Inflate the menu; this adds items to the action bar if it is present.&#xA;    // getMenuInflater().inflate(R.menu.menu_main, menu);&#xA;    // 返回&#xA;    return true;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onOptionsItemSelected(MenuItem item) {&#xA;    // Handle action bar item clicks here. The action bar will&#xA;    // automatically handle clicks on the Home/Up button, so long&#xA;    // as you specify a parent activity in AndroidManifest.xml.&#xA;    int id = item.getItemId();&#xA;    //noinspection SimplifiableIfStatement&#xA;    if (id == R.id.action_settings) {&#xA;        return true;&#xA;    }&#xA;    return super.onOptionsItemSelected(item);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// R.layout.menu 自定义的布局文件&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;RelativeLayout&#xA;    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;63.0dp&amp;quot;&#xA;    android:id=&amp;quot;@+id/actionbarLayoutId&amp;quot;&#xA;    android:background=&amp;quot;@drawable/actionbar_background&amp;quot;&amp;gt;&#xA;    &amp;lt;ImageButton&#xA;    android:id=&amp;quot;@+id/menuBtnId&amp;quot;&#xA;    android:layout_marginLeft=&amp;quot;12.0dp&amp;quot;&#xA;    android:layout_marginTop=&amp;quot;12.0dp&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:background=&amp;quot;@drawable/menu&amp;quot;&#xA;    android:contentDescription=&amp;quot;@string/app_name&amp;quot;&#xA;    android:onClick=&amp;quot;onClick&amp;quot;&#xA;    /&amp;gt;&#xA;    &amp;lt;ImageButton &#xA;    android:id=&amp;quot;@+id/noteBtnId&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_marginTop=&amp;quot;12.0dp&amp;quot;&#xA;    android:background=&amp;quot;@drawable/notes&amp;quot;&#xA;    android:contentDescription=&amp;quot;@string/app_name&amp;quot;&#xA;    android:layout_marginRight=&amp;quot;12.0dp&amp;quot;&#xA;    android:layout_alignParentRight=&amp;quot;true&amp;quot;&#xA;    android:onClick=&amp;quot;onClick&amp;quot;&#xA;    /&amp;gt;&#xA;    &amp;lt;ImageButton &#xA;    android:id=&amp;quot;@+id/editBtnId&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_marginTop=&amp;quot;12.0dp&amp;quot;&#xA;    android:background=&amp;quot;@drawable/edit&amp;quot;&#xA;    android:layout_toLeftOf=&amp;quot;@id/noteBtnId&amp;quot;&#xA;    android:layout_marginRight=&amp;quot;12.0dp&amp;quot;&#xA;    android:contentDescription=&amp;quot;@string/app_name&amp;quot;&#xA;    android:onClick=&amp;quot;onClick&amp;quot;&#xA;    /&amp;gt;&#xA;    &amp;lt;ImageButton &#xA;    android:id=&amp;quot;@+id/downloadBtnId&amp;quot;&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_marginTop=&amp;quot;12.0dp&amp;quot;&#xA;    android:background=&amp;quot;@drawable/download&amp;quot;&#xA;    android:layout_toLeftOf=&amp;quot;@id/editBtnId&amp;quot;&#xA;    android:layout_marginRight=&amp;quot;12.0dp&amp;quot;&#xA;    android:contentDescription=&amp;quot;@string/app_name&amp;quot;&#xA;    android:onClick=&amp;quot;onClick&amp;quot;&#xA;    /&amp;gt;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Fragment使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BFragment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-11 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;备注&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Layout 占位供 Fragment 使用介绍&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当需要使用 Fragment 替换当前 View 里面某一个区域的时候&#xA;// 就需要使用一个 Layout 进行布局，并占位，然后通过 ID 进行&#xA;// Fragment 的 add 或 replace 或 rm 等操作 ...&#xA;&amp;lt;android.support.v4.widget.DrawerLayout&#xA;android:id=&amp;quot;@+id/drawer_layout&amp;quot;&#xA;android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&amp;lt;!-- The main content view --&amp;gt;&#xA;// 这个就是 Layout 占位&#xA;&amp;lt;FrameLayout&#xA;    android:id=&amp;quot;@+id/main&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;&#xA;&amp;lt;!-- The navigation drawer --&amp;gt;&#xA;&amp;lt;ListView&#xA;    android:id=&amp;quot;@+id/left_drawer&amp;quot;&#xA;    android:layout_width=&amp;quot;200dp&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_gravity=&amp;quot;start&amp;quot;&#xA;    android:background=&amp;quot;#f5f5f5f5&amp;quot;&#xA;    android:choiceMode=&amp;quot;singleChoice&amp;quot;&#xA;    android:divider=&amp;quot;#ffe0e0e0&amp;quot;&#xA;    android:dividerHeight=&amp;quot;1dp&amp;quot; /&amp;gt;&#xA;&amp;lt;/android.support.v4.widget.DrawerLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这里就是向占位的 Layout 内替换一个 Fragment (其实不是替换Layout而是替换其内部的Fragment)&#xA;FragmentTransaction transaction = getFragmentManager().beginTransaction();&#xA;transaction.replace(R.id.main,new Fragment());&#xA;transaction.commit();   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Fragment 不使用占位介绍&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 一个完整的 LinearLayout 需要被 Fragment 替换的&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:id=&amp;quot;@+id/main&amp;quot;&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:orientation=&amp;quot;horizontal&amp;quot;&#xA;    android:padding=&amp;quot;10dp&amp;quot;&amp;gt;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 直接用 Fragment 替换整个 Layout (其实不是替换Layout而是替换其内部的Fragment)&#xA;FragmentTransaction transaction = getFragmentManager().beginTransaction();&#xA;transaction.replace(R.id.main,new Fragment());&#xA;transaction.commit();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Fragment 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 对话框界面&#xA;DialogFragment&#xA;// 实现列表界面&#xA;ListFragment&#xA;// 选项设置界面&#xA;PreferenceFragment&#xA;// WebView界面&#xA;WebViewFragment&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Fragment 可以被 add 或者 rm 或 replace 到 Layout 中 ...&#xA;public class MainActivity extends Activity {&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        MyFragment fragment = new MyFragment();&#xA;        FragmentTransaction ft = getFragmentManager().beginTransaction() ;&#xA;        ft.add(R.id.framelayout, fragment);&#xA;        ft.commit() ;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 主要有三点&#xA;1，有个主(FrameLayout)供你添加或替换(Fragment)&#xA;2，有几个(Fragment)供你添加到(FrameLayout)&#xA;3，有个事件触发(Fragment)间的添加或者替换(Fragment)&#xA;&#xA;// Fragment生命周期的核心函数&#xA;// 从fragment运行起来到恢复状态(跟用户紧密相关的)有：&#xA;onAttach(Activity) &#xA;// 当Fragment关联activity时调用onAttach（Activity）。&#xA;onCreate(Bundle) &#xA;// 第一次创建Fragment的时候调用onCreate（Bundle）。&#xA;onCreateView(LayoutInflater, ViewGroup, Bundle) &#xA;// 创建一个跟Fragment关联的视图层级。&#xA;onActivityCreated(Bundle) &#xA;// 函数告诉Fragment跟它关联的activity已经完成Activity.onCreaate。&#xA;onStart() &#xA;// 函数可以让用户看见Fragment（条件是Activity已经启动）。&#xA;onResume() &#xA;// 使Fragment跟用户交互（条件是Activity已经恢复了）&#xA;// 当一个Fragment不再使用，它必须经历一系列反向回调：&#xA;onPause() &#xA;// 不论因为Activity被暂停或者Fragment的操作正在修改导致Fragment不再和用户交互。&#xA;onStop() &#xA;// 不论因为Activity已经停止或者Fragment的操作正在修改导致用户不能看见Fragment。&#xA;onDestroyView() &#xA;// Fragment清理和它关联的View的资源。&#xA;onDestroy()&#xA;// 清理Fragment的状态。&#xA;onDetach()&#xA;// 在Fragment不再和Activity关联之前调用onDetach()。    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 一，主(FrameLayout)&#xA;// activity_main.xml&#xA;&amp;lt;FrameLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:id=&amp;quot;@+id/container&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    tools:context=&amp;quot;.MainActivity&amp;quot; tools:ignore=&amp;quot;MergeRootFrame&amp;quot; &amp;gt;&#xA;&#xA;    // 这个主(FrameLayout)已经有个内置的(Fragment)了&#xA;    &amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    tools:context=&amp;quot;.MainActivity$PlaceholderFragment&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;Button&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;New Button&amp;quot;&#xA;        android:id=&amp;quot;@+id/button&amp;quot;&#xA;        android:layout_below=&amp;quot;@+id/textView&amp;quot;&#xA;        android:layout_alignParentLeft=&amp;quot;true&amp;quot;&#xA;        android:layout_marginTop=&amp;quot;173dp&amp;quot; /&amp;gt;&#xA;&#xA;    &amp;lt;/RelativeLayout&amp;gt;&#xA;&#xA;&amp;lt;/FrameLayout&amp;gt;&#xA;&#xA;// 二，主类&#xA;// MainActivity.class&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    // 这里将一个(Fragment)添加到(FrameLayout)中&#xA;    if (savedInstanceState == null) {&#xA;        getFragmentManager().beginTransaction()&#xA;            // 添加&#xA;            .add(R.id.container, new PlaceholderFragment())&#xA;            .commit();&#xA;    }&#xA;    Button button = (Button) findViewById(R.id.button);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        // Bundle 存值&#xA;        Bundle bundle = new Bundle();&#xA;        bundle.putString(&amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;);&#xA;        // Fragment 对象&#xA;        Fragment fr = new Fragment1();&#xA;        // 保存&#xA;        fr.setArguments(bundle);&#xA;        // 这里将一个(Fragment)替换到(FrameLayout)中的(Fragment)&#xA;        getFragmentManager().beginTransaction()&#xA;            // 替换&#xA;            .replace(R.id.container, fr)&#xA;            .commit();&#xA;        }&#xA;    });&#xA;    }&#xA;&#xA;    // 创建了一个(Fragment)并返回(Fragment)的(xLayout)&#xA;    public static class PlaceholderFragment extends Fragment {&#xA;&#xA;    public PlaceholderFragment() {&#xA;    }&#xA;&#xA;    @Override&#xA;    public View onCreateView(LayoutInflater inflater, ViewGroup container,&#xA;                 Bundle savedInstanceState) {&#xA;        View rootView = inflater.inflate(R.layout.fragment_main, container, false);&#xA;        return rootView;&#xA;    }&#xA;    }&#xA;&#xA;   // 创建了一个(Fragment)并返回(Fragment)的(Layout)&#xA;   public static class Fragment1 extends Fragment {&#xA;&#xA;    public Fragment1() {&#xA;    }&#xA;&#xA;    String val;&#xA;    Button button;&#xA;&#xA;    @Override&#xA;    public View onCreateView(LayoutInflater inflater, ViewGroup container,&#xA;                 Bundle savedInstanceState) {&#xA;        // 获取传过来的值&#xA;        val  = getArguments().getString(&amp;quot;key&amp;quot;);&#xA;        Log.i(&amp;quot;info&amp;quot;, val);&#xA;        // 初始化 View&#xA;        View rootView = inflater.inflate(R.layout.fragment, container, false);&#xA;        // 获取 Button&#xA;        button = (Button) rootView.findViewById(R.id.button2);&#xA;        // 监听 Button 事件&#xA;        button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;            // 将值设置为按钮名&#xA;            button.setText(val);&#xA;        }&#xA;        });&#xA;&#xA;        return rootView;&#xA;    }&#xA;    }&#xA;&#xA;// 三，两个(Layout)&#xA;// fragment.xml&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;Switch&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:text=&amp;quot;New Switch&amp;quot;&#xA;    android:id=&amp;quot;@+id/switch1&amp;quot; /&amp;gt;&#xA;&#xA;    // 加个按钮，上面演示了如何使用该按钮&#xA;    &amp;lt;Button&#xA;    android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:text=&amp;quot;New Button&amp;quot;&#xA;    android:id=&amp;quot;@+id/button2&amp;quot; /&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;// fragment_main.xml&#xA;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    tools:context=&amp;quot;.MainActivity$PlaceholderFragment&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;TextView android:text=&amp;quot;@string/hello_world&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:id=&amp;quot;@+id/textView&amp;quot; /&amp;gt;&#xA;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;ListFragment 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FragmentManager 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FragmentTransaction 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;FragmentManager能够实现管理activity中fragment. 通过调用activity的getFragmentManager()取得它的实例.&#xA;FragmentManager可以做如下一些事情:&#xA;    1、使用findFragmentById() (用于在activity layout中提供一个UI的fragment)或findFragmentByTag()&#xA;       (适用于有或没有UI的fragment)获取activity中存在的fragment&#xA;    2、将fragment从后台堆栈中弹出, 使用 popBackStack() (模拟用户按下BACK 命令).&#xA;    3、使用addOnBackStackChangeListener()注册一个监听后台堆栈变化的listener.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// FragmentTransaction：&#xA;// FragmentTransaction对fragment进行添加,移除,替换,以及执行其他动作。&#xA;// 从 FragmentManager 获得一个FragmentTransaction的实例 :&#xA;FragmentManager fragmentManager = getFragmentManager(); &#xA;FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();&#xA;&#xA;// 每一个事务都是同时要执行的一套变化.可以在一个给定的事务中设置你想执行的所有变化&#xA;// 使用诸如 add(), remove(), 和 replace().然后, 要给activity应用事务, 必须调用 commit().&#xA;// 在调用commit()之前, 你可能想调用 addToBackStack(),将事务添加到一个fragment事务的back stack.&#xA;//  这个back stack由activity管理, 并允许用户通过按下 BACK 按键返回到前一个fragment状态.&#xA;&#xA;// Create new fragment and transaction  &#xA;Fragment newFragment = new ExampleFragment();  &#xA;FragmentTransaction transaction = getFragmentManager().beginTransaction();  &#xA;// Replace whatever is in the fragment_container view with this fragment,  &#xA;// and add the transaction to the back stack  &#xA;transaction.replace(R.id.fragment_container, newFragment);  &#xA;transaction.addToBackStack(null);  &#xA;// Commit the transaction  &#xA;transaction.commit();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;FragmentManager（碎片管理器），用来管理当前Activity中所有的Fragment&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;每次替换或者添加后，都要commit一样，才能算一个完整的事务，这里用了Fragment嵌套&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你是嵌套了Fragment，那么使用FragmentManager的一定要注意你当前的Fragment是属于嵌套的还是顶层的Fragment&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果是顶层Fragment，那么你调用FragmentManager的时候，应该这样写getActivity().getSupportFragmentManager()&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果是嵌套的fragment那么应该这样写getChildFragmentManager()&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// activity_main.xml&#xA;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:orientation=&amp;quot;horizontal&amp;quot;&#xA;    tools:context=&amp;quot;.MainActivity&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;    android:id=&amp;quot;@+id/left&amp;quot;&#xA;    android:layout_width=&amp;quot;0dp&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_weight=&amp;quot;1&amp;quot;&#xA;    android:background=&amp;quot;#CCCCCC&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;&#xA;&#xA;    &amp;lt;Button&#xA;        android:id=&amp;quot;@+id/button&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;显示列表&amp;quot; /&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;    android:id=&amp;quot;@+id/center&amp;quot;&#xA;    android:layout_width=&amp;quot;0dp&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_weight=&amp;quot;2&amp;quot;&#xA;    android:background=&amp;quot;#CCDDFF&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;&amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    private Button button;&#xA;    private FragmentManager manager;&#xA;    private FragmentTransaction transaction;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;&#xA;    manager = getFragmentManager();&#xA;&#xA;    button = (Button) findViewById(R.id.button);&#xA;    /**&#xA;     * 点击Activity中的该按钮，Activity会在布局中间添加ArticleListFragment，并显示列表数据。&#xA;     */&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        transaction = manager.beginTransaction();&#xA;        ArticleListFragment articleListFragment = new ArticleListFragment();&#xA;        Bundle a = new Bundle();&#xA;        a.putString(&amp;quot;key&amp;quot;, &amp;quot;center&amp;quot;);&#xA;        articleListFragment.setArguments(a);&#xA;        transaction.add(R.id.center, articleListFragment, &amp;quot;center&amp;quot;);&#xA;        transaction.commit();&#xA;        }&#xA;    });&#xA;    }&#xA;}&#xA;&#xA;// ListFragment&#xA;public class ArticleListFragment extends ListFragment {&#xA;&#xA;    private ArrayAdapter&amp;lt;String&amp;gt; adapter;&#xA;    private List&amp;lt;String&amp;gt; data;&#xA;    private FragmentManager manager;&#xA;    private FragmentTransaction transaction;&#xA;&#xA;    @Override&#xA;    public void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    String k = (String) getArguments().get(&amp;quot;key&amp;quot;);&#xA;    data = new ArrayList&amp;lt;String&amp;gt;();&#xA;    for (int i = 0; i &amp;lt; 30; i++) {&#xA;        data.add(k + i);&#xA;    }&#xA;    manager = getFragmentManager();&#xA;    adapter = new ArrayAdapter&amp;lt;String&amp;gt;(getActivity(),&#xA;        android.R.layout.simple_list_item_1, data);&#xA;    // 设置一个 Adapter&#xA;    setListAdapter(adapter);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onListItemClick(ListView l, View v, int position, long id) {&#xA;    super.onListItemClick(l, v, position, id);&#xA;    // 获取单机的 Item&#xA;    String str = adapter.getItem(position);&#xA;    // 从 FragmentManager 获得一个FragmentTransaction的实例 :&#xA;    // FragmentManager fragmentManager = getFragmentManager();&#xA;    // FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();&#xA;    // transaction.add(); transaction.replace(); transaction.remove();&#xA;    transaction = manager.beginTransaction();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之监听返回键用法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8B%E7%9B%91%E5%90%AC%E8%BF%94%E5%9B%9E%E9%94%AE%E7%94%A8%E6%B3%95/</link>
      <pubDate>2015-03-10 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;主要是实现onKeyDown函数，并且判断KeyEvent.KEYCODE_BACK即可&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    @Override&#xA;    public boolean onKeyDown(int keyCode, KeyEvent event)&#xA;    {&#xA;    if (keyCode == KeyEvent.KEYCODE_BACK )&#xA;    {&#xA;        // 创建退出对话框&#xA;        final AlertDialog.Builder isExit = new AlertDialog.Builder(this)&#xA;        // 设置对话框标题&#xA;        .setTitle(&amp;quot;系统提示&amp;quot;)&#xA;        // 设置对话框消息&#xA;        .setMessage(&amp;quot;确定要退出吗?&amp;quot;);&#xA;        // 添加一个按钮，并监听按钮事件 (积极的;确实的)&#xA;        isExit.setPositiveButton(&amp;quot;确定&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;            // 关闭, 自定义 exitActivity() 方法&#xA;                    AgentApplication.exitActivity();&#xA;        }&#xA;        });&#xA;        // 添加一个按钮，并监听按钮事件 (消极的;否认的)&#xA;        isExit.setNegativeButton(&amp;quot;取消&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;            // 关闭&#xA;            return;&#xA;        }&#xA;        });&#xA;        // 显示对话框&#xA;        isExit.create().show();&#xA;    }&#xA;&#xA;    return false;&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;完美关闭程序，需要记录所有 Activity 统一关闭&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 保存着所有 Activity 关闭时，统一释放&#xA;public class AgentApplication extends Application {&#xA;&#xA;    private static List&amp;lt;Activity&amp;gt; activities = new ArrayList&amp;lt;Activity&amp;gt;();&#xA;&#xA;    public static void addActivity(Activity activity) {&#xA;    activities.add(activity);&#xA;    }&#xA;&#xA;    public static void exitActivity() {&#xA;    for (Activity activity : activities) {&#xA;        activity.finish();&#xA;    }&#xA;    System.exit(0);&#xA;    }&#xA;&#xA;}&#xA;&#xA;// 一个 Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    // 这里，每个 Activity onCreate 都要添加&#xA;    AgentApplication.addActivity(this);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;OnkeyDown 和 OnBackPressed 介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// OnkeyDown事件和OnkeyUp事件是不同事件。 &#xA;// OnBackPressed方法会处理返回键的操作，不会向上传播&#xA;// 如果你想向上传播 请使用OnkeyDown事件或OnkeyUp事件&#xA;@Override&#xA;public void onBackPressed() {&#xA;    super.onBackPressed();&#xA;}&#xA;&#xA;// ...&#xA;@Override&#xA;public boolean onKeyDown(int keyCode, KeyEvent event) {&#xA;    return false;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之SubMenu和PopupMenu菜单的使用</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BSubMenu%E5%92%8CPopupMenu%E8%8F%9C%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2015-03-10 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;选项菜单 SubMenu&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onCreateOptionsMenu(Menu menu) {&#xA;    // 普通菜单&#xA;    menu.add(0, 0x101, 0, &amp;quot;普通菜单&amp;quot;);&#xA;    // 包含子菜单&#xA;    SubMenu fontMenu = menu.addSubMenu(&amp;quot;字体大小&amp;quot;);&#xA;    fontMenu.setHeaderTitle(&amp;quot;请选择字体大小&amp;quot;);&#xA;    fontMenu.setIcon(R.mipmap.ic_launcher);&#xA;    fontMenu.setHeaderIcon(R.mipmap.ic_launcher);&#xA;    fontMenu.add(0, 0x111, 0, &amp;quot;10 号字体&amp;quot;);&#xA;    fontMenu.add(0, 0x112, 0, &amp;quot;11 号字体&amp;quot;);&#xA;    // 为菜单项目添加关联的 Activity&#xA;    MenuItem item = fontMenu.add(0, 0x113, 0, &amp;quot;12 号字体&amp;quot;);&#xA;    item.setIntent(new Intent(MainActivity.this, GestureActivity.class));&#xA;    // Inflate the menu; this adds items to the action bar if it is present.&#xA;    getMenuInflater().inflate(R.menu.menu_main, menu);&#xA;    return true;&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean onOptionsItemSelected(MenuItem item) {&#xA;    // Handle action bar item clicks here. The action bar will&#xA;    // automatically handle clicks on the Home/Up button, so long&#xA;    // as you specify a parent activity in AndroidManifest.xml.&#xA;    int id = item.getItemId();&#xA;&#xA;    //noinspection SimplifiableIfStatement&#xA;    if (id == R.id.action_settings) {&#xA;        return true;&#xA;    }&#xA;&#xA;    // 判断单机的是那一个菜单&#xA;    switch (id)&#xA;    {&#xA;        case 0x101:&#xA;        Toast.makeText(MainActivity.this, &amp;quot;您选择了(普通菜单)&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        // 也可以判断单机的是哪一个菜单，来 Intent 到另一个 Activity&#xA;        Intent intent = new Intent(MainActivity.this, GestureActivity.class);&#xA;        startActivity(intent);&#xA;        break;&#xA;        case 0x111:&#xA;        Toast.makeText(MainActivity.this, &amp;quot;您选择了(10 号字体)&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        break;&#xA;        case 0x112:&#xA;        Toast.makeText(MainActivity.this, &amp;quot;您选择了(11 号字体)&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        break;&#xA;        case 0x113:&#xA;        Toast.makeText(MainActivity.this, &amp;quot;您选择了(12 号字体)&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;        break;&#xA;    }&#xA;&#xA;    return super.onOptionsItemSelected(item);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;PopupMenu 创建弹出式菜单&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 加个按钮，用于触发 show(View v)&#xA;&amp;lt;Button&#xA;android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;android:text=&amp;quot;Go&amp;quot;&#xA;android:id=&amp;quot;@+id/button9&amp;quot;&#xA;android:onClick=&amp;quot;show&amp;quot;&#xA;android:layout_alignParentTop=&amp;quot;true&amp;quot;&#xA;android:layout_centerHorizontal=&amp;quot;true&amp;quot; /&amp;gt;&#xA;&#xA;// R.menu.menu_control&#xA;&amp;lt;menu xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&#xA;    tools:context=&amp;quot;com.example.nljb.nljb.ControlActivity&amp;quot;&amp;gt;&#xA;    &amp;lt;item&#xA;    android:id=&amp;quot;@+id/open&amp;quot;&#xA;    android:orderInCategory=&amp;quot;100&amp;quot;&#xA;    android:showAsAction=&amp;quot;never&amp;quot;&#xA;    android:title=&amp;quot;打开&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;item&#xA;    android:id=&amp;quot;@+id/close&amp;quot;&#xA;    android:orderInCategory=&amp;quot;100&amp;quot;&#xA;    android:showAsAction=&amp;quot;never&amp;quot;&#xA;    android:title=&amp;quot;关闭&amp;quot;/&amp;gt;&#xA;&amp;lt;/menu&amp;gt;&#xA;&#xA;// Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    View root;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    }&#xA;&#xA;    // PopupMenu 函数&#xA;    public void show(View v)&#xA;    {&#xA;    PopupMenu pop = new PopupMenu(MainActivity.this, v);&#xA;    // 加载一个 R.menu.menu_control &#xA;    pop.getMenuInflater().inflate(R.menu.menu_control, pop.getMenu());&#xA;    pop.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {&#xA;        public boolean onMenuItemClick(MenuItem item) {&#xA;        switch (item.getItemId())&#xA;        {&#xA;            // 通过按钮ID来判断点击&#xA;            case R.id.open:&#xA;            Toast.makeText(MainActivity.this, &amp;quot;Clicked popup menu item open&amp;quot; + item.getTitle(),&#xA;                Toast.LENGTH_SHORT).show();&#xA;            break;&#xA;            // 通过按钮ID来判断点击&#xA;            case R.id.close:&#xA;            Toast.makeText(MainActivity.this, &amp;quot;Clicked popup menu item close&amp;quot; + item.getTitle(),&#xA;                Toast.LENGTH_SHORT).show();&#xA;            break;&#xA;        }&#xA;&#xA;        return true;&#xA;        }&#xA;    });&#xA;    pop.show();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Activity间数据传递</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BActivity%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</link>
      <pubDate>2015-03-09 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;Activity间数据传递&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Activity 生命周期介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;活动状态，当前Activity位于前台，用户可见，可以获得焦点&#xA;暂停状态，其它Activity位于前台，该Activity依然可见，只是不能获得焦点&#xA;停止状态，该Activity不可见，失去焦点&#xA;销毁状态，该Activity结束，或Activity所在的Dalvik进程被结束&#xA;&#xA;// 创建 Activity 时被回调，该方法只会被调用一次&#xA;onCreate(Bundle savedStatus)&#xA;// 启动 Activity 时被回调&#xA;onStart()&#xA;// 重新启动 Activity 时被回调&#xA;onRestart()&#xA;// 恢复 Activity 时被回调，onStart() 方法后一定会回调 onResume() 方法&#xA;onResume()&#xA;// 暂停 Activity 时被回调&#xA;onPause()&#xA;// 停止 Activity 时被回调&#xA;onStop()&#xA;// 销毁 Activity 时被回调，该方法只会被调用一次&#xA;onDestroy()&#xA;&#xA;@Override&#xA;public void onPause()&#xA;{&#xA;    super.onPause();&#xA;}&#xA;&#xA;@Override&#xA;public void onStart()&#xA;{&#xA;    super.onStart();&#xA;}&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Result 的相关介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 启动一个 Activity 并且设置它的 requestCode&#xA;startActivityForResult -&amp;gt; requestCode&#xA;&#xA;// 在 Activity 关闭前设置一个返回状态 resultCode&#xA;setResult -&amp;gt; resultCode&#xA;&#xA;// 监听 Activity 的返回的 requestCode 和 resultCode 与 intent&#xA;onActivityResult -&amp;gt; requestCode -&amp;gt; resultCode -&amp;gt; intent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;补充关于传递一个类&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 方法一&#xA;public class User implements Serializable {&#xA;     private String username;&#xA;}&#xA;&#xA;User user = new User();&#xA;user.username = &amp;quot;root&amp;quot;;&#xA;&#xA;Intent intent = new Intent(LoginActivity.this, MyNavigationDrawer.class);&#xA;intent.putExtra(&amp;quot;USER_INFO&amp;quot;, (Serializable) user);&#xA;startActivity(intent);&#xA;&#xA;Intent intent = getIntent();&#xA;User user = (User) intent.getSerializableExtra(&amp;quot;USER_INFO&amp;quot;);&#xA;Log.i(&amp;quot;INFO&amp;quot;, user.getUsername());&#xA;&#xA;// 方法二&#xA;Intent intent = new Intent(A.this, B.class);&#xA;Person person = new Person();&#xA;Bundle bundle = new Bundle()&#xA;bundle.putString(“name”, “baidu”);&#xA;bundle.putSerializable(“person”, person);&#xA;…&#xA;intent.putExtras(bundle);&#xA;startActivity(intent)&#xA;&#xA;// bundle传递数据大于0.5M会抛出传输数据过大异常；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;将数据传递到下一个，Activity&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 发送端的 Activity&#xA;public class MainActivity extends Activity {&#xA;&#xA;    View root;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    Button button = (Button) findViewById(R.id.button);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        send();&#xA;        }&#xA;    });&#xA;    }&#xA;&#xA;    public void send()&#xA;    {&#xA;    // 获取一个 View&#xA;    root = this.getLayoutInflater().inflate(R.layout.activity_control, null);&#xA;    // .......&#xA;    AlertDialog.Builder builder = new AlertDialog.Builder(this)&#xA;        // 对话框标题&#xA;        .setTitle(&amp;quot;简单对话框&amp;quot;)&#xA;        // 对话框图标&#xA;        .setIcon(R.mipmap.ic_launcher);&#xA;        // 对话框内容&#xA;        // .setMessage(&amp;quot;对话框内容.&amp;quot;);&#xA;    // 添加一个按钮，并监听按钮事件 (积极的;确实的)&#xA;    builder.setPositiveButton(&amp;quot;确定&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;        /*&#xA;            这里简单介绍一下&#xA;            创建一个AlertDialog对话框&#xA;            创建一个，确定按钮，并且监听事件&#xA;            点击按钮时，将一个对象（可以是一个obj或int,string,bool等)传递出去&#xA;        */&#xA;        EditText edit = (EditText) root.findViewById(R.id.editText);&#xA;        EditText edit2 = (EditText) root.findViewById(R.id.editText2);&#xA;        Bundle data = new Bundle();&#xA;        data.putString(&amp;quot;username&amp;quot;, edit.getText().toString());&#xA;        data.putString(&amp;quot;password&amp;quot;, edit2.getText().toString());&#xA;        /*&#xA;            // 同样，Bundle 也可以传递一个类，比如&#xA;            Person person = new Person(&amp;quot;name&amp;quot;, &amp;quot;pass&amp;quot; ,&amp;quot;...&amp;quot;);&#xA;            data.putSerializable(&amp;quot;person&amp;quot;, person);&#xA;            // 取出时这样就可以&#xA;            Intent intent = getIntent();&#xA;            Person person = (Person) intent.getSerializableExtra(&amp;quot;person&amp;quot;);&#xA;         */&#xA;        Intent intent = new Intent(MainActivity.this, BundleActivity.class);&#xA;        intent.putExtras(data);&#xA;        startActivity(intent);&#xA;        }&#xA;    });&#xA;    // 可以设置 View&#xA;    builder.setView(root);&#xA;    // 创建及显示&#xA;    builder.create().show();&#xA;    // .......&#xA;    }&#xA;&#xA;}&#xA;&#xA;&#xA;// 接收端&#xA;public class BundleActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    /*&#xA;        通过 getIntent() 获取发送的 intent&#xA;        就可以通过，intent 取值了&#xA;    */&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_bundle);&#xA;    TextView text = (TextView) findViewById(R.id.xxx);&#xA;    Intent intent = getIntent();&#xA;    text.setText(intent.getStringExtra(&amp;quot;username&amp;quot;));&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;将数据返回到上一个 Activit&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这里负责启动一个 Activit 并接收其返回的数据&#xA;public class MainActivity extends Activity {&#xA;&#xA;    View root;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    Button button = (Button) findViewById(R.id.button);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        send();&#xA;        }&#xA;    });&#xA;    }&#xA;&#xA;    public void send()&#xA;    {&#xA;    // 获取一个 View&#xA;    root = this.getLayoutInflater().inflate(R.layout.activity_control, null);&#xA;    // .......&#xA;    AlertDialog.Builder builder = new AlertDialog.Builder(this)&#xA;        // 对话框标题&#xA;        .setTitle(&amp;quot;简单对话框&amp;quot;)&#xA;        // 对话框图标&#xA;        .setIcon(R.mipmap.ic_launcher);&#xA;        // 对话框内容&#xA;        // .setMessage(&amp;quot;对话框内容.&amp;quot;);&#xA;    // 添加一个按钮，并监听按钮事件 (消极的;否认的)&#xA;    builder.setNegativeButton(&amp;quot;取消&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;        // 创建 Intent&#xA;        Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;        // 以需要返回数据的模式启动该 Activity&#xA;        // 并传递(请求码)&#xA;        startActivityForResult(intent, 0);&#xA;        }&#xA;    });&#xA;    // 可以设置 View&#xA;    builder.setView(root);&#xA;    // 创建及显示&#xA;    builder.create().show();&#xA;    // .......&#xA;    }&#xA;&#xA;    // 上一个 Activity 返回时触发此方法&#xA;    @Override&#xA;    public void onActivityResult(int requestCode, int resultCode, Intent intent)&#xA;    {&#xA;    // 判断请求码与返回码&#xA;    if (requestCode == 0 &amp;amp;&amp;amp; resultCode == 0)&#xA;    {&#xA;        // 获取 Bundle&#xA;        Bundle data = intent.getExtras();&#xA;        // 通过 Key 获取 Value&#xA;        String resultCity = data.getString(&amp;quot;city&amp;quot;);&#xA;        // 获取 View 对象&#xA;        TextView text = (TextView) findViewById(R.id.show);&#xA;        // 设置对象值&#xA;        text.setText(resultCity);&#xA;    }&#xA;    }&#xA;&#xA;}&#xA;&#xA;&#xA;// 这里就是被启动的 Activit , 并且在退出时返回数据&#xA;public class ControlActivity extends Activity {&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_control);&#xA;    // 获取 Intent&#xA;    Intent intent = getIntent();&#xA;    // 保存需要返回的数据&#xA;    // 当然，返回可以是一个（类，或者 int, string, bool ...)&#xA;    intent.putExtra(&amp;quot;city&amp;quot;, &amp;quot;Google&amp;quot;);&#xA;    // 返回，并且设置(返回码)&#xA;    this.setResult(0, intent);&#xA;    // 关闭&#xA;    this.finish();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Activity切换效果</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BActivity%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C/</link>
      <pubDate>2015-03-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Android开发过程中，经常会碰到Activity之间的切换效果的问题&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面介绍一下如何实现左右滑动的切换效果，首先了解一下Activity切换的实现&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从Android2.0开始在Activity增加了一个方法：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void overridePendingTransition (int enterAnim, int exitAnim)&#xA;&#xA;// 其中：&#xA;// enterAnim 定义Activity进入屏幕时的动画&#xA;// exitAnim 定义Activity退出屏幕时的动画&#xA;// overridePendingTransition 方法必须在startActivity()或者 finish()方法的后面。&#xA;&#xA;// 如果想关闭切换效果，只需要:&#xA;overridePendingTransition(0, 0)&#xA;// 还有个问题是，当用户点击返回键的时候&#xA;// 系统会自动调用默认动画，返回到上一个Activity&#xA;// 看了一些APP的解决办法是，拦截返回键事件，弹出窗口来处理&#xA;// 窗口可以选择，是否需要退出，或者，是否需要返回上一级Activity&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之GestureDetector手势检测</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BGestureDetector%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B/</link>
      <pubDate>2015-03-07 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;GestureDetector 实例代表了一个手势检测器&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;也就是,在Activity中将onTouchEvent事件交给GestureDetector检测&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这里注意，要 implements GestureDetector.OnGestureListener 来实现一些动作方法&#xA;public class MainActivity extends Activity implements GestureDetector.OnGestureListener {&#xA;&#xA;    View root;&#xA;&#xA;    GestureDetector detector;&#xA;&#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.activity_main);&#xA;    detector = new GestureDetector(this, (GestureDetector.OnGestureListener) this);&#xA;    Button button = (Button) findViewById(R.id.button);&#xA;    button.setOnClickListener(new View.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(View v) {&#xA;        send();&#xA;        }&#xA;    });&#xA;    }&#xA;&#xA;    // 这里，一定要把 onTouchEvent 交给 detector.onTouchEvent &#xA;    @Override&#xA;    public boolean onTouchEvent(MotionEvent me)&#xA;    {&#xA;    return detector.onTouchEvent(me);&#xA;    }&#xA;&#xA;    // 当触碰事件按下时触发该方法&#xA;    @Override&#xA;    public boolean onDown(MotionEvent e) {&#xA;    Log.i(&amp;quot;info&amp;quot;, &amp;quot;onDown&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // 当用户在触摸屏上按下，而且还未移动和松开时触发该方法&#xA;    @Override&#xA;    public void onShowPress(MotionEvent e) {&#xA;    Log.i(&amp;quot;info&amp;quot;, &amp;quot;onShowPress&amp;quot;);&#xA;    }&#xA;&#xA;    // 用户在触摸屏上的轻击事件将会触发该方法&#xA;    @Override&#xA;    public boolean onSingleTapUp(MotionEvent e) {&#xA;    Log.i(&amp;quot;info&amp;quot;, &amp;quot;onSingleTapUp&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // 当初始按下动作事件和当前移动动作事件倒置滚动时通知本方法&#xA;    @Override&#xA;    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {&#xA;    Log.i(&amp;quot;info&amp;quot;, &amp;quot;onScroll&amp;quot;);&#xA;    return false;&#xA;    }&#xA;&#xA;    // 初始化并按下触发长安并通知本方法&#xA;    @Override&#xA;    public void onLongPress(MotionEvent e) {&#xA;    Log.i(&amp;quot;info&amp;quot;, &amp;quot;onLongPress&amp;quot;);&#xA;    }&#xA;&#xA;    // 屏幕手势滑动中&#xA;    @Override&#xA;    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {&#xA;    Log.i(&amp;quot;info&amp;quot;, &amp;quot;onFling&amp;quot;);&#xA;    // Y 方向&#xA;    if (e2.getY() - e1.getY() &amp;gt; 50)  // 从上向下滑动&#xA;    {&#xA;        // ...&#xA;    } else if (e1.getY() - e2.getY() &amp;gt; 50) // 从下向上滑动&#xA;    {&#xA;        // ...&#xA;    }&#xA;    // X 方向&#xA;    if (e1.getX() - e2.getX() &amp;gt; 50) // 从右向左滑动&#xA;    {&#xA;        // ...&#xA;    } else if (e2.getX() - e1.getX() &amp;gt; 50) // 从左向右滑动&#xA;    {&#xA;        // ...&#xA;    }&#xA;    return false;&#xA;    }&#xA;&#xA;    public void send()&#xA;    {&#xA;    // 获取一个 View&#xA;    root = this.getLayoutInflater().inflate(R.layout.activity_control, null);&#xA;    // .......&#xA;    AlertDialog.Builder builder = new AlertDialog.Builder(this)&#xA;        // 对话框标题&#xA;        .setTitle(&amp;quot;简单对话框&amp;quot;)&#xA;        // 对话框图标&#xA;        .setIcon(R.mipmap.ic_launcher);&#xA;        // 对话框内容&#xA;        // .setMessage(&amp;quot;对话框内容.&amp;quot;);&#xA;    // 添加一个按钮，并监听按钮事件 (积极的;确实的)&#xA;    builder.setPositiveButton(&amp;quot;确定&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;        EditText edit = (EditText) root.findViewById(R.id.editText);&#xA;        EditText edit2 = (EditText) root.findViewById(R.id.editText2);&#xA;        Log.i(&amp;quot;info&amp;quot;, edit.getText().toString());&#xA;        Log.i(&amp;quot;info&amp;quot;, edit2.getText().toString());&#xA;        }&#xA;    });&#xA;    // 添加一个按钮，并监听按钮事件 (消极的;否认的)&#xA;    builder.setNegativeButton(&amp;quot;取消&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;        Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;        startActivity(intent);&#xA;        }&#xA;    });&#xA;    // 可以设置 View&#xA;    builder.setView(root);&#xA;    // 创建及显示&#xA;    builder.create().show();&#xA;    // .......&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之AlertDialog使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BAlertDialog%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-07 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;什么是AlertDialog?什么是AlertDialog.Builder?&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;AlertDialog是Dialog的一个直接子类&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个AlertDialog可以有两个Button或者3个Button&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以对一个AlertDialog设置title、message。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不能直接通过AlertDialog的构造函数来生成一个AlertDialog&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般生成的时候都是通过它的的一个内部静态类AlertDialog.Builder来构造的。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void send()&#xA;{&#xA;// ....... 构造一个 AlertDialog&#xA;AlertDialog.Builder builder = new AlertDialog.Builder(this)&#xA;    // 对话框标题&#xA;    .setTitle(&amp;quot;简单对话框&amp;quot;)&#xA;    // 对话框图标&#xA;    .setIcon(R.mipmap.ic_launcher);&#xA;    // 对话框内容&#xA;    // .setMessage(&amp;quot;对话框内容.&amp;quot;);&#xA;// 添加一个按钮，并监听按钮事件 (积极的;确实的)&#xA;builder.setPositiveButton(&amp;quot;确定&amp;quot;, new DialogInterface.OnClickListener() {&#xA;    @Override&#xA;    public void onClick(DialogInterface dialog, int which) {&#xA;    Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;    startActivity(intent);&#xA;    }&#xA;});&#xA;// 添加一个按钮，并监听按钮事件 (消极的;否认的)&#xA;builder.setNegativeButton(&amp;quot;取消&amp;quot;, new DialogInterface.OnClickListener() {&#xA;    @Override&#xA;    public void onClick(DialogInterface dialog, int which) {&#xA;    Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;    startActivity(intent);&#xA;    }&#xA;});&#xA;// 添加一个按钮，并监听按钮事件 (中立的)&#xA;builder.setNeutralButton(&amp;quot;帮助&amp;quot;, new DialogInterface.OnClickListener() {&#xA;    @Override&#xA;    public void onClick(DialogInterface dialog, int which) {&#xA;    Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;    startActivity(intent);&#xA;    }&#xA;});&#xA;// 列表&#xA;CharSequence chars[] = {&amp;quot;hello&amp;quot;, &amp;quot;wrold&amp;quot;};&#xA;// 列表项目对话框&#xA;builder.setItems(chars, new DialogInterface.OnClickListener() {&#xA;    @Override&#xA;    public void onClick(DialogInterface dialog, int which) {&#xA;    // 点击了第几列&#xA;    Log.i(&amp;quot;info&amp;quot;, String.valueOf(which));&#xA;    // ... 动作&#xA;    Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;    startActivity(intent);&#xA;    }&#xA;});&#xA;// 单选按钮&#xA;builder.setSingleChoiceItems(chars, 0, new DialogInterface.OnClickListener() {&#xA;    @Override&#xA;    public void onClick(DialogInterface dialog, int which) {&#xA;    // 点击了第几列&#xA;    Log.i(&amp;quot;info&amp;quot;, String.valueOf(which));&#xA;    // ... 动作&#xA;    Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;    startActivity(intent);&#xA;    }&#xA;});&#xA;boolean m_boolean[] = {false, false};&#xA;// 多选按钮&#xA;builder.setMultiChoiceItems(chars, m_boolean, new DialogInterface.OnMultiChoiceClickListener() {&#xA;    @Override&#xA;    public void onClick(DialogInterface dialog, int which, boolean isChecked) {&#xA;    // 获取点击事件，并进行记录&#xA;    Log.i(&amp;quot;info&amp;quot;, String.valueOf(which) + &amp;quot; &amp;quot; + String.valueOf(isChecked));&#xA;    }&#xA;});&#xA;// 获取一个 View&#xA;// View root = this.getLayoutInflater().inflate(R.layout.activity_control, null);&#xA;// 可以设置 View&#xA;// builder.setView(root);&#xA;// 创建及显示&#xA;builder.create().show();&#xA;// .......&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;自定义 AlertDialog&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {&#xA;&#xA;    // 全局 View &#xA;    View root;&#xA;&#xA;    public void send()&#xA;    {&#xA;    // 获取一个 View&#xA;    root = this.getLayoutInflater().inflate(R.layout.activity_control, null);&#xA;    // .......&#xA;    AlertDialog.Builder builder = new AlertDialog.Builder(this)&#xA;        // 对话框标题&#xA;        .setTitle(&amp;quot;简单对话框&amp;quot;)&#xA;        // 对话框图标&#xA;        .setIcon(R.mipmap.ic_launcher);&#xA;        // 对话框内容&#xA;        // .setMessage(&amp;quot;对话框内容.&amp;quot;);&#xA;    // 添加一个按钮，并监听按钮事件 (积极的;确实的)&#xA;    builder.setPositiveButton(&amp;quot;确定&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;        // 获取结果&#xA;        EditText edit = (EditText) root.findViewById(R.id.editText);&#xA;        EditText edit2 = (EditText) root.findViewById(R.id.editText2);&#xA;        Log.i(&amp;quot;info&amp;quot;, edit.getText().toString());&#xA;        Log.i(&amp;quot;info&amp;quot;, edit2.getText().toString());&#xA;        }&#xA;    });&#xA;    // 添加一个按钮，并监听按钮事件 (消极的;否认的)&#xA;    builder.setNegativeButton(&amp;quot;取消&amp;quot;, new DialogInterface.OnClickListener() {&#xA;        @Override&#xA;        public void onClick(DialogInterface dialog, int which) {&#xA;        Intent intent = new Intent(MainActivity.this, ControlActivity.class);&#xA;        startActivity(intent);&#xA;        }&#xA;    });&#xA;    // 可以设置 View&#xA;    builder.setView(root);&#xA;    // 创建及显示&#xA;    builder.create().show();&#xA;    // .......&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&#xA;    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;match_parent&amp;quot; android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;&#xA;    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot;&#xA;    tools:context=&amp;quot;com.example.nljb.nljb.ControlActivity&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&#xA;    android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;    android:layout_centerHorizontal=&amp;quot;true&amp;quot;&#xA;    android:layout_alignParentTop=&amp;quot;true&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;        android:orientation=&amp;quot;horizontal&amp;quot;&#xA;        android:layout_width=&amp;quot;match_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:gravity=&amp;quot;center&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;用户名&amp;quot;&#xA;        android:id=&amp;quot;@+id/textView&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;EditText&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:inputType=&amp;quot;textPersonName&amp;quot;&#xA;        android:text=&amp;quot;Name&amp;quot;&#xA;        android:ems=&amp;quot;10&amp;quot;&#xA;        android:id=&amp;quot;@+id/editText&amp;quot; /&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;    &amp;lt;LinearLayout&#xA;        android:orientation=&amp;quot;horizontal&amp;quot;&#xA;        android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;        android:gravity=&amp;quot;center&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;TextView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:text=&amp;quot;密    码&amp;quot;&#xA;        android:id=&amp;quot;@+id/textView2&amp;quot; /&amp;gt;&#xA;&#xA;        &amp;lt;EditText&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:inputType=&amp;quot;numberPassword&amp;quot;&#xA;        android:ems=&amp;quot;10&amp;quot;&#xA;        android:id=&amp;quot;@+id/editText2&amp;quot; /&amp;gt;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&#xA;    &amp;lt;/LinearLayout&amp;gt;&#xA;&amp;lt;/RelativeLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Toast简单使用方法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BToast%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-03-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Toast是Android中用来显示显示信息的一种机制，和Dialog不一样的是&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Toast是没有焦点的，而且Toast显示的时间有限，过一定的时间就会自动消失。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 直接创建一个Toast并且显示&#xA;Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;// 也可以创建后设置一些参数再显示&#xA;Toast toast = Toast.makeText(getApplicationContext(), &amp;quot;欢迎&amp;quot;, Toast.LENGTH_SHORT);&#xA;// 短时间 Toast.LENGTH_SHORT 长时间 Toast.LENGTH_LONG&#xA;// 当然，也可以具体设置显示的时间&#xA;toast.setDuration(Toast.LENGTH_SHORT);&#xA;// 也可以加入一个 View 显示&#xA;View toast.setView(...);&#xA;// 位置, 也可以指定显示位置，默认为屏幕下部居中位置&#xA;toast.setGravity(Gravity.CENTER, 0 ,0);&#xA;// 开始显示&#xA;toast.show();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 增加图片显示&#xA;toast = Toast.makeText(getApplicationContext(),&#xA;&amp;quot;带图片的Toast&amp;quot;, Toast.LENGTH_LONG);&#xA;// 同上&#xA;toast.setGravity(Gravity.CENTER, 0, 0);&#xA;// 获取 Layout &#xA;LinearLayout toastView = (LinearLayout) toast.getView();&#xA;// 创建 ImageView&#xA;ImageView imageCodeProject = new ImageView(getApplicationContext());&#xA;// 设置 icon&#xA;imageCodeProject.setImageResource(R.drawable.icon);&#xA;// 添加到 toast&#xA;toastView.addView(imageCodeProject, 0);&#xA;// 显示&#xA;toast.show();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;LayoutInflater inflater = getLayoutInflater();&#xA;View layout = inflater.inflate(R.layout.custom,&#xA;(ViewGroup) findViewById(R.id.llToast));&#xA;ImageView image = (ImageView) layout&#xA;.findViewById(R.id.tvImageToast);&#xA;image.setImageResource(R.drawable.icon);&#xA;TextView title = (TextView) layout.findViewById(R.id.tvTitleToast);&#xA;title.setText(&amp;quot;Attention&amp;quot;);&#xA;TextView text = (TextView) layout.findViewById(R.id.tvTextToast);&#xA;text.setText(&amp;quot;完全自定义Toast&amp;quot;);&#xA;toast = new Toast(getApplicationContext());&#xA;toast.setGravity(Gravity.RIGHT | Gravity.TOP, 12, 40);&#xA;toast.setDuration(Toast.LENGTH_LONG);&#xA;toast.setView(layout);&#xA;toast.show();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;new Thread(new Runnable() {&#xA;    public void run() {&#xA;     showToast();&#xA;    }&#xA;   }).start();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之PopupWindow在外点击消失</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BPopupWindow%E5%9C%A8%E5%A4%96%E7%82%B9%E5%87%BB%E6%B6%88%E5%A4%B1/</link>
      <pubDate>2015-03-06 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;PopupWindow 如果要想点击其他地方使其隐藏&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// PopupWindow&#xA;// 载入一个Layout视图&#xA;View root = this.getLayoutInflater().inflate(R.layout.window, null);&#xA;&#xA;// 通过视图及布局生成 PopupWindow&#xA;// import android.view.ViewGroup.LayoutParams;&#xA;// import android.widget.PopupWindow;&#xA;    final PopupWindow popup = new PopupWindow(root, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, true);&#xA;&#xA;// 使其聚焦 &#xA;mPopupWindow.setFocusable(true); &#xA;&#xA;// 设置允许在外点击消失 &#xA;mPopupWindow.setOutsideTouchable(true); &#xA;&#xA;//刷新状态 &#xA;mPopupWindow.update(); &#xA;&#xA;//点back键和其他地方使其消失,设置了这个才能触发OnDismisslistener ，设置其他控件变化等操作 &#xA;// 设置背景色 ...&#xA;mPopupWindow.setBackgroundDrawable(new BitmapDrawable()); &#xA;&#xA;// new BitmapDrawable() 已经过时，可以使用 new BitmapDrawable(this.getResources())&#xA;// 背景色的设置还可以&#xA;// popup.setBackgroundDrawable(new ColorDrawable(0x55000000));&#xA;&#xA;// 监听按钮事件，来触发显示&#xA;popup.showAtLocation(findViewById(R.id.button), Gravity.CENTER, 20, 20);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;关于 PopupWindow 其它区域变暗效果&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;网上查了一下，没有什么具体的好办法，有设置背景色的，有调节透明度的&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果这样，默认非显示区域都是透明的,但是全屏的缘故，在外点击消失失效&#xA;PopupWindow(root, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, true);&#xA;&#xA;// 设置背景色，..... 有点滥&#xA;popup.setBackgroundDrawable(new ColorDrawable(0x55000000));&#xA;&#xA;// 透明度，靠谱点，将主窗口透明&#xA;// 记得关闭窗口的时候要设置回来哦!&#xA;WindowManager.LayoutParams lp = getWindow().getAttributes();&#xA;lp.alpha = 0.3f;&#xA;getWindow().setAttributes(lp);&#xA;&#xA;// 具体介绍&#xA;// alpha 渐变透明度动画效果&#xA;0.0 表示完全透明&#xA;1.0 表示完全不透明&#xA;以上值取0.0-1.0之间的float数据类型的数字&#xA;&#xA;// 返回时,恢复透明度&#xA;    popup.setOnDismissListener(new PopupWindow.OnDismissListener() {&#xA;        @Override&#xA;        public void onDismiss() {&#xA;            WindowManager.LayoutParams lp = getWindow().getAttributes();&#xA;            lp.alpha = 1.0f;&#xA;            getWindow().setAttributes(lp);&#xA;        }&#xA;    });&#xA;&#xA;// 命令关闭 &#xA;popup.dismiss();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之PopupWindow和AlertDialog区别</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BPopupWindow%E5%92%8CAlertDialog%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2015-03-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本质区别为：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;AlertDialog是非阻塞式对话框：AlertDialog弹出时，后台还可以做事情；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而PopupWindow是阻塞式对话框：PopupWindow弹出时，程序会等待&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在PopupWindow退出前，程序一直等待，只有当我们调用了dismiss方法的后，PopupWindow退出，程序才会向下执行。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这两种区别的表现是：AlertDialog弹出时，背景是黑色的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是当我们点击背景，AlertDialog会消失，证明程序不仅响应AlertDialog的操作，还响应其他操作&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他程序没有被阻塞，这说明了AlertDialog是非阻塞式对话框；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PopupWindow弹出时，背景没有什么变化&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是当我们点击背景的时候，程序没有响应，只允许我们操作PopupWindow，其他操作被阻塞。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;PopupWindow pw = new PopupWindow(view,width,height);&#xA;// 重新设置PopupWindow的内容&#xA;pw.setContentView(popupconten);&#xA;// 默认是false，为false时，PopupWindow没有获得焦点能力&#xA;// 如果这是PopupWindow的内容中有EidtText，需要输入，这是是无法输入的；&#xA;// 只有为true的时候，PopupWindow才具有获得焦点能力，EditText才是&amp;gt;真正的EditText。&#xA;pw.setFocusable(true);&#xA;// 设置PopupWindow弹出的位置&#xA;pw.setAsDropDown(View view);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;AlertDialog的构造方法全部是Protected的，所以不能直接通过new一个AlertDialog来创建出一个AlertDialog。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要创建一个AlertDialog，就要用到AlertDialog.Builder中的create()方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用AlertDialog.Builder创建对话框需要了解以下几个方法：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;setTitle ：为对话框设置标题&#xA;setIcon ：为对话框设置图标&#xA;setMessage：为对话框设置内容&#xA;setView ： 给对话框设置自定义样式&#xA;setItems ：设置对话框要显示的一个list，一般用于显示几个命令时&#xA;setMultiChoiceItems ：用来设置对话框显示一系列的复选框&#xA;setNeutralButton ：普通按钮&#xA;setPositiveButton ：给对话框添加&amp;quot;Yes&amp;quot;按钮&#xA;setNegativeButton ：对话框添加&amp;quot;No&amp;quot;按钮&#xA;create ： 创建对话框&#xA;show ：显示对话框&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Dialog alertDialog = new AlertDialog.Builder(this). &#xA;setTitle(&amp;quot;对话框的标题&amp;quot;). &#xA;setMessage(&amp;quot;对话框的内容&amp;quot;). &#xA;setIcon(R.drawable.ic_launcher). &#xA;create(); &#xA;alertDialog.show();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Notification通知用法</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BNotification%E9%80%9A%E7%9F%A5%E7%94%A8%E6%B3%95/</link>
      <pubDate>2015-03-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当用户有没有接到的电话的时候，Android顶部状态栏里就会出现一个小图标。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提示用户有没有处理的快讯，当拖动状态栏时，可以查看这些快讯。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Android给我们提供了NotificationManager来管理这个状态栏。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以很轻松的完成。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void send()&#xA;{&#xA;// .......&#xA;// 消息ID&#xA;final int NOTIFY_ID = 0;&#xA;// 获取系统的 NotificationManager 服务&#xA;NotificationManager notificationManager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);&#xA;// 创建一个点击消息跳转的 Activity&#xA;Intent intent = new Intent(this, ControlActivity.class);&#xA;// Intent 是及时启动，intent 随所在的activity 消失而消失。 &#xA;// PendingIntent 可以看作是对intent的包装，通常通过getActivity,getBroadcast ,getService来得到pendingintent的实例&#xA;// 当前activity并不能马上启动它所包含的intent,而是在外部执行 pendingintent时，调用intent的&#xA;PendingIntent contentIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);//FLAG_ONE_SHOT&#xA;// 开始创建 Notification&#xA;Notification notification = new Notification.Builder(this)&#xA;    // 设置显示在状态栏的通知提示信息&#xA;    .setTicker(&amp;quot;有新的消息&amp;quot;)&#xA;    // 设置消息标题&#xA;    .setContentTitle(&amp;quot;消息标题&amp;quot;)&#xA;    // 设置消息内容&#xA;    .setContentText(&amp;quot;消息内容&amp;quot;)&#xA;    // 通知消息要启动的 Activity&#xA;    .setContentIntent(contentIntent)&#xA;    // 设置消息图标&#xA;    .setSmallIcon(R.mipmap.ic_launcher)&#xA;    // 设置该通知自动消失&#xA;    .setAutoCancel(true)&#xA;    // 设置通知的时间 (消息上面显示的时间)&#xA;    .setWhen(System.currentTimeMillis())&#xA;    // 使用默认声音，默认LED灯，震动&#xA;    // DEFAULT_SOUND 默认声音&#xA;    // DEFAULT_VIBRATE 默认震动&#xA;    // DEFAULT_LIGHTS 默认闪光灯&#xA;    // DEFAULT_ALL 设置使用默认声音，震动，闪光灯&#xA;    // 设置声音 .setSound(Uri.pare(&amp;quot;file:///sdcard/click.mp3&amp;quot;));&#xA;    // 设置震动 .setVibrate(new long[]{0, 50, 100, 150});&#xA;    .setDefaults(Notification.DEFAULT_ALL)&#xA;    // 为通知设置大图标 .setLargeIcon(...)&#xA;    // 生成 Notification&#xA;    // 貌似 getNotification 被强制换成 build() 了&#xA;    // .getNotification(); &#xA;    // .build();&#xA;// 发送消息&#xA;notificationManager.notify(NOTIFY_ID, notification);&#xA;// .......&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 一个可以点击即可打开网址的PendingIntent&#xA;    // PendingIntent&#xA;    PendingIntent contentIntent =&#xA;     PendingIntent.getActivity(this, 0, new Intent(Intent.ACTION_VIEW, Uri.parse(url)), PendingIntent.FLAG_UPDATE_CURRENT);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;而在Android中，如果需要访问硬件设备的话，是需要对其进行授权的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以需要在清单文件AndroidManifest.xml中增加两个授权，分别授予访问振动器与闪光灯的权限：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 闪光灯权限 --&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.FLASHLIGHT&amp;quot;/&amp;gt;&#xA;&amp;lt;!-- 振动器权限 --&amp;gt;&#xA;&amp;lt;uses-permission android:name=&amp;quot;android.permission.VIBRATE&amp;quot;/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之FILL_PARENT与WRAP_CONTENT和MATCH_PARENT介绍</title>
      <link>http://www.nljb.net/default/Android%E4%B9%8BFILL_PARENT%E4%B8%8EWRAP_CONTENT%E5%92%8CMATCH_PARENT%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2015-03-06 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;三个属性都用来适应视图的水平或垂直大小&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;一个以视图的内容或尺寸为基础的布局比精确地指定视图范围更加方便。&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 包裹&#xA;wrap_content &#xA;// 填满&#xA;fill_parent &#xA;// 填满&#xA;match_parent &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;FILL_PARENT&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;设置一个构件的布局为fill_parent将强制性地使构件扩展，以填充布局单元内尽可能多的空间。&#xA;&#xA;这跟Windows控件的dockstyle属性大体一致。&#xA;&#xA;设置一个顶部布局或控件为fill_parent将强制性让它布满整个屏幕。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;WRAP_CONTENT&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;设置一个视图的尺寸为wrap_content将强制性地使视图扩展以显示全部内容。&#xA;&#xA;以TextView和ImageView控件为例，设置为wrap_content将完整显示其内部的文本和图像。&#xA;&#xA;布局元素将根据内容更改大小。&#xA;&#xA;设置一个视图的尺寸为wrap_content大体等同于设置Windows控件的Autosize属性为True。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;MATCH_PARENT&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Android2.2中match_parent和fill_parent是一个意思 .两个参数意思一样，match_parent更贴切&#xA;&#xA;于是从2.2开始两个词都可以用。那么如果考虑低版本的使用情况你就需要用fill_parent了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt动画框架之QPropertyAnimation类</title>
      <link>http://www.nljb.net/default/Qt%E5%8A%A8%E7%94%BB%E6%A1%86%E6%9E%B6%E4%B9%8BQPropertyAnimation%E7%B1%BB/</link>
      <pubDate>2015-03-04 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;从下向上，或者从上向下弹出一个 Dialog 窗口&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Dialog::Dialog(QWidget *parent) :&#xA;    QDialog(parent),&#xA;    ui(new Ui::Dialog)&#xA;{&#xA;    ui-&amp;gt;setupUi(this);&#xA;    // 隐藏菜单栏&#xA;    // this-&amp;gt;setWindowFlags(Qt::FramelessWindowHint);&#xA;    // 初始化位置到右下角 (初始位置, 不一定需要设置）&#xA;    // this-&amp;gt;move((desktop.availableGeometry().width()-this-&amp;gt;width()),desktop.availableGeometry().height());&#xA;    // 开始显示右下角弹出框&#xA;    showAnimation();&#xA;}&#xA;&#xA;&#xA;Dialog::~Dialog()&#xA;{&#xA;    delete ui;&#xA;}&#xA;&#xA;// 弹出动画&#xA;void Dialog::showAnimation(){&#xA;    // 显示弹出框动画&#xA;    animation=new QPropertyAnimation(this,&amp;quot;pos&amp;quot;);&#xA;    // 移动间隔&#xA;    animation-&amp;gt;setDuration(2000);&#xA;    // 移动效果 &#xA;    animation-&amp;gt;setEasingCurve(QEasingCurve::OutBounce);&#xA;    // 起始位置&#xA;    animation-&amp;gt;setStartValue(QPoint(this-&amp;gt;x(),-desktop.availableGeometry().height()));&#xA;    // 终点位置&#xA;    animation-&amp;gt;setEndValue(QPoint((this-&amp;gt;x()),(this-&amp;gt;y())));&#xA;    // 开始移动&#xA;    animation-&amp;gt;start();&#xA;&#xA;}&#xA;&#xA;// 关闭动画&#xA;void Dialog::closeAnimation(){&#xA;    connect(animation,SIGNAL(finished()),this,SLOT(clearAll()));&#xA;}&#xA;&#xA;// 清理动画指针&#xA;void Dialog::clearAll(){&#xA;    disconnect(animation,SIGNAL(finished()),this,SLOT(clearAll()));&#xA;    delete animation;&#xA;    animation = NULL;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;网上的一些例子&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QPushButton button(&amp;quot;Animated Button&amp;quot;);&#xA;button.show();&#xA;QPropertyAnimation animation(&amp;amp;button, &amp;quot;geometry&amp;quot;);&#xA;animation.setDuration(10000);&#xA;animation.setStartValue(QRect(0, 0, 100, 30));&#xA;animation.setEndValue(QRect(250, 250, 100, 30));&#xA;animation.start();&#xA;// 上述代码即在10秒的期限把button从屏幕的左上角移动到(250,250)点处。&#xA;    // 上述代码在开始值与结束值之间做了线性插值。&#xA;// 当然，设置的值在开始处与结束处之间的数值也是合理的，那么插值衍化就沿这些点进行。&#xA;&#xA;QPushButton button(&amp;quot;Animated Button&amp;quot;);&#xA;button.show();&#xA;QPropertyAnimation animation(&amp;amp;button, &amp;quot;geometry&amp;quot;);&#xA;animation.setDuration(10000);&#xA;animation.setKeyValueAt(0, QRect(0, 0, 100, 30));&#xA;animation.setKeyValueAt(0.8, QRect(250, 250, 100, 30));&#xA;animation.setKeyValueAt(1, QRect(0, 0, 100, 30));&#xA;animation.start();&#xA;// 在这个例子中，在8秒的期限将button移到(250,250)，然后在剩下的2秒时间移回至初始的位置；&#xA;// 这些点之间的移动都是通过线性插值的。&#xA;&#xA;QPushButton button(&amp;quot;Animated Button&amp;quot;);&#xA;button.show();&#xA;QPropertyAnimation animation(&amp;amp;button, &amp;quot;geometry&amp;quot;);&#xA;animation.setDuration(3000);&#xA;animation.setStartValue(QRect(0, 0, 100, 30));&#xA;animation.setEndValue(QRect(250, 250, 100, 30));&#xA;animation.setEasingCurve(QEasingCurve::OutBounce);&#xA;animation.start();&#xA;// 上述代码中，动画即沿着OutBounce曲线，该曲线样式是到结束处会弹跳起来像个弹跳球。&#xA;// QEasingCurve类有大量的供你选择的曲线，它们被定义成QEasingCurve::Type枚举。&#xA;// 如果你需要另外的曲线样式，你也可以自己实现一个，然后用QEasingCurve注册它既可。&#xA;&#xA;&#xA;QPushButton *bonnie = new QPushButton(&amp;quot;Bonnie&amp;quot;);&#xA;bonnie-&amp;gt;show();&#xA;QPushButton *clyde = new QPushButton(&amp;quot;Clyde&amp;quot;);&#xA;clyde-&amp;gt;show();&#xA;QPropertyAnimation *anim1 = new QPropertyAnimation(bonnie, &amp;quot;geometry&amp;quot;);// Set up anim1  &#xA;QPropertyAnimation *anim2 = new QPropertyAnimation(clyde, &amp;quot;geometry&amp;quot;);// Set up anim2  &#xA;QParallelAnimationGroup *group = new QParallelAnimationGroup;&#xA;group-&amp;gt;addAnimation(anim1);&#xA;group-&amp;gt;addAnimation(anim2);&#xA;group-&amp;gt;start();&#xA;// 动画分组&#xA;&#xA;QPushButton button(&amp;quot;Animated Button&amp;quot;);&#xA;button.show();&#xA;QPropertyAnimation anim1(&amp;amp;button, &amp;quot;geometry&amp;quot;);&#xA;anim1.setDuration(3000);&#xA;anim1.setStartValue(QRect(0, 0, 100, 30));&#xA;anim1.setEndValue(QRect(500, 500, 100, 30));&#xA;QPropertyAnimation anim2(&amp;amp;button, &amp;quot;geometry&amp;quot;);&#xA;anim2.setDuration(3000);&#xA;anim2.setStartValue(QRect(500, 500, 100, 30));&#xA;anim2.setEndValue(QRect(1000, 500, 100, 30));&#xA;QSequentialAnimationGroup group;&#xA;group.addAnimation(&amp;amp;anim1);&#xA;group.addAnimation(&amp;amp;anim2);&#xA;group.start();&#xA;// 动画分组&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;其它相关&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;QApplication::desktop()-&amp;gt;width();QApplication::desktop()-&amp;gt;height(); &#xA;// 这个方法对于单显示器模式当然没有问题。&#xA;// 但是对于多显示器，特别是使用了扩展桌面的就会有问题了。&#xA;// 今天上午仔细看了QDesktopWidget的帮助&#xA;// 需要使用QApplication::desktop()-&amp;gt;screenGeometry();这个函数有好几个重载的版本，意思都一样。&#xA;// 该函数返回一个QRect，这个QRect的宽和高就是所在Screen的分辨率。获取方法如下：&#xA;void GetScreenInfo()&#xA;{&#xA;    QDesktopWidget* desktopWidget = QApplication::desktop();&#xA;    //获取可用桌面大小&#xA;    QRect deskRect = desktopWidget-&amp;gt;availableGeometry();&#xA;    //获取设备屏幕大小&#xA;    QRect screenRect = desktopWidget-&amp;gt;screenGeometry();&#xA;    g_nActScreenX = screenRect.width();&#xA;    g_nActScreenY = screenRect.height();&#xA;    //g_nActScreenX = deskRect.width();&#xA;    //g_nActScreenY = deskRect.height();&#xA;    //获取系统设置的屏幕个数（屏幕拷贝方式该值为1）&#xA;    g_nScreenCount = desktopWidget-&amp;gt;screenCount();&#xA;}&#xA;// 说到这里，顺便标记以下多屏幕设置成拷贝方式时，获取的屏幕的个数是一个，只有设置成扩展时才返回多个。&#xA;&#xA;// 打印屏幕分辨率和个数信息：&#xA;void printscreeninfo()&#xA;{&#xA;    QDesktopWidget *dwsktopwidget = QApplication::desktop();&#xA;    QRect deskrect = dwsktopwidget-&amp;gt;availableGeometry();&#xA;    QRect screenrect = dwsktopwidget-&amp;gt;screenGeometry();&#xA;    QDesktopWidget *dwsktopwidget = QApplication::desktop();&#xA;    QRect deskrect = dwsktopwidget-&amp;gt;availableGeometry();&#xA;    QRect screenrect = dwsktopwidget-&amp;gt;screenGeometry();&#xA;    int scrcount = dwsktopwidget-&amp;gt;screenCount();&#xA;    qCritical(&amp;quot;screenrect.w==%s\n&amp;quot;,qPrintable(QString::number(screenrect.width())));&#xA;    qCritical(&amp;quot;screenrect.h==%s\n&amp;quot;,qPrintable(QString::number(screenrect.height())));&#xA;    qCritical(&amp;quot;deskrect.w==%s\n&amp;quot;,qPrintable(QString::number(deskrect.width())));&#xA;    qCritical(&amp;quot;deskrect.h==%s\n&amp;quot;,qPrintable(QString::number(deskrect.height())));&#xA;    qCritical(&amp;quot;scrcount==%s\n&amp;quot;,qPrintable(QString::number(scrcount)));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Android SDK Manager Proxy</title>
      <link>http://www.nljb.net/default/Android-SDK-Manager-Proxy/</link>
      <pubDate>2015-03-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1、打开android sdk manager&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、打开tool-&amp;gt;options，如图所示&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android-SDK-Manager-Proxy/1.jpeg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3、将Proxy Settings 里的HTTP Proxy Server和HTTP Proxy Port分别设置成mirrors.neusoft.edu.cn和80&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将Others中的Force https://&amp;hellip;sources to be fetched using http://&amp;hellip;复选框勾上&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如下图所示：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Android-SDK-Manager-Proxy/2.jpeg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4、重启Eclipse见证奇迹吧~&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>总结一套行之有效的CGO与QT开发方案</title>
      <link>http://www.nljb.net/default/%E6%80%BB%E7%BB%93%E4%B8%80%E5%A5%97%E8%A1%8C%E4%B9%8B%E6%9C%89%E6%95%88%E7%9A%84CGO%E4%B8%8EQT%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88/</link>
      <pubDate>2015-02-28 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;总结&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;使用QT与GO开发图形程序，无非就是在QT中调用GO函数，在GO中使用QT方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目的呢，也就是贪图GO的简介以及在网络单元开发的优势，同时发挥QT的界面强项&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在MVC中，数据层交给GO，视图交给QT，控制主要交给QT，部分触发事件由GO来做.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;具体一些特点&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在 GO 里面调用 C 函数，想必大家一点不陌生。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 特点：&#xA;// 一，注释内可以写C代码,并且通过C库调用方法&#xA;//  A，C代码中可以，#include &amp;lt;stdio.h&amp;gt; &#xA;//  B，C代码中可以，static int callback() { ...&#xA;//      C，就像写C语言一样...&#xA;// 二，可以引入LIB库，并且通过C库调用方法&#xA;//  A，引入了 examples 库，调用里面的方法 C.start()&#xA;/*&#xA;    static int callback()&#xA;    {&#xA;        return 1;&#xA;    }&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -lexamples&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;&#xA;// 主&#xA;func main() {&#xA;    C.callback()&#xA;    C.start()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在 C 中调用 Go 函数，这个不少人不知道，还是上面的例子.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    extern int cgo_checkconn();&#xA;    // 也可以在C中使用&#xA;    int xxx()&#xA;    {&#xA;        return cgo_checkconn()&#xA;    }&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;&#xA;// 主&#xA;func main() {&#xA;    // 看这里，把GO转C，然后当C用.&#xA;    // 你可能要问了，这不是多此一举吗.&#xA;    // 往下看吧.&#xA;    C.cgo_checkconn();&#xA;    // 这样也行,哦.&#xA;    C.xxx()&#xA;}&#xA;&#xA;//export cgo_checkconn&#xA;func cgo_checkconn() C.int {&#xA;    return C.int(1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;好了，至此，你已经看到了什么：&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A，在GO中，通过注释导入#include &lt;xxx.h&gt;头文件来使用其中的函数(C.xxx())&lt;/p&gt;&#xA;&#xA;&lt;p&gt;B，在GO中，通过注释引导-lexamples库文件来使用其中的函数(C.xxx())&lt;/p&gt;&#xA;&#xA;&lt;p&gt;C，在GO中，通过函数行注释//export cgo_checkconn方式把GO函数转成C函数，并且在C中调用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;D，在GO中，通过//export方式将Go转C，一定要，extern(表示变量或者函数的定义在别的文件中)&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;具体说一下具体，行之有效的调用方法&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;一，在 QT 中定义一个类，用来存储GO传过来的函数指针&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Cgo.h&#xA;#ifndef CGO_H&#xA;#define CGO_H&#xA;&#xA;#include &amp;lt;map&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;typedef int (*COMMAND_CGO_CONNECT_FUNCTION)(void*, int, void*, int);&#xA;typedef int (*COMMAND_CGO_CHECKCONN_FUNCTION)();&#xA;typedef void (*COMMAND_CGO_DISCONN_FUNCTION)();&#xA;typedef void (*COMMAND_CGO_COMMAND_FUNCTION)(void*, int);&#xA;typedef void (*COMMAND_CGO_SHORTCUTS_FUNCTION)(void*, int);&#xA;typedef int (*COMMAND_CGO_GOLINE_FUNCTION)(void*, int);&#xA;typedef void (*COMMAND_CGO_READER_FUNCTION)(void*, int);&#xA;typedef int (*COMMAND_CGO_WRITER_FUNCTION)(void*, int, void*, int);&#xA;&#xA;class Cgo&#xA;{&#xA;public:&#xA;    Cgo();&#xA;    int setCgo(void*, void*);&#xA;public:&#xA;    COMMAND_CGO_CONNECT_FUNCTION cgo_connect;&#xA;    COMMAND_CGO_CHECKCONN_FUNCTION cgo_checkconn;&#xA;    COMMAND_CGO_DISCONN_FUNCTION cgo_disconn;&#xA;    COMMAND_CGO_COMMAND_FUNCTION cgo_command;&#xA;    COMMAND_CGO_SHORTCUTS_FUNCTION cgo_shortcuts;&#xA;    COMMAND_CGO_GOLINE_FUNCTION cgo_goline;&#xA;    COMMAND_CGO_READER_FUNCTION cgo_reader;&#xA;    COMMAND_CGO_WRITER_FUNCTION cgo_writer;&#xA;};&#xA;&#xA;#endif // CGO_H&#xA;&#xA;// Cgo.cpp&#xA;#include &amp;lt;QString&amp;gt;&#xA;#include &amp;quot;cgo.h&amp;quot;&#xA;&#xA;Cgo::Cgo()&#xA;{&#xA;    cgo_connect = 0;&#xA;    cgo_checkconn = 0;&#xA;    cgo_disconn = 0;&#xA;    cgo_command = 0;&#xA;    cgo_shortcuts = 0;&#xA;    cgo_goline = 0;&#xA;    cgo_reader = 0;&#xA;    cgo_writer = 0;&#xA;}&#xA;&#xA;int Cgo::setCgo(void* _a, void* _b)&#xA;{&#xA;    if (QString(&amp;quot;cgo_connect&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_connect = (COMMAND_CGO_CONNECT_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_checkconn&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_checkconn = (COMMAND_CGO_CHECKCONN_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_disconn&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_disconn = (COMMAND_CGO_DISCONN_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_command&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_command = (COMMAND_CGO_COMMAND_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_shortcuts&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_shortcuts = (COMMAND_CGO_SHORTCUTS_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_goline&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_goline = (COMMAND_CGO_GOLINE_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_reader&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_reader = (COMMAND_CGO_READER_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_writer&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_writer = (COMMAND_CGO_WRITER_FUNCTION)_b;&#xA;    return 1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;二，在QT中定义一个函数，用于接收GO传过来的函数指针，并且保存到类中.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 说明&#xA;// 也就是，在 Go 里面调用 QT 函数&#xA;// 然后 把 Go转C 的函数传入 QT 函数内&#xA;// 然后 在 QT 函数内调用 Go转C 的函数&#xA;#include &amp;lt;QApplication&amp;gt;&#xA;#include &amp;lt;QTextCodec&amp;gt;&#xA;#include &amp;quot;examples.h&amp;quot;&#xA;#include &amp;quot;cgo.h&amp;quot;&#xA;&#xA;using namespace std;&#xA;&#xA;// 这里是QT窗口&#xA;Examples * win;&#xA;&#xA;// Cgo 就是保存有GO函数指针的类&#xA;Cgo * cgo;&#xA;&#xA;// 初始化，生成保存函数指针的类 (在Go内调用）&#xA;extern &amp;quot;C&amp;quot; void init()&#xA;{&#xA;    cgo = new Cgo();&#xA;}&#xA;&#xA;// 开始运行 (在Go内调用)&#xA;extern &amp;quot;C&amp;quot; int start()&#xA;{&#xA;    int argc = 0 ;&#xA;    char *argv[] = {};&#xA;    QApplication a(argc, argv);&#xA;    win = new Examples();&#xA;    // 这里把存有GO函数指针的类传入QT窗口类中.&#xA;    win-&amp;gt;setCgo(cgo);&#xA;    win-&amp;gt;show();&#xA;    return a.exec();&#xA;}&#xA;&#xA;// 这里就是，接收GO传入函数指针的地方 (在GO内调用)&#xA;extern &amp;quot;C&amp;quot; void drv_cgo_callback(void* _a, void* _b)&#xA;{&#xA;    // 这里，将函数指针保存到Cgo类中&#xA;    // _a 是函数名，_b 是函数指针&#xA;    cgo-&amp;gt;setCgo(_a, _b);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;三，在 Go 内将函数传入到 QT 中&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;/*&#xA;    extern void init(); // 这里是声明在QT里面的函数，方便调用&#xA;    extern int start(); // 这里是声明在QT里面的函数，方便调用&#xA;    extern void drv_cgo_callback(void*, void*); // 这里是声明在QT里面的函数，方便调用&#xA;    static void callback() // GO中调用&#xA;    {   char * _cgo_connect = &amp;quot;cgo_connect&amp;quot;; // 函数名称，以便QT内区分&#xA;        char * _cgo_checkconn = &amp;quot;cgo_checkconn&amp;quot;; // 函数名称，以便QT内区分&#xA;        char * _cgo_disconn = &amp;quot;cgo_disconn&amp;quot;; // 函数名称，以便QT内区分&#xA;        char * _cgo_command = &amp;quot;cgo_command&amp;quot;; // 函数名称，以便QT内区分&#xA;        char * _cgo_shortcuts = &amp;quot;cgo_shortcuts&amp;quot;; // 函数名称，以便QT内区分&#xA;        char * _cgo_goline = &amp;quot;cgo_goline&amp;quot;; // 函数名称，以便QT内区分&#xA;        char * _cgo_reader = &amp;quot;cgo_reader&amp;quot;; // 函数名称，以便QT内区分&#xA;        char * _cgo_writer = &amp;quot;cgo_writer&amp;quot;; // 函数名称，以便QT内区分&#xA;        extern int cgo_connect(void*, int, void*, int); // 这里是声明在GO转C函数，方便传递&#xA;        extern int cgo_checkconn(); // 这里是声明在GO转C函数，方便传递&#xA;        extern void cgo_disconn(); // 这里是声明在GO转C函数，方便传递&#xA;        extern void cgo_command(void*, int); // 这里是声明在GO转C函数，方便传递&#xA;        extern void cgo_shortcuts(void*, int); // 这里是声明在GO转C函数，方便传递&#xA;        extern void cgo_goline(void*, int); // 这里是声明在GO转C函数，方便传递&#xA;        extern void cgo_reader(void*, int); // 这里是声明在GO转C函数，方便传递&#xA;        extern void cgo_writer(void*, int, void*, int); // 这里是声明在GO转C函数，方便传递&#xA;        drv_cgo_callback(_cgo_connect, &amp;amp;cgo_connect); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;        drv_cgo_callback(_cgo_checkconn, &amp;amp;cgo_checkconn); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;        drv_cgo_callback(_cgo_disconn, &amp;amp;cgo_disconn); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;        drv_cgo_callback(_cgo_command, &amp;amp;cgo_command); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;        drv_cgo_callback(_cgo_shortcuts, &amp;amp;cgo_shortcuts); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;        drv_cgo_callback(_cgo_goline, &amp;amp;cgo_goline); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;        drv_cgo_callback(_cgo_reader, &amp;amp;cgo_reader); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;        drv_cgo_callback(_cgo_writer, &amp;amp;cgo_writer); // 调用 QT 内函数，传入 GO转C 函数指针&#xA;    }&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -lexamples // 注意：这里将QT编译成库文件，在GO中引入使用.&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;import (&#xA;    z &amp;quot;github.com/nutzam/zgo&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;runtime&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;&#xA;// 全局连接&#xA;var StaticConn *Conn&#xA;&#xA;// 开始&#xA;func start() {&#xA;    C.init() // 调用QT中的函数，初始化&#xA;    C.callback() // 调用GO中注释的C函数，建GO转C函数传入到QT中&#xA;    C.start() // 调用QT中的函数，启动程序&#xA;}&#xA;&#xA;// 主&#xA;func main() {&#xA;    log.Println(z.UnixMsSec(1))&#xA;    runtime.GOMAXPROCS(runtime.NumCPU())&#xA;    log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime | log.Lmicroseconds)&#xA;    StaticConn = NewConn()&#xA;    start()&#xA;}&#xA;&#xA;//export cgo_connect&#xA;func cgo_connect(_content unsafe.Pointer, _size C.int, _content_2 unsafe.Pointer, _size_2 C.int) C.int {&#xA;    device := string(C.GoBytes(_content, _size))&#xA;    authorize := string(C.GoBytes(_content_2, _size_2))&#xA;    if err := StaticConn.Connect(device, &amp;quot;1.03&amp;quot;, authorize); err != nil {&#xA;        return C.int(0)&#xA;    }&#xA;    return C.int(1)&#xA;}&#xA;&#xA;//export cgo_checkconn&#xA;func cgo_checkconn() C.int {&#xA;    if StaticConn.CheckConn() {&#xA;        return C.int(1)&#xA;    }&#xA;    return C.int(0)&#xA;}&#xA;&#xA;//export cgo_disconn&#xA;func cgo_disconn() {&#xA;    StaticConn.DisConn()&#xA;}&#xA;&#xA;//export cgo_command&#xA;func cgo_command(_content unsafe.Pointer, _size C.int) {&#xA;    command := string(C.GoBytes(_content, _size))&#xA;    err := StaticConn.SendCommandByConn(z.Trim(command))&#xA;    if err != nil {&#xA;        cgo_message(err.Error())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt中拖拽移动控件位置</title>
      <link>http://www.nljb.net/default/Qt%E4%B8%AD%E6%8B%96%E6%8B%BD%E7%A7%BB%E5%8A%A8%E6%8E%A7%E4%BB%B6%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>2015-02-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Qt中拖拽移动控件位置/move.jpeg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;注：摘自网络，亲测可行.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//Widget.h&#xA;#ifndef WIDGET_H&#xA;#define WIDGET_H&#xA;#include &amp;lt;QtGui/QWidget&amp;gt;&#xA;#include &amp;lt;QLabel&amp;gt;&#xA;class Widget : public QWidget&#xA;{&#xA;    Q_OBJECT&#xA;public:&#xA;    Widget(QWidget *parent = 0);&#xA;protected slots:&#xA;    bool eventFilter(QObject *, QEvent *);&#xA;private:&#xA;    QLabel *label;&#xA;};&#xA;#endif // WIDGET_H&#xA;&#xA;//Widget.cpp&#xA;#include &amp;lt;QEvent&amp;gt;&#xA;#include &amp;lt;QLabel&amp;gt;&#xA;#include &amp;lt;QMouseEvent&amp;gt;&#xA;#include &amp;quot;Widget.h&amp;quot;&#xA;&#xA;// 构造&#xA;Widget::Widget(QWidget *parent):QWidget(parent)&#xA;{&#xA;    label=new QLabel(&amp;quot;hello&amp;quot;,this);&#xA;    // 事件扑捉&#xA;    label-&amp;gt;installEventFilter(this);&#xA;}&#xA;&#xA;// 事件&#xA;bool Widget::eventFilter(QObject *, QEvent *evt)&#xA;{&#xA;    static QPoint lastPnt;&#xA;    static bool isHover = false;&#xA;    // 鼠标按下&#xA;    if(evt-&amp;gt;type() == QEvent::MouseButtonPress)&#xA;    {&#xA;    QMouseEvent* e = static_cast&amp;lt;QMouseEvent*&amp;gt;(evt);&#xA;    if(label-&amp;gt;rect().contains(e-&amp;gt;pos()) &amp;amp;&amp;amp; //is the mouse is clicking the key&#xA;        (e-&amp;gt;button() == Qt::LeftButton)) //if the mouse click the right key&#xA;    {&#xA;        lastPnt = e-&amp;gt;pos();&#xA;        isHover = true;&#xA;    }&#xA;    }&#xA;    // 鼠标移动&#xA;    else if(evt-&amp;gt;type() == QEvent::MouseMove &amp;amp;&amp;amp; isHover)&#xA;    {&#xA;    // 鼠标位置&#xA;    QMouseEvent* e = static_cast&amp;lt;QMouseEvent*&amp;gt;(evt);&#xA;    int dx = e-&amp;gt;pos().x() - lastPnt.x();&#xA;    int dy=e-&amp;gt;pos().y()-lastPnt.y();&#xA;    // 修改对象位置&#xA;    label-&amp;gt;move(label-&amp;gt;x()+dx,label-&amp;gt;y()+dy);&#xA;    }else if(evt-&amp;gt;type() == QEvent::MouseButtonRelease &amp;amp;&amp;amp; isHover)&#xA;    {&#xA;    isHover = false;&#xA;    }&#xA;    return false;&#xA;}&#xA;&#xA;//main.cpp&#xA;#include &amp;quot;Widget.h&amp;quot;&#xA;#include &amp;lt;QtGui/QApplication&amp;gt;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;    QApplication a(argc, argv);&#xA;    Widget w;&#xA;    w.show();&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之焦点事件</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8B%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>2015-02-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1、setFocusPolicy（&amp;hellip;）设置获得焦点的方式:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Qt::TabFocus&#xA;// 通过Tab键获得焦点&#xA;Qt::ClickFocus&#xA;// 通过被单击获得焦点&#xA;Qt::StrongFocus&#xA;// 可通过上面两种方式获得焦点&#xA;Qt::NoFocus&#xA;// 不能通过上两种方式获得焦点(默认值), setFocus仍可使其获得焦点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、setFocus使Widget获得焦点&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;this.setFocus&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、void QWidget::setFocusProxy(QWidget * w)设置焦点的委托:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;将该widget的focus proxy设置给w。&#xA;如果w为0，该函数将此widget设为没有任何focus proxy。&#xA;有些widget，比如QComboBox，可以“拥有focus”&#xA;但是它们会创建一个子的widget来实际地处理焦点。&#xA;比如QComboBox创建的叫做QLineEdit。&#xA;setFocusProxy()用来指定当该widget获得焦点时实际上由谁来处理这个焦点。&#xA;如果某个widget拥有focus proxy，focusPolicy()，setFocusPolicy()，setFocus()和hasFocus()都是对focus proxy进行操作。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之QThread通过信号与槽传递数据</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8BQThread%E9%80%9A%E8%BF%87%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</link>
      <pubDate>2015-02-11 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 子线程 .H&#xA;#ifndef MESSAGE_H&#xA;#define MESSAGE_H&#xA;&#xA;#include &amp;lt;QThread&amp;gt;&#xA;#include &amp;lt;QString&amp;gt;&#xA;&#xA;class Message : public QThread&#xA;{&#xA;    Q_OBJECT&#xA;&#xA;public:&#xA;    Message();&#xA;&#xA;public:&#xA;    void stop();&#xA;&#xA;protected:&#xA;    void run();&#xA;&#xA;public:&#xA;    Cgo *cgo;&#xA;&#xA;// 这里，声明一个信号&#xA;signals:&#xA;    void send_message_signal(const QString &amp;amp;);&#xA;&#xA;public slots:&#xA;&#xA;private:&#xA;    volatile bool stopped;&#xA;&#xA;};&#xA;&#xA;#endif // MESSAGE_H&#xA;&#xA;// 子线程 .CPP&#xA;#include &amp;lt;QMessageBox&amp;gt;&#xA;#include &amp;lt;QDebug&amp;gt;&#xA;#include &amp;quot;message.h&amp;quot;&#xA;&#xA;Message::Message()&#xA;{&#xA;    stopped = false;&#xA;}&#xA;&#xA;void Message::run()&#xA;{&#xA;    // 发送信号到主线程&#xA;    emit send_message_signal(command);&#xA;}&#xA;&#xA;void Message::stop()&#xA;{&#xA;    stopped = true;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 主线程 .H&#xA;// 这里，声明一个槽&#xA;private slots:&#xA;    void on_message_signal(const QString &amp;amp;);&#xA;&#xA;// 主线程 .CPP&#xA;// 构造, 初始化线程&#xA;Message *message = new Message();&#xA;// 这里，将信号与槽建立连接&#xA;connect(message, SIGNAL(send_message_signal(const QString&amp;amp;)), this, SLOT(on_message_signal(const QString&amp;amp;)));&#xA;// 启动线程&#xA;message-&amp;gt;start();&#xA;&#xA;// 接收，信号发来的数据&#xA;void Examples::on_message_signal(const QString &amp;amp;_message)&#xA;{&#xA;    QMessageBox::information(this, tr(&amp;quot;提示&amp;quot;), tr(_message.toLatin1().data()), QMessageBox::Yes);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之QLineEdit自动补全</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8BQLineEdit%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</link>
      <pubDate>2015-02-10 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// .H&#xA;public:&#xA;    void sendKeyword();&#xA;&#xA;protected:&#xA;    bool eventFilter(QObject *obj, QEvent *ev);&#xA;&#xA;// .CPP&#xA;// ui-&amp;gt;display 存储全部内容，关键字在内容中搜索&#xA;// 如果有多个结果，会直接输出到 ui-&amp;gt;display 中.&#xA;// QWidget 初始化 ui-&amp;gt;command 是个 QLineEdit&#xA;ui-&amp;gt;command-&amp;gt;installEventFilter(this);&#xA;&#xA;// 按键事件捕捉&#xA;bool Examples::eventFilter(QObject *obj, QEvent *event)&#xA;{&#xA;    if (obj == ui-&amp;gt;command) {&#xA;    if (event-&amp;gt;type() == QEvent::KeyPress) {&#xA;        QKeyEvent *keyEvent = static_cast&amp;lt;QKeyEvent*&amp;gt;(event);&#xA;        if (keyEvent-&amp;gt;key() == Qt::Key_Tab)&#xA;        {&#xA;        // 这里触发&#xA;        sendKeyword();&#xA;        }&#xA;        else&#xA;        return QMainWindow::eventFilter(obj, event);&#xA;        return true;&#xA;    } else&#xA;        return false;&#xA;    } else&#xA;    // pass the event on to the parent class&#xA;    return QMainWindow::eventFilter(obj, event);&#xA;}&#xA;&#xA;// sendKeyword&#xA;void Examples::sendKeyword()&#xA;{&#xA;    if(ui-&amp;gt;command-&amp;gt;text().isEmpty())&#xA;    return;&#xA;    QMap&amp;lt;QString,int&amp;gt; backs;&#xA;    QStringList keys = ui-&amp;gt;command-&amp;gt;text().trimmed().split(&amp;quot; &amp;quot;);&#xA;    QStringList values = ui-&amp;gt;display-&amp;gt;toPlainText().split(&amp;quot;\n&amp;quot;);&#xA;    for (int i = 0; i &amp;lt; values.size(); ++i)&#xA;    {&#xA;    if (values.at(i).split(&amp;quot; &amp;quot;).last().trimmed().startsWith(keys.last().trimmed()))&#xA;        backs.insert(values.at(i).split(&amp;quot; &amp;quot;).last().trimmed(), 0);&#xA;    }&#xA;    if (backs.size() == 0)&#xA;    return;&#xA;    else if (backs.size() == 1)&#xA;    {&#xA;    QString keyword;&#xA;    QMap&amp;lt;QString, int&amp;gt;::iterator it;&#xA;    for (it = backs.begin(); it != backs.end(); ++it)&#xA;    {&#xA;        for (int i = 0; i &amp;lt; keys.size(); ++i)&#xA;        {&#xA;        if (i == (keys.size() - 1))&#xA;            keyword = keyword + &amp;quot; &amp;quot; + it.key();&#xA;        else&#xA;            keyword = keyword + &amp;quot; &amp;quot; + keys.at(i);&#xA;        }&#xA;        ui-&amp;gt;command-&amp;gt;setText(keyword);&#xA;    }&#xA;    }&#xA;    else if (backs.size() &amp;gt; 1)&#xA;    {&#xA;    QString command;&#xA;    command.append(&amp;quot;&amp;lt;pre&amp;gt;&amp;quot;);&#xA;    QMap&amp;lt;QString, int&amp;gt;::iterator it;&#xA;    for (it = backs.begin(); it != backs.end(); ++it)&#xA;    {&#xA;        command += it.key() + &amp;quot; &amp;quot;;&#xA;    }&#xA;    command.append(&amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;);&#xA;    ui-&amp;gt;display-&amp;gt;append(command);&#xA;    ui-&amp;gt;display-&amp;gt;moveCursor(QTextCursor::End);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt之QLineEdit关键字提示</title>
      <link>http://www.nljb.net/default/Qt%E4%B9%8BQLineEdit%E5%85%B3%E9%94%AE%E5%AD%97%E6%8F%90%E7%A4%BA/</link>
      <pubDate>2015-02-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Qt之QLineEdit关键字提示/keyword.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// .H&#xA;public:&#xA;    // history 内容&#xA;    QStringList *history;&#xA;    QCompleter *completer;&#xA;    QStandardItemModel *model;&#xA;&#xA;private slots:&#xA;    void onCommandChanged(const QString&amp;amp;);&#xA;    void onCommandChoosed(const QString&amp;amp;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// .CPP&#xA;// ...&#xA;history = new QStringList();&#xA;model = new QStandardItemModel(0, 1, this);&#xA;completer = new QCompleter(model, this);&#xA;// ui-&amp;gt;command 是一个 QLineEdit&#xA;ui-&amp;gt;command-&amp;gt;setCompleter(completer);&#xA;connect(completer, SIGNAL(activated(const QString&amp;amp;)), this, SLOT(onCommandChoosed(const QString&amp;amp;)));&#xA;// ui-&amp;gt;command 是一个 QLineEdit&#xA;connect(ui-&amp;gt;command, SIGNAL(textChanged(const QString&amp;amp;)), this, SLOT(onCommandChanged(const QString&amp;amp;)));&#xA;// ...&#xA;&#xA;// ...&#xA;void Examples::onCommandChoosed(const QString&amp;amp; _command)&#xA;{&#xA;    // 清除已存在的文本更新内容&#xA;    ui-&amp;gt;command-&amp;gt;clear();&#xA;    ui-&amp;gt;command-&amp;gt;setText(_command);&#xA;}&#xA;&#xA;void Examples::onCommandChanged(const QString&amp;amp; _str)&#xA;{&#xA;    // 清除已经存在的数据&#xA;    model-&amp;gt;removeRows(0, model-&amp;gt;rowCount());&#xA;&#xA;    // 遍历所有的命令, 在内容中查找关键字开头.&#xA;    for (int i = 0; i &amp;lt; history-&amp;gt;size(); ++i)&#xA;    {&#xA;    // 插入包含关键字的数据&#xA;    if (history-&amp;gt;at(i).startsWith(_str))&#xA;    {&#xA;        model-&amp;gt;insertRow(0);&#xA;        model-&amp;gt;setData(model-&amp;gt;index(0, 0), history-&amp;gt;at(i));&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Qt反向调用Go函数管理及使用方法</title>
      <link>http://www.nljb.net/default/Qt%E5%8F%8D%E5%90%91%E8%B0%83%E7%94%A8Go%E5%87%BD%E6%95%B0%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-02-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Qt反向调用Go函数管理及使用方法/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C.char&lt;/li&gt;&#xA;&lt;li&gt;C.schar（signed char）&lt;/li&gt;&#xA;&lt;li&gt;C.uchar（unsigned char）&lt;/li&gt;&#xA;&lt;li&gt;C.short&lt;/li&gt;&#xA;&lt;li&gt;C.ushort（unsigned short）&lt;/li&gt;&#xA;&lt;li&gt;C.int&lt;/li&gt;&#xA;&lt;li&gt;C.uint（unsigned int）&lt;/li&gt;&#xA;&lt;li&gt;C.long&lt;/li&gt;&#xA;&lt;li&gt;C.ulong（unsigned long）&lt;/li&gt;&#xA;&lt;li&gt;C.longlong（long long）&lt;/li&gt;&#xA;&lt;li&gt;C.ulonglong（unsigned long long）&lt;/li&gt;&#xA;&lt;li&gt;C.float&lt;/li&gt;&#xA;&lt;li&gt;C.double&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Golang 的字符串转为 C 字符串&#xA;// C 的字符串是使用 malloc 分配的，因此，此函数的调用者&#xA;// 需要调用 C.free 来释放内存&#xA;func C.CString(string) *C.char&#xA;&#xA;// 转换 C 字符串到 Golang 字符串&#xA;func C.GoString(*C.char) string&#xA;&#xA;// 转换一定长度的 C 字符串到 Golang 字符串&#xA;func C.GoStringN(*C.char, C.int) string&#xA;&#xA;// 转换一块 C 内存区域到 Golang 的字节数组中去&#xA;func C.GoBytes(unsafe.Pointer, C.int) []byte&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;简单说一下&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在Go中将Go-&amp;gt;C函数通过函数指针(void*)传入Qt中进行使用&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Go-&amp;gt;C传入Qt&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如果看过我之前几篇介绍，这里就不用多说了吧&#xA;/*&#xA;    extern void cgo_init();&#xA;    extern int cgo_start();&#xA;    extern void drv_cgo_callback(void*, void*);&#xA;    static void callback()&#xA;    {   &#xA;        char * _cgo_connect = &amp;quot;cgo_connect&amp;quot;;&#xA;        extern int cgo_connect(void*, int); // Go -&amp;gt; C&#xA;        drv_cgo_callback(_cgo_connect, &amp;amp;cgo_connect); // 将 Go -&amp;gt; C 传入 Qt&#xA;&#xA;    }&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -lexamples&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;&#xA;func start() {&#xA;    // 需要注意的是先通过函数调用Qt里面的初始化函数初始化类，以便存储Go -&amp;gt; C的函数&#xA;    C.cgo_init()&#xA;    // 将 Go -&amp;gt; C 传入 Qt&#xA;    C.callback()    &#xA;    // 运行&#xA;    C.cgo_start()&#xA;}&#xA;&#xA;// Go -&amp;gt; C&#xA;//export cgo_connect &#xA;func cgo_connect(_content unsafe.Pointer, _size C.int) C.int {&#xA;    device := string(C.GoBytes(_content, _size))&#xA;    log.Println(&amp;quot;Go-&amp;gt;&amp;quot;, device)&#xA;    if err := StaticConn.Connect(device, &amp;quot;1.0.1&amp;quot;); err != nil {&#xA;        return C.int(0)&#xA;    }&#xA;    return C.int(1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;Qt 里面看一下&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef CGO_H&#xA;#define CGO_H&#xA;&#xA;#include &amp;lt;map&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;// 定义将函数指针转换回来的函数类型&#xA;typedef int (*COMMAND_CGO_CONNECT_FUNCTION)(void*, int);&#xA;typedef int (*COMMAND_CGO_CHECKCONN_FUNCTION)();&#xA;typedef void (*COMMAND_CGO_DISCONN_FUNCTION)();&#xA;typedef void (*COMMAND_CGO_COMMAND_FUNCTION)(void*, int);&#xA;typedef void (*COMMAND_CGO_SHORTCUTS_FUNCTION)(void*, int);&#xA;typedef void * (*COMMAND_CGO_MESSAGE_FUNCTION)();&#xA;typedef int (*COMMAND_CGO_GOLINE_FUNCTION)(void*, int);&#xA;&#xA;// 定义一个类&#xA;class Cgo&#xA;{&#xA;public:&#xA;    Cgo();&#xA;    // 将函数指针存入本类&#xA;    int setCgo(void*, void*);&#xA;public:&#xA;    // 所有需要用到的Go函数&#xA;    COMMAND_CGO_CONNECT_FUNCTION cgo_connect;&#xA;    COMMAND_CGO_CHECKCONN_FUNCTION cgo_checkconn;&#xA;    COMMAND_CGO_DISCONN_FUNCTION cgo_disconn;&#xA;    COMMAND_CGO_COMMAND_FUNCTION cgo_command;&#xA;    COMMAND_CGO_SHORTCUTS_FUNCTION cgo_shortcuts;&#xA;    COMMAND_CGO_MESSAGE_FUNCTION cgo_message;&#xA;    COMMAND_CGO_GOLINE_FUNCTION cgo_goline;&#xA;};&#xA;&#xA;#endif // CGO_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这里就不多说了.&#xA;#include &amp;quot;cgo.h&amp;quot;&#xA;#include &amp;lt;QString&amp;gt;&#xA;&#xA;Cgo::Cgo()&#xA;{&#xA;    cgo_connect = 0;&#xA;    cgo_checkconn = 0;&#xA;    cgo_disconn = 0;&#xA;    cgo_command = 0;&#xA;    cgo_shortcuts = 0;&#xA;    cgo_message = 0;&#xA;    cgo_goline = 0;&#xA;}&#xA;&#xA;int Cgo::setCgo(void* _a, void* _b)&#xA;{&#xA;    if (QString(&amp;quot;cgo_connect&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_connect = (COMMAND_CGO_CONNECT_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_checkconn&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_checkconn = (COMMAND_CGO_CHECKCONN_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_disconn&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_disconn = (COMMAND_CGO_DISCONN_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_command&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_command = (COMMAND_CGO_COMMAND_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_shortcuts&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_shortcuts = (COMMAND_CGO_SHORTCUTS_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_message&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_message = (COMMAND_CGO_MESSAGE_FUNCTION)_b;&#xA;    if (QString(&amp;quot;cgo_goline&amp;quot;).compare((char*)_a) == 0)&#xA;    cgo_goline = (COMMAND_CGO_GOLINE_FUNCTION)_b;&#xA;    return 1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;主要说一下，函数传递进来，怎么用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 所有会用到Go函数的类都需要有(Cgo *cgo 和 setCgo(Cgo*))&#xA;class Examples : public QMainWindow&#xA;{&#xA;    Q_OBJECT&#xA;&#xA;public:&#xA;    explicit Examples(QWidget *parent = 0);&#xA;    ~Examples();&#xA;&#xA;public:&#xA;    QTimer* timer;&#xA;    Cgo* cgo; // 这里&#xA;&#xA;public:&#xA;&#xA;    void sendDisplay(const char *);&#xA;&#xA;    int setCgo(Cgo*); // 这里&#xA;&#xA;.........&#xA;&#xA;// 另一个，QDialog 里面也是一样&#xA;class Connect : public QDialog&#xA;{&#xA;    Q_OBJECT&#xA;&#xA;public:&#xA;    explicit Connect(QWidget *parent = 0);&#xA;    ~Connect();&#xA;&#xA;public:&#xA;    Cgo *cgo;&#xA;&#xA;public:&#xA;    int setCgo(Cgo*);&#xA;&#xA;.......&#xA;&#xA;// 至于怎么设置，不用我说了吧&#xA;int Connect::setCgo(Cgo *_a)&#xA;{&#xA;    cgo = _a;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;也就是说，新建一个Cgo类，把所有Go传入进来的类型都放到里面去，然后传到QT类里面!!!&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void Examples::sendMessage()&#xA;{&#xA;    // 这里用了 Examples 里面的 cgo&#xA;    void * p = cgo-&amp;gt;cgo_message();&#xA;    QString command = (char*)p;&#xA;    if (!command.isEmpty())&#xA;    {&#xA;    QMessageBox::information(this, tr(&amp;quot;提示&amp;quot;), tr(command.toLatin1().data()), QMessageBox::Yes);&#xA;    }&#xA;}&#xA;&#xA;// 这里为了让 Connect 也能用所以传入 cgo&#xA;void Examples::on_connect_triggered()&#xA;{&#xA;    Connect conn(this);&#xA;    conn.setCgo(cgo);&#xA;    conn.exec();&#xA;}&#xA;&#xA;.......&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;初始化 cgo_init 所调用函数&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;examples.h&amp;quot;&#xA;#include &amp;quot;cgo.h&amp;quot;&#xA;#include &amp;lt;QApplication&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;// ...&#xA;Examples * win;&#xA;&#xA;// ...&#xA;Cgo * cgo;&#xA;&#xA;// C.cgo_init 这里很重要，要先把, Cgo 初始化.&#xA;extern &amp;quot;C&amp;quot; void cgo_init()&#xA;{&#xA;    cgo = new Cgo();&#xA;}&#xA;&#xA;// C.cgo_start&#xA;extern &amp;quot;C&amp;quot; int cgo_start()&#xA;{&#xA;    int argc = 0 ;&#xA;    char *argv[] = {};&#xA;    QApplication a(argc, argv);&#xA;    QTextCodec::setCodecForTr(QTextCodec::codecForName(&amp;quot;UTF-8&amp;quot;));&#xA;    win = new Examples();&#xA;    win-&amp;gt;setCgo(cgo);&#xA;    win-&amp;gt;show();&#xA;    return a.exec();&#xA;}&#xA;&#xA;// 这是一个 Go 调用 C 函数 C.cgo_callback&#xA;extern &amp;quot;C&amp;quot; void cgo_callback(void * p)&#xA;{&#xA;    win-&amp;gt;sendDisplay((char*)p);&#xA;}&#xA;&#xA;// 这里，在 Go 中调用，传入函数&#xA;extern &amp;quot;C&amp;quot; void drv_cgo_callback(void* _a, void* _b)&#xA;{&#xA;    cgo-&amp;gt;setCgo(_a, _b);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>关于最近用Golang和Qt混写程序所遇到的坑</title>
      <link>http://www.nljb.net/default/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E7%94%A8Golang%E5%92%8CQt%E6%B7%B7%E5%86%99%E7%A8%8B%E5%BA%8F%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</link>
      <pubDate>2015-01-31 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;先说 Mac os 下面吧&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;一路上顺风顺水。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;总结了一下，CGO所使用的原理，在Go里面调用C的程序&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实就是使用了C++的一个特性，extern&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 网上是这样解释的&#xA;extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中&#xA;提示编译器遇到此变量和函数时在其他模块中寻找其定义。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当你对一个函数 extern 声明后，这个函数你就可以使用了，但是其实它并不存在，需要Go去生成&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Go 生成有个前地，就是在这个函数上面加一行(//export cgo_connect)，cgo_connect 就是函数名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是当使用的时候，其实Go已经生成好了，编译到程序里面，所以运行的就是所以 Cgo 的程序&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以通过一个命令来看 Go 中间做了什么&#xA;go tool cgo xxx.go&#xA;// 这 xxx.go 里面要写的就是下面这些C与Go的混合代码&#xA;/*&#xA;// 这里看到 extern 了把，使用这个的函数，只有三个地方存在&#xA;// 一，注释内&#xA;// 二，Go 内用 //export drv_cgo_connect 实现的&#xA;// 三，在 C 里面实现的（可能是文件，也可能是库) &#xA;extern void drv_cgo_connect(int (*)(void *, int));&#xA;static void init_callback()&#xA;{&#xA;    extern int cgo_connect(void *, int);&#xA;    drv_cgo_connect(&amp;amp;cgo_connect);&#xA;}&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -lexamples // 库内有一切，不仅调用，还可以互访&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;&#xA;func start() {&#xA;    C.init_callback()&#xA;}&#xA;&#xA;// 这里就是生成了一个 C 的 cgo_connect 函数&#xA;// 想要在 C 中使用这个函数，就需要在 C 里面 extern int cgo_connect(...) 才可以.&#xA;//export cgo_connect &#xA;func cgo_connect(_content unsafe.Pointer, _size C.int) C.int {&#xA;    device := string(C.GoBytes(_content, _size))&#xA;    log.Println(&amp;quot;Go-&amp;gt;&amp;quot;, device)&#xA;    if err := StaticConn.Connect(device); err != nil {&#xA;        return C.int(0)&#xA;    }&#xA;    return C.int(1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样一来，你就可以在 Go 里面调用 C 里面实现的函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样原理，如果 C 想要调用 Go 的函数，相同方法，只是把 extern 调换一下!&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;上面简单的了解了一下，CGO 原理，现在说一下具体情况，比如 QT 这样庞大的程序&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;对于 QT 这样的大程序，而且涉及到 QMake 编译，所以使用 CGO 本身混编(.go,.c.,.h)就没戏了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以怎么办呢，这位同学说对了，就是这样，使用库（windows是dll)(linux是so)(mac是dylib)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将 QT 的 .Pro 文件改一下 TEMPLATE = lib 这样就会生成库文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是上面的同学问了，库文件能被Go调用，那库文件怎么调用Go呢&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;问题就来了，我试验了无数次。坑，坑，坑！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你想到了，extern 没错，但是 extern 的函数需要在本库中找到实现的函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于Cgo里面，你没有实现是因为你设置了 //export 所以 Go 就帮你做了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以怎么办，对了，你想到，go tool cgo 把 C 编译出来，导入到 QT 中不就了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;错，大错特错，编译出来的文件，不完整，可远观，不可近玩嫣！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我试的时候虽然能编译过，但是 Go 转 C 的函数根本没运行&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这样一来，楼上的同学哭了，那怎么办啊。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;当当当当～！在这里用到了 C++ 的另外一个关键字 inline 隆重出马&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 网上这样介绍的&#xA;inline关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也就是说，你在C库中用inline定义一个空函数，然后使用TA，然后在Go里面用//export 定义一个同名函数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样一来，C里面就使用的不是inline定义的函数，而是你Go里面的函数了，天哪，太简单，太方便了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/关于最近用Golang和Qt混写程序所遇到的坑/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;再说 Windows 这个坑吧&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;当你 Mac 或者 Linux 按照上面方法，写完了，你可能兴高采烈的跑去 windows 编译&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当你 费了 九牛二虎之力，把环境编译好了，之后呢，编译呗，坑坑坑，恭喜，你又掉坑里了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个问题，我找啊找，查啊查，费了就牛二老之力，找到了问题了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;问题就是 inline  // 网上是这样说的&#xA;inline说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。&#xA;比如，你将一个长达1000多行的函数指定为inline，编译器就会忽略这个inline，将这个函数还原成普通函数。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;天哪，看编译器心情吗，在 Mac 里面就用 Go 里面 原始函数，在 Windows 下面就选择了，inline 定义的空函数，这可怎么办啊。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;网上一顿乱找，什么，强制 inline ，编译器不优化，一顿乱找，搞不定啊。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后来听说，windows 对 dll 有特殊限制，有些 关键字无法传递，比如 inline ,所以，唉！！！，没办法.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然不用 inline 也就不能用 extern 因为 只有加了 extern inline 的函数才变成实际存在的，如果去掉 inline&lt;/p&gt;&#xA;&#xA;&lt;p&gt;编译器会一直提示你，没有找到，没有找到，没有找到。啊啊啊啊啊啊啊！&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;找啊找，查啊查，坑啊坑。看了一些别人的代码，涉及到的太少，几乎没有&lt;/p&gt;&#xA;&#xA;&lt;p&gt;翻了一下 liteide 的代码，哈哈，看到曙光了，怎么办呢&lt;/p&gt;&#xA;&#xA;&lt;p&gt;是怎么处理的呢，比较复杂，但是可行&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就是在 Cgo 里面自己调用自己的函数，然后 CGo 的方法，把函数指针传到库里去，在库里面搞个全局保存一下.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;    extern void drv_cgo_connect(int (*)(void *, int));&#xA;    static void init_callback()&#xA;    {&#xA;        extern int cgo_connect(void *, int);&#xA;        drv_cgo_connect(&amp;amp;cgo_connect);&#xA;    }&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -lexamples&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;&#xA;func start() {&#xA;    C.init_callback()&#xA;}&#xA;&#xA;//export cgo_connect&#xA;func cgo_connect(_content unsafe.Pointer, _size C.int) C.int {&#xA;    device := string(C.GoBytes(_content, _size))&#xA;    log.Println(&amp;quot;Go-&amp;gt;&amp;quot;, device)&#xA;    if err := StaticConn.Connect(device); err != nil {&#xA;        return C.int(0)&#xA;    }&#xA;    return C.int(1)&#xA;}&#xA;&#xA;// 在 C 里面是这样&#xA;&#xA;typedef int (*COMMAND_CGO_CONNECT_FUNCTION)(void *, int);&#xA;&#xA;typedef int (*COMMAND_CGO_CHECKCONN_FUNCTION)();&#xA;&#xA;COMMAND_CGO_CONNECT_FUNCTION cgo_connect;&#xA;&#xA;COMMAND_CGO_CHECKCONN_FUNCTION cgo_checkconn;&#xA;&#xA;extern &amp;quot;C&amp;quot; void drv_cgo_connect(int (*_a)(void *, int))&#xA;{&#xA;    cgo_connect = _a;&#xA;}&#xA;&#xA;extern &amp;quot;C&amp;quot; void drv_cgo_checkconn(int (*_a)())&#xA;{&#xA;    cgo_checkconn = _a;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样一来，问题解决了，但是复杂了一些，对 Cgo 减10分.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;补充，当 windows 运行的时候 会显示 DOS 窗口，怎么办呢&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go build -ldflags -H=windowsgui &#xA;go build -ldflags -H=windowsgui XXX.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;再次补充：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 可以把函数当指针传，这样就不需要那么多的 drv_cgo_xxx&#xA;/*&#xA;    extern void cgo_init();&#xA;    extern int cgo_start();&#xA;    extern void cgo_callback(void *);&#xA;    extern void drv_cgo_callback(int, void*);&#xA;    extern void drv_cgo_callback_2(int, void*);&#xA;    static void init_callback()&#xA;    {&#xA;        int _cgo_connect = 1;&#xA;        int _cgo_checkconn = 2;&#xA;        int _cgo_disconn = 3;&#xA;        int _cgo_command = 4;&#xA;        int _cgo_shortcuts = 5;&#xA;        int _cgo_message = 6;&#xA;        extern int cgo_connect(void *, int);&#xA;        extern int cgo_checkconn();&#xA;        extern void cgo_disconn();&#xA;        extern void cgo_command(void *, int);&#xA;        extern void cgo_shortcuts(void *, int);&#xA;        extern void * cgo_message();&#xA;        drv_cgo_callback_2(_cgo_connect, &amp;amp;cgo_connect);&#xA;        drv_cgo_callback_2(_cgo_checkconn, &amp;amp;cgo_checkconn);&#xA;        drv_cgo_callback(_cgo_checkconn, &amp;amp;cgo_checkconn);&#xA;        drv_cgo_callback(_cgo_disconn, &amp;amp;cgo_disconn);&#xA;        drv_cgo_callback(_cgo_command, &amp;amp;cgo_command);&#xA;        drv_cgo_callback(_cgo_shortcuts, &amp;amp;cgo_shortcuts);&#xA;        drv_cgo_callback(_cgo_message, &amp;amp;cgo_message);&#xA;    }&#xA;*/&#xA;&#xA;typedef int (*COMMAND_CGO_CONNECT_FUNCTION)(void *, int);&#xA;&#xA;typedef int (*COMMAND_CGO_CHECKCONN_FUNCTION)();&#xA;&#xA;static COMMAND_CGO_CONNECT_FUNCTION cgo_connect = 0;&#xA;&#xA;static COMMAND_CGO_CHECKCONN_FUNCTION cgo_checkconn = 0;&#xA;&#xA;extern &amp;quot;C&amp;quot; void drv_cgo_callback_2(int _a, void * _b)&#xA;{&#xA;    /*&#xA;    int _cgo_connect = 1;&#xA;    int _cgo_checkconn = 2;&#xA;    */&#xA;    switch (_a) {&#xA;    case 1:&#xA;    cgo_connect = (COMMAND_CGO_CONNECT_FUNCTION)_b;&#xA;    break;&#xA;    case 2:&#xA;    cgo_checkconn = (COMMAND_CGO_CHECKCONN_FUNCTION)_b;&#xA;    break;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/关于最近用Golang和Qt混写程序所遇到的坑/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之Go内调用C中Class方法</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BGo%E5%86%85%E8%B0%83%E7%94%A8C%E4%B8%ADClass%E6%96%B9%E6%B3%95/</link>
      <pubDate>2015-01-15 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;介绍&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;之前已经解决了，在Go中调用C函数方法，及在C内调用Go函数方法&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;但是今日在调用QT内方法的时候发现，所有方法都是封装在类对象中的.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;且有些对象无法传递出来，私有对象，私有函数，只能内部调用.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;比如：想在Go里面调用QT的QMessageBox弹出个提示框怎么办&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// C&#xA;// 第一步，全部对象&#xA;Doors * w;&#xA;&#xA;// C    &#xA;// 这里初始化了全局对象(new)&#xA;extern &amp;quot;C&amp;quot; int start()&#xA;{&#xA;    int argc = 0 ;&#xA;    char *argv[] = {};&#xA;    QApplication a(argc, argv);&#xA;    w = new Doors();&#xA;    w-&amp;gt;init();&#xA;    w-&amp;gt;show();&#xA;    return a.exec();&#xA;}&#xA;&#xA;// C&#xA;// 第二步，当然在你的 QWidget 对象中定义一个方法&#xA;void Doors::message(const char * _message)&#xA;{&#xA;    QMessageBox::about(this, tr(&amp;quot;提示&amp;quot;), tr(_message));&#xA;}&#xA;&#xA;// C&#xA;// 第三部，在外面定义一个供Go调用的方法&#xA;extern &amp;quot;C&amp;quot; void message(void * p)&#xA;{&#xA;    w-&amp;gt;message((char*)p);&#xA;}&#xA;&#xA;// Go   &#xA;// 第四步，Go内声明&#xA;/*&#xA;    extern void message(void *);&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -ldoors -framework QtGui&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;&#xA;// Go&#xA;// 第五步，当然是调用了&#xA;// 提示，一定要在 start() 之后使用哦，也就是(new)后. &#xA;C.message(unsafe.Pointer(C.CString(&amp;quot;您如输入命令不支持!&amp;quot;)))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Magic System Request Key</title>
      <link>http://www.nljb.net/default/Magic-System-Request-Key/</link>
      <pubDate>2015-01-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在使用任何办法都无法重启系统时，可以尝试下面的方法&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;此方法放弃保存当前运行的任何数据，直接重启，但是却对硬盘无害。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;echo 1 &amp;gt; /proc/sys/kernel/sysrq&#xA;echo b &amp;gt; /proc/sysrq-trigger&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;/proc/sys/kernel/sysrq&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;向sysrq文件中写入1是为了开启SysRq功能。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;根据linux/Documentations/sysrq.txt中所说：SysRq代表的是Magic System Request Key。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;开启了这个功能以后，只要内核没有挂掉，它就会响应你要求的任何操作。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;但是这需要内核支持(CONFIG_MAGIC_SYSRQ选项)。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;向/proc/sys/kernel/sysrq中写入0是关闭sysrq功能，写入1是开启，其他选项请参考sysrq.txt。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;需要注意的是，/proc/sys/kernel/sysrq中的值只影响键盘的操作。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 将会立即重启系统，并且不会管你有没有数据没有写回磁盘，也不卸载磁盘，而是完完全全的立即重启&#xA;&#39;b&#39;&#xA;// 将会关机&#xA;&#39;o&#39;&#xA;// 将会同步所有以挂在的文件系统&#xA;&#39;s&#39;&#xA;// 将会重新将所有的文件系统挂在为只读属性&#xA;&#39;u&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;/proc/sysrq-trigger&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;从文件名字就可以看出来这两个是有关系的。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;写入/proc/sysrq-trigger中的字符其实就是sysrq.txt中说的&lt;command key&gt;键所对应的字符，其功能也和上述一样。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;所以，这两行命令先开启SysRq功能，然后用&amp;rsquo;b&amp;rsquo;命令让计算机立刻重启。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang Android</title>
      <link>http://www.nljb.net/default/Golang-Android/</link>
      <pubDate>2014-12-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;声明：本文转自(&lt;a href=&#34;http://blog.nzlov.com/article/44/golang-android.html&#34;&gt;http://blog.nzlov.com/article/44/golang-android.html&lt;/a&gt;) , 感谢作者.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;随着Golang发布1.4正式版，Android下的开发也可以实现(go/mobile)了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就等1.5版本的ios支持了，可以使用golang跨平台开发游戏了&amp;hellip;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;环境准备&lt;/h3&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;Ant&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;下载apache-ant并配置好环境变量。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ANT_HOME=antpath //你的ant目录&#xA;$PATH=$ANT_HOME/bin:$PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Android&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;下载SDK,android-ndk-r9d(这里之所以不用r10d是因为在测试时ndk源码出现问题，而r9d没有问题)。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;安装并配置环境变量。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ANDROID_HOME=sdkpath //你的sdk目录&#xA;$NDK_ROOT=ndkpath //你的ndk目录&#xA;$PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$NDK_ROOT:$PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h3&gt;Go&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;1.下载Go，或者克隆。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Git&#xA;$ git clone https://github.com/golang/go.git&#xA;Hg(不推荐使用)&#xA;$ hg clone https://code.google.com/p/go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;2.配置环境变量&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$GOOS=darwin&#xA;$GOARCH=amd64&#xA;$GOROOT=gopath //你的go源码目录&#xA;$GOPATH=goworkpath //你的go工作目录&#xA;$GOBIN=$GOPATH/bin&#xA;$PATH=$GOBIN:$GOROOT/bin:$PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;3.编译 使用console进入go源码目录执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$cd $GOROOT/src&#xA;$./all.bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;4.测试&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$go version&#xA;go version devel +082a237 Fri Dec 12 04:59:51 2014 +0000 darwin/amd64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;构建Golang Android环境&lt;/h3&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;Android NDK交叉环境构建&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$$NDK_ROOT/build/tools/make-standalone-toolchain.sh --platform=android-9 \&#xA;    --install-dir=$NDK_ROOT --system=darwin-x86_64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;执行结果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Auto-config: --toolchain=arm-linux-androideabi-4.6&#xA;Copying prebuilt binaries...&#xA;Copying sysroot headers and libraries...&#xA;Copying libstdc++ headers and libraries...&#xA;Copying files to: /Users/qipeng/program/android/android-ndk-r9d&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Golang 交叉环境构建&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$cd $GOROOT/src&#xA;$CC_FOR_TARGET=$NDK_ROOT/bin/arm-linux-androideabi-gcc GOOS=android \&#xA;    GOARCH=arm GOARM=7 CGO_ENABLED=1  ./make.bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;执行结果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Installed Go for android/arm in /Users/qipeng/program/go&#xA;Installed commands in /Users/qipeng/mac/workspace/go/bin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;测试,使用官方(go/mobile)自带例子测试。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//由于gfw可能无法下载，可以翻墙也可以从Github上下载并move到golang.org/x/mobile下&#xA;$go get golang.org/x/mobile&#xA;$cd $GOPATH/src/golang.org/x/mobile/example/basic&#xA;$./all.bash //最好连接你的手机并开启usb调试，这样编译完成后会直接在手机上运行。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Android/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Bluez之常用命令</title>
      <link>http://www.nljb.net/default/Bluez%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>2014-12-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;启动服务：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; /usr/lib/bluetooth/bluetoothd -C (兼容性)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/usr/lib/systemd/system/bluetooth.service&#xA;&#xA;/etc/bluetooth/ (hcid.conf,main.conf,rfcomm.conf)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装软件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;bluez&#xA;&#xA;obexd&#xA;&#xA;sobexsrv (接收)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;hciconfig hci0 up&#xA;&#xA;hcitool scan &#xA;&#xA;hcidump (状态)&#xA;&#xA;l2ping (Ping)&#xA;&#xA;hciconfig hci0 iscan (可见)&#xA;&#xA;hciconfig hci0 pscan (开启Inquiry Scan和Page Scan,使手机处于可被搜索和可连接状态)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;服务：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;service bluetooth start&#xA;&#xA;bluetoothctl (工具)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;本地增加所有服务：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sdptool add --channel=1 DID SP DUN LAN FAX OPUSH FTP HS HF SAP NAP GN PANU HID CIP CTP A2SRC A2SNK SYNCML NOKID PCSUITE SR1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;检查手机：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sdptool browse 00:66:4B:40:91:44&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;联接手机：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;rfcomm bind 0 00:66:4B:40:91:44 1 (使用的接口及频道)&#xA;&#xA;cat &amp;gt;/dev/rfcomm0 (配对)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;发送：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;obex_test -b 00:66:4B:40:91:44 7 (需要选择模式和信道)&#xA;&#xA;obexftp -b 00:66:4B:40:91:44 -B 12 -U none -p /root/json.json&#xA;&#xA;obexfs …&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之CGO与QT相互传参</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BCGO%E4%B8%8EQT%E7%9B%B8%E4%BA%92%E4%BC%A0%E5%8F%82/</link>
      <pubDate>2014-12-25 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;暂时还没考虑到，对指针释放的问题 &amp;hellip;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang之CGO与QT相互传参/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;cgo.h&amp;quot;&#xA;#include &amp;quot;doors.h&amp;quot;&#xA;#include &amp;quot;ui_doors.h&amp;quot;&#xA;#include &amp;lt;QtGui&amp;gt;&#xA;&#xA;Doors::Doors(QWidget *parent) :&#xA;    QMainWindow(parent),&#xA;    ui(new Ui::Doors)&#xA;{&#xA;    ui-&amp;gt;setupUi(this);&#xA;}&#xA;&#xA;Doors::~Doors()&#xA;{&#xA;    delete ui;&#xA;}&#xA;&#xA;// 主要是这里，从 request 传入字符串，并返回字符串&#xA;void Doors::on_pushButton_clicked() {&#xA;    string x = &amp;quot;xxxxxx&amp;quot;;&#xA;    void * p = request((void*)x.c_str(), x.length());&#xA;    QMessageBox::question(this, &amp;quot;hello&amp;quot;, tr((char*)p), QMessageBox::Yes, QMessageBox::No);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang之CGO与QT相互传参/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// CGO 的灵魂，声明一个函数，等待GO定义&#xA;#include &amp;lt;string&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;extern &amp;quot;C&amp;quot; inline void * request(void *, int) { /* CGO */ }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang之CGO与QT相互传参/3.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Go 内是定义&#xA;package main&#xA;&#xA;/*&#xA;    extern void init();&#xA;    extern int start();&#xA;    // 修正，此处 export 下无需声明&#xA;    // extern void * request(void *, int);&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -ldoors&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;func main() {&#xA;    C.init()&#xA;    C.start()&#xA;}&#xA;&#xA;//export request&#xA;func request(_content unsafe.Pointer, _size C.int) unsafe.Pointer {&#xA;    fmt.Println(string(C.GoBytes(_content, _size)))&#xA;    content := unsafe.Pointer(C.CString(&amp;quot;你好, Golang&amp;quot;))&#xA;    defer func() {&#xA;        C.free(content)&#xA;    }()&#xA;    return unsafe.Pointer(content)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go之C中声明-Go内定义-C里调用</title>
      <link>http://www.nljb.net/default/Go%E4%B9%8BC%E4%B8%AD%E5%A3%B0%E6%98%8E-Go%E5%86%85%E5%AE%9A%E4%B9%89-C%E9%87%8C%E8%B0%83%E7%94%A8/</link>
      <pubDate>2014-12-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/c-go-cgo&#34;&gt;http://blog.golang.org/c-go-cgo&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;说起来容易，做起来难啊，研究了两天了 &amp;hellip;&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Go之C中声明-Go内定义-C里调用/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// extern &amp;quot;C&amp;quot; 就不说了&#xA;// inline 多处定义 ... 这样就可以在 Go 中定义了 ...&#xA;extern &amp;quot;C&amp;quot; inline void drv_appmain() { /* CGO */ }&#xA;&#xA;// 在 start() 函数内, 调用 drv_appmain()&#xA;// 也就是 Go 中的 drv_appmain() 了.&#xA;extern &amp;quot;C&amp;quot; int start() {&#xA;    drv_appmain();&#xA;    int argc = 0;&#xA;    char **argv = 0;&#xA;    QApplication a(argc, argv);&#xA;    QDialog w;&#xA;    QTabWidget t(&amp;amp;w);&#xA;    t.resize(800, 600);&#xA;    QWidget widget_a;&#xA;    QWidget widget_b;&#xA;    widget_a.resize(800,600);&#xA;    widget_b.resize(800,600);&#xA;    t.addTab(&amp;amp;widget_a,  &amp;quot;0&amp;quot;);&#xA;    t.addTab(&amp;amp;widget_b,  &amp;quot;1&amp;quot;);&#xA;    QMessageBox x;&#xA;    x.show();&#xA;    w.show();&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Go之C中声明-Go内定义-C里调用/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Go中做了什么呢 ...&#xA;// 声明一下，使用的函数 &#xA;// 调用启动函数 start()&#xA;// 这句 //export drv_appmain 是必不可少的 ...&#xA;// 在里面用Go畅所欲言吧...&#xA;// 要注意的是，需要使用 C.int , C.uint ...&#xA;package main&#xA;&#xA;/*&#xA;    extern int start();&#xA;    // 此处错误修正, export 下不需要此处声明&#xA;    // extern void drv_appmain(); &#xA;*/&#xA;// #cgo LDFLAGS: -L./ -ldemo&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;func main() {&#xA;    C.start()&#xA;}&#xA;&#xA;//export drv_appmain&#xA;func drv_appmain() {&#xA;    fmt.Println(&amp;quot;xxx&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;传参呢&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 比如 增加一个 int 返回值&#xA;extern &amp;quot;C&amp;quot; inline int drv_appmain() { /* CGO */ }&#xA;&#xA;// 调用输出这个值&#xA;extern &amp;quot;C&amp;quot; int start() {&#xA;    int i = drv_appmain();&#xA;    qDebug(&amp;quot;-&amp;gt; %d&amp;quot;, i);&#xA;}&#xA;&#xA;// Go里面当然是 ...&#xA;//export drv_appmain&#xA;func drv_appmain() C.int {&#xA;    return 100&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之CGO与QT绑定编译</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8BCGO%E4%B8%8EQT%E7%BB%91%E5%AE%9A%E7%BC%96%E8%AF%91/</link>
      <pubDate>2014-12-23 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;随便写个QT窗口&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang之CGO与QT绑定编译/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;将代码编译成库文件&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang之CGO与QT绑定编译/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;Go中调用这个函数&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang之CGO与QT绑定编译/3.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;完成&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang之CGO与QT绑定编译/4.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;字符串参数传递&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;QtGui&amp;gt;&#xA;&#xA;extern &amp;quot;C&amp;quot; void qtDebug(const char *typeName)&#xA;{&#xA;    qDebug() &amp;lt;&amp;lt; &amp;quot;Debug:&amp;quot; &amp;lt;&amp;lt; typeName;&#xA;}&#xA;&#xA;extern &amp;quot;C&amp;quot; int start(const char *typeName) {&#xA;&#xA;    int argc =0;&#xA;    char **argv = 0;&#xA;    QApplication a(argc, argv);&#xA;    QDialog w;&#xA;    QLabel l(&amp;amp;w);&#xA;    l.setText(typeName);&#xA;    w.show();&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;/*&#xA;    extern int start(const char *typeName);&#xA;    extern void qtDebug(const char *typeName);&#xA;*/&#xA;// #include &amp;lt;stdio.h&amp;gt;&#xA;// #include &amp;lt;stdlib.h&amp;gt;&#xA;// #cgo LDFLAGS: -L./ -ldemo&#xA;import &amp;quot;C&amp;quot;&#xA;import &amp;quot;unsafe&amp;quot;&#xA;&#xA;func main() {&#xA;    cTypeName := C.CString(&amp;quot;abc&amp;quot;)&#xA;    C.qtDebug(cTypeName)&#xA;    C.start(cTypeName)&#xA;    C.free(unsafe.Pointer(cTypeName))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-如何使用蓝牙</title>
      <link>http://www.nljb.net/default/Linux-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99/</link>
      <pubDate>2014-12-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;lsusb&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Linux-如何使用蓝牙/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;运行hciconfig可以看到：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Linux-如何使用蓝牙/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;从上图可以看出，我们的蓝牙设备是 hci0&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;查看我们的蓝牙设备的硬件地址:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;hcitool dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;运行hcitoo &amp;ndash;help 可以查看更多相关命令&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;然后我们激活它：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo hciconfig hci0 up&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;要注意的是，激活前蓝牙必须是打开的，否则会出现如下错误：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Linux-如何使用蓝牙/3.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;然后我们开始扫描了：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;hcitool scan&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Linux-如何使用蓝牙/4.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;可以看到，发现了我手机的蓝牙了~~&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;然后我们要开始连接了，连接阶段使用的主要命令是&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;rfcomm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;查看用法:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;rfcomm --help&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;首先需要绑定目的蓝牙设备：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo rfcomm bind /dev/rfcomm0 E0:A6:70:8C:A3:02&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;注意：上面的这个地址是目的蓝牙设备的硬件地址&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;接着我们连接它：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo cat &amp;gt;/dev/rfcomm0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这是目的蓝牙主机就会弹出一个对话框要求输入pin码，随便输入一个.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后主机就会弹出一个对话框，只要输入的和刚才一致就可以通过验证。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之后我们发现我的手机已经显示了成功配对的标记了。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;在配对完成之后我们需要删除绑定（否则在下次使用时会提示设备正忙），命令如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo rfcomm release /dev/rfcomm0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang Package Sync</title>
      <link>http://www.nljb.net/default/Golang-Package-Sync/</link>
      <pubDate>2014-12-10 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;import &amp;quot;sync&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Locker interface {&#xA;    Lock()&#xA;    Unlock()&#xA;}&#xA;// Locker接口代表一个可以加锁和解锁的对象。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Once struct {&#xA;    // 包含隐藏或非导出字段&#xA;}&#xA;// Once是只执行一次动作的对象。&#xA;&#xA;func (o *Once) Do(f func())&#xA;    // Do方法当且仅当第一次被调用时才执行函数f。换句话说，给定变量：&#xA;&#xA;var once Once&#xA;    // 如果once.Do(f)被多次调用，只有第一次调用会执行f，即使f每次调用Do 提供的f值不同。&#xA;&#xA;// 需要给每个要执行仅一次的函数都建立一个Once类型的实例。&#xA;&#xA;// Do用于必须刚好运行一次的初始化。&#xA;&#xA;// 因为f是没有参数的，因此可能需要使用闭包来提供给Do方法调用：&#xA;config.once.Do(func() { config.init(filename) })&#xA;// 因为只有f返回后Do方法才会返回，f若引起了Do的调用，会导致死锁。&#xA;&#xA;var once sync.Once&#xA;onceBody := func() {&#xA;    fmt.Println(&amp;quot;Only once&amp;quot;)&#xA;}&#xA;done := make(chan bool)&#xA;for i := 0; i &amp;lt; 10; i++ {&#xA;    go func() {&#xA;    once.Do(onceBody)&#xA;    done &amp;lt;- true&#xA;    }()&#xA;}&#xA;for i := 0; i &amp;lt; 10; i++ {&#xA;    &amp;lt;-done&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Mutex struct {&#xA;    // 包含隐藏或非导出字段&#xA;}&#xA;// Mutex是一个互斥锁，可以创建为其他结构体的字段；&#xA;// 零值为解锁状态。Mutex类型的锁和线程无关，可以由不同的线程加锁和解锁。&#xA;&#xA;func (m *Mutex) Lock()&#xA;// Lock方法锁住m，如果m已经加锁，则阻塞直到m解锁。&#xA;&#xA;func (m *Mutex) Unlock()&#xA;// Unlock方法解锁m，如果m未加锁会导致运行时错误。&#xA;// 锁和线程无关，可以由不同的线程加锁和解锁。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type RWMutex struct {&#xA;        // 包含隐藏或非导出字段&#xA;}&#xA;// RWMutex是读写互斥锁。&#xA;// 该锁可以被同时多个读取者持有或唯一个写入者持有。&#xA;// RWMutex可以创建为其他结构体的字段；零值为解锁状态。&#xA;// RWMutex类型的锁也和线程无关，可以由不同的线程加读取锁/写入和解读取锁/写入锁。&#xA;&#xA;func (rw *RWMutex) Lock()&#xA;// Lock方法将rw锁定为写入状态，禁止其他线程读取或者写入。&#xA;&#xA;func (rw *RWMutex) Unlock()&#xA;// Unlock方法解除rw的写入锁状态，如果m未加写入锁会导致运行时错误。&#xA;&#xA;func (rw *RWMutex) RLock()&#xA;// RLock方法将rw锁定为读取状态，禁止其他线程写入，但不禁止读取。&#xA;&#xA;func (rw *RWMutex) RUnlock()&#xA;// Runlock方法解除rw的读取锁状态，如果m未加读取锁会导致运行时错误。&#xA;&#xA;func (rw *RWMutex) RLocker() Locker&#xA;// Rlocker方法返回一个互斥锁，通过调用rw.Rlock和rw.Runlock实现了Locker接口。 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type WaitGroup struct {&#xA;        // 包含隐藏或非导出字段&#xA;}&#xA;// WaitGroup用于等待一组线程的结束。&#xA;// 父线程调用Add方法来设定应等待的线程的数量。&#xA;// 每个被等待的线程在结束时应调用Done方法。&#xA;// 同时，主线程里可以调用Wait方法阻塞至所有线程结束。&#xA;&#xA;var wg sync.WaitGroup&#xA;var urls = []string{&#xA;    &amp;quot;http://www.golang.org/&amp;quot;,&#xA;    &amp;quot;http://www.google.com/&amp;quot;,&#xA;    &amp;quot;http://www.somestupidname.com/&amp;quot;,&#xA;}&#xA;for _, url := range urls {&#xA;    // Increment the WaitGroup counter.&#xA;    wg.Add(1)&#xA;    // Launch a goroutine to fetch the URL.&#xA;    go func(url string) {&#xA;    // Decrement the counter when the goroutine completes.&#xA;    defer wg.Done()&#xA;    // Fetch the URL.&#xA;    http.Get(url)&#xA;    }(url)&#xA;}&#xA;// Wait for all HTTP fetches to complete.&#xA;wg.Wait()&#xA;&#xA;func (wg *WaitGroup) Add(delta int)&#xA;// Add方法向内部计数加上delta，delta可以是负数；&#xA;// 如果内部计数器变为0，Wait方法阻塞等待的所有线程都会释放，如果计数器小于0，方法panic。&#xA;// 注意Add加上正数的调用应在Wait之前，否则Wait可能只会等待很少的线程。&#xA;// 一般来说本方法应在创建新的线程或者其他应等待的事件之前调用。&#xA;&#xA;func (wg *WaitGroup) Done()&#xA;// Done方法减少WaitGroup计数器的值，应在线程的最后执行。&#xA;&#xA;func (wg *WaitGroup) Wait()&#xA;// Wait方法阻塞直到WaitGroup计数器减为0。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Cond struct {&#xA;    // 在观测或更改条件时L会冻结&#xA;    L Locker&#xA;    // 包含隐藏或非导出字段&#xA;}&#xA;// Cond实现了一个条件变量，一个线程集合地，供线程等待或者宣布某事件的发生。&#xA;&#xA;// 每个Cond实例都有一个相关的锁（一般是*Mutex或*RWMutex类型的值）&#xA;// 它必须在改变条件时或者调用Wait方法时保持锁定。&#xA;// Cond可以创建为其他结构体的字段，Cond在开始使用后不能被拷贝。&#xA;&#xA;func NewCond(l Locker) *Cond&#xA;// 使用锁l创建一个*Cond。&#xA;&#xA;func (c *Cond) Broadcast()&#xA;// Broadcast唤醒所有等待c的线程。&#xA;// 调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。&#xA;&#xA;func (c *Cond) Signal()&#xA;// Signal唤醒等待c的一个线程（如果存在）。&#xA;// 调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。&#xA;&#xA;func (c *Cond) Wait()&#xA;// Wait自行解锁c.L并阻塞当前线程，在之后线程恢复执行时，Wait方法会在返回前锁定c.L。&#xA;// 和其他系统不同，Wait除非被Broadcast或者Signal唤醒，不会主动返回。&#xA;&#xA;// 因为线程中Wait方法是第一个恢复执行的，而此时c.L未加锁。&#xA;// 调用者不应假设Wait恢复时条件已满足，相反，调用者应在循环中等待：&#xA;&#xA;c.L.Lock()&#xA;for !condition() {&#xA;    c.Wait()&#xA;}&#xA;... make use of condition ...&#xA;c.L.Unlock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 本博客另行介绍&#xA;type Pool struct {&#xA;    // 可选参数New指定一个函数在Get方法可能返回nil时来生成一个值&#xA;    // 该参数不能在调用Get方法时被修改&#xA;    New func() interface{}&#xA;    // 包含隐藏或非导出字段&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Redis最佳的Go语言驱动</title>
      <link>http://www.nljb.net/default/Redis%E6%9C%80%E4%BD%B3%E7%9A%84Go%E8%AF%AD%E8%A8%80%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>2014-12-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在redis的官网，golang驱动有几个，忽然来了兴致，那个才是redis最佳的Go语言驱动？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些驱动都处于开发的前期，还没有发行正式版，有些已经很久没更新了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从更新日期来看，Gary Burd的radigo和gosexy的redis最近有更新，而且从他们的README文件来看，他们对redis的支持还不错。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在gosexy的redis源码库中的有个_benchmarks文件，里面就是一些对各个redis的Go驱动的一些简单的性能测试。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单看了一下，里面的代码就是调用他们各自包中的函数来达到测试的功能。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go get github.com/alphazero/Go-Redis&#xA;go get github.com/simonz05/godis&#xA;go get github.com/garyburd/redigo&#xA;go get github.com/gosexy/redis&#xA;go get cgl.tideland.biz/redis&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Redis最佳的Go语言驱动/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Redis最佳的Go语言驱动/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;测试的数据中，GosexyRedis几乎赢得了所有的测试（除了LRange100输给了GaryburdRedigo），GaryburdRedigo基本上是排老二。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而使用gosexy的数据，除了tcgl，其他4个的数据相差不大&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而GaryburdRedigo还是赢得了LRange100测试，说明在数量比较大的list方面，GaryburdRedigo是十分有优势的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从上面的数据可以知道，set, get, incr,lpush的操作耗时都在40微秒左右，那就是1s里面能够操作25000次左右。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>将Go编译成JavaScript之GopherJS工具</title>
      <link>http://www.nljb.net/default/%E5%B0%86Go%E7%BC%96%E8%AF%91%E6%88%90JavaScript%E4%B9%8BGopherJS%E5%B7%A5%E5%85%B7/</link>
      <pubDate>2014-12-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;GopherJS 可以将 Go 代码编译成纯 JavaScript 代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其主要目的是为了让你可以使用 Go 来编写前端代码，这些代码可执行在浏览器上运行。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你可以通过这里尝试下 GopherJS： GopherJS Playground.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例如 JavaScript 代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;document.write(&amp;quot;Hello world!&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;用 GopherJS 来写就变成这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;js.Global.Get(&amp;quot;document&amp;quot;).Call(&amp;quot;write&amp;quot;, &amp;quot;Hello world!&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;好像复杂了不少，函数调用这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;github.com/gopherjs/gopherjs/js&amp;quot;&#xA;&#xA;func main() {&#xA;  js.Global.Set(&amp;quot;myLibrary&amp;quot;, map[string]interface{}{&#xA;    &amp;quot;someFunction&amp;quot;: someFunction,&#xA;  })&#xA;}&#xA;&#xA;func someFunction() {&#xA;  [...]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之广播时间戳</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8B%E5%B9%BF%E6%92%AD%E6%97%B6%E9%97%B4%E6%88%B3/</link>
      <pubDate>2014-12-01 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// Broadcast.h&#xA;#ifndef BROADCAST_H&#xA;#define BROADCAST_H&#xA;&#xA;class Broadcast&#xA;{&#xA;public:&#xA;    Broadcast();&#xA;public:&#xA;    static void run();&#xA;    void start();&#xA;};&#xA;&#xA;#endif // BROADCAST_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Broadcast.cpp&#xA;#include &amp;quot;include/Broadcast.h&amp;quot;&#xA;#include &amp;quot;include/Context.h&amp;quot;&#xA;#include &amp;quot;include/Utils.h&amp;quot;&#xA;#include &amp;lt;boost/thread.hpp&amp;gt;&#xA;#include &amp;lt;boost/asio.hpp&amp;gt;&#xA;#include &amp;lt;boost/lexical_cast.hpp&amp;gt;&#xA;#include &amp;lt;glog/logging.h&amp;gt;&#xA;#include &amp;lt;boost/format.hpp&amp;gt;&#xA;&#xA;using namespace std;&#xA;using namespace boost;&#xA;using namespace boost::asio;&#xA;using boost::asio::ip::udp;&#xA;using boost::asio::ip::address;&#xA;&#xA;Broadcast::Broadcast(){}&#xA;&#xA;void Broadcast::run()&#xA;{&#xA;    Broadcast broadcast;&#xA;    broadcast.start();&#xA;}&#xA;&#xA;void Broadcast::start()&#xA;{&#xA;    try&#xA;    {&#xA;    io_service ios;&#xA;    boost::system::error_code error;&#xA;    int port = Context::GetContext()-&amp;gt;config-&amp;gt;GetInt(&amp;quot;config.broadcast_port&amp;quot;, 55601);&#xA;    udp::socket sock(ios, udp::endpoint(udp::v4(), port));&#xA;    boost::asio::socket_base::broadcast option(true);&#xA;    sock.set_option(option);&#xA;    udp::endpoint destination(address::from_string(&amp;quot;255.255.255.255&amp;quot;), port);&#xA;    while(true)&#xA;    {&#xA;        uint64_t nano = Utils::GetTimeNS();&#xA;        string ns = lexical_cast&amp;lt;string&amp;gt;(nano);&#xA;        sock.send_to(buffer(ns, ns.size()), destination, 0, error);&#xA;        if(error)&#xA;        {&#xA;        LOG(ERROR) &amp;lt;&amp;lt; format(&amp;quot;Broadcast:: %s&amp;quot;) % boost::system::system_error(error).what() &amp;lt;&amp;lt; endl;&#xA;        }&#xA;        sleep(10);&#xA;    }&#xA;    }&#xA;    catch (std::exception&amp;amp; e)&#xA;    {&#xA;    LOG(ERROR) &amp;lt;&amp;lt; format(&amp;quot;Broadcast:: %s&amp;quot;) % e.what() &amp;lt;&amp;lt; endl;&#xA;    abort();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go-SSH-使用</title>
      <link>http://www.nljb.net/default/Go-SSH-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2014-11-26 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;建立连接 (密码登陆模式)&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;&#xA;    &amp;quot;code.google.com/p/go.crypto/ssh&amp;quot;&#xA;)&#xA;&#xA;type Node struct {&#xA;    User     string&#xA;    Password string&#xA;}&#xA;&#xA;func NewNode(user, password string) *Node {&#xA;    node := new(Node)&#xA;    node.User = user&#xA;    node.Password = password&#xA;    return node&#xA;}&#xA;&#xA;func (this *Node) Conn(addr string) (*ssh.Client, error) {&#xA;&#xA;    authMethods := []ssh.AuthMethod{}&#xA;&#xA;    keyboardInteractiveChallenge := func(&#xA;        user,&#xA;        instruction string,&#xA;        questions []string,&#xA;        echos []bool,&#xA;    ) (answers []string, err error) {&#xA;        if len(questions) == 0 {&#xA;            return []string{}, nil&#xA;        }&#xA;        return []string{this.Password}, nil&#xA;    }&#xA;&#xA;    authMethods = append(authMethods, ssh.KeyboardInteractive(keyboardInteractiveChallenge))&#xA;    authMethods = append(authMethods, ssh.Password(this.Password))&#xA;&#xA;    sshConfig := &amp;amp;ssh.ClientConfig{&#xA;        User: this.User,&#xA;        Auth: authMethods,&#xA;    }&#xA;&#xA;    client, err := ssh.Dial(&amp;quot;tcp&amp;quot;, fmt.Sprintf(&amp;quot;%s:22&amp;quot;, addr), sshConfig)&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;&#xA;    return client, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;建立 Session 并设置&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Root&#xA;node := NewNode(&amp;quot;root&amp;quot;, &amp;quot;123456&amp;quot;)&#xA;&#xA;// Connect&#xA;client, err := node.Conn(&amp;quot;127.0.0.1&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer client.Close()&#xA;&#xA;session, err := client.NewSession()&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer session.Close()&#xA;&#xA;// 注意：如果想模拟SSH，可以将流输出到os.Stdout和os.Stderr中.&#xA;// Set IO&#xA;stdin, _ := session.StdinPipe()&#xA;stdout, _ := session.StdoutPipe()&#xA;&#xA;// 以下设置，可以支持目录，文件，颜色输出&#xA;/*&#xA;&#xA;    // Set up terminal modes&#xA;    modes := ssh.TerminalModes{&#xA;        ssh.ECHO:          0,     // disable echoing&#xA;        ssh.TTY_OP_ISPEED: 14400, // input speed = 14.4kbaud&#xA;        ssh.TTY_OP_OSPEED: 14400, // output speed = 14.4kbaud&#xA;    }&#xA;&#xA;    // Request pseudo terminal&#xA;    if err := session.RequestPty(&amp;quot;xterm&amp;quot;, 80, 40, modes); err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;*/&#xA;&#xA;// Start remote shell&#xA;if err := session.Shell(); err != nil {&#xA;    panic(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;使用&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 执行&#xA;stdin.Write([]byte(fmt.Sprintf(&amp;quot;%s 2&amp;gt;&amp;amp;1; echo -e End-Goline-End\n&amp;quot;, command)))&#xA;&#xA;// 读取返回&#xA;r_ := bufio.NewReader(stdout)&#xA;&#xA;//  返回数据&#xA;datas := make([]byte, 0)&#xA;&#xA;// 读取客户端返回&#xA;for {&#xA;    data, err := r_.ReadBytes(&#39;\n&#39;)&#xA;    if err != nil {&#xA;        break&#xA;    }&#xA;    if z.Trim(string(data)) == &amp;quot;End-Goline-End&amp;quot; {&#xA;        // 返回&#xA;        fmt.Println(z.Trim(string(datas))) &#xA;        // 清零&#xA;        datas = []byte{}&#xA;        // 跳出&#xA;        break&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Darwin Streaming Server</title>
      <link>http://www.nljb.net/default/Darwin-Streaming-Server/</link>
      <pubDate>2014-11-14 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;1、什么是Darwin Streaming Server&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;目前主流的流媒体服务器有&lt;/p&gt;&#xA;&#xA;&lt;p&gt;微软的windows media server&lt;/p&gt;&#xA;&#xA;&lt;p&gt;RealNetworks的Helixserver&lt;/p&gt;&#xA;&#xA;&lt;p&gt;苹果公司的Darwin Streaming Server.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;微软的windows media server只能在windows下使用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;RealNetworks的Helixserver是一款跨平台的软件，功能强大，但非免费。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Darwin Streaming Server简称DSS。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;DSS是Apple公司提供的开源实时流媒体播放服务器程序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;整个程序使用C++编写，在设计上遵循高性能，简单，模块化等程序设计原则，务求做到程序高效，可扩充性好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;并且DSS是一个开放源代码的，基于标准的流媒体服务器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以运行在Windows NT和Windows 2000，以及几个UNIX实现上，包括Mac OS X，Linux，FreeBSD，和Solaris操作系统上的。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;2、在Linux中编译安装Darwin Streaming Server&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;首先需要进行一些必要的准备工作：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install patch make gcc g++ &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;准备好软件暂存的目录，并从官网下载软件的源码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mkdir soft&#xA;cd soft&#xA;wget http://dss.macosforge.org/downloads/DarwinStreamingSrvr6.0.3-Source.tar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;源码下载完成后，需要解压tar包，&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tar xvf DarwinStreamingSrvr6.0.3-Source.tar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;给源码安装补丁文件，进入DarwinStreamingSrvr6.0.3-Source目录，并打补丁：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd DarwinStreamingSrvr6.0.3-Source&#xA;wget http://www.abrahamsson.com/dss-6.0.3.patch&#xA;patch -p1 &amp;lt; dss-6.0.3.patch  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;./Buildit &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编译完成后，我们来生成linux下的dss安装包&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;执行 ./buildtarball &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成 DarwinStreamingSrvr-Linux.tar.gz&lt;/p&gt;&#xA;&#xA;&lt;p&gt;解压缩&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tar -zxvf DarwinStreamingSrvr-Linux.tar.gz &#xA;cd DarwinStreamingSrvr-Linux &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对Install文件做修改&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if [ $INSTALL_OS = &amp;quot;Linux&amp;quot; ]; then &#xA;    /usr/sbin/useradd -M qtss &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &#xA;else &#xA;    /usr/sbin/useradd qtss &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;将-M修改成-m&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Darwin-Streaming-Server/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行./Install&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Please enter a new administrator user name: 【新管理员】&#xA;Please enter a new administrator Password: 【密码】&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;查看是否安裝成功&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ps aux | grep Darwin(查看流媒体服务器的进程) &#xA;root ... ... ... /usr/local/sbin/DarwinStreamingServer&#xA;qtss ... ... ... /usr/local/sbin/DarwinStreamingServer&#xA;netstat -ntulp | grep Darwin(查看流媒体服务器的端口)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Darwin-Streaming-Server/2.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;3、启动 Darwin Streaming Server&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo /usr/local/sbin/DarwinStreamingServer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;启动 Web 管理介面 (tcp port 1220)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo /usr/local/sbin/streamingadminserver.pl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;ps. 以上两项在刚安装好的时候会自动启动，不需手动执行&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小技巧：自动启动流媒体服务器的方法：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;自动运行流媒体服务器序非常简单，把上述命令添加在/etc/rc.d/rc.local脚本中即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后在服务器输入 http://你的IP:1220/来访问web管理&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Darwin-Streaming-Server/3.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;默认的媒体文件存放在/usr/local/movies&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你可以在web管理面板修改这个路径。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;4、访问自己的流媒体服务&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;可以使用VLC media player这个软件，输入&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;rtsp://你的IP/sample_100kbit.mp4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;来播放默认的测试视频。如果你的网速够给力的话效果还不错 ：)&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;视频需要 MP4Box 处理一下，否则无法播放&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MP4Box -hint xxx.mp4 // hints the given file for rtp/rtsp&#xA;&#xA;yum -y install freeglut&#xA;&#xA;yum -y install freeglut-devel&#xA;&#xA;wget http://downloads.sourceforge.net/gpac/gpac-0.4.5.tar.gz&#xA;&#xA;wget http://downloads.sourceforge.net/gpac/gpac_extra_libs-0.4.5.tar.gz&#xA;&#xA;tar zxvf gpac-0.4.5.tar.gz&#xA;&#xA;tar zxvf gpac_extra_libs-0.4.5.tar.gz&#xA;&#xA;cd gpac&#xA;&#xA;cp -r ../gpac_extra_libs/* extra_lib/&#xA;&#xA;chmod +x configure&#xA;&#xA;./configure&#xA;&#xA;make lib&#xA;&#xA;make apps&#xA;&#xA;make install&#xA;&#xA;cp bin/gcc/libgpac.so /usr/lib&#xA;&#xA;ldconfig&#xA;&#xA;MP4Box -version&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go-SSH</title>
      <link>http://www.nljb.net/default/Go-SSH/</link>
      <pubDate>2014-11-07 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;bufio&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;&#xA;    &amp;quot;code.google.com/p/go.crypto/ssh&amp;quot;&#xA;)&#xA;&#xA;type Node struct {&#xA;    User     string&#xA;    Password string&#xA;}&#xA;&#xA;func NewNode(user, password string) *Node {&#xA;    node := new(Node)&#xA;    node.User = user&#xA;    node.Password = password&#xA;    return node&#xA;}&#xA;&#xA;func (this *Node) Conn(addr string) (*ssh.Client, error) {&#xA;&#xA;    authMethods := []ssh.AuthMethod{}&#xA;&#xA;    keyboardInteractiveChallenge := func(&#xA;        user,&#xA;        instruction string,&#xA;        questions []string,&#xA;        echos []bool,&#xA;    ) (answers []string, err error) {&#xA;        if len(questions) == 0 {&#xA;            return []string{}, nil&#xA;        }&#xA;        return []string{this.Password}, nil&#xA;    }&#xA;&#xA;    authMethods = append(authMethods, ssh.KeyboardInteractive(keyboardInteractiveChallenge))&#xA;    authMethods = append(authMethods, ssh.Password(this.Password))&#xA;&#xA;    sshConfig := &amp;amp;ssh.ClientConfig{&#xA;        User: this.User,&#xA;        Auth: authMethods,&#xA;    }&#xA;&#xA;    client, err := ssh.Dial(&amp;quot;tcp&amp;quot;, fmt.Sprintf(&amp;quot;%s:22&amp;quot;, addr), sshConfig)&#xA;    if err != nil {&#xA;        return nil, fmt.Errorf(fmt.Sprintf(&amp;quot;Connect fail \n(%s)&amp;quot;, addr, err.Error()))&#xA;    }&#xA;&#xA;    return client, nil&#xA;}&#xA;&#xA;func (this *Node) Command(client *ssh.Client, command string) {&#xA;    session, err := client.NewSession()&#xA;    if err != nil {&#xA;        fmt.Println(err)&#xA;        return&#xA;    }&#xA;    defer session.Close()&#xA;    output, err := session.Output(command)&#xA;    if err != nil {&#xA;        fmt.Println(err)&#xA;        return&#xA;    }&#xA;    fmt.Println(string(output))&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    node := NewNode(&amp;quot;root&amp;quot;, &amp;quot;...&amp;quot;)&#xA;&#xA;    client, err := node.Conn(&amp;quot;192.168.0.100&amp;quot;)&#xA;    if err != nil {&#xA;        fmt.Println(err)&#xA;        return&#xA;    }&#xA;    defer client.Close()&#xA;&#xA;    input := bufio.NewReader(os.Stdin)&#xA;    for {&#xA;        fmt.Print(&amp;quot;$: &amp;quot;)&#xA;        line, _ := input.ReadString(&#39;\n&#39;)&#xA;        if Trim(line) == &amp;quot;bye&amp;quot; {&#xA;            os.Exit(0)&#xA;        }&#xA;        node.Command(client, Trim(line))&#xA;    }&#xA;&#xA;    return&#xA;}&#xA;&#xA;func IsSpace(c byte) bool {&#xA;    if c &amp;gt;= 0x00 &amp;amp;&amp;amp; c &amp;lt;= 0x20 {&#xA;        return true&#xA;    }&#xA;    return false&#xA;}&#xA;&#xA;func Trim(s string) string {&#xA;    size := len(s)&#xA;    if size &amp;lt;= 0 {&#xA;        return s&#xA;    }&#xA;    l := 0&#xA;    for ; l &amp;lt; size; l++ {&#xA;        b := s[l]&#xA;        if !IsSpace(b) {&#xA;            break&#xA;        }&#xA;    }&#xA;    r := size - 1&#xA;    for ; r &amp;gt;= l; r-- {&#xA;        b := s[r]&#xA;        if !IsSpace(b) {&#xA;            break&#xA;        }&#xA;    }&#xA;    return string(s[l : r+1])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++中使用boost::property_tree解析INI</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B8%AD%E4%BD%BF%E7%94%A8boost--property_tree%E8%A7%A3%E6%9E%90INI/</link>
      <pubDate>2014-11-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#ifndef INICONFIG_H&#xA;#define INICONFIG_H&#xA;&#xA;#include &amp;lt;boost/property_tree/ptree.hpp&amp;gt;&#xA;#include &amp;lt;boost/property_tree/ini_parser.hpp&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;vector&amp;gt;&#xA;&#xA;using namespace std;&#xA;using namespace boost;&#xA;using namespace boost::property_tree;&#xA;&#xA;class INIConfig&#xA;{&#xA;public:&#xA;    INIConfig(string);&#xA;    ~INIConfig();&#xA;public:&#xA;    bool ReadINI();&#xA;    bool WriteINI();&#xA;    bool AddString(string, string);&#xA;    bool PutString(string, string);&#xA;    string GetString(string, string);&#xA;    int GetInt(string, int);&#xA;    vector&amp;lt;string&amp;gt; GetChildString(string);&#xA;private:&#xA;    string path;&#xA;    ptree conf;&#xA;};&#xA;&#xA;#endif // INICONFIG_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;include/INIConfig.h&amp;quot;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;boost/format.hpp&amp;gt;&#xA;&#xA;INIConfig::INIConfig(string _path)&#xA;{&#xA;    path = _path;&#xA;}&#xA;&#xA;INIConfig::~INIConfig(){}&#xA;&#xA;bool INIConfig::ReadINI()&#xA;{&#xA;    try&#xA;    {&#xA;    read_ini(path, conf);&#xA;    }&#xA;    catch (std::exception&amp;amp; e)&#xA;    {&#xA;    return false;&#xA;    }&#xA;    return true;&#xA;}&#xA;&#xA;bool INIConfig::AddString(string _path, string _value)&#xA;{&#xA;    try&#xA;    {&#xA;    conf.add(_path, _value);&#xA;    }&#xA;    catch (std::exception&amp;amp; e)&#xA;    {&#xA;    return false;&#xA;    }&#xA;    return true;&#xA;}&#xA;&#xA;bool INIConfig::PutString(string _path, string _value)&#xA;{&#xA;    try&#xA;    {&#xA;    conf.put(_path, _value);&#xA;    }&#xA;    catch (std::exception&amp;amp; e)&#xA;    {&#xA;    return false;&#xA;    }&#xA;    return true;&#xA;}&#xA;&#xA;string INIConfig::GetString(string _path, string _default)&#xA;{&#xA;    return conf.get&amp;lt;string&amp;gt;(_path, _default);&#xA;}&#xA;&#xA;int INIConfig::GetInt(string _path, int _default)&#xA;{&#xA;    return conf.get&amp;lt;int&amp;gt;(_path, _default);&#xA;}&#xA;&#xA;vector&amp;lt;string&amp;gt; INIConfig::GetChildString(string _path)&#xA;{&#xA;    vector&amp;lt;string&amp;gt; child;&#xA;    try&#xA;    {&#xA;    auto x = conf.get_child(_path);&#xA;    for (auto&amp;amp; pos : x)&#xA;    {&#xA;        child.push_back(pos.first);&#xA;    }&#xA;    }&#xA;    catch (std::exception&amp;amp;)&#xA;    {&#xA;    return std::move(child);&#xA;    }&#xA;    return std::move(child);&#xA;}&#xA;&#xA;bool INIConfig::WriteINI()&#xA;{&#xA;    try&#xA;    {&#xA;    write_ini(path, conf);&#xA;    }&#xA;    catch (std::exception&amp;amp;)&#xA;    {&#xA;    return false;&#xA;    }&#xA;    return true;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++11之auto</title>
      <link>http://www.nljb.net/default/C%2B%2B11%E4%B9%8Bauto/</link>
      <pubDate>2014-10-31 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;在那些情况下要申明类型:&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1,定义变量类型&#xA;2,函数返回值，函数参数&#xA;3,表达式返回变量类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;auto关键字原理&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在定义变量的时候必须申明类型，c++是强语言类型，在编译阶段需要知道类型，这样的好处是程序效率更高&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而动态语言不需要类型申明的需要自推导变量类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用了auto是不是c++效率会变慢？完全不是，因为在编译阶段编译器已经帮程序员推导好了变量的类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;前提条件是编译器可以根据当前的程序的状态推导出变量类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;只是编译器更加智能，我猜想编译时间岂不更长了。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;auto关键字使用场景&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;场景一，申明普通变量&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;auto num = 10;   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;场景二，函数返回值，如果没有auto，总是要巧那么长的返回值，有了auto关键字后，是不是心里感觉很爽。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vector&amp;lt;string&amp;gt; str_vec;  &#xA;vector&amp;lt;string&amp;gt;::iterator it_old = str_vec.begin();  &#xA;auto it_new  = str_vec.begin();  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;场景三，申明函数返回值&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;auto add(int a, int b)-&amp;gt;int {  &#xA;     return a + b;  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;auto使用需要注意的几个问题&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;1、使用auto关键字的变量必须有初始值，编译器才能推导出变量类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、在传递const变量的时候，使用auto必须自己加const&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const int a =10;  &#xA;auto b = a;                // b的类型是int  &#xA;const auto c = a;      // c 的类型是const int  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、关于很奇葩的函数返回值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;auto关键字只能在函数的返回值使用auto关键字，并且在函数尾还需要标注返回类型&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样看起来很奇葩，莫不如不用auto关键字，但我认为委员会的人没这么闲，上google查了下，有下面两条原因：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1、他们认为把返回值放在函数后面更好看（特别是返回值很长的时候）&#xA;2、C++14将会把讨人烦得返回值去掉，编译器直接支持自推导。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Jsoncpp解析拼装数组</title>
      <link>http://www.nljb.net/default/Jsoncpp%E8%A7%A3%E6%9E%90%E6%8B%BC%E8%A3%85%E6%95%B0%E7%BB%84/</link>
      <pubDate>2014-10-29 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 例子一:&#xA;string strValue =&#xA;     &amp;quot;{\&amp;quot;ldh\&amp;quot;:\&amp;quot;001\&amp;quot;,\&amp;quot;gfc\&amp;quot;:\&amp;quot;002\&amp;quot;,\&amp;quot;yyj\&amp;quot;:\&amp;quot;003\&amp;quot;,\&amp;quot;andy\&amp;quot;:[\&amp;quot;005\&amp;quot;,\&amp;quot;123\&amp;quot;,\&amp;quot;true\&amp;quot;]}&amp;quot;;&#xA;Json::Reader read;&#xA;Json::Value value;&#xA;value[&amp;quot;ldh&amp;quot;] = &amp;quot;001&amp;quot;;&#xA;value[&amp;quot;gfc&amp;quot;] = &amp;quot;002&amp;quot;;&#xA;value[&amp;quot;andy&amp;quot;].append( &amp;quot;005&amp;quot; );&#xA;value[&amp;quot;andy&amp;quot;].append( &amp;quot;123&amp;quot; );&#xA;value[&amp;quot;andy&amp;quot;].append( &amp;quot;true&amp;quot; );&#xA;if( read.parse( strValue,value ) )&#xA;{&#xA;    Json::Value val_array = value[&amp;quot;andy&amp;quot;];&#xA;    int iSize = val_array.size();&#xA;    for ( int nIndex = 0;nIndex &amp;lt; iSize;++ nIndex )&#xA;    {&#xA;        cout &amp;lt;&amp;lt; val_array[nIndex] &amp;lt;&amp;lt; endl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 例子二:&#xA;Json::Reader read;&#xA;Json::Value value;&#xA;value[&amp;quot;ldh&amp;quot;] = &amp;quot;001&amp;quot;;&#xA;value[&amp;quot;gfc&amp;quot;] = &amp;quot;002&amp;quot;;&#xA;Value item;&#xA;Value array;&#xA;item[&amp;quot;andy1&amp;quot;] = &amp;quot;005&amp;quot;;&#xA;array.append( item );&#xA;item[&amp;quot;andy1&amp;quot;] = &amp;quot;123&amp;quot;;&#xA;array.append( item );&#xA;item[&amp;quot;andy1&amp;quot;] = &amp;quot;true&amp;quot;;&#xA;array.append( item );&#xA;value[&amp;quot;andy&amp;quot;] = array;&#xA;cout &amp;lt;&amp;lt; value.toStyledString() &amp;lt;&amp;lt; endl;&#xA;Json::Value val_array = value[&amp;quot;andy&amp;quot;];&#xA;int iSize = val_array.size();&#xA;for ( int nIndex = 0;nIndex &amp;lt; iSize;++ nIndex )&#xA;{&#xA;    cout &amp;lt;&amp;lt; val_array[nIndex] &amp;lt;&amp;lt; endl;&#xA;    if ( !val_array[nIndex][&amp;quot;andy1&amp;quot;].isNull() )&#xA;    {&#xA;        cout &amp;lt;&amp;lt; val_array[nIndex][&amp;quot;andy1&amp;quot;] &amp;lt;&amp;lt; endl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 例子三:&#xA;std::string strValue =&#xA;     &amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;json\&amp;quot;,\&amp;quot;array\&amp;quot;:[{\&amp;quot;cpp\&amp;quot;:\&amp;quot;jsoncpp\&amp;quot;},{\&amp;quot;java\&amp;quot;:\&amp;quot;jsoninjava\&amp;quot;}]}&amp;quot;;&#xA;Json::Value value;&#xA;Reader read;&#xA;if ( !read.parse( strValue,value ) )&#xA;{&#xA;    return -1;&#xA;}&#xA;cout &amp;lt;&amp;lt; value.toStyledString() &amp;lt;&amp;lt; endl;&#xA;Json::Value val_array = value[&amp;quot;array&amp;quot;];&#xA;int iSize = val_array.size();&#xA;for ( int nIndex = 0;nIndex &amp;lt; iSize;++ nIndex )&#xA;{&#xA;    cout &amp;lt;&amp;lt; val_array[nIndex] &amp;lt;&amp;lt; endl;&#xA;    if ( val_array[nIndex].isMember( &amp;quot;cpp&amp;quot; ) )&#xA;    {&#xA;        cout &amp;lt;&amp;lt; val_array[nIndex][&amp;quot;cpp&amp;quot;] &amp;lt;&amp;lt; endl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>String转uint64_t</title>
      <link>http://www.nljb.net/default/String%E8%BD%ACuint64_t/</link>
      <pubDate>2014-10-28 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;sstream&amp;gt;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char **argv)&#xA;{&#xA;    if (argc &amp;lt; 2)&#xA;    {&#xA;        cerr&amp;lt;&amp;lt;&amp;quot;Usage: transfernum num&amp;quot;&amp;lt;&amp;lt;endl;&#xA;        return -1;&#xA;    }&#xA;&#xA;    cout&amp;lt;&amp;lt;&amp;quot;Input Num:&amp;quot;&amp;lt;&amp;lt;argv[1]&amp;lt;&amp;lt;endl;&#xA;&#xA;    unsigned long long ullNum1 = 0, ullNum2=0, ullNum3=0, ullNum4=0;&#xA;    ullNum1 = atoi(argv[1]);&#xA;    ullNum2 = atol(argv[1]);&#xA;    ullNum3 = atoll(argv[1]);&#xA;    ullNum4 = strtoull(argv[1], NULL, 10);&#xA;&#xA;    cout&amp;lt;&amp;lt;&amp;quot;transfer by atoi: &amp;quot;&amp;lt;&amp;lt;ullNum1&amp;lt;&amp;lt;endl;&#xA;    cout&amp;lt;&amp;lt;&amp;quot;transfer by atol: &amp;quot;&amp;lt;&amp;lt;ullNum2&amp;lt;&amp;lt;endl;&#xA;    cout&amp;lt;&amp;lt;&amp;quot;transfer by atoll: &amp;quot;&amp;lt;&amp;lt;ullNum3&amp;lt;&amp;lt;endl;&#xA;    cout&amp;lt;&amp;lt;&amp;quot;transfer by strtoull: &amp;quot;&amp;lt;&amp;lt;ullNum4&amp;lt;&amp;lt;endl;&#xA;&#xA;    // 这个方法是在网上找的，这里测试下是否管用&#xA;    stringstream strValue;&#xA;    strValue&amp;lt;&amp;lt;argv[1];&#xA;    unsigned long long value;&#xA;    strValue &amp;lt;&amp;lt; value;&#xA;    cout&amp;lt;&amp;lt;value&amp;lt;&amp;lt;endl;&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;g++ main.cpp -o transfernum&#xA;./transfernum 18446744073709551615  (这个值是2^64-1，即64位的最大值)&#xA;&#xA;输出：&#xA;Input Num:18446744073709551615      &#xA;transfer by atoi: 18446744073709551615     (atoi也正确了？奇怪)&#xA;transfer by atol: 9223372036854775807&#xA;transfer by atoll: 9223372036854775807&#xA;transfer by strtoull: 18446744073709551615  &#xA;4196992 使用网上找的方法发现不正确）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++11中的日期和时间库</title>
      <link>http://www.nljb.net/default/C%2B%2B11%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%BA%93/</link>
      <pubDate>2014-10-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;C++11供给了日期时候相干的库chrono，经由过程chrono相干的库我们可以很便利的处理惩罚日期和时候。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;C++11还供给了字符串的宽窄转换功能，也供给了字符串和数字的彼此转换的库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有了这些库供给的便利的对象类，我们能便利的处理惩罚日期和时候相干的转换和格局输出。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;chrono&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;chrono库首要包含了三种类型：时候间隔Duration、时钟Clocks和时候点Time point。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;Duration&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;duration默示一段时候间隔，用来记录时候长度，可以默示几秒钟、几分钟或者几个小时的时候间隔，duration的原型是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;template&amp;lt;class Rep， class Period = std::ratio&amp;lt;1&amp;gt;&amp;gt; class duration;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;第一个模板参数Rep是一个数值类型，默示时钟个数；第二个模板参数是一个默认模板参数std::ratio，它的原型是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;template&amp;lt;std::intmax_t Num， std::intmax_t Denom = 1&amp;gt; class ratio;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;typedef duration &amp;lt;Rep， ratio&amp;lt;3600，1&amp;gt;&amp;gt; hours;&#xA;&#xA;typedef duration &amp;lt;Rep， ratio&amp;lt;60，1&amp;gt;&amp;gt; minutes;&#xA;&#xA;typedef duration &amp;lt;Rep， ratio&amp;lt;1，1&amp;gt;&amp;gt; seconds;&#xA;&#xA;typedef duration &amp;lt;Rep， ratio&amp;lt;1，1000&amp;gt;&amp;gt; milliseconds;&#xA;&#xA;typedef duration &amp;lt;Rep， ratio&amp;lt;1，1000000&amp;gt;&amp;gt; microseconds;&#xA;&#xA;typedef duration &amp;lt;Rep， ratio&amp;lt;1，1000000000&amp;gt;&amp;gt; nanoseconds;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;由过程定义这些常用的时候间隔类型，我们能便利的应用它们，比如线程的休眠：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;std::this_thread::sleep_for（std::chrono::seconds（3））; //休眠三秒&#xA;std::this_thread::sleep_for（std::chrono:: milliseconds （100））; //休眠100毫秒&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;chrono还供给了获取时候间隔的时钟周期个数的办法count（），它的根蒂根基用法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;＃include &amp;lt;chrono&amp;gt;&#xA;＃include &amp;lt;iostream&amp;gt;&#xA;int main（）&#xA;{&#xA;    std::chrono::milliseconds ms{3}; // 3 毫秒&#xA;    // 6000 microseconds constructed  3 milliseconds&#xA;    std::chrono::microseconds us = 2*ms; //6000微秒&#xA;    // 30Hz clock using fractional ticks&#xA;    std::chrono::duration&amp;lt;double， std::ratio&amp;lt;1， 30&amp;gt;&amp;gt; hz30（3.5）;&#xA;    std::cout &amp;lt;&amp;lt;  &amp;quot;3 ms duration has &amp;quot; &amp;lt;&amp;lt; ms.count（） &amp;lt;&amp;lt; &#xA;    &amp;quot; ticks\n&amp;quot;&amp;lt;&amp;lt;  &amp;quot;6000 us duration has &amp;quot; &amp;lt;&amp;lt; us.count（） &amp;lt;&amp;lt; &amp;quot; ticks\n&amp;quot;&#xA;}&#xA;输出：&#xA;3 ms duration has 3 ticks&#xA;6000 us duration has 6000 ticks&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;时候间隔之间可以做运算，比如下面的例子中策画两端时候间隔的差值：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;std::chrono::minutes t1（ 10 ）;&#xA;std::chrono::seconds t2（ 60 ）;&#xA;std::chrono::seconds t3 = t1 - t2;&#xA;std::cout &amp;lt;&amp;lt; t3.count（） &amp;lt;&amp;lt; &amp;quot; second&amp;quot; &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;Time point&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;time_point默示一个时候点，用来获取1970.1.1以来的秒数和当前的时候&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以做一些时候的斗劲和算术运算，可以和ctime库连络起来显示时候。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;time_point必必要clock来计时，time_point有一个函数time__eproch（）用来获得1970年1月1日到time_point时候经过的duration。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的例子策画当前时候间隔1970年1月一日有几许天：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;＃include &amp;lt;iostream&amp;gt;&#xA;＃include &amp;lt;ratio&amp;gt;&#xA;＃include &amp;lt;chrono&amp;gt;&#xA;int main （）&#xA;{&#xA;  using namespace std::chrono;&#xA;  typedef duration&amp;lt;int，std::ratio&amp;lt;60*60*24&amp;gt;&amp;gt; days_type;&#xA;  time_point&amp;lt;system_clock，days_type&amp;gt; today = time_point_cast&amp;lt;days_type&amp;gt;（system_clock::now（））;&#xA;  std::cout &amp;lt;&amp;lt; today.time_since_epoch（）.count（） &amp;lt;&amp;lt; &amp;quot; days since epoch&amp;quot; &amp;lt;&amp;lt; std::endl;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;time_point还支撑一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的例子输出前一天和后一天的日期：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;＃include &amp;lt;iostream&amp;gt;&#xA;＃include &amp;lt;iomanip&amp;gt;&#xA;＃include &amp;lt;ctime&amp;gt;&#xA;＃include &amp;lt;chrono&amp;gt;&#xA;int main（）&#xA;{&#xA;    using namespace std::chrono;&#xA;    system_clock::time_point now = system_clock::now（）;&#xA;    std::time_t last = system_clock::to_time_t（now - std::chrono::hours（24））;&#xA;　　std::time_t next= system_clock::to_time_t（now - std::chrono::hours（24））;&#xA;    std::cout &amp;lt;&amp;lt; &amp;quot;One day ago， the time was &amp;quot;&amp;lt;&amp;lt; std::put_time（std::localtime（&amp;amp;last）， &amp;quot;％F ％T&amp;quot;） &amp;lt;&amp;lt; &amp;quot;&amp;quot;\n&amp;quot;&amp;quot;;&#xA;　　std::cout &amp;lt;&amp;lt; &amp;quot;Next day， the time was &amp;quot;&amp;lt;&amp;lt; std::put_time（std::localtime（&amp;amp;next）， &amp;quot;％F ％T&amp;quot;） &amp;lt;&amp;lt; &amp;quot;&amp;quot;\n&amp;quot;&amp;quot;;&#xA;}&#xA;输出：&#xA;One day ago， the time was 2014-3-2622:38:27&#xA;Next day， the time was 2014-3-2822:38:27&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;Clocks&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;默示当前的体系时钟，内部有time_point， duration， Rep， Period等信息&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它首要用来获取当前时候，以及实现time_t和time_point的彼此转换。Clocks包含三种时钟：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;system_clock：从体系获取的时钟；&#xA;steady_clock：不克不及被批改的时钟；&#xA;high_resolution_clock：高精度时钟，实际上是system_clock或者steady_clock的别号。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以经由过程now（）来获取当前时候点：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;＃include &amp;lt;iostream&amp;gt;&#xA;＃include &amp;lt;chrono&amp;gt;&#xA;int main（）&#xA;{&#xA;    std::chrono::steady_clock::time_point t1 = std::chrono::system_clock::now（）;&#xA;    std::cout &amp;lt;&amp;lt; &amp;quot;Hello World\n&amp;quot;;&#xA;    std::chrono::steady_clock::time_point t2 = std::chrono:: system_clock::now（）;&#xA;    std::cout &amp;lt;&amp;lt; （t2-t1）.count（）&amp;lt;&amp;lt;” tick count”&amp;lt;&amp;lt;endl;&#xA;}&#xA;输出：&#xA;Hello World&#xA;20801tick count&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;经由过程期钟获取两个时候点之相差几许个时钟周期&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以经由过程duration_cast将其转换为其它时钟周期的duration：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;（ t2-t1 ）.count（）&#xA;输出：&#xA;20 microseconds&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;system_clock的to_time_t办法可以将一个time_point转换为ctime：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;std::time_t now_c = std::chrono::system_clock::to_time_t（time_point）;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;时候的格局化输出&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;system_clock和std::put_time共同起来应用可以格局化日期的输出，std::put_time能将日期格局化输出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的例子是将当前时候格局化输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;＃include &amp;lt;chrono&amp;gt;&#xA;＃include &amp;lt;ctime&amp;gt;&#xA;＃include &amp;lt;iomanip&amp;gt;&#xA;＃include &amp;lt;string&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;int main（）&#xA;{&#xA;    auto t = chrono::system_clock::to_time_t（std::chrono::system_clock::now（））;&#xA;    cout&amp;lt;&amp;lt; std::put_time（std::localtime（&amp;amp;t）， &amp;quot;％Y-％m-％d ％X&amp;quot;）&amp;lt;&amp;lt;endl;&#xA;    cout&amp;lt;&amp;lt; std::put_time（std::localtime（&amp;amp;t）， &amp;quot;％Y-％m-％d ％H.％M.％S&amp;quot;）&amp;lt;&amp;lt;endl;&#xA;    return 0;&#xA;}&#xA;上方的例子将输出：&#xA;2014-3-27 22:11:49&#xA;2014-3-27 22.11.49&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;timer&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;可以哄骗high_resolution_clock来实现一个类似于boost.timer的按时器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如许的timer在测试机能时会经常用到，经常用它来测试函数耗时，它的根蒂根基用法是如许的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void fun（）&#xA;{&#xA;    cout&amp;lt;&amp;lt;”hello word”&amp;lt;&amp;lt;endl;&#xA;}&#xA;&#xA;int main（）&#xA;{&#xA;     timer t; //开端计时&#xA;     fun（）&#xA;     cout&amp;lt;&amp;lt;t.elapsed（）&amp;lt;&amp;lt;endl; //打印fun函数耗时几许毫秒&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;C++11中增长了chrono库，如今用来实现一个按时器是很简单的工作，还可以移除对boost的依附。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它的实现斗劲简单，下面是具体实现：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;＃include&amp;lt;chrono&amp;gt;&#xA;using namespace std;&#xA;using namespace std::chrono;&#xA;&#xA;classTimer&#xA;{&#xA;&#xA;public:&#xA;    Timer（） : m_begin（high_resolution_clock::now（）） {}&#xA;    void reset（） { m_begin = high_resolution_clock::now（）; }&#xA;&#xA;    //默认输出毫秒&#xA;    int64_t elapsed（） const&#xA;    {&#xA;    return duration_cast&amp;lt;chrono::milliseconds&amp;gt;（high_resolution_clock::now（） - m_begin）.count（）;&#xA;    }&#xA;&#xA;    //微秒&#xA;    int64_t elapsed_micro（） const&#xA;    {&#xA;    return duration_cast&amp;lt;chrono::microseconds&amp;gt;（high_resolution_clock::now（） - m_begin）.count（）;&#xA;    }&#xA;&#xA;    //纳秒&#xA;    int64_t elapsed_nano（） const&#xA;    {&#xA;    return duration_cast&amp;lt;chrono::nanoseconds&amp;gt;（high_resolution_clock::now（） - m_begin）.count（）;&#xA;    }&#xA;    //秒&#xA;    int64_t elapsed_seconds（） const&#xA;    {&#xA;    return duration_cast&amp;lt;chrono::seconds&amp;gt;（high_resolution_clock::now（） - m_begin）.count（）;&#xA;    }&#xA;&#xA;    //分&#xA;    int64_t elapsed_minutes（） const&#xA;    {&#xA;    return duration_cast&amp;lt;chrono::minutes&amp;gt;（high_resolution_clock::now（） - m_begin）.count（）;&#xA;    }&#xA;&#xA;    //时&#xA;    int64_t elapsed_hours（） const&#xA;    {&#xA;    return duration_cast&amp;lt;chrono::hours&amp;gt;（high_resolution_clock::now（） - m_begin）.count（）;&#xA;    }&#xA;&#xA;private:&#xA;    time_point&amp;lt;high_resolution_clock&amp;gt; m_begin;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void fun（）&#xA;{&#xA;    cout&amp;lt;&amp;lt;”hello word”&amp;lt;&amp;lt;endl;&#xA;}&#xA;&#xA;int main（）&#xA;{&#xA;    timer t; //开端计时&#xA;    fun（）&#xA;    cout&amp;lt;&amp;lt;t.elapsed（）&amp;lt;&amp;lt;endl; //打印fun函数耗时几许毫秒&#xA;    cout&amp;lt;&amp;lt;t.elapsed_micro （）&amp;lt;&amp;lt;endl; //打印微秒&#xA;    cout&amp;lt;&amp;lt;t.elapsed_nano （）&amp;lt;&amp;lt;endl; //打印纳秒&#xA;    cout&amp;lt;&amp;lt;t.elapsed_seconds（）&amp;lt;&amp;lt;endl; //打印秒&#xA;    cout&amp;lt;&amp;lt;t.elapsed_minutes（）&amp;lt;&amp;lt;endl; //打印分钟&#xA;    cout&amp;lt;&amp;lt;t.elapsed_hours（）&amp;lt;&amp;lt;endl; //打印小时&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Asio-io_service</title>
      <link>http://www.nljb.net/default/Asio-io_service/</link>
      <pubDate>2014-10-24 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;IO模型&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;io_service对象是asio框架中的调度器，所有异步io事件都是通过它来分发处理的&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// io对象的构造函数中都需要传入一个io_service对象&#xA;asio::io_service io_service;&#xA;asio::ip::tcp::socket socket(io_service);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;在asio框架中，同步的io主要流程如下：&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Asio-io_service/1.jpg&#34; alt=&#34;&#34; width=&#34;250&#34; height=&#34;400&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1, 应用程序调用IO对象成员函数执行IO操作&#xA;2, IO对象向io_service 提出请求.&#xA;3, io_service 调用操作系统的功能执行连接操作.&#xA;4, 操作系统向io_service 返回执行结果.&#xA;5, io_service将错误的操作结果翻译为boost::system::error_code类型，再传递给IO对象.&#xA;6, 如果操作失败,IO对象抛出boost::system::system_error类型的异常.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;而异步IO的处理流程则有些不同：&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Asio-io_service/2.jpg&#34; alt=&#34;&#34; width=&#34;350&#34; height=&#34;400&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1, 应用程序调用IO对象成员函数执行IO操作&#xA;2, IO对象请求io_service的服务&#xA;3, io_service 通知操作系统其需要开始一个异步连接.&#xA;4, 操作系统指示连接操作完成, io_service从队列中获取操作结果&#xA;5, 应用程序必须调用io_service::run()以便于接收结果&#xA;6, 调用io_service::run()后,io_service返回一个操作结果,并将其翻译为error_code,传递到事件回调函数中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>矩阵坐标转换</title>
      <link>http://www.nljb.net/default/%E7%9F%A9%E9%98%B5%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>2014-10-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/矩阵坐标转换/rect.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;比方说画面宽度640，你希望从320开始截取，那就是320/640 = 0.5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;E:&#xA;X0 = 0&#xA;Y0 = 2160&#xA;X1 = 1920&#xA;Y1 = 3240&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;OFF_X0 = 0 / 3840&#xA;OFF_Y0 = 2160 / 3240 &#xA;OFF_X1 = 1920 / 3840&#xA;OFF_Y1 = 3240 / 3240&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 转换为矩阵&#xA;Rect Control::GetRect(int _width, int _height, int _top, int _left)&#xA;{&#xA;    Rect rect;&#xA;    rect.x0 = _left;&#xA;    rect.y0 = _top;&#xA;    rect.x1 = _width + _left;&#xA;    rect.y1 = _height + _top;&#xA;    return std::move(rect);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 计算矩形交点&#xA;Rect Control::GetIntersectRect(Rect* _a, Rect* _b, bool* _error)&#xA;{&#xA;    // 重置&#xA;    (*_error) = false;&#xA;    // 对象&#xA;    Rect rect;&#xA;    // 计算&#xA;    rect.x0 = max(_a-&amp;gt;x0, _b-&amp;gt;x0);&#xA;    rect.y0 = max(_a-&amp;gt;y0, _b-&amp;gt;y0);&#xA;    rect.x1 = min(_a-&amp;gt;x1, _b-&amp;gt;x1);&#xA;    rect.y1 = min(_a-&amp;gt;y1, _b-&amp;gt;y1);&#xA;    // 判断是否相交&#xA;    if (rect.x0 &amp;gt;= rect.x1 || rect.y0 &amp;gt;= rect.y1)&#xA;    {&#xA;    *_error = true;&#xA;    }&#xA;    // 相交区域&#xA;    return std::move(rect);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Offset Control::GetOffset(int _src_top, int _src_left, int _dst_top, int _dst_left)&#xA;{&#xA;    Offset offset;&#xA;    if(_src_left &amp;lt; _dst_left)&#xA;    {&#xA;    offset.left = 0;&#xA;    }&#xA;    else&#xA;    {&#xA;    offset.left = _src_left - _dst_left;&#xA;    }&#xA;    if(_src_top &amp;lt; _dst_top)&#xA;    {&#xA;    offset.top = 0;&#xA;    }&#xA;    else&#xA;    {&#xA;    offset.top = _src_top - _dst_top;&#xA;    }&#xA;    return std::move(offset);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Size Control::GetRectSize(Rect* _rect)&#xA;{&#xA;    Size size;&#xA;    size.width = _rect-&amp;gt;x1 - _rect-&amp;gt;x0;&#xA;    size.height = _rect-&amp;gt;y1 - _rect-&amp;gt;y0;&#xA;    return std::move(size);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// _width 是Pobj的宽&#xA;// _height 是Pobj的高&#xA;// _rect 是相交区域矩阵坐标&#xA;Change Control::GetChangeRect(int _width, int _height, Rect* _rect)&#xA;{&#xA;    Change change;&#xA;    change.off_x0 = float(_rect-&amp;gt;x0) / _width;&#xA;    change.off_y0 = float(_rect-&amp;gt;y0) / _height;&#xA;    change.off_x1 = float(_rect-&amp;gt;x1) / _width;&#xA;    change.off_y1 = float(_rect-&amp;gt;y1) / _height;&#xA;    return std::move(change);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// _b 是Pobj的矩阵坐标&#xA;// _c 是相交区域矩阵坐标&#xA;Change Control::GetChangeRect(Rect* _b, Rect* _c)&#xA;{&#xA;    int b_width = _b-&amp;gt;x1 - _b-&amp;gt;x0;&#xA;    int b_height = _b-&amp;gt;y1 - _b-&amp;gt;y0;&#xA;    int c_width = _c-&amp;gt;x1 - _c-&amp;gt;x0;&#xA;    int c_height = _c-&amp;gt;y1 - _c-&amp;gt;y0;&#xA;    Rect v;&#xA;    v.x0 = _c-&amp;gt;x0 - _b-&amp;gt;x0;&#xA;    v.y0 = _c-&amp;gt;y0 - _b-&amp;gt;y0;&#xA;    v.x1 = v.x0 + c_width;&#xA;    v.y1 = v.y0 + c_height;&#xA;    Change change;&#xA;    change.off_x0 = float(v.x0) / b_width;&#xA;    change.off_y0 = float(v.y0) / b_height;&#xA;    change.off_x1 = float(v.x1) / b_width;&#xA;    change.off_y1 = float(v.y1) / b_height;&#xA;    return std::move(change);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++0x之右值引用</title>
      <link>http://www.nljb.net/default/C%2B%2B0x%E4%B9%8B%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</link>
      <pubDate>2014-10-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;右值引用（及其支持的Move语意和完美转发）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;是C++0x将要加入的最重大语言特性之一&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这点从该特性的提案在C++ - State of the Evolution列表上高居榜首也可以看得出来。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从实践角度讲，它能够完美解决C++中长久以来为人所诟病的临时对象效率问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从库设计者的角度讲，它给库设计者又带来了一把利器。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升…&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; v = readFile();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;readFile()的定义是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; readFile()&#xA;{&#xA;  std::vector&amp;lt;int&amp;gt; retv;&#xA;  … // fill retv&#xA;  return retv;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这段代码低效的地方在于那个返回的临时对象。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一整个vector得被拷贝一遍，仅仅是为了传递其中的一组int，当v被构造完毕之后，这个临时对象便烟消云散。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这完全是公然的浪费！&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;简而言之，问题可以描述为：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;C++没有区分copy和move语意。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;什么是move语意？记得auto_ptr吗？auto_ptr在“拷贝”的时候其实并非严格意义上的拷贝。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“拷贝”是要保留源对象不变，并基于它复制出一个新的对象出来。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但auto_ptr的“拷贝”却会将源对象“掏空”，只留一个空壳——一次资源所有权的转移。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;这就是move。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Move语意的作用——效率优化&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最初的例子——完美解决方案&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在先前的那个例子中&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v = readFile();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;有了move语意的话，readFile就可以简单的改成：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; readFile()&#xA;{&#xA;std::vector&amp;lt;int&amp;gt; retv;&#xA;… // fill retv&#xA;return std::move(retv); // move retv out&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;std::move就可以把retv掏空，即搬移出去，而搬家的最终目的地是v。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样的话，从内存分配的角度讲，只有retv中进行的内存分配，在从retv到返回的临时对象&lt;/p&gt;&#xA;&#xA;&lt;p&gt;再从后者到目的地v的“move”过程中, 没有任何的内存分配（我是指vector内的缓冲区分配）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取而代之的是，先是retv内的缓冲区被“转移”到返回值临时对象中，然后再从临时对象中转移到v中。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Asio之Buffer篇</title>
      <link>http://www.nljb.net/default/Asio%E4%B9%8BBuffer%E7%AF%87/</link>
      <pubDate>2014-10-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用read_until() 和 async_read_until() 读取line-based&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（使用&amp;rdquo;\r\n&amp;rdquo;或者其它自定义字符序列作为分隔符）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;数据时需要boost::asio::streambuf来缓存读取到的数据。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;示例：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;boost::asio::streambuf sb;&#xA;...&#xA;std::size_t n = boost::asio::read_until(sock, sb, &#39;\n&#39;);&#xA;boost::asio::streambuf::const_buffers_type bufs = sb.data();&#xA;std::string line(&#xA;    boost::asio::buffers_begin(bufs),&#xA;    boost::asio::buffers_begin(bufs) + n);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;按行读取:&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    boost::system::error_code error;&#xA;    boost::asio::streambuf content;&#xA;    istream content_stream(&amp;amp;content);&#xA;    char _buffer[8192];&#xA;    while(true)&#xA;    {&#xA;        bzero(_buffer, 8192);&#xA;        size_t n = read_until(*_sock, content, &amp;quot;\n&amp;quot;, error);&#xA;        content_stream.getline(_buffer, n);&#xA;        if(error)&#xA;        {&#xA;    ...&#xA;    }&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;例子:&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//&#xA;// sync_client.cpp&#xA;// ~~~~~~~~~~~~~~~&#xA;//&#xA;// Copyright (c) 2003-2011 Christopher M. Kohlhoff (chris at kohlhoff dot com)&#xA;//&#xA;// Distributed under the Boost Software License, Version 1.0. (See accompanying&#xA;// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)&#xA;//&#xA;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;istream&amp;gt;&#xA;#include &amp;lt;ostream&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;boost/asio.hpp&amp;gt;&#xA;&#xA;using boost::asio::ip::tcp;&#xA;&#xA;int main(int argc, char* argv[])&#xA;{&#xA;  try&#xA;  {&#xA;    if (argc != 3)&#xA;    {&#xA;      std::cout &amp;lt;&amp;lt; &amp;quot;Usage: sync_client &amp;lt;server&amp;gt; &amp;lt;path&amp;gt;\n&amp;quot;;&#xA;      std::cout &amp;lt;&amp;lt; &amp;quot;Example:\n&amp;quot;;&#xA;      std::cout &amp;lt;&amp;lt; &amp;quot;  sync_client www.boost.org /LICENSE_1_0.txt\n&amp;quot;;&#xA;      return 1;&#xA;    }&#xA;&#xA;    boost::asio::io_service io_service;&#xA;&#xA;    // Get a list of endpoints corresponding to the server name.&#xA;    tcp::resolver resolver(io_service);&#xA;    tcp::resolver::query query(argv[1], &amp;quot;http&amp;quot;);&#xA;    tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);&#xA;&#xA;    // Try each endpoint until we successfully establish a connection.&#xA;    tcp::socket socket(io_service);&#xA;    boost::asio::connect(socket, endpoint_iterator);&#xA;&#xA;    // Form the request. We specify the &amp;quot;Connection: close&amp;quot; header so that the&#xA;    // server will close the socket after transmitting the response. This will&#xA;    // allow us to treat all data up until the EOF as the content.&#xA;    boost::asio::streambuf request;&#xA;    std::ostream request_stream(&amp;amp;request);&#xA;    request_stream &amp;lt;&amp;lt; &amp;quot;GET &amp;quot; &amp;lt;&amp;lt; argv[2] &amp;lt;&amp;lt; &amp;quot; HTTP/1.0\r\n&amp;quot;;&#xA;    request_stream &amp;lt;&amp;lt; &amp;quot;Host: &amp;quot; &amp;lt;&amp;lt; argv[1] &amp;lt;&amp;lt; &amp;quot;\r\n&amp;quot;;&#xA;    request_stream &amp;lt;&amp;lt; &amp;quot;Accept: */*\r\n&amp;quot;;&#xA;    request_stream &amp;lt;&amp;lt; &amp;quot;Connection: close\r\n\r\n&amp;quot;;&#xA;&#xA;    // Send the request.&#xA;    boost::asio::write(socket, request);&#xA;&#xA;    // Read the response status line. The response streambuf will automatically&#xA;    // grow to accommodate the entire line. The growth may be limited by passing&#xA;    // a maximum size to the streambuf constructor.&#xA;    boost::asio::streambuf response;&#xA;    boost::asio::read_until(socket, response, &amp;quot;\r\n&amp;quot;);&#xA;&#xA;    // Check that response is OK.&#xA;    std::istream response_stream(&amp;amp;response);&#xA;    std::string http_version;&#xA;    response_stream &amp;gt;&amp;gt; http_version;&#xA;    unsigned int status_code;&#xA;    response_stream &amp;gt;&amp;gt; status_code;&#xA;    std::string status_message;&#xA;    std::getline(response_stream, status_message);&#xA;    if (!response_stream || http_version.substr(0, 5) != &amp;quot;HTTP/&amp;quot;)&#xA;    {&#xA;      std::cout &amp;lt;&amp;lt; &amp;quot;Invalid response\n&amp;quot;;&#xA;      return 1;&#xA;    }&#xA;    if (status_code != 200)&#xA;    {&#xA;      std::cout &amp;lt;&amp;lt; &amp;quot;Response returned with status code &amp;quot; &amp;lt;&amp;lt; status_code &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&#xA;      return 1;&#xA;    }&#xA;&#xA;    // Read the response headers, which are terminated by a blank line.&#xA;    boost::asio::read_until(socket, response, &amp;quot;\r\n\r\n&amp;quot;);&#xA;&#xA;    // Process the response headers.&#xA;    std::string header;&#xA;    while (std::getline(response_stream, header) &amp;amp;&amp;amp; header != &amp;quot;\r&amp;quot;)&#xA;      std::cout &amp;lt;&amp;lt; header &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&#xA;    std::cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&#xA;&#xA;    // Write whatever content we already have to output.&#xA;    if (response.size() &amp;gt; 0)&#xA;      std::cout &amp;lt;&amp;lt; &amp;amp;response;&#xA;&#xA;    // Read until EOF, writing data to output as we go.&#xA;    boost::system::error_code error;&#xA;    while (boost::asio::read(socket, response,&#xA;      boost::asio::transfer_at_least(1), error))&#xA;      std::cout &amp;lt;&amp;lt; &amp;amp;response;&#xA;    if (error != boost::asio::error::eof)&#xA;      throw boost::system::system_error(error);&#xA;  }&#xA;  catch (std::exception&amp;amp; e)&#xA;  {&#xA;    std::cout &amp;lt;&amp;lt; &amp;quot;Exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&#xA;  }&#xA;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Program received signal SIGPIPE, Broken pipe.</title>
      <link>http://www.nljb.net/default/Program-received-signal-SIGPIPE%2C-Broken-pipe./</link>
      <pubDate>2014-10-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天通过send发送消息并通过返回来判断连接是否异常(发送是否成功)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是程序却自动退出了&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;GDB查看发现&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Program received signal SIGPIPE, Broken pipe.&#xA;0x0000003a7fcd55f5 in send () from /lib64/libc.so.6&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;网上查了一下资料&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在linux下写socket的程序的时候&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果尝试send到一个disconnected socket上，就会让底层抛出一个SIGPIPE信号。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个信号的缺省处理方法是退出进程，大多数时候这都不是我们期望的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此我们需要重载这个信号的处理方法。调用以下代码，即可安全的屏蔽SIGPIPE：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct sigaction sa;&#xA;sa.sa_handler = SIG_IGN;&#xA;sigaction( SIGPIPE, &amp;amp;sa, 0 );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;解决办法很多，也很简单。&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// client中忽略SIGPIPE信号&#xA;signal(SIGPIPE, SIG_IGN);&#xA;&#xA;// 阻止SIGPIPE信号&#xA;sigset_t set;&#xA;sigemptyset(&amp;amp;set);&#xA;sigaddset(&amp;amp;set, SIGPIPE);&#xA;sigprocmask(SIG_BLOCK, &amp;amp;set, NULL);&#xA;&#xA;// 为SIGPIPE添加信号处理函数，处理完程序继续执行&#xA;signal(SIGPIPE, pipesig_handler);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Asio异步Socket处理</title>
      <link>http://www.nljb.net/default/Asio%E5%BC%82%E6%AD%A5Socket%E5%A4%84%E7%90%86/</link>
      <pubDate>2014-10-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;保存Socket连接方法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sock_pt sock(new ip::tcp::socket(ios));&#xA;// 改为&#xA;sock_pt * sock = new sock_pt(new ip::tcp::socket(ios));&#xA;// 需要手动释放&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;.h&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef XPLAYEVENT_H&#xA;#define XPLAYEVENT_H&#xA;&#xA;#include &amp;lt;boost/asio.hpp&amp;gt;&#xA;#include &amp;lt;boost/asio/ip/address.hpp&amp;gt;&#xA;#include &amp;lt;boost/bind.hpp&amp;gt;&#xA;#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&#xA;&#xA;using namespace std;&#xA;using namespace boost::asio;&#xA;using namespace boost;&#xA;&#xA;class XplayEvent&#xA;{&#xA;public:&#xA;    XplayEvent(io_service&amp;amp; io):ios(io),&#xA;    acceptor(ios, ip::tcp::endpoint(ip::tcp::v4(), 6688))&#xA;    {&#xA;    start();&#xA;    }&#xA;private:&#xA;    io_service&amp;amp; ios;&#xA;    ip::tcp::acceptor acceptor;&#xA;    typedef boost::shared_ptr&amp;lt;ip::tcp::socket&amp;gt; sock_pt;&#xA;public:&#xA;    void start();&#xA;    void handler(const system::error_code&amp;amp;, sock_pt);&#xA;    void write(const system::error_code&amp;amp;);&#xA;};&#xA;&#xA;#endif // XPLAYEVENT_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;.cpp&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;include/XplayEvent.h&amp;quot;&#xA;#include &amp;lt;glog/logging.h&amp;gt;&#xA;&#xA;void XplayEvent::start()&#xA;{&#xA;    sock_pt sock(new ip::tcp::socket(ios));&#xA;    acceptor.async_accept(*sock,&#xA;              bind(&amp;amp;XplayEvent::handler, this, boost::asio::placeholders::error, sock));&#xA;}&#xA;&#xA;void XplayEvent::handler(const system::error_code&amp;amp; ec, sock_pt sock)&#xA;{&#xA;    if(ec)&#xA;    return;&#xA;    LOG(INFO) &amp;lt;&amp;lt; &amp;quot;client:&amp;quot; &amp;lt;&amp;lt; sock-&amp;gt;remote_endpoint().address() &amp;lt;&amp;lt; endl;&#xA;    sock-&amp;gt;async_write_some(buffer(&amp;quot;hello asio\n&amp;quot;),&#xA;               bind(&amp;amp;XplayEvent::write, this, boost::asio::placeholders::error));&#xA;    sock-&amp;gt;async_write_some(buffer(&amp;quot;hello asio\n&amp;quot;),&#xA;               bind(&amp;amp;XplayEvent::write, this, boost::asio::placeholders::error));&#xA;    start();&#xA;}&#xA;&#xA;void XplayEvent::write(const system::error_code&amp;amp;)&#xA;{&#xA;    LOG(INFO) &amp;lt;&amp;lt; &amp;quot;send mes complete.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Asio同步Socket处理</title>
      <link>http://www.nljb.net/default/Asio%E5%90%8C%E6%AD%A5Socket%E5%A4%84%E7%90%86/</link>
      <pubDate>2014-10-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;关于保存Socket连接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 由于栈的原因，连接被释放了...&#xA;ip::tcp::socket sock(ios);&#xA;// 改为堆的方式，连接被保留了...&#xA;ip::tcp::socket * sock = new ip::tcp::socket(ios);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;.h&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef XPLAYEVENT_H&#xA;#define XPLAYEVENT_H&#xA;&#xA;#include &amp;lt;boost/asio.hpp&amp;gt;&#xA;#include &amp;lt;boost/asio/ip/address.hpp&amp;gt;&#xA;#include &amp;lt;boost/bind.hpp&amp;gt;&#xA;#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&#xA;&#xA;using namespace std;&#xA;using namespace boost::asio;&#xA;using namespace boost;&#xA;&#xA;class XplayEvent&#xA;{&#xA;public:&#xA;    XplayEvent();&#xA;public:&#xA;    void start();&#xA;};&#xA;&#xA;#endif // XPLAYEVENT_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;.cpp&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;include/XplayEvent.h&amp;quot;&#xA;#include &amp;lt;glog/logging.h&amp;gt;&#xA;&#xA;XplayEvent::XplayEvent()&#xA;{&#xA;&#xA;}&#xA;&#xA;void XplayEvent::start()&#xA;{&#xA;    try&#xA;    {&#xA;    io_service ios;&#xA;    ip::tcp::acceptor acceptor(ios,&#xA;                   ip::tcp::endpoint(ip::tcp::v4(), 6688));&#xA;    LOG(INFO) &amp;lt;&amp;lt; &amp;quot;XplayEvent::&amp;quot; &amp;lt;&amp;lt; acceptor.local_endpoint().address() &amp;lt;&amp;lt; endl;&#xA;    while(true)&#xA;    {&#xA;        ip::tcp::socket sock(ios);&#xA;        acceptor.accept(sock);&#xA;        LOG(INFO) &amp;lt;&amp;lt; &amp;quot;XplayEvent::&amp;quot; &amp;lt;&amp;lt; &amp;quot;xplay -&amp;gt;&amp;quot; &amp;lt;&amp;lt; sock.remote_endpoint().address() &amp;lt;&amp;lt; endl;&#xA;        sock.write_some(buffer(&amp;quot;hello asio\n&amp;quot;));&#xA;    }&#xA;    }&#xA;    catch (std::exception&amp;amp; e)&#xA;    {&#xA;    LOG(ERROR) &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; endl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>GLog-日志库</title>
      <link>http://www.nljb.net/default/GLog-%E6%97%A5%E5%BF%97%E5%BA%93/</link>
      <pubDate>2014-10-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Google Glog 是一个C++语言的应用级日志记录框架，提供了C++风格的流操作和各种助手宏。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码位于谷歌代码“google-glog”项目&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;安装&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载地址&#xA;https://code.google.com/p/google-glog/downloads/list&#xA;&#xA;// 安装&#xA;./configure ; make ; make install&#xA;&#xA;// Lib&#xA;LIBS += -lglog&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;示例&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;glog/logging.h&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;// 日志支持类型&#xA;// INFO = GLOG_INFO&#xA;// WARNING = GLOG_WARNING,&#xA;// ERROR = GLOG_ERROR&#xA;// FATAL = GLOG_FATAL;&#xA;&#xA;int main(int argc,char *argv[])&#xA;{&#xA;    // 输出日志到文件&#xA;    // 如果不设置输出文件,则默认输出到/tmp/下&#xA;    google::InitGoogleLogging(argv[0]);&#xA;&#xA;    // 设置 google::INFO 级别的日志存储路径和文件名前缀&#xA;    // google::SetLogDestination(google::INFO,LOGDIR&amp;quot;/INFO_&amp;quot;);&#xA;    // 设置 google::WARNING 级别的日志存储路径和文件名前缀&#xA;    // google::SetLogDestination(google::WARNING,LOGDIR&amp;quot;/WARNING_&amp;quot;);&#xA;    // 设置 google::ERROR 级别的日志存储路径和文件名前缀&#xA;    // google::SetLogDestination(google::ERROR,LOGDIR&amp;quot;/ERROR_&amp;quot;);&#xA;    // 设置 google::FATAL 级别的日志存储路径和文件名前缀&#xA;    // google::SetLogDestination(google::FATAL,LOGDIR&amp;quot;/FATAL_&amp;quot;);&#xA;&#xA;    // 缓冲日志输出，默认为30秒，此处改为立即输出&#xA;    FLAGS_logbufsecs =0;&#xA;&#xA;    // 最大日志大小为 100MB&#xA;    FLAGS_max_log_size =100;&#xA;&#xA;    // 当磁盘被写满时，停止日志输出&#xA;    FLAGS_stop_logging_if_full_disk = true;&#xA;&#xA;    // 设置文件名扩展，如平台？或其它需要区分的信息&#xA;    google::SetLogFilenameExtension(&amp;quot;91_&amp;quot;);&#xA;&#xA;    // 设置级别高于 google::INFO 的日志同时输出到屏幕&#xA;    google::SetStderrLogging(google::INFO);&#xA;&#xA;    // 设置输出到屏幕的日志显示相应颜色&#xA;    FLAGS_colorlogtostderr=true;&#xA;&#xA;    // 当条件满足时输出日志&#xA;    LOG_IF(INFO, 20 &amp;gt; 10) &amp;lt;&amp;lt; &amp;quot;OK&amp;quot;;&#xA;&#xA;    // 输出信息&#xA;    LOG(INFO)    &amp;lt;&amp;lt; &amp;quot;log message...&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    LOG(WARNING) &amp;lt;&amp;lt; &amp;quot;log message...&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    LOG(ERROR)   &amp;lt;&amp;lt; &amp;quot;log message...&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    LOG(FATAL)   &amp;lt;&amp;lt; &amp;quot;log message...&amp;quot; &amp;lt;&amp;lt; endl;&#xA;&#xA;    // 输出结束&#xA;    google::ShutdownGoogleLogging();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Boost-组件库编译方法</title>
      <link>http://www.nljb.net/default/Boost-%E7%BB%84%E4%BB%B6%E5%BA%93%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-10-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Boost库是一个可移植、提供源代码的C++库，作为标准库的后备，是C++标准化进程的开发引擎之一。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Boost库由C++标准委员会库工作组成员发起，其中有些内容有望成为下一代C++标准库内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在C++社区中影响甚大，是不折不扣的“准”标准库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Boost由于其对跨平台的强调，对标准C++的强调，与编写平台无关。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大部分boost库功能的使用只需包括相应头文件即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但Boost中也有很多是实验性质的东西，在实际的开发中实用需要谨慎。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 执行(得到b2)&#xA;./bootstrap.sh --prefix=/usr/local&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 编译所有&#xA;./b2 install --with=all&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 指定编译&#xA;./b2 install --with=thread&#xA;&#xA;    - atomic                   : not building&#xA;    - chrono                   : not building&#xA;    - context                  : not building&#xA;    - date_time                : not building&#xA;    - exception                : not building&#xA;    - filesystem               : not building&#xA;    - graph                    : not building&#xA;    - graph_parallel           : not building&#xA;    - iostreams                : not building&#xA;    - locale                   : not building&#xA;    - math                     : not building&#xA;    - mpi                      : not building&#xA;    - program_options          : not building&#xA;    - python                   : not building&#xA;    - random                   : not building&#xA;    - regex                    : not building&#xA;    - serialization            : not building&#xA;    - signals                  : not building&#xA;    - system                   : not building&#xA;    - test                     : not building&#xA;    - thread                   : building&#xA;    - timer                    : not building&#xA;    - wave                     : not building&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>sync.Pool</title>
      <link>http://www.nljb.net/default/sync.Pool/</link>
      <pubDate>2014-09-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go 1.3 的sync包中加入一个新特性：Pool。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;官方文档可以看这里&lt;a href=&#34;http://golang.org/pkg/sync/#Pool&#34;&gt;http://golang.org/pkg/sync/#Pool&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个类设计的目的是用来保存和复用临时对象，以减少内存分配，降低CG压力。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Pool  &#xA;    func (p *Pool) Get() interface{}  &#xA;    func (p *Pool) Put(x interface{})  &#xA;    New func() interface{}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Get返回Pool中的任意一个对象。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果Pool为空，则调用New返回一个新创建的对象。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果没有设置New，则返回nil。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;还有一个重要的特性是，放进Pool中的对象，会在说不准什么时候被回收掉。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以如果事先Put进去100个对象，下次Get的时候发现Pool是空也是有可能的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过这个特性的一个好处就在于不用担心Pool会一直增长，因为Go已经帮你在Pool中做了回收机制。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个清理过程是在每次垃圾回收之前做的。垃圾回收是固定两分钟触发一次。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而且每次清理会将Pool中的所有对象都清理掉！&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import(&#xA;    &amp;quot;sync&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;func main(){&#xA;&#xA;    // 建立对象&#xA;    var pipe = &amp;amp;sync.Pool{New:func()interface{}{return &amp;quot;Hello,BeiJing&amp;quot;}}&#xA;&#xA;    // 准备放入的字符串&#xA;    val := &amp;quot;Hello,World!&amp;quot;&#xA;&#xA;    // 放入&#xA;    pipe.Put(val)&#xA;&#xA;    // 取出&#xA;    log.Println(pipe.Get())&#xA;&#xA;    // 再取就没有了,会自动调用NEW&#xA;    log.Println(pipe.Get())&#xA;&#xA;}&#xA;&#xA;// 输出&#xA;2014/09/30 15:43:30 Hello,World!&#xA;2014/09/30 15:43:30 Hello,BeiJing&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>XRandR</title>
      <link>http://www.nljb.net/default/XRandR/</link>
      <pubDate>2014-09-30 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// XRandR 源码&#xA;&#xA;/* &#xA; * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.&#xA; * Copyright © 2002 Hewlett Packard Company, Inc.&#xA; * Copyright © 2006 Intel Corporation&#xA; * Copyright © 2013 NVIDIA Corporation&#xA; *&#xA; * Permission to use, copy, modify, distribute, and sell this software and its&#xA; * documentation for any purpose is hereby granted without fee, provided that&#xA; * the above copyright notice appear in all copies and that both that copyright&#xA; * notice and this permission notice appear in supporting documentation, and&#xA; * that the name of the copyright holders not be used in advertising or&#xA; * publicity pertaining to distribution of the software without specific,&#xA; * written prior permission.  The copyright holders make no representations&#xA; * about the suitability of this software for any purpose.  It is provided &amp;quot;as&#xA; * is&amp;quot; without express or implied warranty.&#xA; *&#xA; * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,&#xA; * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO&#xA; * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR&#xA; * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,&#xA; * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER&#xA; * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE&#xA; * OF THIS SOFTWARE.&#xA; *&#xA; * Thanks to Jim Gettys who wrote most of the client side code,&#xA; * and part of the server code for randr.&#xA; */&#xA;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;X11/Xlib.h&amp;gt;&#xA;#include &amp;lt;X11/Xlibint.h&amp;gt;&#xA;#include &amp;lt;X11/Xproto.h&amp;gt;&#xA;#include &amp;lt;X11/Xatom.h&amp;gt;&#xA;#include &amp;lt;X11/extensions/Xrandr.h&amp;gt;&#xA;#include &amp;lt;X11/extensions/Xrender.h&amp;gt; /* we share subpixel information */&#xA;#include &amp;lt;strings.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;stdint.h&amp;gt;&#xA;#include &amp;lt;inttypes.h&amp;gt;&#xA;#include &amp;lt;stdarg.h&amp;gt;&#xA;#include &amp;lt;math.h&amp;gt;&#xA;&#xA;#ifdef HAVE_CONFIG_H&#xA;#include &amp;quot;config.h&amp;quot;&#xA;#endif&#xA;&#xA;static char *program_name;&#xA;static Display  *dpy;&#xA;static Window   root;&#xA;static int  screen = -1;&#xA;static Bool verbose = False;&#xA;static Bool automatic = False;&#xA;static Bool properties = False;&#xA;static Bool grab_server = True;&#xA;static Bool no_primary = False;&#xA;&#xA;static const char *direction[5] = {&#xA;    &amp;quot;normal&amp;quot;, &#xA;    &amp;quot;left&amp;quot;, &#xA;    &amp;quot;inverted&amp;quot;, &#xA;    &amp;quot;right&amp;quot;,&#xA;    &amp;quot;\n&amp;quot;};&#xA;&#xA;static const char *reflections[5] = {&#xA;    &amp;quot;normal&amp;quot;, &#xA;    &amp;quot;x&amp;quot;, &#xA;    &amp;quot;y&amp;quot;, &#xA;    &amp;quot;xy&amp;quot;,&#xA;    &amp;quot;\n&amp;quot;};&#xA;&#xA;/* subpixel order */&#xA;static const char *order[6] = {&#xA;    &amp;quot;unknown&amp;quot;,&#xA;    &amp;quot;horizontal rgb&amp;quot;,&#xA;    &amp;quot;horizontal bgr&amp;quot;,&#xA;    &amp;quot;vertical rgb&amp;quot;,&#xA;    &amp;quot;vertical bgr&amp;quot;,&#xA;    &amp;quot;no subpixels&amp;quot;};&#xA;&#xA;static const struct {&#xA;    const char      *string;&#xA;    unsigned long   flag;&#xA;} mode_flags[] = {&#xA;    { &amp;quot;+HSync&amp;quot;, RR_HSyncPositive },&#xA;    { &amp;quot;-HSync&amp;quot;, RR_HSyncNegative },&#xA;    { &amp;quot;+VSync&amp;quot;, RR_VSyncPositive },&#xA;    { &amp;quot;-VSync&amp;quot;, RR_VSyncNegative },&#xA;    { &amp;quot;Interlace&amp;quot;, RR_Interlace },&#xA;    { &amp;quot;DoubleScan&amp;quot;, RR_DoubleScan },&#xA;    { &amp;quot;CSync&amp;quot;,      RR_CSync },&#xA;    { &amp;quot;+CSync&amp;quot;,     RR_CSyncPositive },&#xA;    { &amp;quot;-CSync&amp;quot;,     RR_CSyncNegative },&#xA;    { NULL,     0 }&#xA;};&#xA;&#xA;static void&#xA;usage(void)&#xA;{&#xA;    printf(&amp;quot;usage: %s [options]\n%s&amp;quot;, program_name,&#xA;       &amp;quot;  where options are:\n&amp;quot;&#xA;       &amp;quot;  --display &amp;lt;display&amp;gt; or -d &amp;lt;display&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --help\n&amp;quot;&#xA;       &amp;quot;  -o &amp;lt;normal,inverted,left,right,0,1,2,3&amp;gt;\n&amp;quot;&#xA;       &amp;quot;            or --orientation &amp;lt;normal,inverted,left,right,0,1,2,3&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  -q        or --query\n&amp;quot;&#xA;       &amp;quot;  -s &amp;lt;size&amp;gt;/&amp;lt;width&amp;gt;x&amp;lt;height&amp;gt; or --size &amp;lt;size&amp;gt;/&amp;lt;width&amp;gt;x&amp;lt;height&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  -r &amp;lt;rate&amp;gt; or --rate &amp;lt;rate&amp;gt; or --refresh &amp;lt;rate&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  -v        or --version\n&amp;quot;&#xA;       &amp;quot;  -x        (reflect in x)\n&amp;quot;&#xA;       &amp;quot;  -y        (reflect in y)\n&amp;quot;&#xA;       &amp;quot;  --screen &amp;lt;screen&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --verbose\n&amp;quot;&#xA;       &amp;quot;  --current\n&amp;quot;&#xA;       &amp;quot;  --dryrun\n&amp;quot;&#xA;       &amp;quot;  --nograb\n&amp;quot;&#xA;       &amp;quot;  --prop or --properties\n&amp;quot;&#xA;       &amp;quot;  --fb &amp;lt;width&amp;gt;x&amp;lt;height&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --fbmm &amp;lt;width&amp;gt;x&amp;lt;height&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --dpi &amp;lt;dpi&amp;gt;/&amp;lt;output&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --output &amp;lt;output&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --auto\n&amp;quot;&#xA;       &amp;quot;      --mode &amp;lt;mode&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --preferred\n&amp;quot;&#xA;       &amp;quot;      --pos &amp;lt;x&amp;gt;x&amp;lt;y&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --rate &amp;lt;rate&amp;gt; or --refresh &amp;lt;rate&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --reflect normal,x,y,xy\n&amp;quot;&#xA;       &amp;quot;      --rotate normal,inverted,left,right\n&amp;quot;&#xA;       &amp;quot;      --left-of &amp;lt;output&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --right-of &amp;lt;output&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --above &amp;lt;output&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --below &amp;lt;output&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --same-as &amp;lt;output&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --set &amp;lt;property&amp;gt; &amp;lt;value&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --scale &amp;lt;x&amp;gt;x&amp;lt;y&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --scale-from &amp;lt;w&amp;gt;x&amp;lt;h&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --transform &amp;lt;a&amp;gt;,&amp;lt;b&amp;gt;,&amp;lt;c&amp;gt;,&amp;lt;d&amp;gt;,&amp;lt;e&amp;gt;,&amp;lt;f&amp;gt;,&amp;lt;g&amp;gt;,&amp;lt;h&amp;gt;,&amp;lt;i&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --off\n&amp;quot;&#xA;       &amp;quot;      --crtc &amp;lt;crtc&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --panning &amp;lt;w&amp;gt;x&amp;lt;h&amp;gt;[+&amp;lt;x&amp;gt;+&amp;lt;y&amp;gt;[/&amp;lt;track:w&amp;gt;x&amp;lt;h&amp;gt;+&amp;lt;x&amp;gt;+&amp;lt;y&amp;gt;[/&amp;lt;border:l&amp;gt;/&amp;lt;t&amp;gt;/&amp;lt;r&amp;gt;/&amp;lt;b&amp;gt;]]]\n&amp;quot;&#xA;       &amp;quot;      --gamma &amp;lt;r&amp;gt;:&amp;lt;g&amp;gt;:&amp;lt;b&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --brightness &amp;lt;value&amp;gt;\n&amp;quot;&#xA;       &amp;quot;      --primary\n&amp;quot;&#xA;       &amp;quot;  --noprimary\n&amp;quot;&#xA;       &amp;quot;  --newmode &amp;lt;name&amp;gt; &amp;lt;clock MHz&amp;gt;\n&amp;quot;&#xA;       &amp;quot;            &amp;lt;hdisp&amp;gt; &amp;lt;hsync-start&amp;gt; &amp;lt;hsync-end&amp;gt; &amp;lt;htotal&amp;gt;\n&amp;quot;&#xA;       &amp;quot;            &amp;lt;vdisp&amp;gt; &amp;lt;vsync-start&amp;gt; &amp;lt;vsync-end&amp;gt; &amp;lt;vtotal&amp;gt;\n&amp;quot;&#xA;       &amp;quot;            [flags...]\n&amp;quot;&#xA;       &amp;quot;            Valid flags: +HSync -HSync +VSync -VSync\n&amp;quot;&#xA;       &amp;quot;                         +CSync -CSync CSync Interlace DoubleScan\n&amp;quot;&#xA;       &amp;quot;  --rmmode &amp;lt;name&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --addmode &amp;lt;output&amp;gt; &amp;lt;name&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --delmode &amp;lt;output&amp;gt; &amp;lt;name&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --listproviders\n&amp;quot;&#xA;       &amp;quot;  --setprovideroutputsource &amp;lt;prov-xid&amp;gt; &amp;lt;source-xid&amp;gt;\n&amp;quot;&#xA;       &amp;quot;  --setprovideroffloadsink &amp;lt;prov-xid&amp;gt; &amp;lt;sink-xid&amp;gt;\n&amp;quot;);&#xA;}&#xA;&#xA;static void _X_NORETURN _X_ATTRIBUTE_PRINTF(1,2)&#xA;fatal (const char *format, ...)&#xA;{&#xA;    va_list ap;&#xA;&#xA;    va_start (ap, format);&#xA;    fprintf (stderr, &amp;quot;%s: &amp;quot;, program_name);&#xA;    vfprintf (stderr, format, ap);&#xA;    va_end (ap);&#xA;    exit (1);&#xA;    /*NOTREACHED*/&#xA;}&#xA;&#xA;static void _X_ATTRIBUTE_PRINTF(1,2)&#xA;warning (const char *format, ...)&#xA;{&#xA;    va_list ap;&#xA;&#xA;    va_start (ap, format);&#xA;    fprintf (stderr, &amp;quot;%s: &amp;quot;, program_name);&#xA;    vfprintf (stderr, format, ap);&#xA;    va_end (ap);&#xA;}&#xA;&#xA;static void _X_NORETURN _X_ATTRIBUTE_PRINTF(1,2)&#xA;argerr (const char *format, ...)&#xA;{&#xA;    va_list ap;&#xA;&#xA;    va_start (ap, format);&#xA;    fprintf (stderr, &amp;quot;%s: &amp;quot;, program_name);&#xA;    vfprintf (stderr, format, ap);&#xA;    fprintf (stderr, &amp;quot;Try &#39;%s --help&#39; for more information.\n&amp;quot;, program_name);&#xA;    va_end (ap);&#xA;    exit (1);&#xA;    /*NOTREACHED*/&#xA;}&#xA;&#xA;/* Because fmin requires C99 suppport */&#xA;static inline double dmin (double x, double y)&#xA;{&#xA;    return x &amp;lt; y ? x : y;&#xA;}&#xA;&#xA;static const char *&#xA;rotation_name (Rotation rotation)&#xA;{&#xA;    int i;&#xA;&#xA;    if ((rotation &amp;amp; 0xf) == 0)&#xA;    return &amp;quot;normal&amp;quot;;&#xA;    for (i = 0; i &amp;lt; 4; i++)&#xA;    if (rotation &amp;amp; (1 &amp;lt;&amp;lt; i))&#xA;        return direction[i];&#xA;    return &amp;quot;invalid rotation&amp;quot;;&#xA;}&#xA;&#xA;static const char *&#xA;reflection_name (Rotation rotation)&#xA;{&#xA;    rotation &amp;amp;= (RR_Reflect_X|RR_Reflect_Y);&#xA;    switch (rotation) {&#xA;    case 0:&#xA;    return &amp;quot;none&amp;quot;;&#xA;    case RR_Reflect_X:&#xA;    return &amp;quot;X axis&amp;quot;;&#xA;    case RR_Reflect_Y:&#xA;    return &amp;quot;Y axis&amp;quot;;&#xA;    case RR_Reflect_X|RR_Reflect_Y:&#xA;    return &amp;quot;X and Y axis&amp;quot;;&#xA;    }&#xA;    return &amp;quot;invalid reflection&amp;quot;;&#xA;}&#xA;&#xA;static const char *&#xA;capability_name (int cap_bit)&#xA;{&#xA;    switch (cap_bit) {&#xA;    case RR_Capability_SourceOutput:&#xA;    return &amp;quot;Source Output&amp;quot;;&#xA;    case RR_Capability_SinkOutput:&#xA;    return &amp;quot;Sink Output&amp;quot;;&#xA;    case RR_Capability_SourceOffload:&#xA;    return &amp;quot;Source Offload&amp;quot;;&#xA;    case RR_Capability_SinkOffload:&#xA;    return &amp;quot;Sink Offload&amp;quot;;&#xA;    }&#xA;    return &amp;quot;invalid capability&amp;quot;;&#xA;}&#xA;&#xA;typedef enum _relation {&#xA;    relation_left_of,&#xA;    relation_right_of,&#xA;    relation_above,&#xA;    relation_below,&#xA;    relation_same_as,&#xA;} relation_t;&#xA;&#xA;typedef struct {&#xA;    int     x, y, width, height;&#xA;} rectangle_t;&#xA;&#xA;typedef struct {&#xA;    int     x1, y1, x2, y2;&#xA;} box_t;&#xA;&#xA;typedef struct {&#xA;    int     x, y;&#xA;} point_t;&#xA;&#xA;typedef enum _changes {&#xA;    changes_none = 0,&#xA;    changes_crtc = (1 &amp;lt;&amp;lt; 0),&#xA;    changes_mode = (1 &amp;lt;&amp;lt; 1),&#xA;    changes_relation = (1 &amp;lt;&amp;lt; 2),&#xA;    changes_position = (1 &amp;lt;&amp;lt; 3),&#xA;    changes_rotation = (1 &amp;lt;&amp;lt; 4),&#xA;    changes_reflection = (1 &amp;lt;&amp;lt; 5),&#xA;    changes_automatic = (1 &amp;lt;&amp;lt; 6),&#xA;    changes_refresh = (1 &amp;lt;&amp;lt; 7),&#xA;    changes_property = (1 &amp;lt;&amp;lt; 8),&#xA;    changes_transform = (1 &amp;lt;&amp;lt; 9),&#xA;    changes_panning = (1 &amp;lt;&amp;lt; 10),&#xA;    changes_gamma = (1 &amp;lt;&amp;lt; 11),&#xA;    changes_primary = (1 &amp;lt;&amp;lt; 12),&#xA;} changes_t;&#xA;&#xA;typedef enum _name_kind {&#xA;    name_none = 0,&#xA;    name_string = (1 &amp;lt;&amp;lt; 0),&#xA;    name_xid = (1 &amp;lt;&amp;lt; 1),&#xA;    name_index = (1 &amp;lt;&amp;lt; 2),&#xA;    name_preferred = (1 &amp;lt;&amp;lt; 3),&#xA;} name_kind_t;&#xA;&#xA;typedef struct {&#xA;    name_kind_t     kind;&#xA;    char            *string;&#xA;    XID             xid;&#xA;    int         index;&#xA;} name_t;&#xA;&#xA;typedef struct _crtc crtc_t;&#xA;typedef struct _output  output_t;&#xA;typedef struct _transform transform_t;&#xA;typedef struct _umode   umode_t;&#xA;typedef struct _output_prop output_prop_t;&#xA;typedef struct _provider provider_t;&#xA;&#xA;struct _transform {&#xA;    XTransform      transform;&#xA;    const char      *filter;&#xA;    int         nparams;&#xA;    XFixed      *params;&#xA;};&#xA;&#xA;struct _crtc {&#xA;    name_t      crtc;&#xA;    Bool        changing;&#xA;    XRRCrtcInfo     *crtc_info;&#xA;&#xA;    XRRModeInfo     *mode_info;&#xA;    XRRPanning      *panning_info;&#xA;    int         x;&#xA;    int         y;&#xA;    Rotation        rotation;&#xA;    output_t        **outputs;&#xA;    int         noutput;&#xA;    transform_t     current_transform, pending_transform;&#xA;};&#xA;&#xA;struct _output_prop {&#xA;    struct _output_prop *next;&#xA;    char        *name;&#xA;    char        *value;&#xA;};&#xA;&#xA;struct _output {&#xA;    struct _output   *next;&#xA;&#xA;    changes_t       changes;&#xA;&#xA;    output_prop_t   *props;&#xA;&#xA;    name_t      output;&#xA;    XRROutputInfo   *output_info;&#xA;&#xA;    name_t      crtc;&#xA;    crtc_t      *crtc_info;&#xA;    crtc_t      *current_crtc_info;&#xA;&#xA;    name_t      mode;&#xA;    double      refresh;&#xA;    XRRModeInfo     *mode_info;&#xA;&#xA;    name_t      addmode;&#xA;&#xA;    relation_t      relation;&#xA;    char        *relative_to;&#xA;&#xA;    int         x, y;&#xA;    Rotation        rotation;&#xA;&#xA;    XRRPanning      panning;&#xA;&#xA;    Bool            automatic;&#xA;    int             scale_from_w, scale_from_h;&#xA;    transform_t     transform;&#xA;&#xA;    struct {&#xA;    float red;&#xA;    float green;&#xA;    float blue;&#xA;    } gamma;&#xA;&#xA;    float       brightness;&#xA;&#xA;    Bool        primary;&#xA;&#xA;    Bool        found;&#xA;};&#xA;&#xA;typedef enum _umode_action {&#xA;    umode_create, umode_destroy, umode_add, umode_delete&#xA;} umode_action_t;&#xA;&#xA;&#xA;struct _umode {&#xA;    struct _umode   *next;&#xA;&#xA;    umode_action_t  action;&#xA;    XRRModeInfo     mode;&#xA;    name_t      output;&#xA;    name_t      name;&#xA;};&#xA;&#xA;struct _provider {&#xA;    name_t      provider;&#xA;    XRRProviderInfo *info;&#xA;};&#xA;&#xA;static const char *connection[3] = {&#xA;    &amp;quot;connected&amp;quot;,&#xA;    &amp;quot;disconnected&amp;quot;,&#xA;    &amp;quot;unknown connection&amp;quot;};&#xA;&#xA;#define OUTPUT_NAME 1&#xA;&#xA;#define CRTC_OFF    2&#xA;#define CRTC_UNSET  3&#xA;#define CRTC_INDEX  0x40000000&#xA;&#xA;#define MODE_NAME   1&#xA;#define MODE_OFF    2&#xA;#define MODE_UNSET  3&#xA;#define MODE_PREF   4&#xA;&#xA;#define POS_UNSET   -1&#xA;&#xA;static output_t *all_outputs = NULL;&#xA;static output_t **all_outputs_tail = &amp;amp;all_outputs;&#xA;static crtc_t   *crtcs;&#xA;static provider_t   *providers;&#xA;static umode_t  *umodes;&#xA;static int  num_crtcs, num_providers;&#xA;static XRRScreenResources  *res;&#xA;static int  fb_width = 0, fb_height = 0;&#xA;static int  fb_width_mm = 0, fb_height_mm = 0;&#xA;static double   dpi = 0;&#xA;static char *dpi_output_name = NULL;&#xA;static Bool dryrun = False;&#xA;static int  minWidth, maxWidth, minHeight, maxHeight;&#xA;static Bool     has_1_2 = False;&#xA;static Bool     has_1_3 = False;&#xA;static Bool     has_1_4 = False;&#xA;static name_t   provider_name, output_source_provider_name, offload_sink_provider_name;&#xA;&#xA;static int&#xA;mode_height (XRRModeInfo *mode_info, Rotation rotation)&#xA;{&#xA;    switch (rotation &amp;amp; 0xf) {&#xA;    case RR_Rotate_0:&#xA;    case RR_Rotate_180:&#xA;    return mode_info-&amp;gt;height;&#xA;    case RR_Rotate_90:&#xA;    case RR_Rotate_270:&#xA;    return mode_info-&amp;gt;width;&#xA;    default:&#xA;    return 0;&#xA;    }&#xA;}&#xA;&#xA;static int&#xA;mode_width (XRRModeInfo *mode_info, Rotation rotation)&#xA;{&#xA;    switch (rotation &amp;amp; 0xf) {&#xA;    case RR_Rotate_0:&#xA;    case RR_Rotate_180:&#xA;    return mode_info-&amp;gt;width;&#xA;    case RR_Rotate_90:&#xA;    case RR_Rotate_270:&#xA;    return mode_info-&amp;gt;height;&#xA;    default:&#xA;    return 0;&#xA;    }&#xA;}&#xA;&#xA;static Bool&#xA;transform_point (XTransform *transform, double *xp, double *yp)&#xA;{&#xA;    double  vector[3];&#xA;    double  result[3];&#xA;    int     i, j;&#xA;    double  v;&#xA;&#xA;    vector[0] = *xp;&#xA;    vector[1] = *yp;&#xA;    vector[2] = 1;&#xA;    for (j = 0; j &amp;lt; 3; j++)&#xA;    {&#xA;    v = 0;&#xA;    for (i = 0; i &amp;lt; 3; i++)&#xA;        v += (XFixedToDouble (transform-&amp;gt;matrix[j][i]) * vector[i]);&#xA;    result[j] = v;&#xA;    }&#xA;    if (!result[2])&#xA;    return False;&#xA;    for (j = 0; j &amp;lt; 2; j++) {&#xA;    vector[j] = result[j] / result[2];&#xA;    if (vector[j] &amp;gt; 32767 || vector[j] &amp;lt; -32767)&#xA;        return False;&#xA;    }&#xA;    *xp = vector[0];&#xA;    *yp = vector[1];&#xA;    return True;&#xA;}&#xA;&#xA;static void&#xA;path_bounds (XTransform *transform, point_t *points, int npoints, box_t *box)&#xA;{&#xA;    int     i;&#xA;    box_t   point;&#xA;&#xA;    for (i = 0; i &amp;lt; npoints; i++) {&#xA;    double  x, y;&#xA;    x = points[i].x;&#xA;    y = points[i].y;&#xA;    transform_point (transform, &amp;amp;x, &amp;amp;y);&#xA;    point.x1 = floor (x);&#xA;    point.y1 = floor (y);&#xA;    point.x2 = ceil (x);&#xA;    point.y2 = ceil (y);&#xA;    if (i == 0)&#xA;        *box = point;&#xA;    else {&#xA;        if (point.x1 &amp;lt; box-&amp;gt;x1) box-&amp;gt;x1 = point.x1;&#xA;        if (point.y1 &amp;lt; box-&amp;gt;y1) box-&amp;gt;y1 = point.y1;&#xA;        if (point.x2 &amp;gt; box-&amp;gt;x2) box-&amp;gt;x2 = point.x2;&#xA;        if (point.y2 &amp;gt; box-&amp;gt;y2) box-&amp;gt;y2 = point.y2;&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;static void&#xA;mode_geometry (XRRModeInfo *mode_info, Rotation rotation,&#xA;           XTransform *transform,&#xA;           box_t *bounds)&#xA;{&#xA;    point_t rect[4];&#xA;    int width = mode_width (mode_info, rotation);&#xA;    int height = mode_height (mode_info, rotation);&#xA;&#xA;    rect[0].x = 0;&#xA;    rect[0].y = 0;&#xA;    rect[1].x = width;&#xA;    rect[1].y = 0;&#xA;    rect[2].x = width;&#xA;    rect[2].y = height;&#xA;    rect[3].x = 0;&#xA;    rect[3].y = height;&#xA;    path_bounds (transform, rect, 4, bounds);&#xA;}&#xA;&#xA;/* v refresh frequency in Hz */&#xA;static double&#xA;mode_refresh (XRRModeInfo *mode_info)&#xA;{&#xA;    double rate;&#xA;    double vTotal = mode_info-&amp;gt;vTotal;&#xA;&#xA;    if (mode_info-&amp;gt;modeFlags &amp;amp; RR_DoubleScan) {&#xA;    /* doublescan doubles the number of lines */&#xA;    vTotal *= 2;&#xA;    }&#xA;&#xA;    if (mode_info-&amp;gt;modeFlags &amp;amp; RR_Interlace) {&#xA;    /* interlace splits the frame into two fields */&#xA;    /* the field rate is what is typically reported by monitors */&#xA;    vTotal /= 2;&#xA;    }&#xA;&#xA;    if (mode_info-&amp;gt;hTotal &amp;amp;&amp;amp; vTotal)&#xA;    rate = ((double) mode_info-&amp;gt;dotClock /&#xA;        ((double) mode_info-&amp;gt;hTotal * (double) vTotal));&#xA;    else&#xA;    rate = 0;&#xA;    return rate;&#xA;}&#xA;&#xA;/* h sync frequency in Hz */&#xA;static double&#xA;mode_hsync (XRRModeInfo *mode_info)&#xA;{&#xA;    double rate;&#xA;&#xA;    if (mode_info-&amp;gt;hTotal)&#xA;    rate = (double) mode_info-&amp;gt;dotClock / (double) mode_info-&amp;gt;hTotal;&#xA;    else&#xA;    rate = 0;&#xA;    return rate;&#xA;}&#xA;&#xA;static void&#xA;init_name (name_t *name)&#xA;{&#xA;    name-&amp;gt;kind = name_none;&#xA;}&#xA;&#xA;static void&#xA;set_name_string (name_t *name, char *string)&#xA;{&#xA;    name-&amp;gt;kind |= name_string;&#xA;    name-&amp;gt;string = string;&#xA;}&#xA;&#xA;static void&#xA;set_name_xid (name_t *name, XID xid)&#xA;{&#xA;    name-&amp;gt;kind |= name_xid;&#xA;    name-&amp;gt;xid = xid;&#xA;}&#xA;&#xA;static void&#xA;set_name_index (name_t *name, int idx)&#xA;{&#xA;    name-&amp;gt;kind |= name_index;&#xA;    name-&amp;gt;index = idx;&#xA;}&#xA;&#xA;static void&#xA;set_name_preferred (name_t *name)&#xA;{&#xA;    name-&amp;gt;kind |= name_preferred;&#xA;}&#xA;&#xA;static void&#xA;set_name_all (name_t *name, name_t *old)&#xA;{&#xA;    if (old-&amp;gt;kind &amp;amp; name_xid)&#xA;    name-&amp;gt;xid = old-&amp;gt;xid;&#xA;    if (old-&amp;gt;kind &amp;amp; name_string)&#xA;    name-&amp;gt;string = old-&amp;gt;string;&#xA;    if (old-&amp;gt;kind &amp;amp; name_index)&#xA;    name-&amp;gt;index = old-&amp;gt;index;&#xA;    name-&amp;gt;kind |= old-&amp;gt;kind;&#xA;}&#xA;&#xA;static void&#xA;set_name (name_t *name, char *string, name_kind_t valid)&#xA;{&#xA;    unsigned int xid; /* don&#39;t make it XID (which is unsigned long):&#xA;             scanf() takes unsigned int */&#xA;    int idx;&#xA;&#xA;    if ((valid &amp;amp; name_xid) &amp;amp;&amp;amp; sscanf (string, &amp;quot;0x%x&amp;quot;, &amp;amp;xid) == 1)&#xA;    set_name_xid (name, xid);&#xA;    else if ((valid &amp;amp; name_index) &amp;amp;&amp;amp; sscanf (string, &amp;quot;%d&amp;quot;, &amp;amp;idx) == 1)&#xA;    set_name_index (name, idx);&#xA;    else if (valid &amp;amp; name_string)&#xA;    set_name_string (name, string);&#xA;    else&#xA;    argerr (&amp;quot;invalid name &#39;%s&#39;\n&amp;quot;, string);&#xA;}&#xA;&#xA;static int&#xA;print_name (const name_t *name)&#xA;{&#xA;    name_kind_t kind = name-&amp;gt;kind;&#xA;&#xA;    if ((kind &amp;amp; name_xid))         return printf(&amp;quot;XID 0x%x&amp;quot;, (unsigned int)name-&amp;gt;xid);&#xA;    else if ((kind &amp;amp; name_string)) return printf(&amp;quot;name %s&amp;quot;, name-&amp;gt;string);&#xA;    else if ((kind &amp;amp; name_index))  return printf(&amp;quot;index %d&amp;quot;, name-&amp;gt;index);&#xA;    else                           return printf(&amp;quot;unknown name&amp;quot;);&#xA;}&#xA;&#xA;static void&#xA;init_transform (transform_t *transform)&#xA;{&#xA;    int x;&#xA;    memset (&amp;amp;transform-&amp;gt;transform, &#39;\0&#39;, sizeof (transform-&amp;gt;transform));&#xA;    for (x = 0; x &amp;lt; 3; x++)&#xA;    transform-&amp;gt;transform.matrix[x][x] = XDoubleToFixed (1.0);&#xA;    transform-&amp;gt;filter = &amp;quot;&amp;quot;;&#xA;    transform-&amp;gt;nparams = 0;&#xA;    transform-&amp;gt;params = NULL;&#xA;}&#xA;&#xA;static void&#xA;set_transform (transform_t  *dest,&#xA;           XTransform   *transform,&#xA;           const char   *filter,&#xA;           XFixed       *params,&#xA;           int      nparams)&#xA;{&#xA;    dest-&amp;gt;transform = *transform;&#xA;    /* note: this string is leaked */&#xA;    dest-&amp;gt;filter = strdup (filter);&#xA;    dest-&amp;gt;nparams = nparams;&#xA;    dest-&amp;gt;params = malloc (nparams * sizeof (XFixed));&#xA;    memcpy (dest-&amp;gt;params, params, nparams * sizeof (XFixed));&#xA;}&#xA;&#xA;static void&#xA;copy_transform (transform_t *dest, transform_t *src)&#xA;{&#xA;    set_transform (dest, &amp;amp;src-&amp;gt;transform,&#xA;           src-&amp;gt;filter, src-&amp;gt;params, src-&amp;gt;nparams);&#xA;}&#xA;&#xA;static Bool&#xA;equal_transform (transform_t *a, transform_t *b)&#xA;{&#xA;    if (memcmp (&amp;amp;a-&amp;gt;transform, &amp;amp;b-&amp;gt;transform, sizeof (XTransform)) != 0)&#xA;    return False;&#xA;    if (strcmp (a-&amp;gt;filter, b-&amp;gt;filter) != 0)&#xA;    return False;&#xA;    if (a-&amp;gt;nparams != b-&amp;gt;nparams)&#xA;    return False;&#xA;    if (memcmp (a-&amp;gt;params, b-&amp;gt;params, a-&amp;gt;nparams * sizeof (XFixed)) != 0)&#xA;    return False;&#xA;    return True;&#xA;}&#xA;&#xA;static output_t *&#xA;add_output (void)&#xA;{&#xA;    output_t *output = calloc (1, sizeof (output_t));&#xA;&#xA;    if (!output)&#xA;    fatal (&amp;quot;out of memory\n&amp;quot;);&#xA;    output-&amp;gt;next = NULL;&#xA;    output-&amp;gt;found = False;&#xA;    output-&amp;gt;brightness = 1.0;&#xA;    *all_outputs_tail = output;&#xA;    all_outputs_tail = &amp;amp;output-&amp;gt;next;&#xA;    return output;&#xA;}&#xA;&#xA;static output_t *&#xA;find_output (name_t *name)&#xA;{&#xA;    output_t *output;&#xA;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;    name_kind_t common = name-&amp;gt;kind &amp;amp; output-&amp;gt;output.kind;&#xA;&#xA;    if ((common &amp;amp; name_xid) &amp;amp;&amp;amp; name-&amp;gt;xid == output-&amp;gt;output.xid)&#xA;        break;&#xA;    if ((common &amp;amp; name_string) &amp;amp;&amp;amp; !strcmp (name-&amp;gt;string, output-&amp;gt;output.string))&#xA;        break;&#xA;    if ((common &amp;amp; name_index) &amp;amp;&amp;amp; name-&amp;gt;index == output-&amp;gt;output.index)&#xA;        break;&#xA;    }&#xA;    return output;&#xA;}&#xA;&#xA;static output_t *&#xA;find_output_by_xid (RROutput output)&#xA;{&#xA;    name_t  output_name;&#xA;&#xA;    init_name (&amp;amp;output_name);&#xA;    set_name_xid (&amp;amp;output_name, output);&#xA;    return find_output (&amp;amp;output_name);&#xA;}&#xA;&#xA;static output_t *&#xA;find_output_by_name (char *name)&#xA;{&#xA;    name_t  output_name;&#xA;&#xA;    init_name (&amp;amp;output_name);&#xA;    set_name_string (&amp;amp;output_name, name);&#xA;    return find_output (&amp;amp;output_name);&#xA;}&#xA;&#xA;static crtc_t *&#xA;find_crtc (name_t *name)&#xA;{&#xA;    int     c;&#xA;    crtc_t  *crtc = NULL;&#xA;&#xA;    for (c = 0; c &amp;lt; num_crtcs; c++)&#xA;    {&#xA;    name_kind_t common;&#xA;&#xA;    crtc = &amp;amp;crtcs[c];&#xA;    common = name-&amp;gt;kind &amp;amp; crtc-&amp;gt;crtc.kind;&#xA;&#xA;    if ((common &amp;amp; name_xid) &amp;amp;&amp;amp; name-&amp;gt;xid == crtc-&amp;gt;crtc.xid)&#xA;        break;&#xA;    if ((common &amp;amp; name_string) &amp;amp;&amp;amp; !strcmp (name-&amp;gt;string, crtc-&amp;gt;crtc.string))&#xA;        break;&#xA;    if ((common &amp;amp; name_index) &amp;amp;&amp;amp; name-&amp;gt;index == crtc-&amp;gt;crtc.index)&#xA;        break;&#xA;    crtc = NULL;&#xA;    }&#xA;    return crtc;&#xA;}&#xA;&#xA;static crtc_t *&#xA;find_crtc_by_xid (RRCrtc crtc)&#xA;{&#xA;    name_t  crtc_name;&#xA;&#xA;    init_name (&amp;amp;crtc_name);&#xA;    set_name_xid (&amp;amp;crtc_name, crtc);&#xA;    return find_crtc (&amp;amp;crtc_name);&#xA;}&#xA;&#xA;static XRRModeInfo *&#xA;find_mode (name_t *name, double refresh)&#xA;{&#xA;    int     m;&#xA;    XRRModeInfo *best = NULL;&#xA;    double  bestDist = 0;&#xA;&#xA;    for (m = 0; m &amp;lt; res-&amp;gt;nmode; m++)&#xA;    {&#xA;    XRRModeInfo *mode = &amp;amp;res-&amp;gt;modes[m];&#xA;    if ((name-&amp;gt;kind &amp;amp; name_xid) &amp;amp;&amp;amp; name-&amp;gt;xid == mode-&amp;gt;id)&#xA;    {&#xA;        best = mode;&#xA;        break;&#xA;    }&#xA;    if ((name-&amp;gt;kind &amp;amp; name_string) &amp;amp;&amp;amp; !strcmp (name-&amp;gt;string, mode-&amp;gt;name))&#xA;    {&#xA;        double   dist;&#xA;&#xA;        if (refresh)&#xA;        dist = fabs (mode_refresh (mode) - refresh);&#xA;        else&#xA;        dist = 0;&#xA;        if (!best || dist &amp;lt; bestDist)&#xA;        {&#xA;        bestDist = dist;&#xA;        best = mode;&#xA;        }&#xA;    }&#xA;    }&#xA;    return best;&#xA;}&#xA;&#xA;static XRRModeInfo *&#xA;find_mode_by_xid (RRMode mode)&#xA;{&#xA;    name_t  mode_name;&#xA;&#xA;    init_name (&amp;amp;mode_name);&#xA;    set_name_xid (&amp;amp;mode_name, mode);&#xA;    return find_mode (&amp;amp;mode_name, 0);&#xA;}&#xA;&#xA;#if 0&#xA;static XRRModeInfo *&#xA;find_mode_by_name (char *name)&#xA;{&#xA;    name_t  mode_name;&#xA;    init_name (&amp;amp;mode_name);&#xA;    set_name_string (&amp;amp;mode_name, name);&#xA;    return find_mode (&amp;amp;mode_name, 0);&#xA;}&#xA;#endif&#xA;&#xA;static&#xA;XRRModeInfo *&#xA;find_mode_for_output (output_t *output, name_t *name)&#xA;{&#xA;    XRROutputInfo   *output_info = output-&amp;gt;output_info;&#xA;    int         m;&#xA;    XRRModeInfo     *best = NULL;&#xA;    double      bestDist = 0;&#xA;&#xA;    for (m = 0; m &amp;lt; output_info-&amp;gt;nmode; m++)&#xA;    {&#xA;    XRRModeInfo     *mode;&#xA;&#xA;    mode = find_mode_by_xid (output_info-&amp;gt;modes[m]);&#xA;    if (!mode) continue;&#xA;    if ((name-&amp;gt;kind &amp;amp; name_xid) &amp;amp;&amp;amp; name-&amp;gt;xid == mode-&amp;gt;id)&#xA;    {&#xA;        best = mode;&#xA;        break;&#xA;    }&#xA;    if ((name-&amp;gt;kind &amp;amp; name_string) &amp;amp;&amp;amp; !strcmp (name-&amp;gt;string, mode-&amp;gt;name))&#xA;    {&#xA;        double   dist;&#xA;&#xA;        /* Stay away from doublescan modes unless refresh rate is specified. */&#xA;        if (!output-&amp;gt;refresh &amp;amp;&amp;amp; (mode-&amp;gt;modeFlags &amp;amp; RR_DoubleScan))&#xA;        continue;&#xA;&#xA;        if (output-&amp;gt;refresh)&#xA;        dist = fabs (mode_refresh (mode) - output-&amp;gt;refresh);&#xA;        else&#xA;        dist = 0;&#xA;        if (!best || dist &amp;lt; bestDist)&#xA;        {&#xA;        bestDist = dist;&#xA;        best = mode;&#xA;        }&#xA;    }&#xA;    }&#xA;    return best;&#xA;}&#xA;&#xA;static XRRModeInfo *&#xA;preferred_mode (output_t *output)&#xA;{&#xA;    XRROutputInfo   *output_info = output-&amp;gt;output_info;&#xA;    int         m;&#xA;    XRRModeInfo     *best;&#xA;    int         bestDist;&#xA;&#xA;    best = NULL;&#xA;    bestDist = 0;&#xA;    for (m = 0; m &amp;lt; output_info-&amp;gt;nmode; m++)&#xA;    {&#xA;    XRRModeInfo *mode_info = find_mode_by_xid (output_info-&amp;gt;modes[m]);&#xA;    int     dist;&#xA;&#xA;    if (m &amp;lt; output_info-&amp;gt;npreferred)&#xA;        dist = 0;&#xA;    else if (output_info-&amp;gt;mm_height)&#xA;        dist = (1000 * DisplayHeight(dpy, screen) / DisplayHeightMM(dpy, screen) -&#xA;            1000 * mode_info-&amp;gt;height / output_info-&amp;gt;mm_height);&#xA;    else&#xA;        dist = DisplayHeight(dpy, screen) - mode_info-&amp;gt;height;&#xA;&#xA;    if (dist &amp;lt; 0) dist = -dist;&#xA;    if (!best || dist &amp;lt; bestDist)&#xA;    {&#xA;        best = mode_info;&#xA;        bestDist = dist;&#xA;    }&#xA;    }&#xA;    return best;&#xA;}&#xA;&#xA;static Bool&#xA;output_can_use_crtc (output_t *output, crtc_t *crtc)&#xA;{&#xA;    XRROutputInfo   *output_info = output-&amp;gt;output_info;&#xA;    int         c;&#xA;&#xA;    for (c = 0; c &amp;lt; output_info-&amp;gt;ncrtc; c++)&#xA;    if (output_info-&amp;gt;crtcs[c] == crtc-&amp;gt;crtc.xid)&#xA;        return True;&#xA;    return False;&#xA;}&#xA;&#xA;static Bool&#xA;output_can_use_mode (output_t *output, XRRModeInfo *mode)&#xA;{&#xA;    XRROutputInfo   *output_info = output-&amp;gt;output_info;&#xA;    int         m;&#xA;&#xA;    for (m = 0; m &amp;lt; output_info-&amp;gt;nmode; m++)&#xA;    if (output_info-&amp;gt;modes[m] == mode-&amp;gt;id)&#xA;        return True;&#xA;    return False;&#xA;}&#xA;&#xA;static Bool&#xA;crtc_can_use_rotation (crtc_t *crtc, Rotation rotation)&#xA;{&#xA;    Rotation    rotations = crtc-&amp;gt;crtc_info-&amp;gt;rotations;&#xA;    Rotation    dir = rotation &amp;amp; (RR_Rotate_0|RR_Rotate_90|RR_Rotate_180|RR_Rotate_270);&#xA;    Rotation    reflect = rotation &amp;amp; (RR_Reflect_X|RR_Reflect_Y);&#xA;    if (((rotations &amp;amp; dir) != 0) &amp;amp;&amp;amp; ((rotations &amp;amp; reflect) == reflect))&#xA;    return True;&#xA;    return False;&#xA;}&#xA;&#xA;#if 0&#xA;static Bool&#xA;crtc_can_use_transform (crtc_t *crtc, XTransform *transform)&#xA;{&#xA;    int major, minor;&#xA;&#xA;    XRRQueryVersion (dpy, &amp;amp;major, &amp;amp;minor);&#xA;    if (major &amp;gt; 1 || (major == 1 &amp;amp;&amp;amp; minor &amp;gt;= 3))&#xA;    return True;&#xA;    return False;&#xA;}&#xA;#endif&#xA;&#xA;/*&#xA; * Report only rotations that are supported by all crtcs&#xA; */&#xA;static Rotation&#xA;output_rotations (output_t *output)&#xA;{&#xA;    Bool        found = False;&#xA;    Rotation        rotation = RR_Rotate_0;&#xA;    XRROutputInfo   *output_info = output-&amp;gt;output_info;&#xA;    int         c;&#xA;&#xA;    for (c = 0; c &amp;lt; output_info-&amp;gt;ncrtc; c++)&#xA;    {&#xA;    crtc_t  *crtc = find_crtc_by_xid (output_info-&amp;gt;crtcs[c]);&#xA;    if (crtc)&#xA;    {&#xA;        if (!found) {&#xA;        rotation = crtc-&amp;gt;crtc_info-&amp;gt;rotations;&#xA;        found = True;&#xA;        } else&#xA;        rotation &amp;amp;= crtc-&amp;gt;crtc_info-&amp;gt;rotations;&#xA;    }&#xA;    }&#xA;    return rotation;&#xA;}&#xA;&#xA;static Bool&#xA;output_can_use_rotation (output_t *output, Rotation rotation)&#xA;{&#xA;    XRROutputInfo   *output_info = output-&amp;gt;output_info;&#xA;    int         c;&#xA;&#xA;    /* make sure all of the crtcs can use this rotation.&#xA;     * yes, this is not strictly necessary, but it is &#xA;     * simpler,and we expect most drivers to either&#xA;     * support rotation everywhere or nowhere&#xA;     */&#xA;    for (c = 0; c &amp;lt; output_info-&amp;gt;ncrtc; c++)&#xA;    {&#xA;    crtc_t  *crtc = find_crtc_by_xid (output_info-&amp;gt;crtcs[c]);&#xA;    if (crtc &amp;amp;&amp;amp; !crtc_can_use_rotation (crtc, rotation))&#xA;        return False;&#xA;    }&#xA;    return True;&#xA;}&#xA;&#xA;static Bool&#xA;output_is_primary(output_t *output)&#xA;{&#xA;    if (has_1_3)&#xA;        return XRRGetOutputPrimary(dpy, root) == output-&amp;gt;output.xid;&#xA;    return False;&#xA;}&#xA;&#xA;/* Returns the index of the last value in an array &amp;lt; 0xffff */&#xA;static int&#xA;find_last_non_clamped(CARD16 array[], int size) {&#xA;    int i;&#xA;    for (i = size - 1; i &amp;gt; 0; i--) {&#xA;    if (array[i] &amp;lt; 0xffff)&#xA;        return i;&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;static void&#xA;set_gamma_info(output_t *output)&#xA;{&#xA;    XRRCrtcGamma *crtc_gamma;&#xA;    double i1, v1, i2, v2;&#xA;    int size, middle, last_best, last_red, last_green, last_blue;&#xA;    CARD16 *best_array;&#xA;&#xA;    if (!output-&amp;gt;crtc_info)&#xA;    return;&#xA;&#xA;    size = XRRGetCrtcGammaSize(dpy, output-&amp;gt;crtc_info-&amp;gt;crtc.xid);&#xA;    if (!size) {&#xA;    warning(&amp;quot;Failed to get size of gamma for output %s\n&amp;quot;, output-&amp;gt;output.string);&#xA;    return;&#xA;    }&#xA;&#xA;    crtc_gamma = XRRGetCrtcGamma(dpy, output-&amp;gt;crtc_info-&amp;gt;crtc.xid);&#xA;    if (!crtc_gamma) {&#xA;    warning(&amp;quot;Failed to get gamma for output %s\n&amp;quot;, output-&amp;gt;output.string);&#xA;    return;&#xA;    }&#xA;&#xA;    /*&#xA;     * Here is a bit tricky because gamma is a whole curve for each&#xA;     * color.  So, typically, we need to represent 3 * 256 values as 3 + 1&#xA;     * values.  Therefore, we approximate the gamma curve (v) by supposing&#xA;     * it always follows the way we set it: a power function (i^g)&#xA;     * multiplied by a brightness (b).&#xA;     * v = i^g * b&#xA;     * so g = (ln(v) - ln(b))/ln(i)&#xA;     * and b can be found using two points (v1,i1) and (v2, i2):&#xA;     * b = e^((ln(v2)*ln(i1) - ln(v1)*ln(i2))/ln(i1/i2))&#xA;     * For the best resolution, we select i2 at the highest place not&#xA;     * clamped and i1 at i2/2. Note that if i2 = 1 (as in most normal&#xA;     * cases), then b = v2.&#xA;     */&#xA;    last_red = find_last_non_clamped(crtc_gamma-&amp;gt;red, size);&#xA;    last_green = find_last_non_clamped(crtc_gamma-&amp;gt;green, size);&#xA;    last_blue = find_last_non_clamped(crtc_gamma-&amp;gt;blue, size);&#xA;    best_array = crtc_gamma-&amp;gt;red;&#xA;    last_best = last_red;&#xA;    if (last_green &amp;gt; last_best) {&#xA;    last_best = last_green;&#xA;    best_array = crtc_gamma-&amp;gt;green;&#xA;    }&#xA;    if (last_blue &amp;gt; last_best) {&#xA;    last_best = last_blue;&#xA;    best_array = crtc_gamma-&amp;gt;blue;&#xA;    }&#xA;    if (last_best == 0)&#xA;    last_best = 1;&#xA;&#xA;    middle = last_best / 2;&#xA;    i1 = (double)(middle + 1) / size;&#xA;    v1 = (double)(best_array[middle]) / 65535;&#xA;    i2 = (double)(last_best + 1) / size;&#xA;    v2 = (double)(best_array[last_best]) / 65535;&#xA;    if (v2 &amp;lt; 0.0001) { /* The screen is black */&#xA;    output-&amp;gt;brightness = 0;&#xA;    output-&amp;gt;gamma.red = 1;&#xA;    output-&amp;gt;gamma.green = 1;&#xA;    output-&amp;gt;gamma.blue = 1;&#xA;    } else {&#xA;    if ((last_best + 1) == size)&#xA;        output-&amp;gt;brightness = v2;&#xA;    else&#xA;        output-&amp;gt;brightness = exp((log(v2)*log(i1) - log(v1)*log(i2))/log(i1/i2));&#xA;    output-&amp;gt;gamma.red = log((double)(crtc_gamma-&amp;gt;red[last_red / 2]) / output-&amp;gt;brightness&#xA;                / 65535) / log((double)((last_red / 2) + 1) / size);&#xA;    output-&amp;gt;gamma.green = log((double)(crtc_gamma-&amp;gt;green[last_green / 2]) / output-&amp;gt;brightness&#xA;                  / 65535) / log((double)((last_green / 2) + 1) / size);&#xA;    output-&amp;gt;gamma.blue = log((double)(crtc_gamma-&amp;gt;blue[last_blue / 2]) / output-&amp;gt;brightness&#xA;                 / 65535) / log((double)((last_blue / 2) + 1) / size);&#xA;    }&#xA;&#xA;    XRRFreeGamma(crtc_gamma);&#xA;}&#xA;&#xA;static void&#xA;set_output_info (output_t *output, RROutput xid, XRROutputInfo *output_info)&#xA;{&#xA;    /* sanity check output info */&#xA;    if (output_info-&amp;gt;connection != RR_Disconnected &amp;amp;&amp;amp; !output_info-&amp;gt;nmode)&#xA;    warning (&amp;quot;Output %s is not disconnected but has no modes\n&amp;quot;,&#xA;         output_info-&amp;gt;name);&#xA;&#xA;    /* set output name and info */&#xA;    if (!(output-&amp;gt;output.kind &amp;amp; name_xid))&#xA;    set_name_xid (&amp;amp;output-&amp;gt;output, xid);&#xA;    if (!(output-&amp;gt;output.kind &amp;amp; name_string))&#xA;    set_name_string (&amp;amp;output-&amp;gt;output, output_info-&amp;gt;name);&#xA;    output-&amp;gt;output_info = output_info;&#xA;&#xA;    /* set crtc name and info */&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_crtc))&#xA;    set_name_xid (&amp;amp;output-&amp;gt;crtc, output_info-&amp;gt;crtc);&#xA;&#xA;    if (output-&amp;gt;crtc.kind == name_xid &amp;amp;&amp;amp; output-&amp;gt;crtc.xid == None)&#xA;    output-&amp;gt;crtc_info = NULL;&#xA;    else&#xA;    {&#xA;    output-&amp;gt;crtc_info = find_crtc (&amp;amp;output-&amp;gt;crtc);&#xA;    if (!output-&amp;gt;crtc_info)&#xA;    {&#xA;        if (output-&amp;gt;crtc.kind &amp;amp; name_xid)&#xA;        fatal (&amp;quot;cannot find crtc 0x%lx\n&amp;quot;, output-&amp;gt;crtc.xid);&#xA;        if (output-&amp;gt;crtc.kind &amp;amp; name_index)&#xA;        fatal (&amp;quot;cannot find crtc %d\n&amp;quot;, output-&amp;gt;crtc.index);&#xA;    }&#xA;    if (!output_can_use_crtc (output, output-&amp;gt;crtc_info))&#xA;        fatal (&amp;quot;output %s cannot use crtc 0x%lx\n&amp;quot;, output-&amp;gt;output.string,&#xA;           output-&amp;gt;crtc_info-&amp;gt;crtc.xid);&#xA;    }&#xA;&#xA;    /* set mode name and info */&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_mode))&#xA;    {&#xA;    crtc_t  *crtc = NULL;&#xA;&#xA;    if (output_info-&amp;gt;crtc)&#xA;        crtc = find_crtc_by_xid(output_info-&amp;gt;crtc);&#xA;    if (crtc &amp;amp;&amp;amp; crtc-&amp;gt;crtc_info)&#xA;        set_name_xid (&amp;amp;output-&amp;gt;mode, crtc-&amp;gt;crtc_info-&amp;gt;mode);&#xA;    else if (output-&amp;gt;crtc_info)&#xA;        set_name_xid (&amp;amp;output-&amp;gt;mode, output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;mode);&#xA;    else&#xA;        set_name_xid (&amp;amp;output-&amp;gt;mode, None);&#xA;    if (output-&amp;gt;mode.xid)&#xA;    {&#xA;        output-&amp;gt;mode_info = find_mode_by_xid (output-&amp;gt;mode.xid);&#xA;        if (!output-&amp;gt;mode_info)&#xA;        fatal (&amp;quot;server did not report mode 0x%lx for output %s\n&amp;quot;,&#xA;               output-&amp;gt;mode.xid, output-&amp;gt;output.string);&#xA;    }&#xA;    else&#xA;        output-&amp;gt;mode_info = NULL;&#xA;    }&#xA;    else if (output-&amp;gt;mode.kind == name_xid &amp;amp;&amp;amp; output-&amp;gt;mode.xid == None)&#xA;    output-&amp;gt;mode_info = NULL;&#xA;    else&#xA;    {&#xA;    if (output-&amp;gt;mode.kind == name_preferred)&#xA;        output-&amp;gt;mode_info = preferred_mode (output);&#xA;    else&#xA;        output-&amp;gt;mode_info = find_mode_for_output (output, &amp;amp;output-&amp;gt;mode);&#xA;    if (!output-&amp;gt;mode_info)&#xA;    {&#xA;        if (output-&amp;gt;mode.kind &amp;amp; name_preferred)&#xA;        fatal (&amp;quot;cannot find preferred mode\n&amp;quot;);&#xA;        if (output-&amp;gt;mode.kind &amp;amp; name_string)&#xA;        fatal (&amp;quot;cannot find mode %s\n&amp;quot;, output-&amp;gt;mode.string);&#xA;        if (output-&amp;gt;mode.kind &amp;amp; name_xid)&#xA;        fatal (&amp;quot;cannot find mode 0x%lx\n&amp;quot;, output-&amp;gt;mode.xid);&#xA;    }&#xA;    if (!output_can_use_mode (output, output-&amp;gt;mode_info))&#xA;        fatal (&amp;quot;output %s cannot use mode %s\n&amp;quot;, output-&amp;gt;output.string,&#xA;           output-&amp;gt;mode_info-&amp;gt;name);&#xA;    }&#xA;&#xA;    /* set position */&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_position))&#xA;    {&#xA;    if (output-&amp;gt;crtc_info)&#xA;    {&#xA;        output-&amp;gt;x = output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;x;&#xA;        output-&amp;gt;y = output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;y;&#xA;    }&#xA;    else&#xA;    {&#xA;        output-&amp;gt;x = 0;&#xA;        output-&amp;gt;y = 0;&#xA;    }&#xA;    }&#xA;&#xA;    /* set rotation */&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_rotation))&#xA;    {&#xA;    output-&amp;gt;rotation &amp;amp;= ~0xf;&#xA;    if (output-&amp;gt;crtc_info)&#xA;        output-&amp;gt;rotation |= (output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;rotation &amp;amp; 0xf);&#xA;    else&#xA;        output-&amp;gt;rotation = RR_Rotate_0;&#xA;    }&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_reflection))&#xA;    {&#xA;    output-&amp;gt;rotation &amp;amp;= ~(RR_Reflect_X|RR_Reflect_Y);&#xA;    if (output-&amp;gt;crtc_info)&#xA;        output-&amp;gt;rotation |= (output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;rotation &amp;amp;&#xA;                 (RR_Reflect_X|RR_Reflect_Y));&#xA;    }&#xA;    if (!output_can_use_rotation (output, output-&amp;gt;rotation))&#xA;    fatal (&amp;quot;output %s cannot use rotation \&amp;quot;%s\&amp;quot; reflection \&amp;quot;%s\&amp;quot;\n&amp;quot;,&#xA;           output-&amp;gt;output.string,&#xA;           rotation_name (output-&amp;gt;rotation),&#xA;           reflection_name (output-&amp;gt;rotation));&#xA;&#xA;    /* set gamma */&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_gamma))&#xA;        set_gamma_info(output);&#xA;&#xA;    /* set transformation */&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_transform))&#xA;    {&#xA;    if (output-&amp;gt;crtc_info)&#xA;        copy_transform (&amp;amp;output-&amp;gt;transform, &amp;amp;output-&amp;gt;crtc_info-&amp;gt;current_transform);&#xA;    else&#xA;        init_transform (&amp;amp;output-&amp;gt;transform);&#xA;    } else {&#xA;    /* transform was already set for --scale or --transform */&#xA;&#xA;    /* for --scale-from, figure out the mode size and compute the transform&#xA;     * for the target framebuffer area */&#xA;    if (output-&amp;gt;scale_from_w &amp;gt; 0 &amp;amp;&amp;amp; output-&amp;gt;mode_info) {&#xA;        double sx = (double)output-&amp;gt;scale_from_w /&#xA;                output-&amp;gt;mode_info-&amp;gt;width;&#xA;        double sy = (double)output-&amp;gt;scale_from_h /&#xA;                output-&amp;gt;mode_info-&amp;gt;height;&#xA;        if (verbose)&#xA;        printf(&amp;quot;scaling %s by %lfx%lf\n&amp;quot;, output-&amp;gt;output.string, sx,&#xA;               sy);&#xA;        init_transform (&amp;amp;output-&amp;gt;transform);&#xA;        output-&amp;gt;transform.transform.matrix[0][0] = XDoubleToFixed (sx);&#xA;        output-&amp;gt;transform.transform.matrix[1][1] = XDoubleToFixed (sy);&#xA;        output-&amp;gt;transform.transform.matrix[2][2] = XDoubleToFixed (1.0);&#xA;        if (sx != 1 || sy != 1)&#xA;        output-&amp;gt;transform.filter = &amp;quot;bilinear&amp;quot;;&#xA;        else&#xA;        output-&amp;gt;transform.filter = &amp;quot;nearest&amp;quot;;&#xA;        output-&amp;gt;transform.nparams = 0;&#xA;        output-&amp;gt;transform.params = NULL;&#xA;    }&#xA;    }&#xA;&#xA;    /* set primary */&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_primary))&#xA;    output-&amp;gt;primary = output_is_primary(output);&#xA;}&#xA;&#xA;static void&#xA;get_screen (Bool current)&#xA;{&#xA;    if (!has_1_2)&#xA;    fatal (&amp;quot;Server RandR version before 1.2\n&amp;quot;);&#xA;&#xA;    if (res)&#xA;    return;&#xA;&#xA;    XRRGetScreenSizeRange (dpy, root, &amp;amp;minWidth, &amp;amp;minHeight,&#xA;               &amp;amp;maxWidth, &amp;amp;maxHeight);&#xA;&#xA;    if (current)&#xA;    res = XRRGetScreenResourcesCurrent (dpy, root);&#xA;    else&#xA;    res = XRRGetScreenResources (dpy, root);&#xA;    if (!res) fatal (&amp;quot;could not get screen resources&amp;quot;);&#xA;}&#xA;&#xA;static void&#xA;get_crtcs (void)&#xA;{&#xA;    int     c;&#xA;&#xA;    num_crtcs = res-&amp;gt;ncrtc;&#xA;    crtcs = calloc (num_crtcs, sizeof (crtc_t));&#xA;    if (!crtcs) fatal (&amp;quot;out of memory\n&amp;quot;);&#xA;&#xA;    for (c = 0; c &amp;lt; res-&amp;gt;ncrtc; c++)&#xA;    {&#xA;    XRRCrtcInfo *crtc_info = XRRGetCrtcInfo (dpy, res, res-&amp;gt;crtcs[c]);&#xA;    XRRCrtcTransformAttributes  *attr;&#xA;    XRRPanning  *panning_info = NULL;&#xA;&#xA;    if (has_1_3) {&#xA;        XRRPanning zero;&#xA;        memset(&amp;amp;zero, 0, sizeof(zero));&#xA;        panning_info = XRRGetPanning  (dpy, res, res-&amp;gt;crtcs[c]);&#xA;        zero.timestamp = panning_info-&amp;gt;timestamp;&#xA;        if (!memcmp(panning_info, &amp;amp;zero, sizeof(zero))) {&#xA;        Xfree(panning_info);&#xA;        panning_info = NULL;&#xA;        }&#xA;    }&#xA;&#xA;    set_name_xid (&amp;amp;crtcs[c].crtc, res-&amp;gt;crtcs[c]);&#xA;    set_name_index (&amp;amp;crtcs[c].crtc, c);&#xA;    if (!crtc_info) fatal (&amp;quot;could not get crtc 0x%lx information\n&amp;quot;, res-&amp;gt;crtcs[c]);&#xA;    crtcs[c].crtc_info = crtc_info;&#xA;    crtcs[c].panning_info = panning_info;&#xA;    if (crtc_info-&amp;gt;mode == None)&#xA;    {&#xA;        crtcs[c].mode_info = NULL;&#xA;        crtcs[c].x = 0;&#xA;        crtcs[c].y = 0;&#xA;        crtcs[c].rotation = RR_Rotate_0;&#xA;    }&#xA;    if (XRRGetCrtcTransform (dpy, res-&amp;gt;crtcs[c], &amp;amp;attr) &amp;amp;&amp;amp; attr) {&#xA;        set_transform (&amp;amp;crtcs[c].current_transform,&#xA;               &amp;amp;attr-&amp;gt;currentTransform,&#xA;               attr-&amp;gt;currentFilter,&#xA;               attr-&amp;gt;currentParams,&#xA;               attr-&amp;gt;currentNparams);&#xA;        XFree (attr);&#xA;    }&#xA;    else&#xA;    {&#xA;        init_transform (&amp;amp;crtcs[c].current_transform);&#xA;    }&#xA;    copy_transform (&amp;amp;crtcs[c].pending_transform, &amp;amp;crtcs[c].current_transform);&#xA;   }&#xA;}&#xA;&#xA;static void&#xA;crtc_add_output (crtc_t *crtc, output_t *output)&#xA;{&#xA;    if (crtc-&amp;gt;outputs)&#xA;    crtc-&amp;gt;outputs = realloc (crtc-&amp;gt;outputs, (crtc-&amp;gt;noutput + 1) * sizeof (output_t *));&#xA;    else&#xA;    {&#xA;    crtc-&amp;gt;outputs = malloc (sizeof (output_t *));&#xA;    crtc-&amp;gt;x = output-&amp;gt;x;&#xA;    crtc-&amp;gt;y = output-&amp;gt;y;&#xA;    crtc-&amp;gt;rotation = output-&amp;gt;rotation;&#xA;    crtc-&amp;gt;mode_info = output-&amp;gt;mode_info;&#xA;    copy_transform (&amp;amp;crtc-&amp;gt;pending_transform, &amp;amp;output-&amp;gt;transform);&#xA;   }&#xA;    if (!crtc-&amp;gt;outputs) fatal (&amp;quot;out of memory\n&amp;quot;);&#xA;    crtc-&amp;gt;outputs[crtc-&amp;gt;noutput++] = output;&#xA;}&#xA;&#xA;static void&#xA;set_crtcs (void)&#xA;{&#xA;    output_t    *output;&#xA;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;    if (!output-&amp;gt;mode_info) continue;&#xA;    crtc_add_output (output-&amp;gt;crtc_info, output);&#xA;    }&#xA;}&#xA;&#xA;static void&#xA;set_panning (void)&#xA;{&#xA;    output_t    *output;&#xA;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;    if (! output-&amp;gt;crtc_info)&#xA;        continue;&#xA;    if (! (output-&amp;gt;changes &amp;amp; changes_panning))&#xA;        continue;&#xA;    if (! output-&amp;gt;crtc_info-&amp;gt;panning_info)&#xA;        output-&amp;gt;crtc_info-&amp;gt;panning_info = malloc (sizeof(XRRPanning));&#xA;    memcpy (output-&amp;gt;crtc_info-&amp;gt;panning_info, &amp;amp;output-&amp;gt;panning, sizeof(XRRPanning));&#xA;    output-&amp;gt;crtc_info-&amp;gt;changing = 1;&#xA;    }&#xA;}&#xA;&#xA;static void&#xA;set_gamma(void)&#xA;{&#xA;    output_t    *output;&#xA;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next) {&#xA;    int i, size;&#xA;    crtc_t *crtc;&#xA;    XRRCrtcGamma *crtc_gamma;&#xA;    float gammaRed;&#xA;    float gammaGreen;&#xA;    float gammaBlue;&#xA;&#xA;    if (!(output-&amp;gt;changes &amp;amp; changes_gamma))&#xA;        continue;&#xA;&#xA;    if (!output-&amp;gt;crtc_info) {&#xA;        fatal(&amp;quot;Need crtc to set gamma on.\n&amp;quot;);&#xA;        continue;&#xA;    }&#xA;&#xA;    crtc = output-&amp;gt;crtc_info;&#xA;&#xA;    size = XRRGetCrtcGammaSize(dpy, crtc-&amp;gt;crtc.xid);&#xA;&#xA;    if (!size) {&#xA;        fatal(&amp;quot;Gamma size is 0.\n&amp;quot;);&#xA;        continue;&#xA;    }&#xA;&#xA;    /*&#xA;     * The gamma-correction lookup table managed through XRR[GS]etCrtcGamma&#xA;     * is 2^n in size, where &#39;n&#39; is the number of significant bits in&#xA;     * the X Color.  Because an X Color is 16 bits, size cannot be larger&#xA;     * than 2^16.&#xA;     */&#xA;    if (size &amp;gt; 65536) {&#xA;        fatal(&amp;quot;Gamma correction table is impossibly large.\n&amp;quot;);&#xA;        continue;&#xA;    }&#xA;&#xA;    crtc_gamma = XRRAllocGamma(size);&#xA;    if (!crtc_gamma) {&#xA;        fatal(&amp;quot;Gamma allocation failed.\n&amp;quot;);&#xA;        continue;&#xA;    }&#xA;&#xA;    if (output-&amp;gt;gamma.red == 0.0)&#xA;        output-&amp;gt;gamma.red = 1.0;&#xA;    if (output-&amp;gt;gamma.green == 0.0)&#xA;        output-&amp;gt;gamma.green = 1.0;&#xA;    if (output-&amp;gt;gamma.blue == 0.0)&#xA;        output-&amp;gt;gamma.blue = 1.0;&#xA;&#xA;    gammaRed = 1.0 / output-&amp;gt;gamma.red;&#xA;    gammaGreen = 1.0 / output-&amp;gt;gamma.green;&#xA;    gammaBlue = 1.0 / output-&amp;gt;gamma.blue;&#xA;&#xA;    for (i = 0; i &amp;lt; size; i++) {&#xA;        if (gammaRed == 1.0 &amp;amp;&amp;amp; output-&amp;gt;brightness == 1.0)&#xA;        crtc_gamma-&amp;gt;red[i] = (double)i / (double)(size - 1) * 65535.0;&#xA;        else&#xA;        crtc_gamma-&amp;gt;red[i] = dmin(pow((double)i/(double)(size - 1),&#xA;                          gammaRed) * output-&amp;gt;brightness,&#xA;                      1.0) * 65535.0;&#xA;&#xA;        if (gammaGreen == 1.0 &amp;amp;&amp;amp; output-&amp;gt;brightness == 1.0)&#xA;        crtc_gamma-&amp;gt;green[i] = (double)i / (double)(size - 1) * 65535.0;&#xA;        else&#xA;        crtc_gamma-&amp;gt;green[i] = dmin(pow((double)i/(double)(size - 1),&#xA;                        gammaGreen) * output-&amp;gt;brightness,&#xA;                        1.0) * 65535.0;&#xA;&#xA;        if (gammaBlue == 1.0 &amp;amp;&amp;amp; output-&amp;gt;brightness == 1.0)&#xA;        crtc_gamma-&amp;gt;blue[i] = (double)i / (double)(size - 1) * 65535.0;&#xA;        else&#xA;        crtc_gamma-&amp;gt;blue[i] = dmin(pow((double)i/(double)(size - 1),&#xA;                           gammaBlue) * output-&amp;gt;brightness,&#xA;                       1.0) * 65535.0;&#xA;    }&#xA;&#xA;    XRRSetCrtcGamma(dpy, crtc-&amp;gt;crtc.xid, crtc_gamma);&#xA;&#xA;    free(crtc_gamma);&#xA;    }&#xA;}&#xA;&#xA;static void&#xA;set_primary(void)&#xA;{&#xA;    output_t *output;&#xA;&#xA;    if (no_primary) {&#xA;    XRRSetOutputPrimary(dpy, root, None);&#xA;    } else {&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next) {&#xA;        if (!(output-&amp;gt;changes &amp;amp; changes_primary))&#xA;        continue;&#xA;        if (output-&amp;gt;primary)&#xA;        XRRSetOutputPrimary(dpy, root, output-&amp;gt;output.xid);&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;static Status&#xA;crtc_disable (crtc_t *crtc)&#xA;{&#xA;    if (verbose)&#xA;    printf (&amp;quot;crtc %d: disable\n&amp;quot;, crtc-&amp;gt;crtc.index);&#xA;&#xA;    if (dryrun)&#xA;    return RRSetConfigSuccess;&#xA;    return XRRSetCrtcConfig (dpy, res, crtc-&amp;gt;crtc.xid, CurrentTime,&#xA;                 0, 0, None, RR_Rotate_0, NULL, 0);&#xA;}&#xA;&#xA;static void&#xA;crtc_set_transform (crtc_t *crtc, transform_t *transform)&#xA;{&#xA;    int major, minor;&#xA;&#xA;    XRRQueryVersion (dpy, &amp;amp;major, &amp;amp;minor);&#xA;    if (major &amp;gt; 1 || (major == 1 &amp;amp;&amp;amp; minor &amp;gt;= 3))&#xA;    XRRSetCrtcTransform (dpy, crtc-&amp;gt;crtc.xid,&#xA;                 &amp;amp;transform-&amp;gt;transform,&#xA;                 transform-&amp;gt;filter,&#xA;                 transform-&amp;gt;params,&#xA;                 transform-&amp;gt;nparams);&#xA;}&#xA;&#xA;static Status&#xA;crtc_revert (crtc_t *crtc)&#xA;{&#xA;    XRRCrtcInfo *crtc_info = crtc-&amp;gt;crtc_info;&#xA;&#xA;    if (verbose)&#xA;    printf (&amp;quot;crtc %d: revert\n&amp;quot;, crtc-&amp;gt;crtc.index);&#xA;&#xA;    if (dryrun)&#xA;    return RRSetConfigSuccess;&#xA;&#xA;    if (!equal_transform (&amp;amp;crtc-&amp;gt;current_transform, &amp;amp;crtc-&amp;gt;pending_transform))&#xA;    crtc_set_transform (crtc, &amp;amp;crtc-&amp;gt;current_transform);&#xA;    return XRRSetCrtcConfig (dpy, res, crtc-&amp;gt;crtc.xid, CurrentTime,&#xA;                crtc_info-&amp;gt;x, crtc_info-&amp;gt;y,&#xA;                crtc_info-&amp;gt;mode, crtc_info-&amp;gt;rotation,&#xA;                crtc_info-&amp;gt;outputs, crtc_info-&amp;gt;noutput);&#xA;}&#xA;&#xA;static Status&#xA;crtc_apply (crtc_t *crtc)&#xA;{&#xA;    RROutput    *rr_outputs;&#xA;    int     o;&#xA;    Status  s;&#xA;    RRMode  mode = None;&#xA;&#xA;    if (!crtc-&amp;gt;changing || !crtc-&amp;gt;mode_info)&#xA;    return RRSetConfigSuccess;&#xA;&#xA;    rr_outputs = calloc (crtc-&amp;gt;noutput, sizeof (RROutput));&#xA;    if (!rr_outputs)&#xA;    return BadAlloc;&#xA;    for (o = 0; o &amp;lt; crtc-&amp;gt;noutput; o++)&#xA;    rr_outputs[o] = crtc-&amp;gt;outputs[o]-&amp;gt;output.xid;&#xA;    mode = crtc-&amp;gt;mode_info-&amp;gt;id;&#xA;    if (verbose) {&#xA;    printf (&amp;quot;crtc %d: %12s %6.2f +%d+%d&amp;quot;, crtc-&amp;gt;crtc.index,&#xA;        crtc-&amp;gt;mode_info-&amp;gt;name, mode_refresh (crtc-&amp;gt;mode_info),&#xA;        crtc-&amp;gt;x, crtc-&amp;gt;y);&#xA;    for (o = 0; o &amp;lt; crtc-&amp;gt;noutput; o++)&#xA;        printf (&amp;quot; \&amp;quot;%s\&amp;quot;&amp;quot;, crtc-&amp;gt;outputs[o]-&amp;gt;output.string);&#xA;    printf (&amp;quot;\n&amp;quot;);&#xA;    }&#xA;&#xA;    if (dryrun)&#xA;    s = RRSetConfigSuccess;&#xA;    else&#xA;    {&#xA;    if (!equal_transform (&amp;amp;crtc-&amp;gt;current_transform, &amp;amp;crtc-&amp;gt;pending_transform))&#xA;        crtc_set_transform (crtc, &amp;amp;crtc-&amp;gt;pending_transform);&#xA;    s = XRRSetCrtcConfig (dpy, res, crtc-&amp;gt;crtc.xid, CurrentTime,&#xA;                  crtc-&amp;gt;x, crtc-&amp;gt;y, mode, crtc-&amp;gt;rotation,&#xA;                  rr_outputs, crtc-&amp;gt;noutput);&#xA;    if (s == RRSetConfigSuccess &amp;amp;&amp;amp; crtc-&amp;gt;panning_info) {&#xA;        if (has_1_3)&#xA;        s = XRRSetPanning (dpy, res, crtc-&amp;gt;crtc.xid, crtc-&amp;gt;panning_info);&#xA;        else&#xA;        fatal (&amp;quot;panning needs RandR 1.3\n&amp;quot;);&#xA;    }&#xA;    }&#xA;    free (rr_outputs);&#xA;    return s;&#xA;}&#xA;&#xA;static void&#xA;screen_revert (void)&#xA;{&#xA;    if (verbose)&#xA;    printf (&amp;quot;screen %d: revert\n&amp;quot;, screen);&#xA;&#xA;    if (dryrun)&#xA;    return;&#xA;    XRRSetScreenSize (dpy, root,&#xA;              DisplayWidth (dpy, screen),&#xA;              DisplayHeight (dpy, screen),&#xA;              DisplayWidthMM (dpy, screen),&#xA;              DisplayHeightMM (dpy, screen));&#xA;}&#xA;&#xA;static void&#xA;screen_apply (void)&#xA;{&#xA;    if (fb_width == DisplayWidth (dpy, screen) &amp;amp;&amp;amp;&#xA;    fb_height == DisplayHeight (dpy, screen) &amp;amp;&amp;amp;&#xA;    fb_width_mm == DisplayWidthMM (dpy, screen) &amp;amp;&amp;amp;&#xA;    fb_height_mm == DisplayHeightMM (dpy, screen))&#xA;    {&#xA;    return;&#xA;    }&#xA;    if (verbose)&#xA;    printf (&amp;quot;screen %d: %dx%d %dx%d mm %6.2fdpi\n&amp;quot;, screen,&#xA;        fb_width, fb_height, fb_width_mm, fb_height_mm, dpi);&#xA;    if (dryrun)&#xA;    return;&#xA;    XRRSetScreenSize (dpy, root, fb_width, fb_height,&#xA;              fb_width_mm, fb_height_mm);&#xA;}&#xA;&#xA;static void&#xA;revert (void)&#xA;{&#xA;    int c;&#xA;&#xA;    /* first disable all crtcs */&#xA;    for (c = 0; c &amp;lt; res-&amp;gt;ncrtc; c++)&#xA;    crtc_disable (&amp;amp;crtcs[c]);&#xA;    /* next reset screen size */&#xA;    screen_revert ();&#xA;    /* now restore all crtcs */&#xA;    for (c = 0; c &amp;lt; res-&amp;gt;ncrtc; c++)&#xA;    crtc_revert (&amp;amp;crtcs[c]);&#xA;}&#xA;&#xA;/*&#xA; * uh-oh, something bad happened in the middle of changing&#xA; * the configuration. Revert to the previous configuration&#xA; * and bail&#xA; */&#xA;static void _X_NORETURN&#xA;panic (Status s, crtc_t *crtc)&#xA;{&#xA;    int     c = crtc-&amp;gt;crtc.index;&#xA;    const char *message;&#xA;&#xA;    switch (s) {&#xA;    case RRSetConfigSuccess:        message = &amp;quot;succeeded&amp;quot;;          break;&#xA;    case BadAlloc:          message = &amp;quot;out of memory&amp;quot;;      break;&#xA;    case RRSetConfigFailed:     message = &amp;quot;failed&amp;quot;;         break;&#xA;    case RRSetConfigInvalidConfigTime:  message = &amp;quot;invalid config time&amp;quot;;    break;&#xA;    case RRSetConfigInvalidTime:    message = &amp;quot;invalid time&amp;quot;;       break;&#xA;    default:                message = &amp;quot;unknown failure&amp;quot;;        break;&#xA;    }&#xA;&#xA;    fprintf (stderr, &amp;quot;%s: Configure crtc %d %s\n&amp;quot;, program_name, c, message);&#xA;    revert ();&#xA;    exit (1);&#xA;}&#xA;&#xA;static void&#xA;apply (void)&#xA;{&#xA;    Status  s;&#xA;    int     c;&#xA;&#xA;    /*&#xA;     * Hold the server grabbed while messing with&#xA;     * the screen so that apps which notice the resize&#xA;     * event and ask for xinerama information from the server&#xA;     * receive up-to-date information&#xA;     */&#xA;    if (grab_server)&#xA;    XGrabServer (dpy);&#xA;&#xA;    /*&#xA;     * Turn off any crtcs which are to be disabled or which are&#xA;     * larger than the target size&#xA;     */&#xA;    for (c = 0; c &amp;lt; res-&amp;gt;ncrtc; c++)&#xA;    {&#xA;    crtc_t      *crtc = &amp;amp;crtcs[c];&#xA;    XRRCrtcInfo *crtc_info = crtc-&amp;gt;crtc_info;&#xA;&#xA;    /* if this crtc is already disabled, skip it */&#xA;    if (crtc_info-&amp;gt;mode == None) &#xA;        continue;&#xA;&#xA;    /* &#xA;     * If this crtc is to be left enabled, make&#xA;     * sure the old size fits then new screen&#xA;     */&#xA;    if (crtc-&amp;gt;mode_info) &#xA;    {&#xA;        XRRModeInfo *old_mode = find_mode_by_xid (crtc_info-&amp;gt;mode);&#xA;        int x, y, w, h;&#xA;        box_t bounds;&#xA;&#xA;        if (!old_mode) &#xA;        panic (RRSetConfigFailed, crtc);&#xA;&#xA;        /* old position and size information */&#xA;        mode_geometry (old_mode, crtc_info-&amp;gt;rotation,&#xA;               &amp;amp;crtc-&amp;gt;current_transform.transform,&#xA;               &amp;amp;bounds);&#xA;&#xA;        x = crtc_info-&amp;gt;x + bounds.x1;&#xA;        y = crtc_info-&amp;gt;y + bounds.y1;&#xA;        w = bounds.x2 - bounds.x1;&#xA;        h = bounds.y2 - bounds.y1;&#xA;&#xA;        /* if it fits, skip it */&#xA;        if (x + w &amp;lt;= fb_width &amp;amp;&amp;amp; y + h &amp;lt;= fb_height) &#xA;        continue;&#xA;        crtc-&amp;gt;changing = True;&#xA;    }&#xA;    s = crtc_disable (crtc);&#xA;    if (s != RRSetConfigSuccess)&#xA;        panic (s, crtc);&#xA;    }&#xA;&#xA;    /*&#xA;     * Set the screen size&#xA;     */&#xA;    screen_apply ();&#xA;&#xA;    /*&#xA;     * Set crtcs&#xA;     */&#xA;&#xA;    for (c = 0; c &amp;lt; res-&amp;gt;ncrtc; c++)&#xA;    {&#xA;    crtc_t  *crtc = &amp;amp;crtcs[c];&#xA;&#xA;    s = crtc_apply (crtc);&#xA;    if (s != RRSetConfigSuccess)&#xA;        panic (s, crtc);&#xA;    }&#xA;&#xA;    set_primary ();&#xA;&#xA;    /*&#xA;     * Release the server grab and let all clients&#xA;     * respond to the updated state&#xA;     */&#xA;    if (grab_server)&#xA;    XUngrabServer (dpy);&#xA;}&#xA;&#xA;/*&#xA; * Use current output state to complete the output list&#xA; */&#xA;static void&#xA;get_outputs (void)&#xA;{&#xA;    int     o;&#xA;    output_t    *q;&#xA;&#xA;    for (o = 0; o &amp;lt; res-&amp;gt;noutput; o++)&#xA;    {&#xA;    XRROutputInfo   *output_info = XRRGetOutputInfo (dpy, res, res-&amp;gt;outputs[o]);&#xA;    output_t    *output;&#xA;    name_t      output_name;&#xA;    if (!output_info) fatal (&amp;quot;could not get output 0x%lx information\n&amp;quot;, res-&amp;gt;outputs[o]);&#xA;    set_name_xid (&amp;amp;output_name, res-&amp;gt;outputs[o]);&#xA;    set_name_index (&amp;amp;output_name, o);&#xA;    set_name_string (&amp;amp;output_name, output_info-&amp;gt;name);&#xA;    output = find_output (&amp;amp;output_name);&#xA;    if (!output)&#xA;    {&#xA;        output = add_output ();&#xA;        set_name_all (&amp;amp;output-&amp;gt;output, &amp;amp;output_name);&#xA;        /*&#xA;         * When global --automatic mode is set, turn on connected but off&#xA;         * outputs, turn off disconnected but on outputs&#xA;         */&#xA;        if (automatic)&#xA;        {&#xA;        switch (output_info-&amp;gt;connection) {&#xA;        case RR_Connected:&#xA;            if (!output_info-&amp;gt;crtc) {&#xA;            output-&amp;gt;changes |= changes_automatic;&#xA;            output-&amp;gt;automatic = True;&#xA;            }&#xA;            break;&#xA;        case RR_Disconnected:&#xA;            if (output_info-&amp;gt;crtc)&#xA;            {&#xA;            output-&amp;gt;changes |= changes_automatic;&#xA;            output-&amp;gt;automatic = True;&#xA;            }&#xA;            break;&#xA;        }&#xA;        }&#xA;    }&#xA;    output-&amp;gt;found = True;&#xA;&#xA;    /*&#xA;     * Automatic mode -- track connection state and enable/disable outputs&#xA;     * as necessary&#xA;     */&#xA;    if (output-&amp;gt;automatic)&#xA;    {&#xA;        switch (output_info-&amp;gt;connection) {&#xA;        case RR_Connected:&#xA;        case RR_UnknownConnection:&#xA;        if ((!(output-&amp;gt;changes &amp;amp; changes_mode)))&#xA;        {&#xA;            set_name_preferred (&amp;amp;output-&amp;gt;mode);&#xA;            output-&amp;gt;changes |= changes_mode;&#xA;        }&#xA;        break;&#xA;        case RR_Disconnected:&#xA;        if ((!(output-&amp;gt;changes &amp;amp; changes_mode)))&#xA;        {&#xA;            set_name_xid (&amp;amp;output-&amp;gt;mode, None);&#xA;            set_name_xid (&amp;amp;output-&amp;gt;crtc, None);&#xA;            output-&amp;gt;changes |= changes_mode;&#xA;            output-&amp;gt;changes |= changes_crtc;&#xA;        }&#xA;        break;&#xA;        }&#xA;    }&#xA;&#xA;    set_output_info (output, res-&amp;gt;outputs[o], output_info);&#xA;    }&#xA;    for (q = all_outputs; q; q = q-&amp;gt;next)&#xA;    {&#xA;    if (!q-&amp;gt;found)&#xA;    {&#xA;        fprintf(stderr, &amp;quot;warning: output %s not found; ignoring\n&amp;quot;,&#xA;            q-&amp;gt;output.string);&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;static void&#xA;mark_changing_crtcs (void)&#xA;{&#xA;    int c;&#xA;&#xA;    for (c = 0; c &amp;lt; num_crtcs; c++)&#xA;    {&#xA;    crtc_t      *crtc = &amp;amp;crtcs[c];&#xA;    int     o;&#xA;    output_t    *output;&#xA;&#xA;    /* walk old output list (to catch disables) */&#xA;    for (o = 0; o &amp;lt; crtc-&amp;gt;crtc_info-&amp;gt;noutput; o++)&#xA;    {&#xA;        output = find_output_by_xid (crtc-&amp;gt;crtc_info-&amp;gt;outputs[o]);&#xA;        if (!output) fatal (&amp;quot;cannot find output 0x%lx\n&amp;quot;,&#xA;                crtc-&amp;gt;crtc_info-&amp;gt;outputs[o]);&#xA;        if (output-&amp;gt;changes)&#xA;        crtc-&amp;gt;changing = True;&#xA;    }&#xA;    /* walk new output list */&#xA;    for (o = 0; o &amp;lt; crtc-&amp;gt;noutput; o++)&#xA;    {&#xA;        output = crtc-&amp;gt;outputs[o];&#xA;        if (output-&amp;gt;changes)&#xA;        crtc-&amp;gt;changing = True;&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;/*&#xA; * Test whether &#39;crtc&#39; can be used for &#39;output&#39;&#xA; */&#xA;static Bool&#xA;check_crtc_for_output (crtc_t *crtc, output_t *output)&#xA;{&#xA;    int     c;&#xA;    int     l;&#xA;    output_t    *other;&#xA;&#xA;    for (c = 0; c &amp;lt; output-&amp;gt;output_info-&amp;gt;ncrtc; c++)&#xA;    if (output-&amp;gt;output_info-&amp;gt;crtcs[c] == crtc-&amp;gt;crtc.xid)&#xA;        break;&#xA;    if (c == output-&amp;gt;output_info-&amp;gt;ncrtc)&#xA;    return False;&#xA;    for (other = all_outputs; other; other = other-&amp;gt;next)&#xA;    {&#xA;    if (other == output)&#xA;        continue;&#xA;&#xA;    if (other-&amp;gt;mode_info == NULL)&#xA;        continue;&#xA;&#xA;    if (other-&amp;gt;crtc_info != crtc)&#xA;        continue;&#xA;&#xA;    /* see if the output connected to the crtc can clone to this output */&#xA;    for (l = 0; l &amp;lt; output-&amp;gt;output_info-&amp;gt;nclone; l++)&#xA;        if (output-&amp;gt;output_info-&amp;gt;clones[l] == other-&amp;gt;output.xid)&#xA;        break;&#xA;    /* not on the list, can&#39;t clone */&#xA;    if (l == output-&amp;gt;output_info-&amp;gt;nclone) &#xA;        return False;&#xA;    }&#xA;&#xA;    if (crtc-&amp;gt;noutput)&#xA;    {&#xA;    /* make sure the state matches */&#xA;    if (crtc-&amp;gt;mode_info != output-&amp;gt;mode_info)&#xA;        return False;&#xA;    if (crtc-&amp;gt;x != output-&amp;gt;x)&#xA;        return False;&#xA;    if (crtc-&amp;gt;y != output-&amp;gt;y)&#xA;        return False;&#xA;    if (crtc-&amp;gt;rotation != output-&amp;gt;rotation)&#xA;        return False;&#xA;    if (!equal_transform (&amp;amp;crtc-&amp;gt;current_transform, &amp;amp;output-&amp;gt;transform))&#xA;        return False;&#xA;    }&#xA;    else if (crtc-&amp;gt;crtc_info-&amp;gt;noutput)&#xA;    {&#xA;    /* make sure the state matches the already used state */&#xA;    XRRModeInfo *mode = find_mode_by_xid (crtc-&amp;gt;crtc_info-&amp;gt;mode);&#xA;&#xA;    if (mode != output-&amp;gt;mode_info)&#xA;        return False;&#xA;    if (crtc-&amp;gt;crtc_info-&amp;gt;x != output-&amp;gt;x)&#xA;        return False;&#xA;    if (crtc-&amp;gt;crtc_info-&amp;gt;y != output-&amp;gt;y)&#xA;        return False;&#xA;    if (crtc-&amp;gt;crtc_info-&amp;gt;rotation != output-&amp;gt;rotation)&#xA;        return False;&#xA;    }&#xA;    return True;&#xA;}&#xA;&#xA;static crtc_t *&#xA;find_crtc_for_output (output_t *output)&#xA;{&#xA;    int     c;&#xA;&#xA;    for (c = 0; c &amp;lt; output-&amp;gt;output_info-&amp;gt;ncrtc; c++)&#xA;    {&#xA;    crtc_t      *crtc;&#xA;&#xA;    crtc = find_crtc_by_xid (output-&amp;gt;output_info-&amp;gt;crtcs[c]);&#xA;    if (!crtc) fatal (&amp;quot;cannot find crtc 0x%lx\n&amp;quot;, output-&amp;gt;output_info-&amp;gt;crtcs[c]);&#xA;&#xA;    if (check_crtc_for_output (crtc, output))&#xA;        return crtc;&#xA;    }&#xA;    return NULL;&#xA;}&#xA;&#xA;static void&#xA;set_positions (void)&#xA;{&#xA;    output_t    *output;&#xA;    Bool    keep_going;&#xA;    Bool    any_set;&#xA;    int     min_x, min_y;&#xA;&#xA;    for (;;)&#xA;    {&#xA;    any_set = False;&#xA;    keep_going = False;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;        output_t    *relation;&#xA;        name_t  relation_name;&#xA;&#xA;        if (!(output-&amp;gt;changes &amp;amp; changes_relation)) continue;&#xA;&#xA;        if (output-&amp;gt;mode_info == NULL) continue;&#xA;&#xA;        init_name (&amp;amp;relation_name);&#xA;        set_name_string (&amp;amp;relation_name, output-&amp;gt;relative_to);&#xA;        relation = find_output (&amp;amp;relation_name);&#xA;        if (!relation) fatal (&amp;quot;cannot find output \&amp;quot;%s\&amp;quot;\n&amp;quot;, output-&amp;gt;relative_to);&#xA;&#xA;        if (relation-&amp;gt;mode_info == NULL) &#xA;        {&#xA;        output-&amp;gt;x = 0;&#xA;        output-&amp;gt;y = 0;&#xA;        output-&amp;gt;changes |= changes_position;&#xA;        any_set = True;&#xA;        continue;&#xA;        }&#xA;        /*&#xA;         * Make sure the dependent object has been set in place&#xA;         */&#xA;        if ((relation-&amp;gt;changes &amp;amp; changes_relation) &amp;amp;&amp;amp; &#xA;        !(relation-&amp;gt;changes &amp;amp; changes_position))&#xA;        {&#xA;        keep_going = True;&#xA;        continue;&#xA;        }&#xA;&#xA;        switch (output-&amp;gt;relation) {&#xA;        case relation_left_of:&#xA;        output-&amp;gt;y = relation-&amp;gt;y;&#xA;        output-&amp;gt;x = relation-&amp;gt;x - mode_width (output-&amp;gt;mode_info, output-&amp;gt;rotation);&#xA;        break;&#xA;        case relation_right_of:&#xA;        output-&amp;gt;y = relation-&amp;gt;y;&#xA;        output-&amp;gt;x = relation-&amp;gt;x + mode_width (relation-&amp;gt;mode_info, relation-&amp;gt;rotation);&#xA;        break;&#xA;        case relation_above:&#xA;        output-&amp;gt;x = relation-&amp;gt;x;&#xA;        output-&amp;gt;y = relation-&amp;gt;y - mode_height (output-&amp;gt;mode_info, output-&amp;gt;rotation);&#xA;        break;&#xA;        case relation_below:&#xA;        output-&amp;gt;x = relation-&amp;gt;x;&#xA;        output-&amp;gt;y = relation-&amp;gt;y + mode_height (relation-&amp;gt;mode_info, relation-&amp;gt;rotation);&#xA;        break;&#xA;        case relation_same_as:&#xA;        output-&amp;gt;x = relation-&amp;gt;x;&#xA;        output-&amp;gt;y = relation-&amp;gt;y;&#xA;        }&#xA;        output-&amp;gt;changes |= changes_position;&#xA;        any_set = True;&#xA;    }&#xA;    if (!keep_going)&#xA;        break;&#xA;    if (!any_set)&#xA;        fatal (&amp;quot;loop in relative position specifications\n&amp;quot;);&#xA;    }&#xA;&#xA;    /*&#xA;     * Now normalize positions so the upper left corner of all outputs is at 0,0&#xA;     */&#xA;    min_x = 32768;&#xA;    min_y = 32768;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;    if (output-&amp;gt;mode_info == NULL) continue;&#xA;&#xA;    if (output-&amp;gt;x &amp;lt; min_x) min_x = output-&amp;gt;x;&#xA;    if (output-&amp;gt;y &amp;lt; min_y) min_y = output-&amp;gt;y;&#xA;    }&#xA;    if (min_x || min_y)&#xA;    {&#xA;    /* move all outputs */&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;        if (output-&amp;gt;mode_info == NULL) continue;&#xA;&#xA;        output-&amp;gt;x -= min_x;&#xA;        output-&amp;gt;y -= min_y;&#xA;        output-&amp;gt;changes |= changes_position;&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;static void&#xA;set_screen_size (void)&#xA;{&#xA;    output_t    *output;&#xA;    Bool    fb_specified = fb_width != 0 &amp;amp;&amp;amp; fb_height != 0;&#xA;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;    XRRModeInfo *mode_info = output-&amp;gt;mode_info;&#xA;    int     x, y, w, h;&#xA;    box_t       bounds;&#xA;&#xA;    if (!mode_info) continue;&#xA;&#xA;    mode_geometry (mode_info, output-&amp;gt;rotation,&#xA;               &amp;amp;output-&amp;gt;transform.transform,&#xA;               &amp;amp;bounds);&#xA;    x = output-&amp;gt;x + bounds.x1;&#xA;    y = output-&amp;gt;y + bounds.y1;&#xA;    w = bounds.x2 - bounds.x1;&#xA;    h = bounds.y2 - bounds.y1;&#xA;    /* make sure output fits in specified size */&#xA;    if (fb_specified)&#xA;    {&#xA;        if (x + w &amp;gt; fb_width || y + h &amp;gt; fb_height)&#xA;        warning (&amp;quot;specified screen %dx%d not large enough for output %s (%dx%d+%d+%d)\n&amp;quot;,&#xA;             fb_width, fb_height, output-&amp;gt;output.string, w, h, x, y);&#xA;    }&#xA;    /* fit fb to output */&#xA;    else&#xA;    {&#xA;        XRRPanning *pan;&#xA;        if (x + w &amp;gt; fb_width)&#xA;        fb_width = x + w;&#xA;        if (y + h &amp;gt; fb_height)&#xA;        fb_height = y + h;&#xA;        if (output-&amp;gt;changes &amp;amp; changes_panning)&#xA;        pan = &amp;amp;output-&amp;gt;panning;&#xA;        else&#xA;        pan = output-&amp;gt;crtc_info ? output-&amp;gt;crtc_info-&amp;gt;panning_info : NULL;&#xA;        if (pan &amp;amp;&amp;amp; pan-&amp;gt;left + pan-&amp;gt;width &amp;gt; fb_width)&#xA;        fb_width = pan-&amp;gt;left + pan-&amp;gt;width;&#xA;        if (pan &amp;amp;&amp;amp; pan-&amp;gt;top + pan-&amp;gt;height &amp;gt; fb_height)&#xA;        fb_height = pan-&amp;gt;top + pan-&amp;gt;height;&#xA;    }&#xA;    }   &#xA;&#xA;    if (fb_width &amp;gt; maxWidth || fb_height &amp;gt; maxHeight)&#xA;    fatal (&amp;quot;screen cannot be larger than %dx%d (desired size %dx%d)\n&amp;quot;,&#xA;           maxWidth, maxHeight, fb_width, fb_height);&#xA;    if (fb_specified)&#xA;    {&#xA;    if (fb_width &amp;lt; minWidth || fb_height &amp;lt; minHeight)&#xA;        fatal (&amp;quot;screen must be at least %dx%d\n&amp;quot;, minWidth, minHeight);&#xA;    }&#xA;    else&#xA;    {&#xA;    if (fb_width &amp;lt; minWidth) fb_width = minWidth;&#xA;    if (fb_height &amp;lt; minHeight) fb_height = minHeight;&#xA;    }&#xA;}&#xA;&#xA;&#xA;static void&#xA;disable_outputs (output_t *outputs)&#xA;{&#xA;    while (outputs)&#xA;    {&#xA;    outputs-&amp;gt;crtc_info = NULL;&#xA;    outputs = outputs-&amp;gt;next;&#xA;    }&#xA;}&#xA;&#xA;/*&#xA; * find the best mapping from output to crtc available&#xA; */&#xA;static int&#xA;pick_crtcs_score (output_t *outputs)&#xA;{&#xA;    output_t    *output;&#xA;    int     best_score;&#xA;    int     my_score;&#xA;    int     score;&#xA;    crtc_t  *best_crtc;&#xA;    int     c;&#xA;&#xA;    if (!outputs)&#xA;    return 0;&#xA;&#xA;    output = outputs;&#xA;    outputs = outputs-&amp;gt;next;&#xA;    /*&#xA;     * Score with this output disabled&#xA;     */&#xA;    output-&amp;gt;crtc_info = NULL;&#xA;    best_score = pick_crtcs_score (outputs);&#xA;    if (output-&amp;gt;mode_info == NULL)&#xA;    return best_score;&#xA;&#xA;    best_crtc = NULL;&#xA;    /* &#xA;     * Now score with this output any valid crtc&#xA;     */&#xA;    for (c = 0; c &amp;lt; output-&amp;gt;output_info-&amp;gt;ncrtc; c++)&#xA;    {&#xA;    crtc_t      *crtc;&#xA;&#xA;    crtc = find_crtc_by_xid (output-&amp;gt;output_info-&amp;gt;crtcs[c]);&#xA;    if (!crtc)&#xA;        fatal (&amp;quot;cannot find crtc 0x%lx\n&amp;quot;, output-&amp;gt;output_info-&amp;gt;crtcs[c]);&#xA;&#xA;    /* reset crtc allocation for following outputs */&#xA;    disable_outputs (outputs);&#xA;    if (!check_crtc_for_output (crtc, output))&#xA;        continue;&#xA;&#xA;    my_score = 1000;&#xA;    /* slight preference for existing connections */&#xA;    if (crtc == output-&amp;gt;current_crtc_info)&#xA;        my_score++;&#xA;&#xA;    output-&amp;gt;crtc_info = crtc;&#xA;    score = my_score + pick_crtcs_score (outputs);&#xA;    if (score &amp;gt; best_score)&#xA;    {&#xA;        best_crtc = crtc;&#xA;        best_score = score;&#xA;    }&#xA;    }&#xA;    if (output-&amp;gt;crtc_info != best_crtc)&#xA;    output-&amp;gt;crtc_info = best_crtc;&#xA;    /*&#xA;     * Reset other outputs based on this one using the best crtc&#xA;     */&#xA;    (void) pick_crtcs_score (outputs);&#xA;&#xA;    return best_score;&#xA;}&#xA;&#xA;/*&#xA; * Pick crtcs for any changing outputs that don&#39;t have one&#xA; */&#xA;static void&#xA;pick_crtcs (void)&#xA;{&#xA;    output_t    *output;&#xA;&#xA;    /*&#xA;     * First try to match up newly enabled outputs with spare crtcs&#xA;     */&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;    if (output-&amp;gt;changes &amp;amp;&amp;amp; output-&amp;gt;mode_info)&#xA;    {&#xA;        if (output-&amp;gt;crtc_info) {&#xA;        if (output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;noutput &amp;gt; 0 &amp;amp;&amp;amp;&#xA;            (output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;noutput &amp;gt; 1 ||&#xA;             output != find_output_by_xid (output-&amp;gt;crtc_info-&amp;gt;crtc_info-&amp;gt;outputs[0])))&#xA;            break;&#xA;        } else {&#xA;        output-&amp;gt;crtc_info = find_crtc_for_output (output);&#xA;        if (!output-&amp;gt;crtc_info)&#xA;            break;&#xA;        }&#xA;    }&#xA;    }&#xA;    /*&#xA;     * Everyone is happy&#xA;     */&#xA;    if (!output)&#xA;    return;&#xA;    /*&#xA;     * When the simple way fails, see if there is a way&#xA;     * to swap crtcs around and make things work&#xA;     */&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    output-&amp;gt;current_crtc_info = output-&amp;gt;crtc_info;&#xA;    pick_crtcs_score (all_outputs);&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;    if (output-&amp;gt;mode_info &amp;amp;&amp;amp; !output-&amp;gt;crtc_info)&#xA;        fatal (&amp;quot;cannot find crtc for output %s\n&amp;quot;, output-&amp;gt;output.string);&#xA;    if (!output-&amp;gt;changes &amp;amp;&amp;amp; output-&amp;gt;crtc_info != output-&amp;gt;current_crtc_info)&#xA;        output-&amp;gt;changes |= changes_crtc;&#xA;    }&#xA;}&#xA;&#xA;static int&#xA;check_strtol(char *s)&#xA;{&#xA;    char *endptr;&#xA;    int result = strtol(s, &amp;amp;endptr, 10);&#xA;    if (s == endptr)&#xA;    argerr (&amp;quot;failed to parse &#39;%s&#39; as a number\n&amp;quot;, s);&#xA;    return result;&#xA;}&#xA;&#xA;static double&#xA;check_strtod(char *s)&#xA;{&#xA;    char *endptr;&#xA;    double result = strtod(s, &amp;amp;endptr);&#xA;    if (s == endptr)&#xA;    argerr (&amp;quot;failed to parse &#39;%s&#39; as a number\n&amp;quot;, s);&#xA;    return result;&#xA;}&#xA;&#xA;&#xA;static void *&#xA;property_values_from_string(const char *str, const Atom type, const int format,&#xA;                int *returned_nitems)&#xA;{&#xA;    char *token, *tmp;&#xA;    void *returned_bytes = NULL;&#xA;    int nitems = 0, bytes_per_item = format / 8;&#xA;&#xA;    if ((type != XA_INTEGER &amp;amp;&amp;amp; type != XA_CARDINAL) ||&#xA;    (format != 8 &amp;amp;&amp;amp; format != 16 &amp;amp;&amp;amp; format != 32))&#xA;    {&#xA;    return NULL;&#xA;    }&#xA;&#xA;    tmp = strdup (str);&#xA;&#xA;    for (token = strtok (tmp, &amp;quot;,&amp;quot;); token; token = strtok (NULL, &amp;quot;,&amp;quot;))&#xA;    {&#xA;    char *endptr;&#xA;    long int val = strtol (token, &amp;amp;endptr, 0);&#xA;&#xA;    if (token == endptr || *endptr != &#39;\0&#39;)&#xA;    {&#xA;        argerr (&amp;quot;failed to parse &#39;%s&#39; as a number\n&amp;quot;, token);&#xA;    }&#xA;&#xA;    returned_bytes = realloc (returned_bytes, (nitems + 1) * bytes_per_item);&#xA;&#xA;    if (type == XA_INTEGER &amp;amp;&amp;amp; format == 8)&#xA;    {&#xA;        int8_t *ptr = returned_bytes;&#xA;        ptr[nitems] = (int8_t) val;&#xA;    }&#xA;    else if (type == XA_INTEGER &amp;amp;&amp;amp; format == 16)&#xA;    {&#xA;        int16_t *ptr = returned_bytes;&#xA;        ptr[nitems] = (int16_t) val;&#xA;    }&#xA;    else if (type == XA_INTEGER &amp;amp;&amp;amp; format == 32)&#xA;    {&#xA;        int32_t *ptr = returned_bytes;&#xA;        ptr[nitems] = (int32_t) val;&#xA;    }&#xA;    else if (type == XA_CARDINAL &amp;amp;&amp;amp; format == 8)&#xA;    {&#xA;        uint8_t *ptr = returned_bytes;&#xA;        ptr[nitems] = (uint8_t) val;&#xA;    }&#xA;    else if (type == XA_CARDINAL &amp;amp;&amp;amp; format == 16)&#xA;    {&#xA;        uint16_t *ptr = returned_bytes;&#xA;        ptr[nitems] = (uint16_t) val;&#xA;    }&#xA;    else if (type == XA_CARDINAL &amp;amp;&amp;amp; format == 32)&#xA;    {&#xA;        uint32_t *ptr = returned_bytes;&#xA;        ptr[nitems] = (uint32_t) val;&#xA;    }&#xA;    else&#xA;    {&#xA;        free (tmp);&#xA;        free (returned_bytes);&#xA;        return NULL;&#xA;    }&#xA;&#xA;    nitems++;&#xA;    }&#xA;&#xA;    free (tmp);&#xA;&#xA;    *returned_nitems = nitems;&#xA;    return returned_bytes;&#xA;}&#xA;&#xA;&#xA;static void&#xA;print_output_property_value(int value_format, /* 8, 16, 32 */&#xA;                Atom value_type,  /* XA_{ATOM,INTEGER,CARDINAL} */&#xA;                const void *value_bytes)&#xA;{&#xA;    if (value_type == XA_ATOM &amp;amp;&amp;amp; value_format == 32)&#xA;    {&#xA;    const Atom *val = value_bytes;&#xA;    char *str = XGetAtomName (dpy, *val);&#xA;    if (str != NULL)&#xA;    {&#xA;        printf (&amp;quot;%s&amp;quot;, str);&#xA;        XFree (str);&#xA;        return;&#xA;    }&#xA;    }&#xA;&#xA;    if (value_type == XA_INTEGER)&#xA;    {&#xA;    if (value_format == 8)&#xA;    {&#xA;        const int8_t *val = value_bytes;&#xA;        printf (&amp;quot;%&amp;quot; PRId8, *val);&#xA;        return;&#xA;    }&#xA;    if (value_format == 16)&#xA;    {&#xA;        const int16_t *val = value_bytes;&#xA;        printf (&amp;quot;%&amp;quot; PRId16, *val);&#xA;        return;&#xA;    }&#xA;    if (value_format == 32)&#xA;    {&#xA;        const int32_t *val = value_bytes;&#xA;        printf (&amp;quot;%&amp;quot; PRId32, *val);&#xA;        return;&#xA;    }&#xA;    }&#xA;&#xA;    if (value_type == XA_CARDINAL)&#xA;    {&#xA;    if (value_format == 8)&#xA;    {&#xA;        const uint8_t *val = value_bytes;&#xA;        printf (&amp;quot;%&amp;quot; PRIu8, *val);&#xA;        return;&#xA;    }&#xA;    if (value_format == 16)&#xA;    {&#xA;        const uint16_t *val = value_bytes;&#xA;        printf (&amp;quot;%&amp;quot; PRIu16, *val);&#xA;        return;&#xA;    }&#xA;    if (value_format == 32)&#xA;    {&#xA;        const uint32_t *val = value_bytes;&#xA;        printf (&amp;quot;%&amp;quot; PRIu32, *val);&#xA;        return;&#xA;    }&#xA;    }&#xA;&#xA;    printf (&amp;quot;?&amp;quot;);&#xA;}&#xA;&#xA;static void&#xA;print_edid(int nitems, const unsigned char *prop)&#xA;{&#xA;    int k;&#xA;&#xA;    printf (&amp;quot;\n\t\t&amp;quot;);&#xA;&#xA;    for (k = 0; k &amp;lt; nitems; k++)&#xA;    {&#xA;    if (k != 0 &amp;amp;&amp;amp; (k % 16) == 0)&#xA;    {&#xA;        printf (&amp;quot;\n\t\t&amp;quot;);&#xA;    }&#xA;&#xA;    printf(&amp;quot;%02&amp;quot; PRIx8, prop[k]);&#xA;    }&#xA;&#xA;    printf(&amp;quot;\n&amp;quot;);&#xA;}&#xA;&#xA;static void&#xA;print_guid(const unsigned char *prop)&#xA;{&#xA;    int k;&#xA;&#xA;    printf(&amp;quot;{&amp;quot;);&#xA;&#xA;    for (k = 0; k &amp;lt; 16; k++)&#xA;    {&#xA;    printf(&amp;quot;%02&amp;quot; PRIX8, prop[k]);&#xA;    if (k == 3 || k == 5 || k == 7 || k == 9)&#xA;    {&#xA;        printf(&amp;quot;-&amp;quot;);&#xA;    }&#xA;    }&#xA;&#xA;    printf(&amp;quot;}\n&amp;quot;);&#xA;}&#xA;&#xA;static void&#xA;print_output_property(const char *atom_name,&#xA;              int value_format,&#xA;              Atom value_type,&#xA;              int nitems,&#xA;              const unsigned char *prop)&#xA;{&#xA;    int bytes_per_item = value_format / 8;&#xA;    int k;&#xA;&#xA;    /*&#xA;     * Check for properties that need special formatting.&#xA;     */&#xA;    if (strcmp (atom_name, &amp;quot;EDID&amp;quot;) == 0 &amp;amp;&amp;amp; value_format == 8 &amp;amp;&amp;amp;&#xA;    value_type == XA_INTEGER)&#xA;    {&#xA;    print_edid (nitems, prop);&#xA;    return;&#xA;    }&#xA;    else if (strcmp (atom_name, &amp;quot;GUID&amp;quot;) == 0 &amp;amp;&amp;amp; value_format == 8 &amp;amp;&amp;amp;&#xA;         value_type == XA_INTEGER &amp;amp;&amp;amp; nitems == 16)&#xA;    {&#xA;    print_guid (prop);&#xA;    return;&#xA;    }&#xA;&#xA;    for (k = 0; k &amp;lt; nitems; k++)&#xA;    {&#xA;    if (k != 0)&#xA;    {&#xA;        if ((k % 16) == 0)&#xA;        {&#xA;        printf (&amp;quot;\n\t\t&amp;quot;);&#xA;        }&#xA;    }&#xA;    print_output_property_value (value_format, value_type,&#xA;                     prop + (k * bytes_per_item));&#xA;    printf (&amp;quot; &amp;quot;);&#xA;    }&#xA;&#xA;    printf (&amp;quot;\n&amp;quot;);&#xA;}&#xA;&#xA;static void&#xA;get_providers (void)&#xA;{&#xA;    XRRProviderResources *pr;&#xA;    int i;&#xA;&#xA;    if (!has_1_4 || providers)&#xA;    return;&#xA;&#xA;    pr = XRRGetProviderResources(dpy, root);&#xA;    num_providers = pr-&amp;gt;nproviders;&#xA;    providers = calloc (num_providers, sizeof (provider_t));&#xA;    if (!providers)&#xA;    fatal (&amp;quot;out of memory\n&amp;quot;);&#xA;&#xA;    for (i = 0; i &amp;lt; num_providers; i++) {&#xA;    provider_t *provider = &amp;amp;providers[i];&#xA;    name_t *name = &amp;amp;provider-&amp;gt;provider;&#xA;    XRRProviderInfo *info = XRRGetProviderInfo(dpy, res, pr-&amp;gt;providers[i]);&#xA;&#xA;    provider-&amp;gt;info = info;&#xA;    set_name_xid (name, pr-&amp;gt;providers[i]);&#xA;    set_name_index (name, i);&#xA;    set_name_string (name, info-&amp;gt;name);&#xA;   }&#xA;&#xA;   XRRFreeProviderResources(pr);&#xA;}&#xA;&#xA;static provider_t *&#xA;find_provider (name_t *name)&#xA;{&#xA;    int i;&#xA;&#xA;    if ((name-&amp;gt;kind &amp;amp; name_xid) &amp;amp;&amp;amp; name-&amp;gt;xid == 0)&#xA;    return NULL;&#xA;    for (i = 0; i &amp;lt; num_providers; i++) {&#xA;    provider_t *p = &amp;amp;providers[i];&#xA;    name_kind_t common = name-&amp;gt;kind &amp;amp; p-&amp;gt;provider.kind;&#xA;&#xA;    if ((common &amp;amp; name_xid) &amp;amp;&amp;amp; name-&amp;gt;xid == p-&amp;gt;provider.xid)&#xA;        return p;&#xA;    if ((common &amp;amp; name_string) &amp;amp;&amp;amp; !strcmp (name-&amp;gt;string, p-&amp;gt;provider.string))&#xA;        return p;&#xA;    if ((common &amp;amp; name_index) &amp;amp;&amp;amp; name-&amp;gt;index == p-&amp;gt;provider.index)&#xA;        return p;&#xA;    }&#xA;&#xA;    printf (&amp;quot;Could not find provider with &amp;quot;);&#xA;    print_name (name);&#xA;    printf (&amp;quot;\n&amp;quot;);&#xA;    exit (1);&#xA;}&#xA;&#xA;&#xA;int&#xA;main (int argc, char **argv)&#xA;{&#xA;    XRRScreenSize *sizes;&#xA;    XRRScreenConfiguration *sc;&#xA;    int     nsize;&#xA;    int     nrate;&#xA;    short       *rates;&#xA;    Status  status = RRSetConfigFailed;&#xA;    int     rot = -1;&#xA;    int     query = False;&#xA;    int     action_requested = False;&#xA;    Rotation    current_rotation;&#xA;    XEvent  event;&#xA;    XRRScreenChangeNotifyEvent *sce;    &#xA;    char          *display_name = NULL;&#xA;    int         i;&#xA;    SizeID  current_size;&#xA;    short   current_rate;&#xA;    double      rate = -1;&#xA;    int     size = -1;&#xA;    int     dirind = 0;&#xA;    Bool    setit = False;&#xA;    Bool        version = False;&#xA;    int     event_base, error_base;&#xA;    int     reflection = 0;&#xA;    int     width = 0, height = 0;&#xA;    Bool        have_pixel_size = False;&#xA;    int     ret = 0;&#xA;    output_t    *config_output = NULL;&#xA;    Bool        setit_1_2 = False;&#xA;    Bool        query_1_2 = False;&#xA;    Bool    modeit = False;&#xA;    Bool    propit = False;&#xA;    Bool    query_1 = False;&#xA;    Bool    list_providers = False;&#xA;    Bool        provsetoutsource = False;&#xA;    Bool        provsetoffsink = False;&#xA;    int     major, minor;&#xA;    Bool    current = False;&#xA;    Bool    toggle_x = False;&#xA;    Bool    toggle_y = False;&#xA;&#xA;    program_name = argv[0];&#xA;    for (i = 1; i &amp;lt; argc; i++) {&#xA;    if (!strcmp (&amp;quot;-display&amp;quot;, argv[i]) || !strcmp (&amp;quot;--display&amp;quot;, argv[i]) ||&#xA;        !strcmp (&amp;quot;-d&amp;quot;, argv[i])) {&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        display_name = argv[i];&#xA;        continue;&#xA;    }&#xA;    if (!strcmp(&amp;quot;-help&amp;quot;, argv[i]) || !strcmp(&amp;quot;--help&amp;quot;, argv[i])) {&#xA;        usage();&#xA;        exit(0);&#xA;    }&#xA;    if (!strcmp (&amp;quot;--verbose&amp;quot;, argv[i])) {&#xA;        verbose = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--dryrun&amp;quot;, argv[i])) {&#xA;        dryrun = True;&#xA;        verbose = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--nograb&amp;quot;, argv[i])) {&#xA;        grab_server = False;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp(&amp;quot;--current&amp;quot;, argv[i])) {&#xA;        current = True;&#xA;        continue;&#xA;    }&#xA;&#xA;    if (!strcmp (&amp;quot;-s&amp;quot;, argv[i]) || !strcmp (&amp;quot;--size&amp;quot;, argv[i])) {&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf (argv[i], &amp;quot;%dx%d&amp;quot;, &amp;amp;width, &amp;amp;height) == 2) {&#xA;        have_pixel_size = True;&#xA;        } else {&#xA;        size = check_strtol(argv[i]);&#xA;        if (size &amp;lt; 0) argerr (&amp;quot;--size argument must be nonnegative\n&amp;quot;);&#xA;        }&#xA;        setit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;&#xA;    if (!strcmp (&amp;quot;-r&amp;quot;, argv[i]) ||&#xA;        !strcmp (&amp;quot;--rate&amp;quot;, argv[i]) ||&#xA;        !strcmp (&amp;quot;--refresh&amp;quot;, argv[i]))&#xA;    {&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        rate = check_strtod(argv[i]);&#xA;        setit = True;&#xA;        if (config_output)&#xA;        {&#xA;        config_output-&amp;gt;refresh = rate;&#xA;        config_output-&amp;gt;changes |= changes_refresh;&#xA;        setit_1_2 = True;&#xA;        }&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;&#xA;    if (!strcmp (&amp;quot;-v&amp;quot;, argv[i]) || !strcmp (&amp;quot;--version&amp;quot;, argv[i])) {&#xA;        version = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;&#xA;    if (!strcmp (&amp;quot;-x&amp;quot;, argv[i])) {&#xA;        toggle_x = True;&#xA;        setit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;-y&amp;quot;, argv[i])) {&#xA;        toggle_y = True;&#xA;        setit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--screen&amp;quot;, argv[i])) {&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        screen = check_strtol(argv[i]);&#xA;        if (screen &amp;lt; 0) argerr (&amp;quot;--screen argument must be nonnegative\n&amp;quot;);&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;-q&amp;quot;, argv[i]) || !strcmp (&amp;quot;--query&amp;quot;, argv[i])) {&#xA;        query = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;-o&amp;quot;, argv[i]) || !strcmp (&amp;quot;--orientation&amp;quot;, argv[i])) {&#xA;        char *endptr;&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        dirind = strtol(argv[i], &amp;amp;endptr, 10);&#xA;        if (argv[i] == endptr) {&#xA;        for (dirind = 0; dirind &amp;lt; 4; dirind++) {&#xA;            if (strcmp (direction[dirind], argv[i]) == 0) break;&#xA;        }&#xA;        }&#xA;        if ((dirind &amp;lt; 0) || (dirind &amp;gt; 3))&#xA;        argerr (&amp;quot;%s: invalid argument &#39;%s&#39;\n&amp;quot;, argv[i-1], argv[i]);&#xA;        rot = dirind;&#xA;        setit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--prop&amp;quot;, argv[i]) ||&#xA;        !strcmp (&amp;quot;--props&amp;quot;, argv[i]) ||&#xA;        !strcmp (&amp;quot;--madprops&amp;quot;, argv[i]) ||&#xA;        !strcmp (&amp;quot;--properties&amp;quot;, argv[i]))&#xA;    {&#xA;        query_1_2 = True;&#xA;        properties = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--output&amp;quot;, argv[i])) {&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;&#xA;        config_output = find_output_by_name (argv[i]);&#xA;        if (!config_output) {&#xA;        config_output = add_output ();&#xA;        set_name (&amp;amp;config_output-&amp;gt;output, argv[i], name_string|name_xid);&#xA;        }&#xA;&#xA;        setit_1_2 = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--crtc&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        set_name (&amp;amp;config_output-&amp;gt;crtc, argv[i], name_xid|name_index);&#xA;        config_output-&amp;gt;changes |= changes_crtc;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--mode&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        set_name (&amp;amp;config_output-&amp;gt;mode, argv[i], name_string|name_xid);&#xA;        config_output-&amp;gt;changes |= changes_mode;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--preferred&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        set_name_preferred (&amp;amp;config_output-&amp;gt;mode);&#xA;        config_output-&amp;gt;changes |= changes_mode;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--pos&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf (argv[i], &amp;quot;%dx%d&amp;quot;,&#xA;            &amp;amp;config_output-&amp;gt;x, &amp;amp;config_output-&amp;gt;y) != 2)&#xA;        argerr (&amp;quot;failed to parse &#39;%s&#39; as a position\n&amp;quot;, argv[i]);&#xA;        config_output-&amp;gt;changes |= changes_position;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--rotation&amp;quot;, argv[i]) || !strcmp (&amp;quot;--rotate&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        for (dirind = 0; dirind &amp;lt; 4; dirind++) {&#xA;        if (strcmp (direction[dirind], argv[i]) == 0) break;&#xA;        }&#xA;        if (dirind == 4)&#xA;        argerr (&amp;quot;%s: invalid argument &#39;%s&#39;\n&amp;quot;, argv[i-1], argv[i]);&#xA;        config_output-&amp;gt;rotation &amp;amp;= ~0xf;&#xA;        config_output-&amp;gt;rotation |= 1 &amp;lt;&amp;lt; dirind;&#xA;        config_output-&amp;gt;changes |= changes_rotation;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--reflect&amp;quot;, argv[i]) || !strcmp (&amp;quot;--reflection&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        for (dirind = 0; dirind &amp;lt; 4; dirind++) {&#xA;        if (strcmp (reflections[dirind], argv[i]) == 0) break;&#xA;        }&#xA;        if (dirind == 4)&#xA;        argerr (&amp;quot;%s: invalid argument &#39;%s&#39;\n&amp;quot;, argv[i-1], argv[i]);&#xA;        config_output-&amp;gt;rotation &amp;amp;= ~(RR_Reflect_X|RR_Reflect_Y);&#xA;        config_output-&amp;gt;rotation |= dirind * RR_Reflect_X;&#xA;        config_output-&amp;gt;changes |= changes_reflection;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--left-of&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        config_output-&amp;gt;relation = relation_left_of;&#xA;        config_output-&amp;gt;relative_to = argv[i];&#xA;        config_output-&amp;gt;changes |= changes_relation;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--right-of&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        config_output-&amp;gt;relation = relation_right_of;&#xA;        config_output-&amp;gt;relative_to = argv[i];&#xA;        config_output-&amp;gt;changes |= changes_relation;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--above&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        config_output-&amp;gt;relation = relation_above;&#xA;        config_output-&amp;gt;relative_to = argv[i];&#xA;        config_output-&amp;gt;changes |= changes_relation;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--below&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        config_output-&amp;gt;relation = relation_below;&#xA;        config_output-&amp;gt;relative_to = argv[i];&#xA;        config_output-&amp;gt;changes |= changes_relation;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--same-as&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        config_output-&amp;gt;relation = relation_same_as;&#xA;        config_output-&amp;gt;relative_to = argv[i];&#xA;        config_output-&amp;gt;changes |= changes_relation;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--panning&amp;quot;, argv[i])) {&#xA;        XRRPanning *pan;&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        pan = &amp;amp;config_output-&amp;gt;panning;&#xA;        switch (sscanf (argv[i], &amp;quot;%dx%d+%d+%d/%dx%d+%d+%d/%d/%d/%d/%d&amp;quot;,&#xA;                &amp;amp;pan-&amp;gt;width, &amp;amp;pan-&amp;gt;height, &amp;amp;pan-&amp;gt;left, &amp;amp;pan-&amp;gt;top,&#xA;                &amp;amp;pan-&amp;gt;track_width, &amp;amp;pan-&amp;gt;track_height,&#xA;                &amp;amp;pan-&amp;gt;track_left, &amp;amp;pan-&amp;gt;track_top,&#xA;                &amp;amp;pan-&amp;gt;border_left, &amp;amp;pan-&amp;gt;border_top,&#xA;                &amp;amp;pan-&amp;gt;border_right, &amp;amp;pan-&amp;gt;border_bottom)) {&#xA;        case 2:&#xA;        pan-&amp;gt;left = pan-&amp;gt;top = 0;&#xA;        /* fall through */&#xA;        case 4:&#xA;        pan-&amp;gt;track_left = pan-&amp;gt;track_top =&#xA;            pan-&amp;gt;track_width = pan-&amp;gt;track_height = 0;&#xA;        /* fall through */&#xA;        case 8:&#xA;        pan-&amp;gt;border_left = pan-&amp;gt;border_top =&#xA;            pan-&amp;gt;border_right = pan-&amp;gt;border_bottom = 0;&#xA;        /* fall through */&#xA;        case 12:&#xA;        break;&#xA;        default:&#xA;        argerr (&amp;quot;%s: invalid argument &#39;%s&#39;\n&amp;quot;, argv[i-1], argv[i]);&#xA;        }&#xA;        config_output-&amp;gt;changes |= changes_panning;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--gamma&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf(argv[i], &amp;quot;%f:%f:%f&amp;quot;, &amp;amp;config_output-&amp;gt;gamma.red,&#xA;            &amp;amp;config_output-&amp;gt;gamma.green, &amp;amp;config_output-&amp;gt;gamma.blue) != 3)&#xA;        argerr (&amp;quot;%s: invalid argument &#39;%s&#39;\n&amp;quot;, argv[i-1], argv[i]);&#xA;        config_output-&amp;gt;changes |= changes_gamma;&#xA;        setit_1_2 = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--brightness&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf(argv[i], &amp;quot;%f&amp;quot;, &amp;amp;config_output-&amp;gt;brightness) != 1)&#xA;        argerr (&amp;quot;%s: invalid argument &#39;%s&#39;\n&amp;quot;, argv[i-1], argv[i]);&#xA;        config_output-&amp;gt;changes |= changes_gamma;&#xA;        setit_1_2 = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--primary&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        config_output-&amp;gt;changes |= changes_primary;&#xA;        config_output-&amp;gt;primary = True;&#xA;        setit_1_2 = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--noprimary&amp;quot;, argv[i])) {&#xA;        no_primary = True;&#xA;        setit_1_2 = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--set&amp;quot;, argv[i])) {&#xA;        output_prop_t   *prop;&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (i+2 &amp;gt;= argc) argerr (&amp;quot;%s requires two arguments\n&amp;quot;, argv[i]);&#xA;        prop = malloc (sizeof (output_prop_t));&#xA;        prop-&amp;gt;next = config_output-&amp;gt;props;&#xA;        config_output-&amp;gt;props = prop;&#xA;        prop-&amp;gt;name = argv[++i];&#xA;        prop-&amp;gt;value = argv[++i];&#xA;        propit = True;&#xA;        config_output-&amp;gt;changes |= changes_property;&#xA;        setit_1_2 = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--scale&amp;quot;, argv[i]))&#xA;    {&#xA;        double  sx, sy;&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf (argv[i], &amp;quot;%lfx%lf&amp;quot;, &amp;amp;sx, &amp;amp;sy) != 2)&#xA;        argerr (&amp;quot;failed to parse &#39;%s&#39; as a scaling factor\n&amp;quot;, argv[i]);&#xA;        init_transform (&amp;amp;config_output-&amp;gt;transform);&#xA;        config_output-&amp;gt;transform.transform.matrix[0][0] = XDoubleToFixed (sx);&#xA;        config_output-&amp;gt;transform.transform.matrix[1][1] = XDoubleToFixed (sy);&#xA;        config_output-&amp;gt;transform.transform.matrix[2][2] = XDoubleToFixed (1.0);&#xA;        if (sx != 1 || sy != 1)&#xA;        config_output-&amp;gt;transform.filter = &amp;quot;bilinear&amp;quot;;&#xA;        else&#xA;        config_output-&amp;gt;transform.filter = &amp;quot;nearest&amp;quot;;&#xA;        config_output-&amp;gt;transform.nparams = 0;&#xA;        config_output-&amp;gt;transform.params = NULL;&#xA;        config_output-&amp;gt;changes |= changes_transform;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--scale-from&amp;quot;, argv[i]))&#xA;    {&#xA;        int w, h;&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf (argv[i], &amp;quot;%dx%d&amp;quot;, &amp;amp;w, &amp;amp;h) != 2)&#xA;        argerr (&amp;quot;failed to parse &#39;%s&#39; as a scale-from size\n&amp;quot;, argv[i]);&#xA;        if (w &amp;lt;=0 || h &amp;lt;= 0)&#xA;        argerr (&amp;quot;--scale-from dimensions must be nonnegative\n&amp;quot;);&#xA;        config_output-&amp;gt;scale_from_w = w;&#xA;        config_output-&amp;gt;scale_from_h = h;&#xA;        config_output-&amp;gt;changes |= changes_transform;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--transform&amp;quot;, argv[i])) {&#xA;        double  transform[3][3];&#xA;        int     k, l;&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        init_transform (&amp;amp;config_output-&amp;gt;transform);&#xA;        if (strcmp (argv[i], &amp;quot;none&amp;quot;) != 0)&#xA;        {&#xA;        if (sscanf(argv[i], &amp;quot;%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf&amp;quot;,&#xA;               &amp;amp;transform[0][0],&amp;amp;transform[0][1],&amp;amp;transform[0][2],&#xA;               &amp;amp;transform[1][0],&amp;amp;transform[1][1],&amp;amp;transform[1][2],&#xA;               &amp;amp;transform[2][0],&amp;amp;transform[2][1],&amp;amp;transform[2][2])&#xA;            != 9)&#xA;            argerr (&amp;quot;failed to parse &#39;%s&#39; as a transformation\n&amp;quot;, argv[i]);&#xA;        init_transform (&amp;amp;config_output-&amp;gt;transform);&#xA;        for (k = 0; k &amp;lt; 3; k++)&#xA;            for (l = 0; l &amp;lt; 3; l++) {&#xA;            config_output-&amp;gt;transform.transform.matrix[k][l] = XDoubleToFixed (transform[k][l]);&#xA;            }&#xA;        config_output-&amp;gt;transform.filter = &amp;quot;bilinear&amp;quot;;&#xA;        config_output-&amp;gt;transform.nparams = 0;&#xA;        config_output-&amp;gt;transform.params = NULL;&#xA;        }&#xA;        config_output-&amp;gt;changes |= changes_transform;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--off&amp;quot;, argv[i])) {&#xA;        if (!config_output) argerr (&amp;quot;%s must be used after --output\n&amp;quot;, argv[i]);&#xA;        set_name_xid (&amp;amp;config_output-&amp;gt;mode, None);&#xA;        set_name_xid (&amp;amp;config_output-&amp;gt;crtc, None);&#xA;        config_output-&amp;gt;changes |= changes_mode;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--fb&amp;quot;, argv[i])) {&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf (argv[i], &amp;quot;%dx%d&amp;quot;,&#xA;            &amp;amp;fb_width, &amp;amp;fb_height) != 2)&#xA;        argerr (&amp;quot;failed to parse &#39;%s&#39; as a framebuffer size\n&amp;quot;, argv[i]);&#xA;        setit_1_2 = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--fbmm&amp;quot;, argv[i])) {&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        if (sscanf (argv[i], &amp;quot;%dx%d&amp;quot;,&#xA;            &amp;amp;fb_width_mm, &amp;amp;fb_height_mm) != 2)&#xA;        argerr (&amp;quot;failed to parse &#39;%s&#39; as a physical size\n&amp;quot;, argv[i]);&#xA;        setit_1_2 = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--dpi&amp;quot;, argv[i])) {&#xA;        char *strtod_error;&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        dpi = strtod(argv[i], &amp;amp;strtod_error);&#xA;        if (argv[i] == strtod_error)&#xA;        {&#xA;        dpi = 0.0;&#xA;        dpi_output_name = argv[i];&#xA;        }&#xA;        setit_1_2 = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--auto&amp;quot;, argv[i])) {&#xA;        if (config_output)&#xA;        {&#xA;        config_output-&amp;gt;automatic = True;&#xA;        config_output-&amp;gt;changes |= changes_automatic;&#xA;        }&#xA;        else&#xA;        automatic = True;&#xA;        setit_1_2 = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--q12&amp;quot;, argv[i]))&#xA;    {&#xA;        query_1_2 = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--q1&amp;quot;, argv[i]))&#xA;    {&#xA;        query_1 = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--newmode&amp;quot;, argv[i]))&#xA;    {&#xA;        umode_t  *m = calloc (1, sizeof (umode_t));&#xA;        double    clock;&#xA;&#xA;        ++i;&#xA;        if (i + 9 &amp;gt;= argc)&#xA;        argerr (&amp;quot;failed to parse &#39;%s&#39; as a mode specification\n&amp;quot;, argv[i]);&#xA;        m-&amp;gt;mode.name = argv[i];&#xA;        m-&amp;gt;mode.nameLength = strlen (argv[i]);&#xA;        i++;&#xA;        clock = check_strtod(argv[i++]);&#xA;        m-&amp;gt;mode.dotClock = clock * 1e6;&#xA;&#xA;        m-&amp;gt;mode.width = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.hSyncStart = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.hSyncEnd = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.hTotal = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.height = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.vSyncStart = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.vSyncEnd = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.vTotal = check_strtol(argv[i++]);&#xA;        m-&amp;gt;mode.modeFlags = 0;&#xA;        while (i &amp;lt; argc) {&#xA;        int f;&#xA;&#xA;        for (f = 0; mode_flags[f].string; f++)&#xA;            if (!strcasecmp (mode_flags[f].string, argv[i]))&#xA;            break;&#xA;&#xA;        if (!mode_flags[f].string)&#xA;            break;&#xA;        m-&amp;gt;mode.modeFlags |= mode_flags[f].flag;&#xA;        i++;&#xA;        }&#xA;        m-&amp;gt;next = umodes;&#xA;        m-&amp;gt;action = umode_create;&#xA;        umodes = m;&#xA;        modeit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--rmmode&amp;quot;, argv[i]))&#xA;    {&#xA;        umode_t  *m = calloc (1, sizeof (umode_t));&#xA;&#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        set_name (&amp;amp;m-&amp;gt;name, argv[i], name_string|name_xid);&#xA;        m-&amp;gt;action = umode_destroy;&#xA;        m-&amp;gt;next = umodes;&#xA;        umodes = m;&#xA;        modeit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--addmode&amp;quot;, argv[i]))&#xA;    {&#xA;        umode_t  *m = calloc (1, sizeof (umode_t));&#xA;&#xA;        if (i+2 &amp;gt;= argc) argerr (&amp;quot;%s requires two arguments\n&amp;quot;, argv[i]);&#xA;        set_name (&amp;amp;m-&amp;gt;output, argv[++i], name_string|name_xid);&#xA;        set_name (&amp;amp;m-&amp;gt;name, argv[++i], name_string|name_xid);&#xA;        m-&amp;gt;action = umode_add;&#xA;        m-&amp;gt;next = umodes;&#xA;        umodes = m;&#xA;        modeit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--delmode&amp;quot;, argv[i]))&#xA;    {&#xA;        umode_t  *m = calloc (1, sizeof (umode_t));&#xA;&#xA;        if (i+2 &amp;gt;= argc) argerr (&amp;quot;%s requires two arguments\n&amp;quot;, argv[i]);&#xA;        set_name (&amp;amp;m-&amp;gt;output, argv[++i], name_string|name_xid);&#xA;        set_name (&amp;amp;m-&amp;gt;name, argv[++i], name_string|name_xid);&#xA;        m-&amp;gt;action = umode_delete;&#xA;        m-&amp;gt;next = umodes;&#xA;        umodes = m;&#xA;        modeit = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp (&amp;quot;--listproviders&amp;quot;, argv[i]))&#xA;    {&#xA;        list_providers = True;&#xA;        action_requested = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp(&amp;quot;--setprovideroutputsource&amp;quot;, argv[i]))&#xA;    { &#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        set_name (&amp;amp;provider_name, argv[i], name_string|name_xid|name_index);&#xA;        if (++i&amp;gt;=argc) &#xA;        set_name_xid (&amp;amp;output_source_provider_name, 0);&#xA;        else&#xA;        set_name (&amp;amp;output_source_provider_name, argv[i], name_string|name_xid|name_index);&#xA;        action_requested = True;&#xA;        provsetoutsource = True;&#xA;        continue;&#xA;    }&#xA;    if (!strcmp(&amp;quot;--setprovideroffloadsink&amp;quot;, argv[i]))&#xA;    { &#xA;        if (++i &amp;gt;= argc) argerr (&amp;quot;%s requires an argument\n&amp;quot;, argv[i-1]);&#xA;        set_name (&amp;amp;provider_name, argv[i], name_string|name_xid|name_index);&#xA;        if (++i&amp;gt;=argc) &#xA;        set_name_xid (&amp;amp;offload_sink_provider_name, 0);&#xA;        else&#xA;        set_name (&amp;amp;offload_sink_provider_name, argv[i], name_string|name_xid|name_index);&#xA;        action_requested = True;&#xA;        provsetoffsink = True;&#xA;        continue;&#xA;    }&#xA;&#xA;    argerr (&amp;quot;unrecognized option &#39;%s&#39;\n&amp;quot;, argv[i]);&#xA;    }&#xA;    if (!action_requested)&#xA;        query = True;&#xA;    if (verbose) &#xA;    {&#xA;    query = True;&#xA;    if (setit &amp;amp;&amp;amp; !setit_1_2)&#xA;        query_1 = True;&#xA;    }&#xA;    if (version)&#xA;    printf(&amp;quot;xrandr program version       &amp;quot; VERSION &amp;quot;\n&amp;quot;);&#xA;&#xA;    dpy = XOpenDisplay (display_name);&#xA;&#xA;    if (dpy == NULL) {&#xA;    fprintf (stderr, &amp;quot;Can&#39;t open display %s\n&amp;quot;, XDisplayName(display_name));&#xA;    exit (1);&#xA;    }&#xA;    if (screen &amp;lt; 0)&#xA;    screen = DefaultScreen (dpy);&#xA;    if (screen &amp;gt;= ScreenCount (dpy)) {&#xA;    fprintf (stderr, &amp;quot;Invalid screen number %d (display has %d)\n&amp;quot;,&#xA;         screen, ScreenCount (dpy));&#xA;    exit (1);&#xA;    }&#xA;&#xA;    root = RootWindow (dpy, screen);&#xA;&#xA;    if (!XRRQueryExtension (dpy, &amp;amp;event_base, &amp;amp;error_base) ||&#xA;    !XRRQueryVersion (dpy, &amp;amp;major, &amp;amp;minor))&#xA;    {&#xA;    fprintf (stderr, &amp;quot;RandR extension missing\n&amp;quot;);&#xA;    exit (1);&#xA;    }&#xA;    if (major &amp;gt; 1 || (major == 1 &amp;amp;&amp;amp; minor &amp;gt;= 2))&#xA;    has_1_2 = True;&#xA;    if (major &amp;gt; 1 || (major == 1 &amp;amp;&amp;amp; minor &amp;gt;= 3))&#xA;    has_1_3 = True;&#xA;    if (major &amp;gt; 1 || (major == 1 &amp;amp;&amp;amp; minor &amp;gt;= 4))&#xA;    has_1_4 = True;&#xA;&#xA;    if (has_1_2 &amp;amp;&amp;amp; modeit)&#xA;    {&#xA;    umode_t *m;&#xA;&#xA;    get_screen (current);&#xA;    get_crtcs();&#xA;    get_outputs();&#xA;&#xA;    for (m = umodes; m; m = m-&amp;gt;next)&#xA;    {&#xA;        XRRModeInfo *e;&#xA;        output_t    *o;&#xA;&#xA;        switch (m-&amp;gt;action) {&#xA;        case umode_create:&#xA;        XRRCreateMode (dpy, root, &amp;amp;m-&amp;gt;mode);&#xA;        break;&#xA;        case umode_destroy:&#xA;        e = find_mode (&amp;amp;m-&amp;gt;name, 0);&#xA;        if (!e)&#xA;            fatal (&amp;quot;cannot find mode \&amp;quot;%s\&amp;quot;\n&amp;quot;, m-&amp;gt;name.string);&#xA;        XRRDestroyMode (dpy, e-&amp;gt;id);&#xA;        break;&#xA;        case umode_add:&#xA;        o = find_output (&amp;amp;m-&amp;gt;output);&#xA;        if (!o)&#xA;            fatal (&amp;quot;cannot find output \&amp;quot;%s\&amp;quot;\n&amp;quot;, m-&amp;gt;output.string);&#xA;        e = find_mode (&amp;amp;m-&amp;gt;name, 0);&#xA;        if (!e)&#xA;            fatal (&amp;quot;cannot find mode \&amp;quot;%s\&amp;quot;\n&amp;quot;, m-&amp;gt;name.string);&#xA;        XRRAddOutputMode (dpy, o-&amp;gt;output.xid, e-&amp;gt;id);&#xA;        break;&#xA;        case umode_delete:&#xA;        o = find_output (&amp;amp;m-&amp;gt;output);&#xA;        if (!o)&#xA;            fatal (&amp;quot;cannot find output \&amp;quot;%s\&amp;quot;\n&amp;quot;, m-&amp;gt;output.string);&#xA;        e = find_mode (&amp;amp;m-&amp;gt;name, 0);&#xA;        if (!e)&#xA;            fatal (&amp;quot;cannot find mode \&amp;quot;%s\&amp;quot;\n&amp;quot;, m-&amp;gt;name.string);&#xA;        XRRDeleteOutputMode (dpy, o-&amp;gt;output.xid, e-&amp;gt;id);&#xA;        break;&#xA;        }&#xA;    }&#xA;    if (!setit_1_2)&#xA;    {&#xA;        XSync (dpy, False);&#xA;        exit (0);&#xA;    }&#xA;    }&#xA;    if (has_1_2 &amp;amp;&amp;amp; propit)&#xA;    {&#xA;    output_t *output;&#xA;&#xA;    get_screen (current);&#xA;    get_crtcs();&#xA;    get_outputs();&#xA;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;        output_prop_t   *prop;&#xA;&#xA;        for (prop = output-&amp;gt;props; prop; prop = prop-&amp;gt;next)&#xA;        {&#xA;        Atom        name = XInternAtom (dpy, prop-&amp;gt;name, False);&#xA;        Atom        type;&#xA;        int     format = 0;&#xA;        unsigned char   *data, *malloced_data = NULL;&#xA;        int     nelements;&#xA;        int     int_value;&#xA;        unsigned long   ulong_value;&#xA;        unsigned char   *prop_data;&#xA;        int     actual_format;&#xA;        unsigned long   nitems, bytes_after;&#xA;        Atom        actual_type;&#xA;        XRRPropertyInfo *propinfo;&#xA;&#xA;        type = AnyPropertyType;&#xA;&#xA;        if (XRRGetOutputProperty (dpy, output-&amp;gt;output.xid, name,&#xA;                      0, 100, False, False,&#xA;                      AnyPropertyType,&#xA;                      &amp;amp;actual_type, &amp;amp;actual_format,&#xA;                      &amp;amp;nitems, &amp;amp;bytes_after, &amp;amp;prop_data) == Success &amp;amp;&amp;amp;&#xA;&#xA;            (propinfo = XRRQueryOutputProperty(dpy, output-&amp;gt;output.xid,&#xA;                              name)))&#xA;        {&#xA;            type = actual_type;&#xA;            format = actual_format;&#xA;        }&#xA;&#xA;        malloced_data = property_values_from_string&#xA;            (prop-&amp;gt;value, type, actual_format, &amp;amp;nelements);&#xA;&#xA;        if (malloced_data)&#xA;        {&#xA;            data = malloced_data;&#xA;            type = actual_type;&#xA;            format = actual_format;&#xA;        }&#xA;        else if (type == AnyPropertyType &amp;amp;&amp;amp;&#xA;            (sscanf (prop-&amp;gt;value, &amp;quot;%d&amp;quot;, &amp;amp;int_value) == 1 ||&#xA;             sscanf (prop-&amp;gt;value, &amp;quot;0x%x&amp;quot;, &amp;amp;int_value) == 1))&#xA;        {&#xA;            type = XA_INTEGER;&#xA;            ulong_value = int_value;&#xA;            data = (unsigned char *) &amp;amp;ulong_value;&#xA;            nelements = 1;&#xA;            format = 32;&#xA;        }&#xA;        else if (type == XA_ATOM)&#xA;        {&#xA;            ulong_value = XInternAtom (dpy, prop-&amp;gt;value, False);&#xA;            data = (unsigned char *) &amp;amp;ulong_value;&#xA;            nelements = 1;&#xA;        }&#xA;        else if (type == XA_STRING || type == AnyPropertyType)&#xA;        {&#xA;            type = XA_STRING;&#xA;            data = (unsigned char *) prop-&amp;gt;value;&#xA;            nelements = strlen (prop-&amp;gt;value);&#xA;            format = 8;&#xA;        }&#xA;        else&#xA;            continue;&#xA;        XRRChangeOutputProperty (dpy, output-&amp;gt;output.xid,&#xA;                     name, type, format, PropModeReplace,&#xA;                     data, nelements);&#xA;        free (malloced_data);&#xA;        }&#xA;    }&#xA;    if (!setit_1_2)&#xA;    {&#xA;        XSync (dpy, False);&#xA;        exit (0);&#xA;    }&#xA;    }&#xA;    if (provsetoutsource)&#xA;    {&#xA;    provider_t *provider, *source;&#xA;&#xA;    if (!has_1_4)&#xA;        fatal (&amp;quot;--setprovideroutputsource requires RandR 1.4\n&amp;quot;);&#xA;&#xA;    get_screen (current);&#xA;    get_providers ();&#xA;&#xA;    provider = find_provider (&amp;amp;provider_name);&#xA;    source = find_provider(&amp;amp;output_source_provider_name);&#xA;&#xA;    XRRSetProviderOutputSource(dpy, provider-&amp;gt;provider.xid, source ? source-&amp;gt;provider.xid : 0);&#xA;    }&#xA;    if (provsetoffsink)&#xA;    {&#xA;    provider_t *provider, *sink;&#xA;&#xA;    if (!has_1_4)&#xA;        fatal (&amp;quot;--setprovideroffloadsink requires RandR 1.4\n&amp;quot;);&#xA;&#xA;    get_screen (current);&#xA;    get_providers ();&#xA;&#xA;    provider = find_provider (&amp;amp;provider_name);&#xA;    sink = find_provider(&amp;amp;offload_sink_provider_name);&#xA;&#xA;    XRRSetProviderOffloadSink(dpy, provider-&amp;gt;provider.xid, sink ? sink-&amp;gt;provider.xid : 0);&#xA;    }&#xA;    if (setit_1_2)&#xA;    {&#xA;    get_screen (current);&#xA;    get_crtcs ();&#xA;    get_outputs ();&#xA;    set_positions ();&#xA;    set_screen_size ();&#xA;&#xA;    pick_crtcs ();&#xA;&#xA;    /*&#xA;     * Assign outputs to crtcs&#xA;     */&#xA;    set_crtcs ();&#xA;&#xA;    /*&#xA;     * Mark changing crtcs&#xA;     */&#xA;    mark_changing_crtcs ();&#xA;&#xA;    /*&#xA;     * If an output was specified to track dpi, use it&#xA;     */&#xA;    if (dpi_output_name)&#xA;    {&#xA;        output_t    *dpi_output = find_output_by_name (dpi_output_name);&#xA;        XRROutputInfo   *output_info;&#xA;        XRRModeInfo *mode_info;&#xA;        if (!dpi_output)&#xA;        fatal (&amp;quot;Cannot find output %s\n&amp;quot;, dpi_output_name);&#xA;        output_info = dpi_output-&amp;gt;output_info;&#xA;        mode_info = dpi_output-&amp;gt;mode_info;&#xA;        if (output_info &amp;amp;&amp;amp; mode_info &amp;amp;&amp;amp; output_info-&amp;gt;mm_height)&#xA;        {&#xA;        /*&#xA;         * When this output covers the whole screen, just use&#xA;         * the known physical size&#xA;         */&#xA;        if (fb_width == mode_info-&amp;gt;width &amp;amp;&amp;amp;&#xA;            fb_height == mode_info-&amp;gt;height)&#xA;        {&#xA;            fb_width_mm = output_info-&amp;gt;mm_width;&#xA;            fb_height_mm = output_info-&amp;gt;mm_height;&#xA;        }&#xA;        else&#xA;        {&#xA;            dpi = (25.4 * mode_info-&amp;gt;height) / output_info-&amp;gt;mm_height;&#xA;        }&#xA;        }&#xA;    }&#xA;&#xA;    /*&#xA;     * Compute physical screen size&#xA;     */&#xA;    if (fb_width_mm == 0 || fb_height_mm == 0)&#xA;    {&#xA;        if (fb_width != DisplayWidth (dpy, screen) ||&#xA;        fb_height != DisplayHeight (dpy, screen) || dpi != 0.0)&#xA;        {&#xA;        if (dpi &amp;lt;= 0)&#xA;            dpi = (25.4 * DisplayHeight (dpy, screen)) / DisplayHeightMM(dpy, screen);&#xA;&#xA;        fb_width_mm = (25.4 * fb_width) / dpi;&#xA;        fb_height_mm = (25.4 * fb_height) / dpi;&#xA;        }&#xA;        else&#xA;        {&#xA;        fb_width_mm = DisplayWidthMM (dpy, screen);&#xA;        fb_height_mm = DisplayHeightMM (dpy, screen);&#xA;        }&#xA;    }&#xA;&#xA;    /*&#xA;     * Set panning&#xA;     */&#xA;    set_panning ();&#xA;&#xA;    /* &#xA;     * Set gamma on crtc&#39;s that belong to the outputs.&#xA;     */&#xA;    set_gamma ();&#xA;&#xA;    /*&#xA;     * Now apply all of the changes&#xA;     */&#xA;    apply ();&#xA;&#xA;    XSync (dpy, False);&#xA;    exit (0);&#xA;    }&#xA;    if (query_1_2 || (query &amp;amp;&amp;amp; has_1_2 &amp;amp;&amp;amp; !query_1))&#xA;    {&#xA;    output_t    *output;&#xA;    int     m;&#xA;&#xA;#define ModeShown   0x80000000&#xA;&#xA;    get_screen (current);&#xA;    get_crtcs ();&#xA;    get_outputs ();&#xA;&#xA;    printf (&amp;quot;Screen %d: minimum %d x %d, current %d x %d, maximum %d x %d\n&amp;quot;,&#xA;        screen, minWidth, minHeight,&#xA;        DisplayWidth (dpy, screen), DisplayHeight(dpy, screen),&#xA;        maxWidth, maxHeight);&#xA;&#xA;    for (output = all_outputs; output; output = output-&amp;gt;next)&#xA;    {&#xA;        XRROutputInfo   *output_info = output-&amp;gt;output_info;&#xA;        crtc_t      *cur_crtc = output-&amp;gt;crtc_info;&#xA;        XRRCrtcInfo     *crtc_info = cur_crtc ? cur_crtc-&amp;gt;crtc_info : NULL;&#xA;        XRRModeInfo     *cur_mode = output-&amp;gt;mode_info;&#xA;        Atom        *props;&#xA;        int         j, nprop;&#xA;        Bool        *mode_shown;&#xA;        Rotation        rotations = output_rotations (output);&#xA;&#xA;        printf (&amp;quot;%s %s&amp;quot;, output_info-&amp;gt;name, connection[output_info-&amp;gt;connection]);&#xA;        if (output-&amp;gt;primary) {&#xA;        printf(&amp;quot; primary&amp;quot;);&#xA;        }&#xA;        if (cur_mode)&#xA;        {&#xA;        if (crtc_info) {&#xA;            printf (&amp;quot; %dx%d+%d+%d&amp;quot;,&#xA;                crtc_info-&amp;gt;width, crtc_info-&amp;gt;height,&#xA;                crtc_info-&amp;gt;x, crtc_info-&amp;gt;y);&#xA;        } else {&#xA;            printf (&amp;quot; %dx%d+%d+%d&amp;quot;,&#xA;                cur_mode-&amp;gt;width, cur_mode-&amp;gt;height, output-&amp;gt;x,&#xA;                output-&amp;gt;y);&#xA;        }&#xA;        if (verbose)&#xA;            printf (&amp;quot; (0x%x)&amp;quot;, (int)cur_mode-&amp;gt;id);&#xA;        if (output-&amp;gt;rotation != RR_Rotate_0 || verbose)&#xA;        {&#xA;            printf (&amp;quot; %s&amp;quot;, &#xA;                rotation_name (output-&amp;gt;rotation));&#xA;            if (output-&amp;gt;rotation &amp;amp; (RR_Reflect_X|RR_Reflect_Y))&#xA;            printf (&amp;quot; %s&amp;quot;, reflection_name (output-&amp;gt;rotation));&#xA;        }&#xA;        }&#xA;        if (rotations != RR_Rotate_0 || verbose)&#xA;        {&#xA;        Bool    first = True;&#xA;        printf (&amp;quot; (&amp;quot;);&#xA;        for (i = 0; i &amp;lt; 4; i ++) {&#xA;            if ((rotations &amp;gt;&amp;gt; i) &amp;amp; 1) {&#xA;            if (!first) printf (&amp;quot; &amp;quot;); first = False;&#xA;            printf(&amp;quot;%s&amp;quot;, direction[i]);&#xA;            }&#xA;        }&#xA;        if (rotations &amp;amp; RR_Reflect_X)&#xA;        {&#xA;            if (!first) printf (&amp;quot; &amp;quot;); first = False;&#xA;            printf (&amp;quot;x axis&amp;quot;);&#xA;        }&#xA;        if (rotations &amp;amp; RR_Reflect_Y)&#xA;        {&#xA;            if (!first) printf (&amp;quot; &amp;quot;);&#xA;            printf (&amp;quot;y axis&amp;quot;);&#xA;        }&#xA;        printf (&amp;quot;)&amp;quot;);&#xA;        }&#xA;&#xA;        if (cur_mode)&#xA;        {&#xA;        printf (&amp;quot; %dmm x %dmm&amp;quot;,&#xA;            (int)output_info-&amp;gt;mm_width, (int)output_info-&amp;gt;mm_height);&#xA;        }&#xA;&#xA;        if (cur_crtc &amp;amp;&amp;amp; cur_crtc-&amp;gt;panning_info &amp;amp;&amp;amp;&#xA;        cur_crtc-&amp;gt;panning_info-&amp;gt;width &amp;gt; 0)&#xA;        {&#xA;        XRRPanning *pan = cur_crtc-&amp;gt;panning_info;&#xA;        printf (&amp;quot; panning %dx%d+%d+%d&amp;quot;,&#xA;            pan-&amp;gt;width, pan-&amp;gt;height, pan-&amp;gt;left, pan-&amp;gt;top);&#xA;        if ((pan-&amp;gt;track_width    != 0 &amp;amp;&amp;amp;&#xA;             (pan-&amp;gt;track_left    != pan-&amp;gt;left       ||&#xA;              pan-&amp;gt;track_width   != pan-&amp;gt;width      ||&#xA;              pan-&amp;gt;border_left   != 0           ||&#xA;              pan-&amp;gt;border_right  != 0))         ||&#xA;            (pan-&amp;gt;track_height   != 0 &amp;amp;&amp;amp;&#xA;             (pan-&amp;gt;track_top     != pan-&amp;gt;top        ||&#xA;              pan-&amp;gt;track_height  != pan-&amp;gt;height     ||&#xA;              pan-&amp;gt;border_top    != 0           ||&#xA;              pan-&amp;gt;border_bottom != 0)))&#xA;            printf (&amp;quot; tracking %dx%d+%d+%d border %d/%d/%d/%d&amp;quot;,&#xA;                pan-&amp;gt;track_width,  pan-&amp;gt;track_height,&#xA;                pan-&amp;gt;track_left,   pan-&amp;gt;track_top,&#xA;                pan-&amp;gt;border_left,  pan-&amp;gt;border_top,&#xA;                pan-&amp;gt;border_right, pan-&amp;gt;border_bottom);&#xA;        }&#xA;        printf (&amp;quot;\n&amp;quot;);&#xA;&#xA;        if (verbose)&#xA;        {&#xA;        printf (&amp;quot;\tIdentifier: 0x%x\n&amp;quot;, (int)output-&amp;gt;output.xid);&#xA;        printf (&amp;quot;\tTimestamp:  %d\n&amp;quot;, (int)output_info-&amp;gt;timestamp);&#xA;        printf (&amp;quot;\tSubpixel:   %s\n&amp;quot;, order[output_info-&amp;gt;subpixel_order]);&#xA;        if (output-&amp;gt;gamma.red != 0.0 &amp;amp;&amp;amp; output-&amp;gt;gamma.green != 0.0 &amp;amp;&amp;amp; output-&amp;gt;gamma.blue != 0.0) {&#xA;            printf (&amp;quot;\tGamma:      %#.2g:%#.2g:%#.2g\n&amp;quot;,&#xA;                output-&amp;gt;gamma.red, output-&amp;gt;gamma.green, output-&amp;gt;gamma.blue);&#xA;            printf (&amp;quot;\tBrightness: %#.2g\n&amp;quot;, output-&amp;gt;brightness);&#xA;        }&#xA;        printf (&amp;quot;\tClones:    &amp;quot;);&#xA;        for (j = 0; j &amp;lt; output_info-&amp;gt;nclone; j++)&#xA;        {&#xA;            output_t    *clone = find_output_by_xid (output_info-&amp;gt;clones[j]);&#xA;&#xA;            if (clone) printf (&amp;quot; %s&amp;quot;, clone-&amp;gt;output.string);&#xA;        }&#xA;        printf (&amp;quot;\n&amp;quot;);&#xA;        if (output-&amp;gt;crtc_info)&#xA;            printf (&amp;quot;\tCRTC:       %d\n&amp;quot;, output-&amp;gt;crtc_info-&amp;gt;crtc.index);&#xA;        printf (&amp;quot;\tCRTCs:     &amp;quot;);&#xA;        for (j = 0; j &amp;lt; output_info-&amp;gt;ncrtc; j++)&#xA;        {&#xA;            crtc_t  *crtc = find_crtc_by_xid (output_info-&amp;gt;crtcs[j]);&#xA;            if (crtc)&#xA;            printf (&amp;quot; %d&amp;quot;, crtc-&amp;gt;crtc.index);&#xA;        }&#xA;        printf (&amp;quot;\n&amp;quot;);&#xA;        if (output-&amp;gt;crtc_info &amp;amp;&amp;amp; output-&amp;gt;crtc_info-&amp;gt;panning_info) {&#xA;            XRRPanning *pan = output-&amp;gt;crtc_info-&amp;gt;panning_info;&#xA;            printf (&amp;quot;\tPanning:    %dx%d+%d+%d\n&amp;quot;,&#xA;                pan-&amp;gt;width, pan-&amp;gt;height, pan-&amp;gt;left, pan-&amp;gt;top);&#xA;            printf (&amp;quot;\tTracking:   %dx%d+%d+%d\n&amp;quot;,&#xA;                pan-&amp;gt;track_width,  pan-&amp;gt;track_height,&#xA;                pan-&amp;gt;track_left,   pan-&amp;gt;track_top);&#xA;            printf (&amp;quot;\tBorder:     %d/%d/%d/%d\n&amp;quot;,&#xA;                pan-&amp;gt;border_left,  pan-&amp;gt;border_top,&#xA;                pan-&amp;gt;border_right, pan-&amp;gt;border_bottom);&#xA;        }&#xA;        }&#xA;        if (verbose)&#xA;        {&#xA;        int x, y;&#xA;&#xA;        printf (&amp;quot;\tTransform: &amp;quot;);&#xA;        for (y = 0; y &amp;lt; 3; y++)&#xA;        {&#xA;            for (x = 0; x &amp;lt; 3; x++)&#xA;            printf (&amp;quot; %f&amp;quot;, XFixedToDouble (output-&amp;gt;transform.transform.matrix[y][x]));&#xA;            if (y &amp;lt; 2)&#xA;            printf (&amp;quot;\n\t           &amp;quot;);&#xA;        }&#xA;        if (output-&amp;gt;transform.filter)&#xA;            printf (&amp;quot;\n\t           filter: %s&amp;quot;, output-&amp;gt;transform.filter);&#xA;        printf (&amp;quot;\n&amp;quot;);&#xA;        }&#xA;        if (verbose || properties)&#xA;        {&#xA;        props = XRRListOutputProperties (dpy, output-&amp;gt;output.xid,&#xA;                         &amp;amp;nprop);&#xA;        for (j = 0; j &amp;lt; nprop; j++) {&#xA;            unsigned char *prop;&#xA;            int actual_format;&#xA;            unsigned long nitems, bytes_after;&#xA;            Atom actual_type;&#xA;            XRRPropertyInfo *propinfo;&#xA;            char *atom_name = XGetAtomName (dpy, props[j]);&#xA;            int k;&#xA;&#xA;            XRRGetOutputProperty (dpy, output-&amp;gt;output.xid, props[j],&#xA;                      0, 100, False, False,&#xA;                      AnyPropertyType,&#xA;                      &amp;amp;actual_type, &amp;amp;actual_format,&#xA;                      &amp;amp;nitems, &amp;amp;bytes_after, &amp;amp;prop);&#xA;&#xA;            propinfo = XRRQueryOutputProperty(dpy, output-&amp;gt;output.xid,&#xA;                              props[j]);&#xA;&#xA;            printf (&amp;quot;\t%s: &amp;quot;, atom_name);&#xA;&#xA;            print_output_property(atom_name, actual_format,&#xA;                      actual_type, nitems, prop);&#xA;&#xA;            if (propinfo-&amp;gt;range &amp;amp;&amp;amp; propinfo-&amp;gt;num_values &amp;gt; 0)&#xA;            {&#xA;            printf (&amp;quot;\t\trange%s: &amp;quot;,&#xA;                (propinfo-&amp;gt;num_values == 2) ? &amp;quot;&amp;quot; : &amp;quot;s&amp;quot;);&#xA;            for (k = 0; k &amp;lt; propinfo-&amp;gt;num_values / 2; k++)&#xA;            {&#xA;                printf (&amp;quot;(&amp;quot;);&#xA;                print_output_property_value (32, actual_type,&#xA;                             (unsigned char *) &amp;amp;(propinfo-&amp;gt;values[k * 2]));&#xA;                printf (&amp;quot;, &amp;quot;);&#xA;                print_output_property_value (32, actual_type,&#xA;                             (unsigned char *) &amp;amp;(propinfo-&amp;gt;values[k * 2 + 1]));&#xA;                printf (&amp;quot;)&amp;quot;);&#xA;                if (k &amp;lt; propinfo-&amp;gt;num_values / 2 - 1)&#xA;                printf (&amp;quot;, &amp;quot;);&#xA;            }&#xA;            printf (&amp;quot;\n&amp;quot;);&#xA;            }&#xA;            if (!propinfo-&amp;gt;range &amp;amp;&amp;amp; propinfo-&amp;gt;num_values &amp;gt; 0)&#xA;            {&#xA;            printf (&amp;quot;\t\tsupported: &amp;quot;);&#xA;            for (k = 0; k &amp;lt; propinfo-&amp;gt;num_values; k++)&#xA;            {&#xA;                print_output_property_value (32, actual_type,&#xA;                             (unsigned char *) &amp;amp;(propinfo-&amp;gt;values[k]));&#xA;                if (k &amp;lt; propinfo-&amp;gt;num_values - 1)&#xA;                printf (&amp;quot;, &amp;quot;);&#xA;            }&#xA;            printf (&amp;quot;\n&amp;quot;);&#xA;            }&#xA;&#xA;            free(propinfo);&#xA;        }&#xA;        }&#xA;&#xA;        if (verbose)&#xA;        {&#xA;        for (j = 0; j &amp;lt; output_info-&amp;gt;nmode; j++)&#xA;        {&#xA;            XRRModeInfo *mode = find_mode_by_xid (output_info-&amp;gt;modes[j]);&#xA;            int     f;&#xA;&#xA;            printf (&amp;quot;  %s (0x%x) %6.3fMHz&amp;quot;,&#xA;                mode-&amp;gt;name, (int)mode-&amp;gt;id,&#xA;                (double)mode-&amp;gt;dotClock / 1000000.0);&#xA;            for (f = 0; mode_flags[f].flag; f++)&#xA;            if (mode-&amp;gt;modeFlags &amp;amp; mode_flags[f].flag)&#xA;                printf (&amp;quot; %s&amp;quot;, mode_flags[f].string);&#xA;            if (mode == output-&amp;gt;mode_info)&#xA;            printf (&amp;quot; *current&amp;quot;);&#xA;            if (j &amp;lt; output_info-&amp;gt;npreferred)&#xA;            printf (&amp;quot; +preferred&amp;quot;);&#xA;            printf (&amp;quot;\n&amp;quot;);&#xA;            printf (&amp;quot;        h: width  %4d start %4d end %4d total %4d skew %4d clock %6.2fKHz\n&amp;quot;,&#xA;                mode-&amp;gt;width, mode-&amp;gt;hSyncStart, mode-&amp;gt;hSyncEnd,&#xA;                mode-&amp;gt;hTotal, mode-&amp;gt;hSkew, mode_hsync (mode) / 1000);&#xA;            printf (&amp;quot;        v: height %4d start %4d end %4d total %4d           clock %6.2fHz\n&amp;quot;,&#xA;                mode-&amp;gt;height, mode-&amp;gt;vSyncStart, mode-&amp;gt;vSyncEnd, mode-&amp;gt;vTotal,&#xA;                mode_refresh (mode));&#xA;            mode-&amp;gt;modeFlags |= ModeShown;&#xA;        }&#xA;        }&#xA;        else&#xA;        {&#xA;        mode_shown = calloc (output_info-&amp;gt;nmode, sizeof (Bool));&#xA;        if (!mode_shown) fatal (&amp;quot;out of memory\n&amp;quot;);&#xA;        for (j = 0; j &amp;lt; output_info-&amp;gt;nmode; j++)&#xA;        {&#xA;            XRRModeInfo *jmode, *kmode;&#xA;            int k;&#xA;&#xA;            if (mode_shown[j]) continue;&#xA;&#xA;            jmode = find_mode_by_xid (output_info-&amp;gt;modes[j]);&#xA;            printf (&amp;quot; &amp;quot;);&#xA;            printf (&amp;quot;  %-12s&amp;quot;, jmode-&amp;gt;name);&#xA;            for (k = j; k &amp;lt; output_info-&amp;gt;nmode; k++)&#xA;            {&#xA;            if (mode_shown[k]) continue;&#xA;            kmode = find_mode_by_xid (output_info-&amp;gt;modes[k]);&#xA;            if (strcmp (jmode-&amp;gt;name, kmode-&amp;gt;name) != 0) continue;&#xA;            mode_shown[k] = True;&#xA;            kmode-&amp;gt;modeFlags |= ModeShown;&#xA;            printf (&amp;quot; %6.2f&amp;quot;, mode_refresh (kmode));&#xA;            if (kmode == output-&amp;gt;mode_info)&#xA;                printf (&amp;quot;*&amp;quot;);&#xA;            else&#xA;                printf (&amp;quot; &amp;quot;);&#xA;            if (k &amp;lt; output_info-&amp;gt;npreferred)&#xA;                printf (&amp;quot;+&amp;quot;);&#xA;            else&#xA;                printf (&amp;quot; &amp;quot;);&#xA;            }&#xA;            printf (&amp;quot;\n&amp;quot;);&#xA;        }&#xA;        free (mode_shown);&#xA;        }&#xA;    }&#xA;    for (m = 0; m &amp;lt; res-&amp;gt;nmode; m++)&#xA;    {&#xA;        XRRModeInfo *mode = &amp;amp;res-&amp;gt;modes[m];&#xA;&#xA;        if (!(mode-&amp;gt;modeFlags &amp;amp; ModeShown))&#xA;        {&#xA;        printf (&amp;quot;  %s (0x%x) %6.3fMHz\n&amp;quot;,&#xA;            mode-&amp;gt;name, (int)mode-&amp;gt;id,&#xA;            (double)mode-&amp;gt;dotClock / 1000000.0);&#xA;        printf (&amp;quot;        h: width  %4d start %4d end %4d total %4d skew %4d clock %6.2fKHz\n&amp;quot;,&#xA;            mode-&amp;gt;width, mode-&amp;gt;hSyncStart, mode-&amp;gt;hSyncEnd,&#xA;            mode-&amp;gt;hTotal, mode-&amp;gt;hSkew, mode_hsync (mode) / 1000);&#xA;        printf (&amp;quot;        v: height %4d start %4d end %4d total %4d           clock %6.2fHz\n&amp;quot;,&#xA;            mode-&amp;gt;height, mode-&amp;gt;vSyncStart, mode-&amp;gt;vSyncEnd, mode-&amp;gt;vTotal,&#xA;            mode_refresh (mode));&#xA;        }&#xA;    }&#xA;    exit (0);&#xA;    }&#xA;    if (list_providers) {&#xA;    int k;&#xA;&#xA;    if (!has_1_4) {&#xA;        printf (&amp;quot;RandR 1.4 not supported\n&amp;quot;);&#xA;        exit (0);&#xA;    }&#xA;&#xA;    get_screen (current);&#xA;    get_providers ();&#xA;&#xA;    if (providers) {&#xA;        int j;&#xA;&#xA;        printf(&amp;quot;Providers: number : %d\n&amp;quot;, num_providers);&#xA;&#xA;        for (j = 0; j &amp;lt; num_providers; j++) {&#xA;        provider_t *provider = &amp;amp;providers[j];&#xA;        XRRProviderInfo *info = provider-&amp;gt;info;&#xA;&#xA;        printf(&amp;quot;Provider %d: id: 0x%x cap: 0x%x&amp;quot;, j, (int)provider-&amp;gt;provider.xid, info-&amp;gt;capabilities);&#xA;        for (k = 0; k &amp;lt; 4; k++)&#xA;            if (info-&amp;gt;capabilities &amp;amp; (1 &amp;lt;&amp;lt; k))&#xA;                printf(&amp;quot;, %s&amp;quot;, capability_name(1&amp;lt;&amp;lt;k));&#xA;&#xA;        printf(&amp;quot; crtcs: %d outputs: %d associated providers: %d name:%s\n&amp;quot;, info-&amp;gt;ncrtcs, info-&amp;gt;noutputs, info-&amp;gt;nassociatedproviders, info-&amp;gt;name);&#xA;        }&#xA;    }&#xA;    }&#xA;&#xA;    sc = XRRGetScreenInfo (dpy, root);&#xA;&#xA;    if (sc == NULL) &#xA;    exit (1);&#xA;&#xA;    current_size = XRRConfigCurrentConfiguration (sc, &amp;amp;current_rotation);&#xA;&#xA;    sizes = XRRConfigSizes(sc, &amp;amp;nsize);&#xA;&#xA;    if (have_pixel_size) {&#xA;    for (size = 0; size &amp;lt; nsize; size++)&#xA;    {&#xA;        if (sizes[size].width == width &amp;amp;&amp;amp; sizes[size].height == height)&#xA;        break;&#xA;    }&#xA;    if (size &amp;gt;= nsize) {&#xA;        fprintf (stderr,&#xA;             &amp;quot;Size %dx%d not found in available modes\n&amp;quot;, width, height);&#xA;        exit (1);&#xA;    }&#xA;    }&#xA;    else if (size &amp;lt; 0)&#xA;    size = current_size;&#xA;    else if (size &amp;gt;= nsize) {&#xA;    fprintf (stderr,&#xA;         &amp;quot;Size index %d is too large, there are only %d sizes\n&amp;quot;,&#xA;         size, nsize);&#xA;    exit (1);&#xA;    }&#xA;&#xA;    if (rot &amp;lt; 0)&#xA;    {&#xA;    for (rot = 0; rot &amp;lt; 4; rot++)&#xA;        if (1 &amp;lt;&amp;lt; rot == (current_rotation &amp;amp; 0xf))&#xA;        break;&#xA;    }&#xA;&#xA;    current_rate = XRRConfigCurrentRate (sc);&#xA;&#xA;    if (rate &amp;lt; 0)&#xA;    {&#xA;    if (size == current_size)&#xA;        rate = current_rate;&#xA;    else&#xA;        rate = 0;&#xA;    }&#xA;    else&#xA;    {&#xA;    rates = XRRConfigRates (sc, size, &amp;amp;nrate);&#xA;    for (i = 0; i &amp;lt; nrate; i++)&#xA;        if (rate == rates[i])&#xA;        break;&#xA;    if (i == nrate) {&#xA;        fprintf (stderr, &amp;quot;Rate %.2f Hz not available for this size\n&amp;quot;, rate);&#xA;        exit (1);&#xA;    }&#xA;    }&#xA;&#xA;    if (version) {&#xA;    int major_version, minor_version;&#xA;    XRRQueryVersion (dpy, &amp;amp;major_version, &amp;amp;minor_version);&#xA;    printf(&amp;quot;Server reports RandR version %d.%d\n&amp;quot;, &#xA;           major_version, minor_version);&#xA;    }&#xA;&#xA;    if (query || query_1) {&#xA;    printf(&amp;quot; SZ:    Pixels          Physical       Refresh\n&amp;quot;);&#xA;    for (i = 0; i &amp;lt; nsize; i++) {&#xA;        int j;&#xA;&#xA;        printf (&amp;quot;%c%-2d %5d x %-5d  (%4dmm x%4dmm )&amp;quot;,&#xA;            i == current_size ? &#39;*&#39; : &#39; &#39;,&#xA;            i, sizes[i].width, sizes[i].height,&#xA;            sizes[i].mwidth, sizes[i].mheight);&#xA;        rates = XRRConfigRates (sc, i, &amp;amp;nrate);&#xA;        if (nrate) printf (&amp;quot;  &amp;quot;);&#xA;        for (j = 0; j &amp;lt; nrate; j++)&#xA;        printf (&amp;quot;%c%-4d&amp;quot;,&#xA;            i == current_size &amp;amp;&amp;amp; rates[j] == current_rate ? &#39;*&#39; : &#39; &#39;,&#xA;            rates[j]);&#xA;        printf (&amp;quot;\n&amp;quot;);&#xA;    }&#xA;    }&#xA;&#xA;    {&#xA;    Rotation rotations = XRRConfigRotations(sc, &amp;amp;current_rotation);&#xA;&#xA;    if (toggle_x &amp;amp;&amp;amp; !(current_rotation &amp;amp; RR_Reflect_X)) reflection |= RR_Reflect_X;&#xA;    if (toggle_y &amp;amp;&amp;amp; !(current_rotation &amp;amp; RR_Reflect_Y)) reflection |= RR_Reflect_Y;&#xA;&#xA;    if (query) {&#xA;        printf(&amp;quot;Current rotation - %s\n&amp;quot;,&#xA;           rotation_name (current_rotation));&#xA;&#xA;        printf(&amp;quot;Current reflection - %s\n&amp;quot;,&#xA;           reflection_name (current_rotation));&#xA;&#xA;        printf (&amp;quot;Rotations possible - &amp;quot;);&#xA;        for (i = 0; i &amp;lt; 4; i ++) {&#xA;        if ((rotations &amp;gt;&amp;gt; i) &amp;amp; 1)  printf(&amp;quot;%s &amp;quot;, direction[i]);&#xA;        }&#xA;        printf (&amp;quot;\n&amp;quot;);&#xA;&#xA;        printf (&amp;quot;Reflections possible - &amp;quot;);&#xA;        if (rotations &amp;amp; (RR_Reflect_X|RR_Reflect_Y))&#xA;        {&#xA;        if (rotations &amp;amp; RR_Reflect_X) printf (&amp;quot;X Axis &amp;quot;);&#xA;        if (rotations &amp;amp; RR_Reflect_Y) printf (&amp;quot;Y Axis&amp;quot;);&#xA;        }&#xA;        else&#xA;        printf (&amp;quot;none&amp;quot;);&#xA;        printf (&amp;quot;\n&amp;quot;);&#xA;    }&#xA;    }&#xA;&#xA;    if (verbose) { &#xA;    printf(&amp;quot;Setting size to %d, rotation to %s\n&amp;quot;,  size, direction[rot]);&#xA;&#xA;    printf (&amp;quot;Setting reflection on &amp;quot;);&#xA;    if (reflection)&#xA;    {&#xA;        if (reflection &amp;amp; RR_Reflect_X) printf (&amp;quot;X Axis &amp;quot;);&#xA;        if (reflection &amp;amp; RR_Reflect_Y) printf (&amp;quot;Y Axis&amp;quot;);&#xA;    }&#xA;    else&#xA;        printf (&amp;quot;neither axis&amp;quot;);&#xA;    printf (&amp;quot;\n&amp;quot;);&#xA;    }&#xA;&#xA;    /* we should test configureNotify on the root window */&#xA;    XSelectInput (dpy, root, StructureNotifyMask);&#xA;&#xA;    if (setit &amp;amp;&amp;amp; !dryrun) XRRSelectInput (dpy, root,&#xA;                   RRScreenChangeNotifyMask);&#xA;    if (setit &amp;amp;&amp;amp; !dryrun) {&#xA;    Rotation rotation = 1 &amp;lt;&amp;lt; rot;&#xA;    status = XRRSetScreenConfigAndRate (dpy, sc, root, (SizeID) size,&#xA;                        (Rotation) (rotation | reflection),&#xA;                        rate, CurrentTime);&#xA;    }&#xA;&#xA;    if (setit &amp;amp;&amp;amp; !dryrun &amp;amp;&amp;amp; status == RRSetConfigFailed) {&#xA;    printf (&amp;quot;Failed to change the screen configuration!\n&amp;quot;);&#xA;    ret = 1;&#xA;    }&#xA;&#xA;    if (verbose &amp;amp;&amp;amp; setit &amp;amp;&amp;amp; !dryrun &amp;amp;&amp;amp; size != current_size) {&#xA;    if (status == RRSetConfigSuccess)&#xA;    {&#xA;        Bool    seen_screen = False;&#xA;        while (!seen_screen) {&#xA;        int spo;&#xA;        XNextEvent(dpy, (XEvent *) &amp;amp;event);&#xA;&#xA;        printf (&amp;quot;Event received, type = %d\n&amp;quot;, event.type);&#xA;        /* update Xlib&#39;s knowledge of the event */&#xA;        XRRUpdateConfiguration (&amp;amp;event);&#xA;        if (event.type == ConfigureNotify)&#xA;            printf(&amp;quot;Received ConfigureNotify Event!\n&amp;quot;);&#xA;&#xA;        switch (event.type - event_base) {&#xA;        case RRScreenChangeNotify:&#xA;            sce = (XRRScreenChangeNotifyEvent *) &amp;amp;event;&#xA;&#xA;            printf(&amp;quot;Got a screen change notify event!\n&amp;quot;);&#xA;            printf(&amp;quot; window = %d\n root = %d\n size_index = %d\n rotation %d\n&amp;quot;, &#xA;               (int) sce-&amp;gt;window, (int) sce-&amp;gt;root, &#xA;               sce-&amp;gt;size_index,  sce-&amp;gt;rotation);&#xA;            printf(&amp;quot; timestamp = %ld, config_timestamp = %ld\n&amp;quot;,&#xA;               sce-&amp;gt;timestamp, sce-&amp;gt;config_timestamp);&#xA;            printf(&amp;quot; Rotation = %x\n&amp;quot;, sce-&amp;gt;rotation);&#xA;            printf(&amp;quot; %d X %d pixels, %d X %d mm\n&amp;quot;,&#xA;               sce-&amp;gt;width, sce-&amp;gt;height, sce-&amp;gt;mwidth, sce-&amp;gt;mheight);&#xA;            printf(&amp;quot;Display width   %d, height   %d\n&amp;quot;,&#xA;               DisplayWidth(dpy, screen), DisplayHeight(dpy, screen));&#xA;            printf(&amp;quot;Display widthmm %d, heightmm %d\n&amp;quot;, &#xA;               DisplayWidthMM(dpy, screen), DisplayHeightMM(dpy, screen));&#xA;            spo = sce-&amp;gt;subpixel_order;&#xA;            if ((spo &amp;lt; 0) || (spo &amp;gt; 5))&#xA;            printf (&amp;quot;Unknown subpixel order, value = %d\n&amp;quot;, spo);&#xA;            else printf (&amp;quot;new Subpixel rendering model is %s\n&amp;quot;, order[spo]);&#xA;            seen_screen = True;&#xA;            break;&#xA;        default:&#xA;            if (event.type != ConfigureNotify) &#xA;            printf(&amp;quot;unknown event received, type = %d!\n&amp;quot;, event.type);&#xA;        }&#xA;        }&#xA;    }&#xA;    }&#xA;    XRRFreeScreenConfigInfo(sc);&#xA;    return(ret);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-软件看门狗-watchdog</title>
      <link>http://www.nljb.net/default/Linux-%E8%BD%AF%E4%BB%B6%E7%9C%8B%E9%97%A8%E7%8B%97-watchdog/</link>
      <pubDate>2014-09-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux 自带了一个 watchdog 的实现，用于监视系统的运行&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;包括一个内核 watchdog module 和一个用户空间的 watchdog 程序。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;内核 watchdog 模块通过 /dev/watchdog 这个字符设备与用户空间通信。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;用户空间程序一旦打开 /dev/watchdog 设备（俗称“开门放狗”）&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;就会导致在内核中启动一个1分钟的定时器（系统默认时间）&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;此后，用户空间程序需要保证在1分钟之内向这个设备写入数据（俗称“定期喂狗”）&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;每次写操作会导致重新设定定时器。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;如果用户空间程序在1分钟之内没有写操作，定时器到期会导致一次系统 reboot 操作（“狗咬人了”呵呵）。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过这种机制，我们可以保证系统核心进程大部分时间都处于运行状态&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;即使特定情形下进程崩溃，因无法正常定时“喂狗”，Linux系统在看门狗作用下重新启动（reboot）&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;核心进程又运行起来了,多用于嵌入式系统。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;打开 /dev/watchdog 设备（“开门放狗”）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int fd_watchdog = open(&amp;quot;/dev/watchdog&amp;quot;, O_WRONLY);  &#xA;if(fd_watchdog == -1) {  &#xA;    int err = errno;  &#xA;    printf(&amp;quot;\n!!! FAILED to open /dev/watchdog, errno: %d, %s\n&amp;quot;, err, strerror(err));  &#xA;    syslog(LOG_WARNING, &amp;quot;FAILED to open /dev/watchdog, errno: %d, %s&amp;quot;, err, strerror(err));  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;每隔一段时间向 /dev/watchdog 设备写入数据（“定期喂狗”）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//feed the watchdog  &#xA;if(fd_watchdog &amp;gt;= 0) {  &#xA;    static unsigned char food = 0;  &#xA;    ssize_t eaten = write(fd_watchdog, &amp;amp;food, 1);  &#xA;    if(eaten != 1) {  &#xA;    puts(&amp;quot;\n!!! FAILED feeding watchdog&amp;quot;);  &#xA;    syslog(LOG_WARNING, &amp;quot;FAILED feeding watchdog&amp;quot;);  &#xA;    }  &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;关闭 /dev/watchdog 设备，通常不需要这个步骤：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;close(fd_watchdog);    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;所需头文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;  &#xA;#include &amp;lt;sys/stat.h&amp;gt;  &#xA;#include &amp;lt;syslog.h&amp;gt;  &#xA;#include &amp;lt;errno.h&amp;gt;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>CxImage</title>
      <link>http://www.nljb.net/default/CxImage/</link>
      <pubDate>2014-09-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;CxImage类库是一个优秀的图像操作类库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以快捷地存取、显示、转换各种图像。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;添加头文件目录&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;CxImage\Include&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;加库文件目录&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;CxImage\lib&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加链接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cximage.lib&#xA;demod.lib&#xA;j2k.lib&#xA;jasper.lib&#xA;jbig.lib&#xA;jpeg.lib&#xA;png.lib&#xA;tiff.lib&#xA;zlib.lib&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;序中添加头文件&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;ximage.h&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;基本用法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 打开&#xA;CxImage image;&#xA;if(image.load(&amp;quot;name&amp;quot;,类型))&#xA;{&#xA;       CDC *pDC = GetDC();&#xA;       image.Draw(pDC-&amp;gt;GetSafeHDC(),CRect rect(0,0,100,100));&#xA;       pDC-&amp;gt;DeleteDC;     &#xA;}&#xA;　　&#xA;&#xA;// 旋转&#xA;CxImage smallImage; // 旋转后的图片&#xA;image.Rotate(90,&amp;amp;smallImage); // 旋转90，并且保存到smallImage中&#xA;smallImage.Save(保存的名字,类型);&#xA;&#xA;// 镜像&#xA;CxImage ImgTmp = image;&#xA;if(ImgTmp.Mirror())&#xA;{&#xA;     image.Draw(....  ,  .....);&#xA;}&#xA;&#xA;// 缩放&#xA;CxImage samllImg;&#xA;image.Resample(新宽度,新高度,0,&amp;amp;smallImg);&#xA;smallImg.Save(&amp;quot;自定第一大小.jpg&amp;quot;,CXIMAGE_SUPPORT_JPG);&#xA;&#xA;// 剪辑&#xA;CDC *pDC=GetDC();&#xA;UpdateData();&#xA;CxImage smallImg;&#xA;tempimage.Crop(CRect(m_xTop,m_yTop,m_xWidth,m_yHeiht),&amp;amp;smallImg);&#xA;smallImg.Save(&amp;quot;剪辑图片.jpg&amp;quot;,CXIMAGE_SUPPORT_JPG);&#xA;smallImg.Draw(pDC-&amp;gt;GetSafeHdc(),CRect(40,70,picwidth,picheight));&#xA;pDC-&amp;gt;DeleteDC();&#xA;&#xA;// 混合&#xA;CDC *pDC=GetDC();&#xA;CxImage smallImg;&#xA;smallImg.Load(&amp;quot;混合源文件.jpg&amp;quot;,CXIMAGE_SUPPORT_JPG);&#xA;tempimage.Mix(smallImg,CxImage::OpAvg,0,0,true);&#xA;tempimage.Save(&amp;quot;Mix混合.jpg&amp;quot;,CXIMAGE_SUPPORT_JPG);&#xA;tempimage.Draw(pDC-&amp;gt;GetSafeHdc(),CRect(40,70,picwidth,picheight));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;编译&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 下载cximage599c_tar包&#xA;http://www.xdp.it/download.htm。&#xA;&#xA;// 因为是新的版本，编译和网上一些教程有差异。直接使用：&#xA;./configure --prefix=/usr/ --enable-shared （生成并使用静态库）&#xA;// 或者&#xA;./configure --prefix=/usr/ --disable-shared （生成并使用动态库）&#xA;// make&#xA;// make install&#xA;// 大功告成。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之Map使用</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8BMap%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2014-09-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;MAP的说明&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1, 头文件 &#xA;#include &amp;lt;map&amp;gt; &#xA;&#xA;2, 定义 &#xA;map&amp;lt;string, int&amp;gt; my_Map; 或者是typedef map&amp;lt;string, int&amp;gt; MY_MAP; &#xA;MY_MAP my_Map; &#xA;&#xA;3, 插入数据 &#xA;(1) my_Map[&amp;quot;a&amp;quot;] = 1; &#xA;(2) my_Map.insert(map&amp;lt;string, int&amp;gt;::value_type(&amp;quot;b&amp;quot;,2)); &#xA;(3) my_Map.insert(pair&amp;lt;string,int&amp;gt;(&amp;quot;c&amp;quot;,3)); &#xA;(4) my_Map.insert(make_pair&amp;lt;string,int&amp;gt;(&amp;quot;d&amp;quot;,4)); &#xA;&#xA;4, 查找数据和修改数据 &#xA;(1) int i = my_Map[&amp;quot;a&amp;quot;]; &#xA;    my_Map[&amp;quot;a&amp;quot;] = i; &#xA;(2) MY_MAP::iterator my_Itr; &#xA;    my_Itr.find(&amp;quot;b&amp;quot;); &#xA;    int j = my_Itr-&amp;gt;second; &#xA;    my_Itr-&amp;gt;second = j; &#xA;不过注意，键本身是不能被修改的，除非删除。 &#xA;&#xA;5, 删除数据 &#xA;(1) my_Map.erase(my_Itr); &#xA;(2) my_Map.erase(&amp;quot;c&amp;quot;); &#xA;还是注意，第一种情况在迭代期间是不能被删除的，道理和foreach时不能删除元素一样。 &#xA;&#xA;6, 迭代数据 &#xA;for (my_Itr=my_Map.begin(); my_Itr!=my_Map.end(); ++my_Itr) {} &#xA;&#xA;7, 其它方法 &#xA;my_Map.size() 返回元素数目 &#xA;my_Map.empty() 判断是否为空 &#xA;my_Map.clear() 清空所有元素 &#xA;可以直接进行赋值和比较：=,   &amp;gt;,   &amp;gt;=,   &amp;lt;,   &amp;lt;=,   !=   等等 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 判断KEY是否存在&#xA;bool Exist(const keyName)&#xA;{&#xA;     return (mRegistryMap.find(keyName) != mRegistryMap.end());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#ifndef INI_H&#xA;#define INI_H&#xA;&#xA;#include &amp;lt;map&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;typedef map&amp;lt;string, string&amp;gt; values;&#xA;typedef map&amp;lt;string, values*&amp;gt; keys;&#xA;&#xA;class INI&#xA;{&#xA;public:&#xA;    INI(string);&#xA;    ~INI();&#xA;public:&#xA;    int ReadINI();&#xA;    int WriteINI();&#xA;    void ClearINI();&#xA;    void ShowINI();&#xA;    void AppendValByKeysAndVals(string, string, string);&#xA;    int DelValByKeysAndVals(string, string);&#xA;    string GetValByKeysAndVals(string, string);&#xA;private:&#xA;    keys * key;&#xA;    string path;&#xA;};&#xA;&#xA;#endif // INI_H&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;quot;ini.h&amp;quot;&#xA;#include &amp;lt;fstream&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;&#xA;INI::INI(string _path)&#xA;{&#xA;    key = new keys();&#xA;    path = _path;&#xA;}&#xA;&#xA;INI::~INI()&#xA;{&#xA;    ClearINI();&#xA;    delete(key);&#xA;}&#xA;&#xA;int INI::ReadINI()&#xA;{&#xA;    ClearINI();&#xA;    string line;&#xA;    string type;&#xA;    int i;&#xA;    ifstream f(path.c_str());&#xA;    if (!f.is_open()){&#xA;    return -1;&#xA;    }&#xA;    while(getline(f, line)){&#xA;    if (line.substr(0,1) ==  &amp;quot;#&amp;quot; || line.empty())&#xA;    {&#xA;        continue;&#xA;    }&#xA;    if (line.substr(0,1) ==  &amp;quot;[&amp;quot;)&#xA;    {&#xA;        type = line.substr(1,line.length()-2);&#xA;        continue;&#xA;    }&#xA;    if(type.empty()) {&#xA;        continue;&#xA;    }&#xA;    i = line.find(&amp;quot;=&amp;quot;);&#xA;    if(i == -1)&#xA;    {&#xA;        continue;&#xA;    }&#xA;    if(key-&amp;gt;find(type) == key-&amp;gt;end())&#xA;    {&#xA;        values * val = new values();&#xA;        (*key)[type] = val;&#xA;    }&#xA;    values * vals = (*key)[type];&#xA;    (*vals)[line.substr(0,i)] = line.substr(line.find(&amp;quot;=&amp;quot;)+1,line.length());&#xA;    }&#xA;    f.close();&#xA;    return 0;&#xA;}&#xA;&#xA;void INI::ClearINI()&#xA;{&#xA;    keys::iterator it;&#xA;    for(it=(*key).begin(); it!=(*key).end(); it++)&#xA;    {&#xA;    (*(*it).second).clear();&#xA;    delete((*it).second);&#xA;    (*key).erase((*it).first);&#xA;    }&#xA;}&#xA;&#xA;void INI::ShowINI()&#xA;{&#xA;    keys::iterator it;&#xA;    for(it=(*key).begin(); it!=(*key).end(); it++)&#xA;    {&#xA;    cout &amp;lt;&amp;lt; &amp;quot;[&amp;quot; &amp;lt;&amp;lt; (*it).first &amp;lt;&amp;lt; &amp;quot;]&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    values * vals = (*it).second;&#xA;    values::iterator iv;&#xA;    for(iv=(*vals).begin(); iv!=(*vals).end(); iv++)&#xA;    {&#xA;        cout &amp;lt;&amp;lt; (*iv).first &amp;lt;&amp;lt; &amp;quot;=&amp;quot; &amp;lt;&amp;lt; (*iv).second &amp;lt;&amp;lt; endl;&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;string INI::GetValByKeysAndVals(string _keys, string _values)&#xA;{&#xA;    if (key-&amp;gt;find(_keys) == key-&amp;gt;end())&#xA;    {&#xA;    return &amp;quot;&amp;quot;;&#xA;    }&#xA;    values * vals = (*key)[_keys];&#xA;    if (vals-&amp;gt;find(_values) == vals-&amp;gt;end())&#xA;    {&#xA;    return &amp;quot;&amp;quot;;&#xA;    }&#xA;    return (*vals)[_values];&#xA;}&#xA;&#xA;int INI::DelValByKeysAndVals(string _keys, string _values)&#xA;{&#xA;    if (key-&amp;gt;find(_keys) == key-&amp;gt;end())&#xA;    {&#xA;    return -1;&#xA;    }&#xA;    values * vals = (*key)[_keys];&#xA;    if (vals-&amp;gt;find(_values) == vals-&amp;gt;end())&#xA;    {&#xA;    return -1;&#xA;    }&#xA;    (*vals).erase(_values);&#xA;    if ((*vals).size() == 0)&#xA;    {&#xA;    delete(vals);&#xA;    (*key).erase(_keys);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;void INI::AppendValByKeysAndVals(string _keys, string _values, string _value)&#xA;{&#xA;    if(key-&amp;gt;find(_keys) == key-&amp;gt;end())&#xA;    {&#xA;    values * vals = new values();&#xA;    (*key)[_keys] = vals;&#xA;    }&#xA;    values * vals = (*key)[_keys];&#xA;    (*vals)[_values] = _value;&#xA;}&#xA;&#xA;int INI::WriteINI()&#xA;{&#xA;    string data;&#xA;    ofstream f(path.c_str());&#xA;    if(!f.is_open())&#xA;    {&#xA;    return -1;&#xA;    }&#xA;    keys::iterator it;&#xA;    for(it=(*key).begin(); it!=(*key).end(); it++)&#xA;    {&#xA;    data.append(&amp;quot;[&amp;quot;);&#xA;    data.append((*it).first);&#xA;    data.append(&amp;quot;]&amp;quot;);&#xA;    data.append(&amp;quot;\n&amp;quot;);&#xA;    values * vals = (*it).second;&#xA;    values::iterator iv;&#xA;    for(iv=(*vals).begin(); iv!=(*vals).end(); iv++)&#xA;    {&#xA;        data.append((*iv).first);&#xA;        data.append(&amp;quot;=&amp;quot;);&#xA;        data.append((*iv).second);&#xA;        data.append(&amp;quot;\n&amp;quot;);&#xA;    }&#xA;    }&#xA;    f.write(data.c_str(), strlen(data.c_str()));&#xA;    f.flush();&#xA;    f.close();&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux下C++的多线程编程</title>
      <link>http://www.nljb.net/default/Linux%E4%B8%8BC%2B%2B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link>
      <pubDate>2014-09-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;简单的多线程编程&lt;/p&gt;&#xA;&#xA;&lt;p&gt;　　Linux系统下的多线程遵循POSIX线程接口，称为pthread。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。&#xA;&#xA;顺便说一下，Linux下pthread的实现是通过系统调用clone()来实现的。&#xA;&#xA;clone()是Linux所特有的系统调用，它的使用方式类似fork。&#xA;&#xA;// Threads.cpp&#xA;#include &#xA;#include &#xA;#include &#xA;using namespace std;&#xA;&#xA;void *thread(void *ptr)&#xA;{&#xA;    for(int i = 0;i &amp;lt; 3;i++) {&#xA;    sleep(1);&#xA;    cout &amp;lt;&amp;lt; &amp;quot;This is a pthread.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;int main() {&#xA;    pthread_t id;&#xA;    int ret = pthread_create(&amp;amp;id, NULL, thread, NULL);&#xA;    if(ret) {&#xA;    cout &amp;lt;&amp;lt; &amp;quot;Create pthread error!&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    return 1;&#xA;    }&#xA;    for(int i = 0;i &amp;lt; 3;i++) {&#xA;    cout &amp;lt;&amp;lt;  &amp;quot;This is the main process.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    sleep(1);&#xA;    }&#xA;    pthread_join(id, NULL);&#xA;    return 0;&#xA;}&#xA;&#xA;我们编译并运行此程序，可以得到如下结果：&#xA;This is the main process.&#xA;This is a pthread.&#xA;This is the main process.&#xA;This is the main process.&#xA;This is a pthread.&#xA;This is a pthread.&#xA;&#xA;再次运行，我们可能得到如下结果：&#xA;This is a pthread.&#xA;This is the main process.&#xA;This is a pthread.&#xA;This is the main process.&#xA;This is a pthread.&#xA;This is the main process.&#xA;&#xA;// 前后两次结果不一样，这是两个线程争夺CPU资源的结果。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;上面的示例中，我们使用到了两个函数，pthread_create和pthread_join&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;并声明了一个pthread_t型的变量，它是一个线程的标识符。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数pthread_create用来创建一个线程&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;当创建线程成功时，函数返回0，若不为0则说明创建线程失败&#xA;&#xA;常见的错误返回代码为EAGAIN和EINVAL。&#xA;&#xA;前者表示系统限制创建新的线程，例如线程数目过多了；&#xA;&#xA;后者表示第二个参数代表的线程属性值非法。&#xA;&#xA;创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数pthread_join用来等待一个线程的结束&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一个线程的结束有两种途径，一种是象我们上面的例子一样，函数结束了，调用它的线程也就结束了；&#xA;&#xA;另一种方式是通过函数pthread_exit来实现。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>系统启动过程</title>
      <link>http://www.nljb.net/default/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>2014-09-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/系统启动过程/1.gif&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;其实Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1．BIOS加电自检&#xA;&#xA;2．加载主引导加载程序（MBR）&#xA;&#xA;3．加载次引导加载程序（GRUB）&#xA;&#xA;4．Linux内核映像&#xA;&#xA;5．init进程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;内核映像&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当用户选择启动Linux操作系统后:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;GRUB会根据/boot/grub.conf配置文件中所设置的信息,从/boot/所在的分区上读取Linux内核映像&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后把内核映像加载到内存中并把控制权交给Linux内核,Linux内核获得控制权后，将会按以下步骤继续引导系统。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;（1）内核映像首先会检测系统中的硬件设备，包括内存、CPU、硬盘等，对这些设备进行初始化并配置。&#xA;&#xA;（2）内核映像是经过压缩的，接下来它要对自身进行解压，同时加载必要的设备驱动。&#xA;&#xA;（3）初始化与文件系统相关的虚拟设备，如LVM或者软件RAID等。&#xA;&#xA;（4）装载根文件系统（/），把根文件系统挂载到根目录下。&#xA;&#xA;（5）引导后，Linux内核会在其进程空间内加载init，并把控制器交给init，由init继续完成接下来的引导工作。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;内核&lt;/p&gt;&#xA;&#xA;&lt;p&gt;技术上说Linux是一个内核。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;“内核”指的是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。&#xA;&#xA;一个内核不是一套完整的操作系统。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一套基于Linux内核的完整操作系统叫作Linux操作系统，或是GNU/Linux。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>关于bind的使用</title>
      <link>http://www.nljb.net/default/%E5%85%B3%E4%BA%8Ebind%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2014-09-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;无连接的socket的客户端和服务端以及面向连接socket的服务端通过调用bind函数来配置本地信息。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用bind函数时，通过将my_addr.sin_port置为0，函数会自动为你选择一个未占用的端口来使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Bind()函数在成功被调用时返回0；出现错误时返回&amp;rdquo;-1&amp;rdquo;并将errno置为相应的错误号。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;需要注意的是，在调用bind函数时一般不要将端口号置为小于1024的值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为1到1024是保留端口号，你可以选择大于1024中的任何一个没有被占用的端口号。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;有连接的socket客户端通过调用Connect函数在socket数据结构中保存本地和远端信息，无须调用bind()&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为这种情况下只需知道目的机器的IP地址，而客户通过哪个端口与服务器建立连接并不需要关心&lt;/p&gt;&#xA;&#xA;&lt;p&gt;socket执行体为你的程序自动选择一个未被占用的端口，并通知你的程序数据什么时候打开端口。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;总之：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.需要在建连前就知道端口的话，需要 bind&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.需要通过指定的端口来通讯的话，需要 bind&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体到上面那两个程序，本来用的是TCP，客户端就不用绑定端口了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;绑定之后只能运行一个client的程序属于自己人为设定的障碍&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而从服务器那边得到的客户机连接端口号（是系统自动分配的）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;与这边客户机绑定的端口号根本是不相关的，所以客户端绑定也就失去了意义。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;首先，服务器和客户端都可以bind，bind并不是服务器的专利。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端进程bind端口: 由进程选择一个端口去连服务器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（如果默认情况下，调用bind函数时，内核指定的端口是同一个，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么调用多个调用了bind（）的client程序，会出现端口被占用的错误）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意这里的端口是客户端的端口。如果不分配就表示交给内核去选择一个可用端口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端进程bind IP地址：相当于为发送出去的IP数据报分配了源IP地址&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但交给进程分配IP地址的时候（就是这样写明了bind IP地址的时候）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个IP地址必须是主机的一个接口，不能分配一个不存在的IP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果不分配就表示由内核根据所用的输出接口来选择源IP地址。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;一般情况下客户端是不用调用bind函数的，一切都交给内核搞定，YES！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务端进程bind端口：基本是必须要做的事情&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如一个服务器启动时（比如freebsd），它会一个一个的捆绑众所周知的端口来提供服务&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样，如果bind了一个端口就表示我这个服务器会在这个端口提供一些“特殊服务”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务端进程bind IP地址：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目的是限制了服务端进程创建的socket只接受那些目的地为此IP地址的客户链接，一般一个服务器程序里都有&lt;/p&gt;&#xA;&#xA;&lt;p&gt;servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 只是针对IP4，IP6代码不太一样&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样一句话，意思就是：我不指定客户端的IP，随便连，来者不拒！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总之只要你bind时候没有指定哪一项（置为0），内核会帮你选择。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>iostream,fstream,sstream</title>
      <link>http://www.nljb.net/default/iostream%2Cfstream%2Csstream/</link>
      <pubDate>2014-09-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/iostream,fstream,sstream/iostream.gif&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/iostream,fstream,sstream/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;文件的输入和输出:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ifstream：由istream派生而来，提供读文件的功能&#xA;ofstream：由ostream派生而来，提供写文件的功能&#xA;fstream：有iostream派生而来，提供读写同一个文件的功能&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;字符串流:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;istringstream：由istream派生而来，提供读string的功能&#xA;ostringstream：由ostream派生而来，提供写string的功能&#xA;stringstream：由iostream派生而来，提供读写string的功能&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;文件流:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ifstream infile;&#xA;&#xA;// ifstream infile(path)&#xA;infile.open(path.c_str()); &#xA;&#xA;// 如果没有打开成功文件&#xA;if(!infile)&#xA;&#xA;ofstream outfile&#xA;&#xA;// 第二个参数默认为out，清空文件准备写。app为在文件问追加。&#xA;outfile.open(path.c_str(), ofstream::app); &#xA;&#xA;// 最好在打开一文件前&#xA;// 关闭可能张打开的文件，和清空错误标志；   &#xA;in.close(); in.clear(); &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;字符串流:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;string line,word;&#xA;while(getline(cin, line))&#xA;{&#xA;&#xA;    istringstream string_stream(line);&#xA;    while(string_stream &amp;gt;&amp;gt; word)&#xA;    cout&amp;lt;&amp;lt;word&amp;lt;&amp;lt;endl;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;流之间可以相互转换:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;stringstream word_stream(&amp;quot;countryhu!&amp;quot;);&#xA;cout &amp;lt;&amp;lt; word_stream.str()&amp;lt;&amp;lt;endl;&#xA;word_stream.str(&amp;quot;hi,countryhu!&amp;quot;);&#xA;&#xA;// 流读取一个字符&#xA;stream.get()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;例子:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ifstream inf(&amp;quot;/json&amp;quot;);&#xA;stringstream in ;&#xA;in &amp;lt;&amp;lt; inf.rdbuf();&#xA;in.str().c_str();&#xA;inf.close();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>SOCK_STREAM与SOCK_DGRAM的区别</title>
      <link>http://www.nljb.net/default/SOCK_STREAM%E4%B8%8ESOCK_DGRAM%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2014-09-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;SOCK_STREAM&lt;/p&gt;&#xA;&#xA;&lt;p&gt;是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_DGRAM&lt;/p&gt;&#xA;&#xA;&lt;p&gt;是无保障的面向消息的socket，主要用于在网络上发广播信息。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;SOCK_STREAM是基于TCP的，数据传输比较有保障。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_STREAM 是数据流,一般是tcp/ip协议的编程&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_DGRAM分是数据抱,是udp协议网络编程&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;新套接口的类型描述类型，如TCP（SOCK_STREAM）和UDP（SOCK_DGRAM）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;指定协议。套接口所用的协议。如调用者不想指定，可用0。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;常用的协议有，IPPROTO_TCP、IPPROTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_STREAM 提供有序的、可靠的、双向的和基于连接的字节流，使用带外数据传送机制，为Internet地址族使用TCP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_DGRAM 支持无连接的、不可靠的和使用固定大小（通常很小）缓冲区的数据报服务，为Internet地址族使用UDP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_STREAM类型的套接口为全双向的字节流。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于流类套接口，在接收或发送数据前必需处于已连接状态。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用connect()调用建立与另一套接口的连接&lt;/p&gt;&#xA;&#xA;&lt;p&gt;连接成功后，即可用send()和recv()传送数据。当会话结束后，调用closesocket()。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;带外数据根据规定用send()和recv()来接收。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实现SOCK_STREAM类型套接口的通讯协议保证数据不会丢失也不会重复。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果终端协议有缓冲区空间，且数据不能在一定时间成功发送，则认为连接中断，其后续的调用也将以WSAETIMEOUT错误返回。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SOCK_DGRAM类型套接口允许使用sendto()和recvfrom()从任意端口发送或接收数据报。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果这样一个套接口用connect()与一个指定端口连接，则可用send()和recv()与该端口进行数据报的发送与接收。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>openSUSE-源</title>
      <link>http://www.nljb.net/default/openSUSE-%E6%BA%90/</link>
      <pubDate>2014-09-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;打开YaST中的 Software Repositories&lt;/p&gt;&#xA;&#xA;&lt;p&gt;选择Add，通过Specify URL方式，添加如下源：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;163-opensuse-11.4-update: http://mirrors.163.com/openSUSE/update/11.4/&#xA;163-opensuse-11.4-oss: http://mirrors.163.com/openSUSE/distribution/11.4/repo/oss/&#xA;163-opensuse-11.4-non-oss: http://mirrors.163.com/openSUSE/distribution/11.4/repo/non-oss/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中Oss是指 Open Source Software，开源软件。那么Non-Oss就是非开源软件了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外Sohu也有openSUSE的源，但是在我用的网络，不如163的快。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sohu-opensuse-11.4-update: http://mirrors.sohu.com/opensuse/update/11.4/&#xA;sohu-opensuse-11.4-oss: http://mirrors.sohu.com/opensuse/distribution/11.4/repo/oss/&#xA;sohu-opensuse-11.4-non-oss: http://mirrors.sohu.com/opensuse/distribution/11.4/repo/non-oss/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加了国内的源，便可以不选择系统默认的官方SUSE源。更改Priority也可。系统就能飞速更新了。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;163-opensuse-13.1-update: http://mirrors.163.com/openSUSE/update/13.1/&#xA;163-opensuse-13.1-oss: http://mirrors.163.com/openSUSE/distribution/13.1/repo/oss/&#xA;163-opensuse-13.1-non-oss: http://mirrors.163.com/openSUSE/distribution/13.1/repo/non-oss/&#xA;&#xA;sohu-opensuse-13.1-update: http://mirrors.sohu.com/opensuse/update/13.1/&#xA;sohu-opensuse-13.1-oss: http://mirrors.sohu.com/opensuse/distribution/13.1/repo/oss/&#xA;sohu-opensuse-13.1-non-oss: http://mirrors.sohu.com/opensuse/distribution/13.1/repo/non-oss/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo zypper ar -f http://packman.inode.at/suse/openSUSE_13.1/ packman &#xA;&#xA;sudo zypper refresh &#xA;&#xA;sudo zypper install mplayer &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>QTableWidget</title>
      <link>http://www.nljb.net/default/QTableWidget/</link>
      <pubDate>2014-09-11 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;quot;mainwindow.h&amp;quot;&#xA;#include &amp;quot;ui_mainwindow.h&amp;quot;&#xA;#include &amp;lt;QtGui&amp;gt;&#xA;&#xA;MainWindow::MainWindow(QWidget *parent) :&#xA;    QMainWindow(parent),&#xA;    ui(new Ui::MainWindow)&#xA;{&#xA;    ui-&amp;gt;setupUi(this);&#xA;&#xA;    ui-&amp;gt;runButton-&amp;gt;setFlat(true);&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setHidden(true);&#xA;    connect(ui-&amp;gt;runButton, SIGNAL(clicked()), this ,SLOT(runShowTable()));&#xA;&#xA;    ui-&amp;gt;evoButton-&amp;gt;setFlat(true);&#xA;    ui-&amp;gt;evoTableView-&amp;gt;setHidden(true);&#xA;    connect(ui-&amp;gt;evoButton, SIGNAL(clicked()), this ,SLOT(evoShowTable()));&#xA;&#xA;    ui-&amp;gt;sysButton-&amp;gt;setFlat(true);&#xA;    ui-&amp;gt;sysTableView-&amp;gt;setHidden(true);&#xA;    connect(ui-&amp;gt;sysButton, SIGNAL(clicked()), this ,SLOT(sysShowTable()));&#xA;&#xA;    ui-&amp;gt;mbrButton-&amp;gt;setFlat(true);&#xA;    ui-&amp;gt;mbrTableWidget-&amp;gt;setHidden(true);&#xA;    connect(ui-&amp;gt;mbrButton, SIGNAL(clicked()), this ,SLOT(mbrShowTable()));&#xA;&#xA;    ui-&amp;gt;patchButton-&amp;gt;setFlat(true);&#xA;    ui-&amp;gt;patchTableWidget-&amp;gt;setHidden(true);&#xA;    connect(ui-&amp;gt;patchButton, SIGNAL(clicked()), this ,SLOT(patchShowTable()));&#xA;&#xA;}&#xA;&#xA;MainWindow::~MainWindow()&#xA;{&#xA;    delete ui;&#xA;}&#xA;&#xA;void MainWindow::allHidden()&#xA;{&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setHidden(true);&#xA;    ui-&amp;gt;evoTableView-&amp;gt;setHidden(true);&#xA;    ui-&amp;gt;sysTableView-&amp;gt;setHidden(true);&#xA;    ui-&amp;gt;mbrTableWidget-&amp;gt;setHidden(true);&#xA;    ui-&amp;gt;patchTableWidget-&amp;gt;setHidden(true);&#xA;}&#xA;&#xA;void MainWindow::runShowTable()&#xA;{&#xA;&#xA;    allHidden();&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setColumnCount(5);&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setRowCount(100);&#xA;//    ui-&amp;gt;runTableWidget-&amp;gt;horizontalHeader()-&amp;gt;setStretchLastSection(true);&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;horizontalHeader()-&amp;gt;setResizeMode(QHeaderView::Stretch);&#xA;&#xA;    QStringList header;&#xA;    header&amp;lt;&amp;lt; &amp;quot;指派&amp;quot; &amp;lt;&amp;lt; &amp;quot;系统&amp;quot; &amp;lt;&amp;lt; &amp;quot;进化&amp;quot; &amp;lt;&amp;lt; &amp;quot;分区表&amp;quot; &amp;lt;&amp;lt; &amp;quot;补丁&amp;quot;;&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setHorizontalHeaderLabels(header);&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setItem(0,0,new QTableWidgetItem(&amp;quot;Janxxxxxxxxxxxxxxxxx&amp;quot;));&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setItem(1,0,new QTableWidgetItem(&amp;quot;Feb&amp;quot;));&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;setItem(2,0,new QTableWidgetItem(&amp;quot;Mar&amp;quot;));&#xA;    ui-&amp;gt;runTableWidget-&amp;gt;show();&#xA;}&#xA;&#xA;void MainWindow::evoShowTable()&#xA;{&#xA;    allHidden();&#xA;    ui-&amp;gt;evoTableView-&amp;gt;show();&#xA;}&#xA;&#xA;void MainWindow::sysShowTable()&#xA;{&#xA;    allHidden();&#xA;    ui-&amp;gt;sysTableView-&amp;gt;show();&#xA;}&#xA;&#xA;void MainWindow::mbrShowTable()&#xA;{&#xA;    allHidden();&#xA;    ui-&amp;gt;mbrTableWidget-&amp;gt;show();&#xA;}&#xA;&#xA;void MainWindow::patchShowTable()&#xA;{&#xA;    allHidden();&#xA;    ui-&amp;gt;patchTableWidget-&amp;gt;show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;table-&amp;gt;setSelectionMode(QAbstractItemView::SingleSelection)  &#xA;table.horizontalHeader()-&amp;gt;setResizeMode(QheaderView::Fixed);  &#xA;table.horizontalHeader()-&amp;gt;setStretchLastSection(true);  &#xA;table.setEditTrigger(QAbstractItemView::NoEditTriggers);  &#xA;table.setShowGrid(false);  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1.QTableWidget不能在mainwindow中随主窗口的大小变化？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;解决：在表格外部添加布局。&#xA;代码：tableWidget = new QTableWidget;&#xA;      tableWidget -&amp;gt;setObjectName(QString::fromUtf8(&amp;quot;tableWidget&amp;quot;));&#xA;      QVBoxLayout *verticalLayout;&#xA;      verticalLayout-&amp;gt;addWidget(tableWidget );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.将表格变为禁止编辑：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tableWidget-&amp;gt;setEditTriggers(QAbstractItemView::NoEditTriggers);&#xA;（参数含义：QAbstractItemView.NoEditTriggers--不能对表格内容进行修改&#xA;        QAbstractItemView.CurrentChanged--任何时候都能对单元格修改&#xA;        QAbstractItemView.DoubleClicked--双击单元格&#xA;        QAbstractItemView.SelectedClicked--单击已选中的内容 &#xA;        QAbstractItemView.EditKeyPressed--&#xA;        QAbstractItemView.AnyKeyPressed--按下任意键就能修改&#xA;        QAbstractItemView.AllEditTriggers--以上条件全包括）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3.设置表格为整行选择&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  tableWidget-&amp;gt;setSelectionBehavior(QAbstractItemView::SelectRows);  //整行选中的方式&#xA;  （参数含义：AbstractItemView.SelectItems--选中单个单元格&#xA;          QAbstractItemView.SelectRows--选中一行&#xA;          QAbstractItemView.SelectColumns--选中一列）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4.单个选中和多个选中的设置：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  tableWidget-&amp;gt;setSelectionMode(QAbstractItemView::ExtendedSelection);  //设置为可以选中多个目标&#xA; （参数含义：QAbstractItemView.NoSelection--不能选择&#xA;         QAbstractItemView.SingleSelection--选中单个目标&#xA;         QAbstractItemView.MultiSelection--选中多个目标&#xA;  QAbstractItemView.ExtendedSelection/QAbstractItemView.ContiguousSelection &#xA;  的区别不明显，主要功能是正常情况下是单选，但按下Ctrl或Shift键后，可以多选）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5.表格表头的显示与隐藏&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  对于水平或垂直方法的表头，可以用以下方式进行 隐藏/显示 的设置：&#xA;  tableWidget-&amp;gt;verticalHeader()-&amp;gt;setVisible(false);   //隐藏列表头  &#xA;  tableWidget-&amp;gt;horizontalHeader()-&amp;gt;setVisible(false); //隐藏行表头  &#xA;  注意：需要 #include &amp;lt;QHeaderView&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;6.对表头文字的字体、颜色进行设置&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  //获得水平方向表头的Item对象&#xA;  QTableWidgetItem *columnHeaderItem0 = tableWidget-&amp;gt;horizontalHeaderItem(0);&#xA;  columnHeaderItem0-&amp;gt;setFont(QFont(&amp;quot;Helvetica&amp;quot;)); //设置字体  &#xA;  columnHeaderItem0-&amp;gt;setBackgroundColor(QColor(0,60,10)); //设置单元格背景颜色  &#xA;  columnHeaderItem0-&amp;gt;setTextColor(QColor(200,111,30)); //设置文字颜色&#xA;  注意：需要 #include &amp;lt;QHeaderView&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;7.在单元格里加入控件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   QComboBox *comBox = new QComboBox();&#xA;   comBox-&amp;gt;addItem(&amp;quot;Y&amp;quot;);&#xA;   comBox-&amp;gt;addItem(&amp;quot;N&amp;quot;);&#xA;   tableWidget-&amp;gt;setCellWidget(0,2,comBox); &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;8.单元格中添加图片：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  tableWidget-&amp;gt;setItem(row, 0, new QTableWidgetItem(QIcon(&amp;quot;:/new/images/kingdemo.ico&amp;quot;),tr(&amp;quot;&amp;quot;)));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;9.设置单元格字体颜色、背景颜色和字体字符：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  QTableWidgetItem *item = new QTableWidgetItem(&amp;quot;Apple&amp;quot;);&#xA;  item-&amp;gt;setBackgroundColor(QColor(0,60,10));&#xA;  item-&amp;gt;setTextColor(QColor(200,111,100));&#xA;  item-&amp;gt;setFont(QFont(&amp;quot;Helvetica&amp;quot;));&#xA;  tableWidget-&amp;gt;setItem(0,3,item);&#xA;  另：如果需要对所有的单元格都使用这种字体，则可以使用  tableWidget-&amp;gt;setFont(QFont(&amp;quot;Helvetica&amp;quot;));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;10.设置单元格内文字的对齐方式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; 水平对齐方式有：&#xA; Constant Value Description&#xA; Qt.AlignLeft 0x0001 Aligns with the left edge.&#xA; Qt.AlignRight 0x0002 Aligns with the right edge.&#xA; Qt.AlignHCenter 0x0004 Centers horizontally in the available space.&#xA; Qt.AlignJustify 0x0008 Justifies the text in the available space.&#xA; 垂直对齐方式：&#xA; Constant Value Description&#xA; Qt.AlignTop 0x0020 Aligns with the top.&#xA; Qt.AlignBottom 0x0040 Aligns with the bottom.&#xA; Qt.AlignVCenter 0x0080 Centers vertically in the available space.&#xA; 如果两种都要设置，只要用 Qt.AlignHCenter |  Qt.AlignVCenter 的方式即可&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;11.合并单元格：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tableWidget-&amp;gt;setSpan(0, 0, 3, 1)  &#xA;# 其参数为： 要改变单元格的1行数、2列数，要合并的3行数、4列数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;12.设置单元格的大小&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;首先，可以指定某个行或者列的大小&#xA;tableWidget-&amp;gt;setColumnWidth(3,200);&#xA;tableWidget-&amp;gt;setRowHeight(3,60);&#xA;&#xA;还可以将行和列的大小设为与内容相匹配&#xA;tableWidget-&amp;gt;resizeColumnsToContents();&#xA;tableWidget-&amp;gt;resizeRowsToContents();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;13.获得单击单元格的内容&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 信号的槽函数，就可以获得鼠标单击到的单元格指针，进而获得其中的文字信息&#xA;通过实现 itemClicked (QTableWidgetItem *)&#xA;connect(tableWidget,SIGNAL(itemDoubleClicked(QTreeWidgetItem*,int)),&#xA;    this,&#xA;    SLOT(getItem(QTreeWidgetItem*,int)));&#xA;//将itemClicked信号与函数getItem绑定&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;14.QTableWidget要调整表格行宽主要涉及以下函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tableWidget-&amp;gt;horizontalHeader()-&amp;gt;setResizeMode(QHeaderView::Stretch);//使列完全填充并平分&#xA;tableWidget-&amp;gt;resizeColumnsToContents(); //根据内容调整列宽&#xA;tableWidget-&amp;gt;resizeColumnToContents(int col);//根据内容自动调整给定列宽&#xA;tableWidget-&amp;gt;horizontalHeader()-&amp;gt;setResizeMode//把给定列设置为给定模式&#xA;主要模式有Stretch和Fixed&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;15.添加表头内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;方法一：&#xA;QStringList header;&#xA;header&amp;lt;&amp;lt;&amp;quot;&amp;quot;&amp;lt;&amp;lt;tr(&amp;quot;1&amp;quot;)&amp;lt;&amp;lt;tr(&amp;quot;2&amp;quot;)&amp;lt;&amp;lt;tr(&amp;quot;3&amp;quot;);&#xA;&#xA;方法二：&#xA;tableWidget-&amp;gt;setHorizontalHeaderLabels(QStringList()&amp;lt;&amp;lt;tr(&amp;quot;1&amp;quot;)&amp;lt;&amp;lt;tr(&amp;quot;2&amp;quot;)&amp;lt;&amp;lt;tr(&amp;quot;3&amp;quot;));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;16.清除：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tableWidget-&amp;gt;clear();//清除所有可见数据（包括表头），行还在&#xA;tableWidget-&amp;gt;clearContents();//只清除表中数据，不清除表头内容&#xA;tableWidget-&amp;gt;setRowCount(0)；//连行也清除掉&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;15.一些零碎的知识点代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int row = tableWidget-&amp;gt;rowCount();//获取表格中当前总行数&#xA;tableWidget-&amp;gt;setRowCount(row+1);//添加一行&#xA;tableWidget-&amp;gt;removeRow(row);//清除已有的行列&#xA;Int row1 = tableWidget-&amp;gt;currentItem()-&amp;gt;row();//当前选中行&#xA;bool focus = tableWidget-&amp;gt;isItemSelected(tableWidget-&amp;gt;currentItem());//判断是否选中一行&#xA;QString proName = tableWidget-&amp;gt;item(row, col)-&amp;gt;text();//获取某一格内容&#xA;setShowGrid(true);//显示表格线&#xA;verticalHeader()-&amp;gt;setVisible(false);//隐藏左边垂直&#xA;QHeaderView *headerView = horizontalHeader();&#xA;headerView-&amp;gt;setMovable(false);//去除表头的移动&#xA;headerView-&amp;gt;resizeSection(0,284);//设置第一列宽&#xA;headerView-&amp;gt;resizeSection(1,127);//设置第二列宽&#xA;headerView-&amp;gt;setResizeMode(QHeaderView::Fixed);//列表不能移动&#xA;headerView-&amp;gt;setClickable(false);//不响应鼠标单击&#xA;setEditTriggers(QTableWidget::NoEditTriggers);//不能编辑&#xA;setSelectionBehavior(QTableWidget::SelectRows);//一次选中一行&#xA;setSelectionMode(QAbstractItemView::SingleSelection);//只能单选&#xA;&#xA;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//去掉水平滚动条&#xA;setVerticalScrollMode(QAbstractItemView::ScrollPerItem);//垂直滚动条按项移动&#xA;setAutoScroll(false);//去掉自动滚动&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>QListView和QListWidget</title>
      <link>http://www.nljb.net/default/QListView%E5%92%8CQListWidget/</link>
      <pubDate>2014-09-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;QListView是基于Model，而QListWidget是基于Item。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;往QListView中添加条目需借助QAbstractListModel:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如：&#xA;&#xA;    MainWindow::MainWindow(QWidget *parent) :&#xA;    QMainWindow(parent),&#xA;    ui(new Ui::MainWindow)&#xA;{&#xA;    ui-&amp;gt;setupUi(this);&#xA;    QStringListModel* slm = new QStringListModel(this);&#xA;    QStringList* sl = new QStringList();&#xA;    sl-&amp;gt;append(&amp;quot;asdfsadfsa&amp;quot;);&#xA;    sl-&amp;gt;append(&amp;quot;asdfsadfsa&amp;quot;);&#xA;    sl-&amp;gt;append(&amp;quot;asdfsadfsa&amp;quot;);&#xA;    slm-&amp;gt;setStringList(*sl);&#xA;    ui-&amp;gt;listView-&amp;gt;setModel(slm);&#xA;    delete sl;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;而在QListWidget中添加条目可以直接additem&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 如：&#xA;&#xA;MainWindow::MainWindow(QWidget *parent) :&#xA;    QMainWindow(parent),&#xA;    ui(new Ui::MainWindow)&#xA;{&#xA;    ui-&amp;gt;setupUi(this);&#xA;    QStringList* sl = new QStringList();&#xA;    sl-&amp;gt;append(&amp;quot;1&amp;quot;);&#xA;    sl-&amp;gt;append(&amp;quot;2&amp;quot;);&#xA;    sl-&amp;gt;append(&amp;quot;3&amp;quot;);&#xA;    ui-&amp;gt;listWidget-&amp;gt;addItems(*sl);&#xA;    connect(ui-&amp;gt;pushButton,SIGNAL(clicked()), this, SLOT(close()));&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;listWidget = QListWidget() &#xA;#实例化一个(itembase)的列表&#xA;&#xA;listWidget.addItem(&#39;dd&#39;) &#xA;#添加一个项&#xA;&#xA;listWidget.addItems([]) &#xA;#从序列中添加子项&#xA;&#xA;listWidget.setDragEnabled(True)&#xA;#设置拖拉&#xA;&#xA;listWidget.sortItems() &#xA;#排序&#xA;&#xA;listWidget.selectAll()&#xA;#全选&#xA;&#xA;listWidget.setSortingEnabled(bool)&#xA;#设置自动排序&#xA;&#xA;listWidget.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)&#xA;#设置选择模式&#xA;&#xA;选择模式有:&#xA;ExtendedSelection   按住ctrl多选&#xA;SingleSelection     单选 &#xA;MultiSelection      点击多选 &#xA;ContiguousSelection 鼠标拖拉多选&#xA;&#xA;listWidget.setCurrentRow(0) &#xA;#设置当前选择行默认为-1&#xA;&#xA;listWidget.count() &#xA;#得到子项总数&#xA;&#xA;listWidget.item(row).text() &#xA;#得到第 row 行的内容 listWidget.item(row) 返回一个 item 对象&#xA;&#xA;listWidget.takeItem(row) &#xA;#返回row 行的所在的item 对象 可以用在 insertItem（）中&#xA;&#xA;listWidget.insertItem(2,item) &#xA;#在第二行插入一项item可谓为一个listviewitem对象或者string&#xA;&#xA;listWidget.setCurrentItem(&#39;dd&#39;)&#xA;#设置&#39;dd&#39;为当前项&#xA;&#xA;listWidget.selectedItems() &#xA;#返回一个包含item对象 的list 对象&#xA;&#xA;item.setText(&#39;dsds&#39;) &#xA;# 设置item的内容为dsdsitem为对象 可从 listWidget.item(row) takeItem(row) 得到&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;QListWidget的用法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;setSelectionMode()&#xA;#设置list一次最多可以选择多少item&#xA;&#xA;#有两种方法来listwidget中添加Item:&#xA;#一种是在item构造时候，指定父widget，&#xA;#如果item构造时候QListWidget已经存在，可以用下面的方法&#xA;new QListWidgetItem(tr(&amp;quot;Oak&amp;quot;), listWidget);&#xA;&#xA;#第二种方法是构造完item，在使用QListWidget::addItem()来添加item&#xA;#向QListWidget中指定的位置插入item，使用QListWidget::insertItem(int , QListWidgetItem*)&#xA;#使用QListWidget::count()来统计widget中总共的item数目&#xA;#使用QListWidget::takeItem(int index)来删除表中的某一项&#xA;#设置当前的item是第几行，QListWidget::setCurrentRow ( int row )&#xA;#设置list是否可以自动排序QListWidget::setSortingEnabled(bool)，默认是FALSE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;LineEdit 类&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;将LineEdit框设置成密码输入框：line.setEchoMode(QLineEdit::Password)&#xA;获取linedit的值： line.text()&#xA;给lineedit 赋值为空： line.setText()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;MessageBox 类&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;实例介绍：（实现提示框）&#xA;@kuang = Qt::MessageBox.new(Qt::MessageBox::NoIcon, &amp;quot;提示&amp;quot;, &amp;quot;登录成功！&amp;quot;, 0, self)&#xA;@kuang.addButton(&amp;quot;确定&amp;quot;,Qt::MessageBox::AcceptRole)&#xA;@kuang.exec()&#xA;这样就可以创建一个提示登录成功的窗口。（注：这是在QtRuby 中的相关代码。）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;TabelWidget类&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;设置行表头隐藏：&#xA;verticalHeader().setVisible(false);&#xA;设置列表头隐藏：&#xA;horizontalHeader().setVisible(false);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>QT-解决设置中文文字乱码</title>
      <link>http://www.nljb.net/default/QT-%E8%A7%A3%E5%86%B3%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87%E6%96%87%E5%AD%97%E4%B9%B1%E7%A0%81/</link>
      <pubDate>2014-09-05 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;QtGui/QApplication&amp;gt;&#xA;#include &amp;lt;QTextCodec&amp;gt;&#xA;#include &amp;quot;mainwindow.h&amp;quot;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;&#xA;    QApplication a(argc, argv);&#xA;&#xA;    // 以下部分解决中文乱码&#xA;    QTextCodec::setCodecForTr(QTextCodec::codecForName(&amp;quot;GB2312&amp;quot;));&#xA;    QTextCodec::setCodecForLocale(QTextCodec::codecForName(&amp;quot;GB2312&amp;quot;));&#xA;    QTextCodec::setCodecForCStrings(QTextCodec::codecForName(&amp;quot;GB2312&amp;quot;));&#xA;    // 以上部分解决中文乱码&#xA;&#xA;    MainWindow w;&#xA;&#xA;    w.show();&#xA;&#xA;    return a.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>QT-简单类及方法</title>
      <link>http://www.nljb.net/default/QT-%E7%AE%80%E5%8D%95%E7%B1%BB%E5%8F%8A%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-09-05 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;QApplication&amp;gt;&#xA;#include &amp;lt;QTextCodec&amp;gt;&#xA;#include &amp;lt;QLabel&amp;gt;&#xA;#include &amp;lt;QPushButton&amp;gt;&#xA;#include &amp;lt;QWidget&amp;gt;&#xA;#include &amp;lt;QSpinBox&amp;gt;&#xA;#include &amp;lt;QSlider&amp;gt;&#xA;#include &amp;lt;QHBoxLayout&amp;gt;&#xA;&#xA;int main(int argc, char *argv[])&#xA;{&#xA;&#xA;    // -------------------------------- //&#xA;    // 解决中文字体乱码问题&#xA;&#xA;    QTextCodec::setCodecForTr(QTextCodec::codecForName(&amp;quot;UTF-8&amp;quot;));&#xA;    QTextCodec::setCodecForLocale(QTextCodec::codecForName(&amp;quot;UTF-8&amp;quot;));&#xA;    QTextCodec::setCodecForCStrings(QTextCodec::codecForName(&amp;quot;UTF-8&amp;quot;));&#xA;&#xA;    // -------------------------------- //&#xA;    // APP框架，用来管理整个应用程序资源&#xA;&#xA;    QApplication app(argc, argv);&#xA;&#xA;    // -------------------------------- //&#xA;    // 按钮事件&#xA;&#xA;    // QPushButton * button = new QPushButton(&amp;quot;QUIT&amp;quot;);&#xA;    // QObject::connect(button, SIGNAL(clicked()), &amp;amp;app, SLOT(quit()));&#xA;    // button-&amp;gt;show();&#xA;&#xA;    // -------------------------------- //&#xA;&#xA;    // 窗口部件&#xA;    QWidget *window = new QWidget;&#xA;    // 设置标题&#xA;    window-&amp;gt;setWindowTitle(&amp;quot;Enter Your Age&amp;quot;);&#xA;&#xA;    // 微调框&#xA;    QSpinBox * spinBox = new QSpinBox;&#xA;    spinBox-&amp;gt;setRange(0, 130);&#xA;&#xA;    // 滑动条&#xA;    QSlider * slider = new QSlider(Qt::Horizontal);&#xA;    slider-&amp;gt;setRange(0, 130);&#xA;&#xA;    // 连接触发微调框修改滑框&#xA;    QObject::connect(spinBox, SIGNAL(valueChanged(int)),&#xA;             slider, SLOT(setValue(int)));&#xA;&#xA;    // 连接触发滑动条修改微调框&#xA;    QObject::connect(slider, SIGNAL(valueChanged(int)),&#xA;             spinBox, SLOT(setValue(int)));&#xA;&#xA;    // 设置滑动条值&#xA;    slider-&amp;gt;setValue(35);&#xA;&#xA;    // 设置滑动条值&#xA;    spinBox-&amp;gt;setValue(35);&#xA;&#xA;    // 竖直布局&#xA;    // QVBoxLayout *layout = new QVBoxLayout;&#xA;    // 把窗口排列在一个网格中&#xA;    // QGridLayout *layout = new QGridLayout;&#xA;    // 水平布局&#xA;    QHBoxLayout * layout = new QHBoxLayout;&#xA;&#xA;    // 向布局增加组建&#xA;    layout-&amp;gt;addWidget(spinBox);&#xA;    layout-&amp;gt;addWidget(slider);&#xA;&#xA;    // 将布局设置给窗口&#xA;    window-&amp;gt;setLayout(layout);&#xA;    window-&amp;gt;show();&#xA;&#xA;    // -------------------------------- //&#xA;&#xA;    return app.exec();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-GUI</title>
      <link>http://www.nljb.net/default/Golang-GUI/</link>
      <pubDate>2014-09-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有道词典例子（摘抄自网络）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;encoding/json&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;github.com/andlabs/ui&amp;quot;&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;net/url&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;    &amp;quot;regexp&amp;quot;&#xA;)&#xA;&#xA;//从有道获取的JSON的解析结构&#xA;type basic struct {&#xA;    Us_Phonetic string&#xA;    Phonetic    string&#xA;    Uk_Phonetic string&#xA;    Explains    []string&#xA;}&#xA;type web struct {&#xA;    Value []string&#xA;    Key   string&#xA;}&#xA;type Youdao struct {&#xA;    Translation []string&#xA;    Basic       basic&#xA;    Query       string&#xA;    ErrorCode   int32&#xA;    Web         []web&#xA;}&#xA;&#xA;//从百度获取的输入反馈中的部分&#xA;type str struct {&#xA;    WordsToSearch string&#xA;}&#xA;&#xA;var (&#xA;    w     ui.Window&#xA;    si    ui.Label&#xA;    al    ui.Label&#xA;    table ui.Table&#xA;    input ui.TextField&#xA;    proxy string&#xA;)&#xA;&#xA;func main() {&#xA;    if len(os.Args) != 1 {&#xA;        t := getJSON(getWords())&#xA;        fmt.Println(simple(t))&#xA;    } else {&#xA;        go ui.Do(gui)&#xA;        err := ui.Go()&#xA;        if err != nil {&#xA;            panic(err)&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;//gui界面，用的 github.com/andlabs/ui 的ui库&#xA;func gui() {&#xA;    input = ui.NewTextField()&#xA;    input.OnChanged(func() {&#xA;        go feedback() // 主要是这里在不同的刷新(table)内容&#xA;    })&#xA;    button := ui.NewButton(&amp;quot;查词&amp;quot;)&#xA;    button.OnClicked(guiTranslate)&#xA;    inputBox := ui.NewHorizontalStack(input, button)&#xA;    inputBox.SetStretchy(0)&#xA;&#xA;    tab := ui.NewTab()&#xA;    table = ui.NewTable(reflect.TypeOf(str{}))&#xA;    table.OnSelected(tableSelected)&#xA;    tab.Append(&amp;quot;单词&amp;quot;, table)&#xA;    si = ui.NewLabel(&amp;quot;Simple&amp;quot;)&#xA;    tab.Append(&amp;quot;简约&amp;quot;, si)&#xA;    al = ui.NewLabel(&amp;quot;All&amp;quot;)&#xA;    tab.Append(&amp;quot;全部&amp;quot;, al)&#xA;&#xA;    stack := ui.NewVerticalStack(inputBox, tab)&#xA;    stack.SetStretchy(1)&#xA;&#xA;    w = ui.NewWindow(&amp;quot;Window&amp;quot;, 280, 350, stack)&#xA;    w.OnClosing(func() bool {&#xA;        ui.Stop()&#xA;        return true&#xA;    })&#xA;    w.Show()&#xA;}&#xA;&#xA;//取词并在屏幕上显示&#xA;func guiTranslate() {&#xA;    t := getJSON(input.Text())&#xA;    si.SetText(simple(t))&#xA;    al.SetText(all(t))&#xA;}&#xA;&#xA;//输入反馈功能，用的百度的输入反馈接口&#xA;func feedback() {&#xA;    table.Lock()&#xA;    d := table.Data().(*[]str)&#xA;    *d = []str{}&#xA;    table.Unlock()&#xA;    in := input.Text()&#xA;    conn := Proxy()&#xA;    address := &amp;quot;HTTP://nssug.baidu.com/su?prod=recon_dict&amp;amp;wd=&amp;quot; + in&#xA;    resp, err := conn.Get(address)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Connect error&amp;quot;)&#xA;        os.Exit(3)&#xA;    }&#xA;    t, _ := ioutil.ReadAll(resp.Body)&#xA;    t = regexp.MustCompile(`\[.+`).Find(t)&#xA;    tmp := regexp.MustCompile(`\b\w+?\b`).FindAllString(string(t), -1)&#xA;    s := make([]str, len(tmp))&#xA;    for i, key := range tmp {&#xA;        s[i].WordsToSearch = key&#xA;    }&#xA;    table.Lock()&#xA;    d = table.Data().(*[]str)&#xA;    *d = s&#xA;    table.Unlock()&#xA;}&#xA;&#xA;//输入反馈功能，反馈项被选中时进行查房&#xA;func tableSelected() {&#xA;    i := table.Selected()&#xA;    data := table.Data().(*[]str)&#xA;    d := *data&#xA;    t := getJSON(d[i].WordsToSearch)&#xA;    si.SetText(simple(t))&#xA;    al.SetText(all(t))&#xA;}&#xA;&#xA;//以简洁的方式输出翻译的string&#xA;func simple(y *Youdao) string {&#xA;    text := y.Query&#xA;    if len(y.Basic.Explains) == 0 {&#xA;        text = text + &amp;quot;\nNo translation, please check your word&amp;quot;&#xA;    } else {&#xA;        for _, t := range y.Translation {&#xA;            text += &amp;quot;\n&amp;quot; + t&#xA;        }&#xA;        for i, t := range y.Basic.Explains {&#xA;            if (i == 0) &amp;amp;&amp;amp; (t == y.Translation[0]) {&#xA;            } else if i == 0 {&#xA;                text += &amp;quot;\n\n&amp;quot; + t&#xA;            } else {&#xA;                text += &amp;quot;\n&amp;quot; + t&#xA;            }&#xA;        }&#xA;    }&#xA;    return text&#xA;}&#xA;&#xA;//输出全部有道翻译反馈的string&#xA;func all(y *Youdao) string {&#xA;    text := y.Query&#xA;    if len(y.Basic.Explains) == 0 {&#xA;        text = text + &amp;quot;\nNo translation, please check your word&amp;quot;&#xA;    } else {&#xA;        for _, t := range y.Translation {&#xA;            text += &amp;quot;\n&amp;quot; + t&#xA;        }&#xA;        for i, t := range y.Basic.Explains {&#xA;            if (i == 0) &amp;amp;&amp;amp; (t == y.Translation[0]) {&#xA;            } else if i == 0 {&#xA;                text += &amp;quot;\n\n&amp;quot; + t&#xA;            } else {&#xA;                text += &amp;quot;\n&amp;quot; + t&#xA;            }&#xA;        }&#xA;        for _, t := range y.Web {&#xA;            text += &amp;quot;\n\n&amp;quot; + t.Key&#xA;            for i, tmp := range t.Value {&#xA;                if i == 0 {&#xA;                    text += &amp;quot;\n&amp;quot; + tmp&#xA;                } else {&#xA;                    text += &amp;quot;;&amp;quot; + tmp&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;    return text&#xA;}&#xA;&#xA;//根据输入单词取得翻译结果并解析为一个struct&#xA;func getJSON(words string) *Youdao {&#xA;    conn := Proxy()&#xA;    address := &amp;quot;http://fanyi.youdao.com/openapi.do?keyfrom=&amp;quot; +&#xA;        &amp;quot;GoldenDictPlugin&amp;quot; + &amp;quot;&amp;amp;key=&amp;quot; + &amp;quot;1683580050&amp;quot; +&#xA;        &amp;quot;&amp;amp;type=data&amp;amp;doctype=json&amp;amp;version=1.1&amp;amp;q=&amp;quot; + words&#xA;    resp, err := conn.Get(address)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Connect error&amp;quot;)&#xA;        os.Exit(1)&#xA;    }&#xA;    j, _ := ioutil.ReadAll(resp.Body)&#xA;&#xA;    var data *Youdao&#xA;    err = json.Unmarshal(j, &amp;amp;data)&#xA;    if err != nil {&#xA;        fmt.Println(err)&#xA;        os.Exit(5)&#xA;    }&#xA;    return data&#xA;}&#xA;&#xA;//命令行模式下获取作为参数传入的单词&#xA;func getWords() string {&#xA;    var words string&#xA;    l := len(os.Args)&#xA;    if l == 1 {&#xA;        os.Exit(0)&#xA;    } else {&#xA;        words = url.QueryEscape(os.Args[1])&#xA;    }&#xA;    for i := 2; i &amp;lt; l; i++ {&#xA;        words = words + &amp;quot;%20&amp;quot; + url.QueryEscape(os.Args[i])&#xA;    }&#xA;    return words&#xA;}&#xA;&#xA;//返回一个可设置代理的 http Client，代理在全局变量 proxy 中设定&#xA;func Proxy() *http.Client {&#xA;    var conn http.Client&#xA;    if proxy != &amp;quot;&amp;quot; {&#xA;        proxyUrl, err := url.Parse(proxy)&#xA;        if err != nil {&#xA;            fmt.Println(err)&#xA;            os.Exit(2)&#xA;        }&#xA;        conn.Transport = &amp;amp;http.Transport{Proxy: http.ProxyURL(proxyUrl)}&#xA;    }&#xA;    return &amp;amp;conn&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-GUI-客户端</title>
      <link>http://www.nljb.net/default/Golang-GUI-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>2014-09-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;自己写了个例子，学习学习&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;github.com/andlabs/ui&amp;quot;&#xA;    //z &amp;quot;github.com/nutzam/zgo&amp;quot;&#xA;    //&amp;quot;io/ioutil&amp;quot;&#xA;    //&amp;quot;net/http&amp;quot;&#xA;    //&amp;quot;net/url&amp;quot;&#xA;    //&amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;    //&amp;quot;regexp&amp;quot;&#xA;    &amp;quot;encoding/json&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;runtime&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;var (&#xA;    Status = false&#xA;    Server = &amp;quot;127.0.0.1:8080&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    // 设置CPU核心数量&#xA;    runtime.GOMAXPROCS(runtime.NumCPU())&#xA;&#xA;    // 设置日志的结构&#xA;    log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime | log.Lmicroseconds)&#xA;&#xA;    go ui.Do(initGUI)&#xA;&#xA;    err := ui.Go()&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;}&#xA;&#xA;func initGUI() {&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    //// 创建一个标签&#xA;    //serLable := ui.NewLabel(&amp;quot;服务器:&amp;quot;)&#xA;&#xA;    //// 创建一个文本输入区域&#xA;    //serAddr = ui.NewTextField()&#xA;&#xA;    //// 设置文本输入区域事件&#xA;    //serAddr.OnChanged(func() {&#xA;    //  go feedback()&#xA;    //})&#xA;&#xA;    //// 创建一个按钮&#xA;    //connButton := ui.NewButton(&amp;quot;连接&amp;quot;)&#xA;&#xA;    //// 设置按钮事件&#xA;    //connButton.OnClicked(guiTranslate)&#xA;&#xA;    //// 设置为横向排列结构&#xA;    //serAddr := ui.NewHorizontalStack(serLable, serAddr, connButton)&#xA;&#xA;    //// 设置第二个对象弹性填充&#xA;    //serAddr.SetStretchy(1)&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    // 系统&#xA;    sysTable := ui.NewTable(reflect.TypeOf(Sys{}))&#xA;&#xA;    // 系统更新线程&#xA;    go (func() {&#xA;&#xA;        for {&#xA;&#xA;            // ------------------------- //&#xA;            sysTable.Lock()&#xA;            d := sysTable.Data().(*[]Sys)&#xA;            *d = []Sys{}&#xA;            sysTable.Unlock()&#xA;            // ------------------------- //&#xA;&#xA;            var systems Systems&#xA;&#xA;            // 获取系统信息&#xA;            sysData, err := Request(fmt.Sprintf(&amp;quot;http://%s/wsys&amp;quot;, Server))&#xA;            if err != nil {&#xA;                Status = false&#xA;                log.Println(err)&#xA;                time.Sleep(1 * time.Second)&#xA;                continue&#xA;            } else {&#xA;                Status = true&#xA;            }&#xA;&#xA;            err = json.Unmarshal(*sysData, &amp;amp;systems)&#xA;            if err != nil {&#xA;                log.Println(err)&#xA;                time.Sleep(1 * time.Second)&#xA;                continue&#xA;            }&#xA;&#xA;            s := make([]Sys, len(systems.System))&#xA;            for i, systems := range systems.System {&#xA;                s[i].Name = (*systems).Name&#xA;                s[i].Sysboot = (*systems).Sysboot&#xA;                s[i].System = (*systems).System&#xA;                s[i].Remote_command = (*systems).Remote_command&#xA;            }&#xA;&#xA;            // ------------------------- //&#xA;            sysTable.Lock()&#xA;            d = sysTable.Data().(*[]Sys)&#xA;            *d = s&#xA;            sysTable.Unlock()&#xA;            // ------------------------- //&#xA;&#xA;            time.Sleep(1 * time.Second)&#xA;&#xA;        }&#xA;&#xA;    })()&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    // 创建一组系统数据列表&#xA;    evos := make([]Evo, 0)&#xA;&#xA;    evos = append(evos, Evo{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;})&#xA;    evos = append(evos, Evo{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;})&#xA;    evos = append(evos, Evo{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;})&#xA;    evos = append(evos, Evo{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;})&#xA;    evos = append(evos, Evo{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;})&#xA;    evos = append(evos, Evo{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;})&#xA;    evos = append(evos, Evo{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;})&#xA;&#xA;    // 创建表,并导入系统数据&#xA;    evoTable := ui.NewTable(reflect.TypeOf(evos[0]))&#xA;    evoTable.Lock()&#xA;    *(evoTable.Data().(*[]Evo)) = evos&#xA;    evoTable.Unlock()&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    // 创建一组系统数据列表&#xA;    mbrs := make([]Mbr, 0)&#xA;    mbrs = append(mbrs, Mbr{&amp;quot;1&amp;quot;})&#xA;    mbrs = append(mbrs, Mbr{&amp;quot;1&amp;quot;})&#xA;    mbrs = append(mbrs, Mbr{&amp;quot;1&amp;quot;})&#xA;&#xA;    // 创建表,并导入系统数据&#xA;    mbrTable := ui.NewTable(reflect.TypeOf(mbrs[0]))&#xA;    mbrTable.Lock()&#xA;    *(mbrTable.Data().(*[]Mbr)) = mbrs&#xA;    mbrTable.Unlock()&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    // 创建一组系统数据列表&#xA;    patchs := make([]Patch, 0)&#xA;    patchs = append(patchs, Patch{&amp;quot;1&amp;quot;})&#xA;    patchs = append(patchs, Patch{&amp;quot;1&amp;quot;})&#xA;    patchs = append(patchs, Patch{&amp;quot;1&amp;quot;})&#xA;&#xA;    // 创建表,并导入系统数据&#xA;    patchTable := ui.NewTable(reflect.TypeOf(patchs[0]))&#xA;    patchTable.Lock()&#xA;    *(patchTable.Data().(*[]Patch)) = patchs&#xA;    patchTable.Unlock()&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    // 创建一组系统数据列表&#xA;    runs := make([]Run, 0)&#xA;    runs = append(runs, Run{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;})&#xA;    runs = append(runs, Run{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;})&#xA;    runs = append(runs, Run{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;})&#xA;    runs = append(runs, Run{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;})&#xA;&#xA;    // 创建表,并导入系统数据&#xA;    runTable := ui.NewTable(reflect.TypeOf(runs[0]))&#xA;    runTable.Lock()&#xA;    *(runTable.Data().(*[]Run)) = runs&#xA;    runTable.Unlock()&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    // 创建一个标签&#xA;    tab := ui.NewTab()&#xA;    // 将表加入标签&#xA;    tab.Append(&amp;quot;系统&amp;quot;, sysTable)&#xA;    // 将表加入标签&#xA;    tab.Append(&amp;quot;进化&amp;quot;, evoTable)&#xA;    // 将表加入标签&#xA;    tab.Append(&amp;quot;分区表&amp;quot;, mbrTable)&#xA;    // 将表加入标签&#xA;    tab.Append(&amp;quot;补丁&amp;quot;, patchTable)&#xA;    // 将表加入标签&#xA;    tab.Append(&amp;quot;运行&amp;quot;, runTable)&#xA;&#xA;    // ------------------------------------------- //&#xA;&#xA;    // 垂直堆叠&#xA;    stack := ui.NewVerticalStack(tab)&#xA;&#xA;    // 弹性填充&#xA;    stack.SetStretchy(0)&#xA;&#xA;    // 布局窗口&#xA;    w := ui.NewWindow(&amp;quot;北京德纳科技有限公司&amp;quot;, 800, 400, stack)&#xA;    w.OnClosing(func() bool {&#xA;        ui.Stop()&#xA;        return true&#xA;    })&#xA;    go (func() {&#xA;        for {&#xA;            if Status {&#xA;                w.SetTitle(&amp;quot;北京德纳科技有限公司(在线)&amp;quot;)&#xA;            } else {&#xA;                w.SetTitle(&amp;quot;北京德纳科技有限公司(离线)&amp;quot;)&#xA;            }&#xA;            w.Show()&#xA;            time.Sleep(1 * time.Second)&#xA;        }&#xA;    })()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Andlabs-GUI</title>
      <link>http://www.nljb.net/default/Golang-Andlabs-GUI/</link>
      <pubDate>2014-09-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;例子 &amp;ldquo;github.com/andlabs/ui&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Andlabs-GUI/1.png&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;    &amp;quot;github.com/andlabs/ui&amp;quot;&#xA;)&#xA;&#xA;var w ui.Window&#xA;&#xA;type areaHandler struct {&#xA;    img     *image.RGBA&#xA;}&#xA;&#xA;func (a *areaHandler) Paint(rect image.Rectangle) *image.RGBA {&#xA;    return a.img.SubImage(rect).(*image.RGBA)&#xA;}&#xA;&#xA;func (a *areaHandler) Mouse(me ui.MouseEvent) {}&#xA;func (a *areaHandler) Key(ke ui.KeyEvent) bool { return false }&#xA;&#xA;func initGUI() {&#xA;    b := ui.NewButton(&amp;quot;Button&amp;quot;)&#xA;    c := ui.NewCheckbox(&amp;quot;Checkbox&amp;quot;)&#xA;    tf := ui.NewTextField()&#xA;    tf.SetText(&amp;quot;Text Field&amp;quot;)&#xA;    pf := ui.NewPasswordField()&#xA;    pf.SetText(&amp;quot;Password Field&amp;quot;)&#xA;    l := ui.NewStandaloneLabel(&amp;quot;Label&amp;quot;)&#xA;&#xA;    t := ui.NewTab()&#xA;    t.Append(&amp;quot;Tab 1&amp;quot;, ui.Space())&#xA;    t.Append(&amp;quot;Tab 2&amp;quot;, ui.Space())&#xA;    t.Append(&amp;quot;Tab 3&amp;quot;, ui.Space())&#xA;&#xA;    g := ui.NewGroup(&amp;quot;Group&amp;quot;, ui.Space())&#xA;&#xA;    icons, il := readIcons()&#xA;    table := ui.NewTable(reflect.TypeOf(icons[0]))&#xA;    table.Lock()&#xA;    d := table.Data().(*[]icon)&#xA;    *d = icons&#xA;    table.Unlock()&#xA;    table.LoadImageList(il)&#xA;&#xA;    area := ui.NewArea(200, 200, &amp;amp;areaHandler{tileImage(20)})&#xA;&#xA;    stack := ui.NewVerticalStack(&#xA;        b,&#xA;        c,&#xA;        tf,&#xA;        pf,&#xA;        l,&#xA;        t,&#xA;        g,&#xA;        table,&#xA;        area)&#xA;    stack.SetStretchy(5)&#xA;    stack.SetStretchy(6)&#xA;    stack.SetStretchy(7)&#xA;    stack.SetStretchy(8)&#xA;&#xA;    w = ui.NewWindow(&amp;quot;Window&amp;quot;, 400, 500, stack)&#xA;    w.OnClosing(func() bool {&#xA;        ui.Stop()&#xA;        return true&#xA;    })&#xA;    w.Show()&#xA;}&#xA;&#xA;func main() {&#xA;    go ui.Do(initGUI)&#xA;    err := ui.Go()&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;bytes&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/draw&amp;quot;&#xA;    _ &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;github.com/andlabs/ui&amp;quot;&#xA;)&#xA;&#xA;type icon struct {&#xA;    Name    string&#xA;    Icon        ui.ImageIndex&#xA;    Bool        bool&#xA;}&#xA;&#xA;var firstimg *image.RGBA&#xA;&#xA;func readIcons() ([]icon, ui.ImageList) {&#xA;    out := make([]icon, len(icons))&#xA;    outil := ui.NewImageList()&#xA;    for i := range icons {&#xA;        r := bytes.NewReader(icons[i].data)&#xA;        png, _, err := image.Decode(r)&#xA;        if err != nil {&#xA;            panic(fmt.Errorf(&amp;quot;error loading image %d (%q): %v&amp;quot;, i, icons[i].name, err))&#xA;        }&#xA;        img := image.NewRGBA(png.Bounds())&#xA;        draw.Draw(img, img.Rect, png, image.ZP, draw.Src)&#xA;        if firstimg == nil {&#xA;            firstimg = img&#xA;        }&#xA;        out[i].Icon = ui.ImageIndex(i)&#xA;        out[i].Name = icons[i].name&#xA;        outil.Append(img)&#xA;    }&#xA;    return out, outil&#xA;}&#xA;&#xA;func tileImage(times int) *image.RGBA {&#xA;    dx := firstimg.Rect.Dx()&#xA;    dy := firstimg.Rect.Dy()&#xA;    res := image.NewRGBA(image.Rect(0, 0, times * dx, times * dy))&#xA;    r := image.Rect(0, 0, dx, dy)&#xA;    for y := 0; y &amp;lt; times; y++ {&#xA;        rr := r.Add(image.Pt(0, y * dy))&#xA;        for x := 0; x &amp;lt; times; x++ {&#xA;            draw.Draw(res, rr, firstimg, image.ZP, draw.Src)&#xA;            rr = rr.Add(image.Pt(dx, 0))&#xA;        }&#xA;    }&#xA;    return res&#xA;}&#xA;&#xA;var icons = []struct {&#xA;    data        []byte&#xA;    name    string&#xA;}{&#xA;    { __16x16_categories_applications_accessories_png, &amp;quot;16x16/categories/applications-accessories.png&amp;quot;, },&#xA;    { __16x16_places_folder_png, &amp;quot;16x16/places/folder.png&amp;quot;, },&#xA;    { __16x16_mimetypes_x_office_spreadsheet_png, &amp;quot;16x16/mimetypes/x-office-spreadsheet.png&amp;quot;, },&#xA;    { __32x32_categories_applications_accessories_png, &amp;quot;32x32/categories/applications-accessories.png&amp;quot;, },&#xA;    { __32x32_places_folder_png, &amp;quot;32x32/places/folder.png&amp;quot;, },&#xA;    { __32x32_mimetypes_x_office_spreadsheet_png, &amp;quot;32x32/mimetypes/x-office-spreadsheet.png&amp;quot;, },&#xA;}&#xA;&#xA;// from http://tango.freedesktop.org/releases/tango-icon-theme-0.8.90.tar.gz, which is public domain&#xA;&#xA;var __16x16_categories_applications_accessories_png = []byte{&#xA;  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,&#xA;  0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,&#xA;  0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0xf3, 0xff, 0x61, 0x00, 0x00, 0x00,&#xA;  0x06, 0x62, 0x4b, 0x47, 0x44, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xa0,&#xA;  0xbd, 0xa7, 0x93, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00,&#xA;  0x00, 0x0b, 0x13, 0x00, 0x00, 0x0b, 0x13, 0x01, 0x00, 0x9a, 0x9c, 0x18,&#xA;  0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d, 0x45, 0x07, 0xd5, 0x0b, 0x1c,&#xA;  0x17, 0x38, 0x22, 0x38, 0xae, 0xb6, 0xe0, 0x00, 0x00, 0x03, 0x36, 0x49,&#xA;  0x44, 0x41, 0x54, 0x38, 0xcb, 0x5d, 0x93, 0x4b, 0x4c, 0x5c, 0x75, 0x14,&#xA;  0xc6, 0xbf, 0xff, 0x63, 0xe6, 0xde, 0x79, 0x80, 0x73, 0x41, 0x60, 0x66,&#xA;  0x80, 0xa2, 0x13, 0x04, 0x9a, 0x49, 0x53, 0x13, 0x17, 0xc5, 0x57, 0xdd,&#xA;  0x18, 0x4a, 0xd2, 0x8d, 0xa9, 0x55, 0x1b, 0x1f, 0xab, 0x36, 0xc1, 0x54,&#xA;  0x6b, 0xd5, 0xd2, 0x66, 0x48, 0x43, 0x1a, 0x62, 0xa2, 0x0d, 0x94, 0x58,&#xA;  0x9b, 0x34, 0xac, 0x4c, 0x88, 0x8f, 0x85, 0x1b, 0x5c, 0x11, 0x12, 0xbb,&#xA;  0xa8, 0xa6, 0x34, 0x5d, 0x18, 0xb5, 0x75, 0x0c, 0x1d, 0xa8, 0x34, 0xf2,&#xA;  0x98, 0x29, 0x65, 0x18, 0xc6, 0x0e, 0x33, 0x70, 0xe7, 0xce, 0xfd, 0xff,&#xA;  0x8f, 0x1b, 0xc0, 0x49, 0xbf, 0xd5, 0x39, 0xdf, 0xc9, 0xf7, 0xcb, 0x49,&#xA;  0x4e, 0x0e, 0xc3, 0xb6, 0x46, 0x46, 0x2f, 0xf6, 0x02, 0xf8, 0xce, 0x34,&#xA;  0xcd, 0x87, 0xa7, 0x3e, 0xf8, 0x38, 0x8e, 0x2a, 0x8d, 0x8c, 0x5e, 0x1c,&#xA;  0x93, 0x52, 0xbe, 0xf5, 0xc9, 0xe9, 0xfe, 0xba, 0x6a, 0x7f, 0x7a, 0x1c,&#xA;  0xef, 0xf1, 0x9d, 0x46, 0x08, 0x31, 0xf1, 0xe1, 0xc9, 0xd3, 0x96, 0x6d,&#xA;  0xdb, 0x8b, 0x57, 0xc7, 0xae, 0x0c, 0xee, 0xf8, 0x97, 0xbf, 0x1a, 0xcd,&#xA;  0x1c, 0xea, 0xe9, 0xed, 0x03, 0x70, 0xe7, 0xb1, 0xf0, 0xcb, 0x00, 0xbe,&#xA;  0xde, 0x05, 0x28, 0xa5, 0xcc, 0x7b, 0xf3, 0xb3, 0xfc, 0xc4, 0xf1, 0xbe,&#xA;  0x1e, 0xa5, 0xd4, 0x7e, 0x00, 0x18, 0xbe, 0xf4, 0xc5, 0x2b, 0xd1, 0xe6,&#xA;  0x68, 0xa4, 0x58, 0xda, 0x60, 0x5a, 0xeb, 0xee, 0xaa, 0x70, 0x3b, 0xe3,&#xA;  0x62, 0x92, 0x31, 0xe1, 0xd9, 0x05, 0x70, 0xce, 0x4b, 0x0b, 0x0b, 0xff,&#xA;  0xc0, 0x34, 0x0c, 0x56, 0x2e, 0x97, 0xe3, 0x57, 0xc7, 0xae, 0x0c, 0x4a,&#xA;  0x29, 0xaf, 0xc5, 0x62, 0x31, 0xac, 0x3c, 0x58, 0xd1, 0x5a, 0xeb, 0xf9,&#xA;  0xed, 0xb0, 0xc5, 0x85, 0xb8, 0xde, 0xd1, 0xfd, 0x69, 0x50, 0x78, 0x6a,&#xA;  0x54, 0xf5, 0x06, 0x3d, 0xa9, 0x54, 0x0a, 0xcb, 0xe9, 0x25, 0x76, 0xe2,&#xA;  0x78, 0x5f, 0xa7, 0x6d, 0xdb, 0xef, 0x77, 0x75, 0x75, 0x79, 0x18, 0x38,&#xA;  0xe6, 0xef, 0xcf, 0x03, 0xc0, 0x0f, 0xd3, 0xe3, 0xf0, 0x70, 0x21, 0xa6,&#xA;  0x5a, 0xe3, 0x47, 0x9b, 0xea, 0x5a, 0x0e, 0x31, 0x00, 0xd8, 0x05, 0x9c,&#xA;  0xeb, 0x1f, 0xb8, 0xc5, 0x39, 0x5f, 0x9c, 0x9b, 0x9b, 0x85, 0x69, 0x98,&#xA;  0xcc, 0x0a, 0x59, 0x51, 0xd2, 0x40, 0x76, 0x6d, 0x55, 0x03, 0x98, 0x3c,&#xA;  0x7b, 0x26, 0xf1, 0x19, 0x17, 0x62, 0xbc, 0xbe, 0xf9, 0xc0, 0xfe, 0x68,&#xA;  0xc7, 0x9b, 0x1e, 0x50, 0x09, 0x44, 0xf4, 0x3f, 0x00, 0x00, 0xb4, 0xd6,&#xA;  0x47, 0x66, 0xee, 0xce, 0xd0, 0xea, 0xea, 0x0a, 0x5c, 0xe5, 0x62, 0x63,&#xA;  0xa3, 0x80, 0x64, 0x32, 0xe9, 0x00, 0x18, 0xba, 0xf9, 0x0d, 0x3f, 0xef,&#xA;  0x0f, 0xb5, 0xbd, 0x16, 0x7b, 0xee, 0x94, 0xe9, 0x16, 0x27, 0xa1, 0xdd,&#xA;  0x0d, 0x00, 0x8f, 0x01, 0xce, 0x9e, 0x49, 0xfc, 0xc6, 0x39, 0xff, 0x76,&#xA;  0x76, 0x2e, 0xa5, 0x43, 0xa1, 0x10, 0x32, 0x0f, 0x32, 0x44, 0x44, 0xe3,&#xA;  0xcf, 0xd7, 0x27, 0x9e, 0xf2, 0x78, 0x6b, 0xcf, 0x77, 0x76, 0x0f, 0xf8,&#xA;  0xdd, 0xd2, 0x34, 0x2a, 0x5b, 0x8b, 0xd0, 0xca, 0x06, 0x88, 0xc0, 0xaa,&#xA;  0x01, 0x13, 0xe1, 0xf0, 0xa8, 0x4b, 0x74, 0xd2, 0xcd, 0xe7, 0x4d, 0xb8,&#xA;  0x2e, 0x9e, 0x0e, 0x37, 0x21, 0x4d, 0x7a, 0x33, 0x78, 0xd0, 0xf6, 0xbe,&#xA;  0x70, 0x69, 0x40, 0x4a, 0xbe, 0x86, 0x62, 0xee, 0x06, 0x0c, 0xd3, 0x84,&#xA;  0x37, 0xf4, 0x06, 0x6e, 0xff, 0x94, 0x50, 0x02, 0x00, 0x26, 0x22, 0x91,&#xA;  0xc1, 0x23, 0x95, 0xca, 0xf5, 0x4e, 0xcb, 0xea, 0x0e, 0x09, 0x21, 0x95,&#xA;  0x72, 0xa9, 0xec, 0x3a, 0xa8, 0x0b, 0xd4, 0xb0, 0x46, 0xd3, 0xf0, 0x18,&#xA;  0xcb, 0x26, 0xff, 0x75, 0x78, 0x0a, 0x9e, 0xc6, 0x1c, 0xb2, 0x5b, 0x77,&#xA;  0x11, 0x6a, 0x6c, 0x02, 0xf7, 0xb6, 0x63, 0xf5, 0xfe, 0xcf, 0xc4, 0x7f,&#xA;  0x8c, 0x46, 0xdf, 0x75, 0x72, 0xb9, 0xa1, 0xce, 0x70, 0x58, 0xcf, 0x2c,&#xA;  0x2d, 0x5d, 0x2b, 0x6c, 0x6d, 0x3a, 0xf9, 0xc2, 0x06, 0xf7, 0x1d, 0xd6,&#xA;  0x2d, 0x42, 0x32, 0xfc, 0x6b, 0x97, 0x50, 0x88, 0x99, 0x68, 0x6f, 0xa8,&#xA;  0x47, 0x32, 0x31, 0x87, 0xfc, 0x94, 0x44, 0xc5, 0x71, 0xa0, 0xdd, 0x32,&#xA;  0x08, 0x04, 0xee, 0x3a, 0xce, 0xf0, 0xbe, 0xd6, 0x56, 0x4a, 0x2d, 0x2f,&#xA;  0x5f, 0x38, 0xa6, 0x54, 0x6f, 0xad, 0xe9, 0x53, 0xc2, 0xe7, 0x53, 0x8d,&#xA;  0xaf, 0xf3, 0xef, 0xff, 0xce, 0xac, 0x20, 0x18, 0x0c, 0x20, 0xfe, 0x65,&#xA;  0x03, 0xf2, 0x2f, 0xad, 0xb9, 0x7b, 0xa3, 0x11, 0x2a, 0xde, 0xf0, 0x42,&#xA;  0x55, 0x2a, 0x70, 0xdd, 0x4d, 0x80, 0x08, 0x1c, 0xe5, 0x72, 0xbd, 0xe3,&#xA;  0x38, 0xea, 0x98, 0x52, 0x9f, 0x4f, 0x06, 0x02, 0x97, 0x3d, 0x52, 0x9a,&#xA;  0xc2, 0x42, 0xc1, 0x6f, 0xb5, 0x1f, 0x08, 0x3d, 0xbb, 0x07, 0x7e, 0x92,&#xA;  0xb8, 0x37, 0xf4, 0x17, 0xcc, 0x57, 0xb7, 0x24, 0x18, 0x31, 0x5d, 0xd0,&#xA;  0x70, 0x1d, 0x07, 0xaa, 0xb2, 0x09, 0x80, 0x20, 0xe1, 0xf5, 0x66, 0x82,&#xA;  0x7e, 0xff, 0x9e, 0xdb, 0x6d, 0x6d, 0x65, 0xad, 0xb5, 0x9c, 0x59, 0x4b,&#xA;  0x17, 0x9b, 0x2f, 0x3c, 0xe1, 0x6f, 0xd9, 0x7b, 0xd4, 0x08, 0x9c, 0xfb,&#xA;  0x05, 0xc9, 0x8f, 0xfe, 0x40, 0xc7, 0x9d, 0x30, 0x2a, 0xbf, 0xd7, 0x40,&#xA;  0x6b, 0x82, 0xac, 0x95, 0x50, 0xda, 0xdd, 0x06, 0x00, 0xe2, 0x6d, 0xcb,&#xA;  0xca, 0xa5, 0xd7, 0xd7, 0x5f, 0x5c, 0x77, 0x1c, 0x99, 0x67, 0xc4, 0xc2,&#xA;  0xfd, 0x5a, 0x3c, 0x73, 0xf8, 0x1d, 0x83, 0x73, 0x0f, 0x8c, 0x86, 0x27,&#xA;  0x61, 0x44, 0xeb, 0x90, 0x5e, 0xc8, 0x22, 0x9b, 0x2d, 0xe0, 0x91, 0x57,&#xA;  0x21, 0x3e, 0x72, 0x10, 0xbe, 0x48, 0x0c, 0x44, 0x0c, 0x8f, 0x1e, 0xfe,&#xA;  0x49, 0xac, 0xea, 0x41, 0xf6, 0x01, 0xb8, 0xc5, 0x98, 0x34, 0x85, 0xf4,&#xA;  0x3b, 0x00, 0x01, 0x44, 0xdb, 0x53, 0xda, 0x3d, 0x35, 0xed, 0xd4, 0x44,&#xA;  0x50, 0xca, 0xf6, 0xfd, 0x07, 0x11, 0xa6, 0x73, 0x42, 0xc7, 0xee, 0xef,&#xA;  0xaa, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60,&#xA;  0x82,&#xA;}&#xA;&#xA;var __16x16_places_folder_png = []byte{&#xA;  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,&#xA;  0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,&#xA;  0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0xf3, 0xff, 0x61, 0x00, 0x00, 0x00,&#xA;  0x04, 0x73, 0x42, 0x49, 0x54, 0x08, 0x08, 0x08, 0x08, 0x7c, 0x08, 0x64,&#xA;  0x88, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0d,&#xA;  0xd7, 0x00, 0x00, 0x0d, 0xd7, 0x01, 0x42, 0x28, 0x9b, 0x78, 0x00, 0x00,&#xA;  0x00, 0x19, 0x74, 0x45, 0x58, 0x74, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61,&#xA;  0x72, 0x65, 0x00, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x6e, 0x6b, 0x73, 0x63,&#xA;  0x61, 0x70, 0x65, 0x2e, 0x6f, 0x72, 0x67, 0x9b, 0xee, 0x3c, 0x1a, 0x00,&#xA;  0x00, 0x01, 0xc2, 0x49, 0x44, 0x41, 0x54, 0x38, 0x8d, 0xa5, 0x90, 0x31,&#xA;  0x6b, 0x93, 0x51, 0x14, 0x86, 0x9f, 0x73, 0xef, 0x57, 0x2c, 0x29, 0xe2,&#xA;  0xe0, 0x10, 0xba, 0x14, 0x1c, 0x9c, 0x32, 0x76, 0xeb, 0x2e, 0x99, 0x1c,&#xA;  0x82, 0xd0, 0xd5, 0x5f, 0xa0, 0xbb, 0xd0, 0x3f, 0xe0, 0xe2, 0x56, 0x57,&#xA;  0xff, 0x87, 0x28, 0xc4, 0xb9, 0x60, 0xc4, 0x59, 0x29, 0x8a, 0x24, 0x92,&#xA;  0x50, 0x69, 0xbf, 0x26, 0x25, 0xdf, 0xbd, 0xe7, 0x9e, 0xe3, 0x90, 0x26,&#xA;  0x36, 0x58, 0x5a, 0xc1, 0x77, 0x39, 0xdc, 0x7b, 0xcf, 0x79, 0xee, 0x79,&#xA;  0x5f, 0xe9, 0x76, 0xbb, 0xfc, 0x8f, 0xaa, 0xdd, 0xdd, 0xdd, 0x37, 0xee,&#xA;  0xfe, 0xf8, 0x9a, 0xb7, 0x0b, 0x77, 0x7f, 0x32, 0x18, 0x0c, 0x8e, 0x6e,&#xA;  0x04, 0x98, 0x59, 0xaf, 0xd7, 0xeb, 0xdd, 0x33, 0x33, 0xcc, 0x0c, 0x77,&#xA;  0x07, 0xe0, 0xf4, 0xf4, 0xf4, 0x7e, 0xbf, 0xdf, 0x3f, 0xec, 0x74, 0x3a,&#xA;  0xcf, 0x97, 0xcd, 0x39, 0x67, 0x42, 0x08, 0x65, 0x38, 0x1c, 0x7e, 0xac,&#xA;  0xeb, 0xba, 0x00, 0x54, 0x39, 0x67, 0x57, 0x55, 0x26, 0x93, 0x09, 0xa5,&#xA;  0x94, 0x15, 0x24, 0x84, 0xc0, 0xf6, 0xf6, 0x76, 0x07, 0x78, 0xbb, 0x84,&#xA;  0x02, 0x4c, 0xa7, 0xd3, 0xaa, 0x94, 0xf2, 0xaa, 0xae, 0xeb, 0x83, 0x2b,&#xA;  0x80, 0x8c, 0xaa, 0x62, 0x66, 0x6b, 0x90, 0x76, 0xbb, 0xdd, 0xda, 0xdc,&#xA;  0xdc, 0xa4, 0xd5, 0x6a, 0x11, 0x63, 0x24, 0x84, 0xc0, 0x68, 0x34, 0x62,&#xA;  0x3c, 0x1e, 0x3f, 0x5c, 0x59, 0x50, 0x55, 0x53, 0x2d, 0x1c, 0x7e, 0x48,&#xA;  0xcc, 0x9a, 0x3f, 0x3f, 0x81, 0x00, 0xe0, 0xcc, 0x81, 0xf9, 0xea, 0xd6,&#xA;  0x3d, 0x00, 0x7b, 0xfb, 0xec, 0xec, 0xed, 0xc7, 0x18, 0xbe, 0x55, 0x39,&#xA;  0x67, 0x4f, 0x29, 0x31, 0x6d, 0x9c, 0x97, 0xcf, 0x1e, 0x21, 0x72, 0xd9,&#xA;  0x78, 0x35, 0x29, 0x5f, 0x3b, 0x01, 0x90, 0xd4, 0x39, 0x78, 0xfd, 0x7e,&#xA;  0xa7, 0x4a, 0x29, 0x99, 0xaa, 0x02, 0x4e, 0x0c, 0xf0, 0xe9, 0xf8, 0xec,&#xA;  0xea, 0x02, 0xcb, 0xb2, 0x9e, 0x7c, 0x14, 0x1e, 0xb4, 0xb7, 0x40, 0xdc,&#xA;  0x2b, 0x55, 0x25, 0xe7, 0x8c, 0x88, 0x10, 0x83, 0x10, 0xe3, 0x75, 0x23,&#xA;  0xeb, 0xca, 0x6a, 0xb8, 0x39, 0x82, 0x78, 0x95, 0x73, 0xb6, 0x9c, 0x33,&#xA;  0xb8, 0x13, 0x44, 0xd8, 0xb8, 0x01, 0xa0, 0xc5, 0x69, 0xb2, 0x51, 0xcc,&#xA;  0x09, 0x41, 0x00, 0x16, 0x00, 0xd5, 0xc5, 0x06, 0xf3, 0x54, 0x08, 0x80,&#xA;  0xf9, 0xa2, 0xb9, 0xb8, 0x63, 0xe6, 0x98, 0x3b, 0x59, 0x17, 0x75, 0x69,&#xA;  0xa1, 0x49, 0xb6, 0x02, 0xb8, 0x6a, 0x41, 0xa4, 0x62, 0x52, 0x37, 0x0c,&#xA;  0x7f, 0xcd, 0x69, 0xd4, 0x6e, 0xb4, 0x50, 0x45, 0x61, 0x72, 0x36, 0x5f,&#xA;  0x00, 0x54, 0xd5, 0x52, 0x4a, 0xe0, 0x91, 0x2f, 0xa3, 0x73, 0x4e, 0xa6,&#xA;  0x0d, 0x7f, 0x67, 0xbe, 0xae, 0x18, 0x84, 0x9f, 0x67, 0x97, 0x16, 0x44,&#xA;  0xc4, 0xcc, 0x0c, 0x11, 0xa1, 0xc9, 0x46, 0xeb, 0x4e, 0x75, 0x6b, 0x88,&#xA;  0x22, 0xc2, 0x45, 0x52, 0x80, 0x52, 0xb9, 0x3b, 0xc7, 0x27, 0x86, 0x08,&#xA;  0x7c, 0xfe, 0x3a, 0xba, 0x75, 0x78, 0xa9, 0xd9, 0x6c, 0x8e, 0xc0, 0x51,&#xA;  0x65, 0x1b, 0x5b, 0xfd, 0x77, 0xc7, 0x77, 0x9f, 0x82, 0xf3, 0xe3, 0xfb,&#xA;  0xf8, 0x9f, 0x01, 0x22, 0x8c, 0x45, 0xc2, 0x8b, 0xdf, 0x47, 0x16, 0x21,&#xA;  0x9e, 0x1c, 0x63, 0xa7, 0x31, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e,&#xA;  0x44, 0xae, 0x42, 0x60, 0x82,&#xA;}&#xA;&#xA;var __16x16_mimetypes_x_office_spreadsheet_png = []byte{&#xA;  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,&#xA;  0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,&#xA;  0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0xf3, 0xff, 0x61, 0x00, 0x00, 0x00,&#xA;  0x06, 0x62, 0x4b, 0x47, 0x44, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xa0,&#xA;  0xbd, 0xa7, 0x93, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00,&#xA;  0x00, 0x0b, 0x13, 0x00, 0x00, 0x0b, 0x13, 0x01, 0x00, 0x9a, 0x9c, 0x18,&#xA;  0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d, 0x45, 0x07, 0xd5, 0x04, 0x16,&#xA;  0x14, 0x0d, 0x09, 0xd9, 0x88, 0x44, 0xfa, 0x00, 0x00, 0x02, 0x4d, 0x49,&#xA;  0x44, 0x41, 0x54, 0x38, 0xcb, 0x95, 0x92, 0xdf, 0x4b, 0x53, 0x61, 0x18,&#xA;  0xc7, 0x3f, 0x67, 0x9b, 0x6e, 0x7a, 0xd6, 0xfc, 0x55, 0xe0, 0x59, 0x8a,&#xA;  0x95, 0x71, 0x08, 0x52, 0x21, 0x91, 0x2c, 0x8a, 0x0a, 0x94, 0x11, 0x14,&#xA;  0x78, 0x21, 0x99, 0x14, 0x81, 0xdd, 0x48, 0x7f, 0x45, 0x63, 0x5d, 0x75,&#xA;  0x1b, 0x34, 0xd0, 0x9b, 0x52, 0x83, 0x0a, 0xad, 0x0b, 0x43, 0x72, 0xd0,&#xA;  0x85, 0x14, 0x14, 0x68, 0x77, 0x39, 0xcd, 0x6c, 0x94, 0x0c, 0xf4, 0x48,&#xA;  0x4d, 0x5b, 0x5b, 0x4b, 0xcf, 0x39, 0x3b, 0xef, 0xe9, 0x62, 0x3f, 0xec,&#xA;  0xd7, 0x2e, 0x7c, 0xae, 0xbe, 0x2f, 0xef, 0xf3, 0xfd, 0xbc, 0xdf, 0xf7,&#xA;  0x7d, 0x5e, 0x69, 0x78, 0x78, 0xf8, 0xc9, 0xfa, 0xfa, 0x7a, 0x2f, 0xbb,&#xA;  0xab, 0xcb, 0xc1, 0x60, 0x70, 0x1c, 0x80, 0x50, 0x28, 0x64, 0xef, 0xb6,&#xA;  0x42, 0xa1, 0x90, 0x5d, 0x20, 0xb9, 0x0a, 0x22, 0x12, 0x89, 0xe4, 0x95,&#xA;  0x84, 0xa6, 0x69, 0xf8, 0xfd, 0x0a, 0x00, 0x9a, 0xa6, 0xa1, 0x28, 0xfe,&#xA;  0xbc, 0x5e, 0x63, 0x60, 0x60, 0xe0, 0x8f, 0x28, 0x45, 0x80, 0xa6, 0x69,&#xA;  0x48, 0x52, 0x0e, 0x20, 0x49, 0xb9, 0xf5, 0xce, 0xde, 0x5a, 0xc9, 0xbb,&#xA;  0x14, 0x01, 0x8a, 0x5f, 0xc1, 0x2b, 0x7b, 0x01, 0x88, 0xc5, 0x62, 0xf4,&#xA;  0xf4, 0xf4, 0x00, 0x10, 0x8d, 0x46, 0x69, 0x69, 0x6d, 0x41, 0xb2, 0x25,&#xA;  0xe6, 0xa3, 0xf3, 0xa5, 0x01, 0x86, 0x6e, 0x90, 0x21, 0x83, 0x84, 0x04,&#xA;  0x40, 0x2a, 0x95, 0x22, 0x2f, 0x49, 0x7f, 0x4f, 0x91, 0x8f, 0x57, 0x1a,&#xA;  0xe0, 0x71, 0xbb, 0x91, 0xbd, 0x5e, 0x0a, 0xaf, 0xe3, 0xf3, 0x55, 0x15,&#xA;  0xfc, 0xf8, 0xaa, 0x76, 0x74, 0x49, 0xc0, 0xb6, 0xae, 0xe7, 0x4f, 0xcc,&#xA;  0xb5, 0x7e, 0x8c, 0x3c, 0x67, 0xf5, 0xee, 0x1d, 0xb6, 0x16, 0x16, 0x89,&#xA;  0xa7, 0x33, 0xb9, 0x26, 0xb9, 0x82, 0xc9, 0xb6, 0x56, 0xbc, 0x6d, 0xed,&#xA;  0xff, 0x49, 0xe0, 0xf1, 0x20, 0xcb, 0x32, 0x00, 0xf6, 0xe8, 0x3d, 0x3e,&#xA;  0xcd, 0xcd, 0xd1, 0x74, 0xe5, 0x22, 0x65, 0x9d, 0x2a, 0xc2, 0x21, 0x91,&#xA;  0x15, 0x02, 0xc3, 0x14, 0x48, 0x0e, 0x0f, 0x4d, 0xcf, 0xa6, 0x78, 0x74,&#xA;  0xbc, 0xe3, 0x65, 0xff, 0xec, 0xdb, 0xfe, 0x22, 0x40, 0xd7, 0x75, 0x00,&#xA;  0x36, 0x1e, 0x8c, 0x51, 0xb3, 0xb2, 0x4c, 0xc3, 0x8d, 0x3e, 0xb2, 0xe9,&#xA;  0x24, 0xc9, 0xf8, 0x2a, 0xa6, 0x10, 0x18, 0x96, 0x8d, 0xb3, 0xaa, 0x16,&#xA;  0x53, 0x08, 0xac, 0x4e, 0x15, 0xe7, 0xd2, 0xea, 0x99, 0x11, 0xf5, 0xf0,&#xA;  0xed, 0x22, 0xc0, 0xed, 0x76, 0x23, 0xcb, 0x32, 0x89, 0xc8, 0x34, 0xfb,&#xA;  0xaf, 0x9e, 0xe7, 0x47, 0x3c, 0x56, 0x34, 0x9a, 0x42, 0xf0, 0xa1, 0xfe,&#xA;  0x10, 0x9b, 0x86, 0x0b, 0x53, 0x64, 0x31, 0x24, 0x0b, 0xef, 0xb1, 0x7a,&#xA;  0xd4, 0xa7, 0x93, 0x7d, 0xff, 0x24, 0xb0, 0x37, 0xbf, 0x61, 0x19, 0x5b,&#xA;  0xe8, 0xd6, 0x8e, 0x59, 0x52, 0xca, 0xd9, 0xd3, 0xe1, 0x26, 0xfc, 0xb5,&#xA;  0x0b, 0xc3, 0xd4, 0x51, 0x6b, 0xbd, 0x08, 0xcb, 0xe4, 0xe8, 0xe8, 0x43,&#xA;  0x8f, 0xe3, 0xef, 0x04, 0x66, 0x75, 0x0d, 0xce, 0x7d, 0x0d, 0xe0, 0xab,&#xA;  0x41, 0x17, 0x16, 0xba, 0x25, 0x70, 0xaa, 0x95, 0x34, 0x37, 0xa7, 0xa9,&#xA;  0xcf, 0xae, 0x71, 0xb2, 0x71, 0x2f, 0x5f, 0x52, 0x29, 0x7c, 0x2b, 0xef,&#xA;  0xc9, 0x78, 0x3c, 0xdb, 0xc5, 0x04, 0x81, 0x40, 0x20, 0x37, 0x8d, 0xc1,&#xA;  0x41, 0xde, 0xdd, 0x1f, 0xe3, 0xe0, 0xf5, 0x5e, 0xea, 0x0e, 0x1c, 0xc1,&#xA;  0x76, 0xb9, 0xa8, 0x3e, 0x5d, 0x87, 0xa8, 0x70, 0x10, 0xec, 0x90, 0x78,&#xA;  0xfc, 0x39, 0x4d, 0x63, 0x7c, 0x91, 0xf6, 0xc9, 0x09, 0x2a, 0x55, 0x75,&#xA;  0x5c, 0x0a, 0x87, 0xc3, 0x53, 0x89, 0x44, 0xe2, 0xc2, 0xef, 0xb3, 0xad,&#xA;  0x9d, 0x99, 0x41, 0x7e, 0xf3, 0x1a, 0xf3, 0xdc, 0x09, 0xca, 0x1a, 0xaa,&#xA;  0xf1, 0x9c, 0xb5, 0xd1, 0x0d, 0x41, 0x66, 0xc3, 0x64, 0x7a, 0x4a, 0xd0,&#xA;  0x33, 0xfb, 0x8a, 0x0a, 0x55, 0x7d, 0x71, 0x6d, 0x61, 0x21, 0x50, 0xea,&#xA;  0x7f, 0x30, 0xd2, 0xdd, 0x7d, 0x49, 0x5f, 0x5a, 0xba, 0xe9, 0x4e, 0x26,&#xA;  0x55, 0xe7, 0xcf, 0x4c, 0xb9, 0x6d, 0x83, 0x90, 0x65, 0xc3, 0xa5, 0x28,&#xA;  0xcb, 0x07, 0xbb, 0xba, 0x6e, 0x9d, 0x1a, 0x1a, 0x9a, 0x00, 0xf8, 0x05,&#xA;  0xf4, 0xf5, 0x23, 0xe9, 0x30, 0xeb, 0x2d, 0xf9, 0x00, 0x00, 0x00, 0x00,&#xA;  0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,&#xA;}&#xA;&#xA;var __32x32_categories_applications_accessories_png = []byte{&#xA;  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,&#xA;  0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20,&#xA;  0x08, 0x06, 0x00, 0x00, 0x00, 0x73, 0x7a, 0x7a, 0xf4, 0x00, 0x00, 0x00,&#xA;  0x04, 0x73, 0x42, 0x49, 0x54, 0x08, 0x08, 0x08, 0x08, 0x7c, 0x08, 0x64,&#xA;  0x88, 0x00, 0x00, 0x08, 0x66, 0x49, 0x44, 0x41, 0x54, 0x58, 0x85, 0xcd,&#xA;  0x97, 0x7b, 0x70, 0x54, 0xd5, 0x1d, 0xc7, 0xbf, 0xe7, 0x9c, 0xfb, 0xd8,&#xA;  0x57, 0x36, 0x4b, 0xb2, 0xcb, 0x12, 0x24, 0x04, 0x08, 0x41, 0x9e, 0x85,&#xA;  0x00, 0x2d, 0x10, 0x71, 0x24, 0xf2, 0x68, 0x67, 0x64, 0xa0, 0x58, 0xed,&#xA;  0xbb, 0xb4, 0x5a, 0x19, 0x2d, 0x4a, 0x18, 0x1e, 0x82, 0x05, 0x9c, 0x59,&#xA;  0x0d, 0x2a, 0x82, 0xe3, 0x28, 0x1d, 0x5b, 0x69, 0x61, 0x04, 0x44, 0x0a,&#xA;  0x8c, 0x8f, 0x62, 0x47, 0x0a, 0x33, 0x3c, 0x85, 0x20, 0x52, 0x85, 0x28,&#xA;  0x98, 0x28, 0x12, 0x1e, 0x9b, 0x40, 0x08, 0xc9, 0xe6, 0xb1, 0x8f, 0xec,&#xA;  0xde, 0xc7, 0x39, 0xa7, 0x7f, 0x24, 0x4b, 0x13, 0x12, 0x20, 0xfe, 0xd5,&#xA;  0xfe, 0x66, 0x7e, 0x73, 0xce, 0xde, 0xfd, 0x9e, 0xdf, 0xef, 0x73, 0x7f,&#xA;  0xe7, 0x9e, 0x73, 0xcf, 0x05, 0xfe, 0x07, 0x76, 0x74, 0x33, 0x9e, 0x4c,&#xA;  0xf7, 0x49, 0x77, 0x82, 0x35, 0x6b, 0xd6, 0x64, 0x82, 0xf2, 0x66, 0x42,&#xA;  0xc9, 0x4f, 0x96, 0x2f, 0x5d, 0xf1, 0xfe, 0x9d, 0x02, 0xae, 0x5d, 0xbb,&#xA;  0xb6, 0x8f, 0x80, 0x55, 0x2b, 0x89, 0x98, 0xfe, 0xc7, 0xa7, 0x9f, 0xdd,&#xA;  0x7f, 0x3b, 0xed, 0x91, 0xb7, 0x50, 0xc0, 0x08, 0xce, 0x4d, 0xfe, 0x5d,&#xA;  0x5b, 0x6e, 0xda, 0x9d, 0x48, 0x51, 0xb1, 0xc2, 0xed, 0xf6, 0x70, 0x46,&#xA;  0x95, 0x0d, 0xa1, 0x50, 0xc8, 0x75, 0x27, 0x00, 0x45, 0x27, 0xaf, 0x7b,&#xA;  0xbd, 0x99, 0x42, 0x53, 0x1d, 0x7f, 0xdd, 0xb0, 0x61, 0x83, 0x7a, 0x2b,&#xA;  0xdd, 0xae, 0x5d, 0x60, 0x9a, 0xaa, 0xbc, 0xd7, 0xf1, 0x5a, 0x17, 0x80,&#xA;  0xb5, 0x6b, 0x4b, 0xf3, 0x29, 0x65, 0x4f, 0xce, 0x99, 0x3d, 0x87, 0xe5,&#xA;  0x0f, 0x1c, 0xe4, 0x76, 0x79, 0x1c, 0xcf, 0xde, 0x2e, 0xf9, 0x9a, 0x35,&#xA;  0xab, 0x8b, 0x28, 0xa1, 0x33, 0x67, 0xcd, 0x9c, 0x4d, 0xf3, 0x72, 0xfb,&#xA;  0x07, 0x5b, 0x62, 0x4d, 0x8b, 0x6e, 0xa5, 0xed, 0x97, 0xa2, 0x2b, 0x33,&#xA;  0x83, 0xdf, 0xcb, 0xbf, 0x2d, 0x00, 0x61, 0xca, 0xaf, 0x47, 0x8d, 0x1a,&#xA;  0xe5, 0xe0, 0x5c, 0x62, 0xec, 0xb8, 0xef, 0x3b, 0x09, 0x25, 0x25, 0xeb,&#xA;  0xd6, 0x95, 0x0e, 0xec, 0xfe, 0x8e, 0x76, 0x31, 0xcd, 0xa1, 0x6f, 0x2e,&#xA;  0x9e, 0x32, 0xd5, 0x69, 0x59, 0x36, 0xc6, 0x8c, 0x1e, 0xeb, 0x52, 0x14,&#xA;  0xb6, 0xa0, 0x3b, 0xed, 0xf1, 0x2d, 0x28, 0xa4, 0x4c, 0x7f, 0x66, 0xf0,&#xA;  0x84, 0xce, 0x15, 0xed, 0x02, 0xc0, 0x05, 0x8f, 0x85, 0xc3, 0xe1, 0x24,&#xA;  0xa5, 0x14, 0x90, 0x40, 0xd1, 0xc4, 0x22, 0x9d, 0x69, 0x8e, 0x37, 0xbb,&#xA;  0x0b, 0x7a, 0xa9, 0xfa, 0xc2, 0x13, 0x7e, 0x7f, 0x76, 0x4e, 0xa6, 0xd7,&#xA;  0x47, 0xa4, 0x94, 0x68, 0x88, 0xd4, 0x0b, 0xce, 0x45, 0xf3, 0xcd, 0xba,&#xA;  0x3d, 0xeb, 0xa1, 0x13, 0xca, 0xde, 0xbb, 0x7b, 0xd2, 0x42, 0x87, 0xa2,&#xA;  0xb8, 0x3b, 0xfd, 0xd7, 0x05, 0x20, 0x95, 0xb0, 0x5f, 0x6b, 0x8e, 0xb6,&#xA;  0xd4, 0x44, 0x1a, 0xeb, 0xa5, 0x94, 0x12, 0xb9, 0xfd, 0xf2, 0x98, 0xc2,&#xA;  0xd4, 0xc9, 0x2f, 0xad, 0x2b, 0x9d, 0xd6, 0x51, 0xf7, 0xe2, 0x8b, 0x2f,&#xA;  0x06, 0x28, 0x21, 0x2f, 0x4d, 0xbe, 0x67, 0x8a, 0x87, 0x73, 0x0e, 0x4a,&#xA;  0x09, 0xca, 0x8e, 0x1f, 0x33, 0x2c, 0xc9, 0x1f, 0xbe, 0x39, 0x66, 0x2f,&#xA;  0x9f, 0xb2, 0x36, 0xab, 0xdf, 0x84, 0x9c, 0xcc, 0xe0, 0x44, 0x02, 0x88,&#xA;  0xdb, 0x03, 0x84, 0x42, 0x21, 0x61, 0x1b, 0xc6, 0x23, 0x87, 0x8f, 0x1c,&#xA;  0x4a, 0x32, 0x46, 0x61, 0xdb, 0x36, 0xa6, 0x16, 0x4f, 0x73, 0xe9, 0x8a,&#xA;  0xfe, 0xb7, 0x50, 0x28, 0xa4, 0xa4, 0x75, 0x0e, 0x97, 0xfa, 0xea, 0x98,&#xA;  0xd1, 0x85, 0x3a, 0x64, 0xdb, 0xef, 0x2f, 0xbe, 0x3c, 0x95, 0x02, 0xb0,&#xA;  0x71, 0xc5, 0xd2, 0x15, 0x5f, 0x77, 0x8c, 0x77, 0xec, 0x2d, 0xdc, 0x4b,&#xA;  0x35, 0xc7, 0xbc, 0x41, 0x63, 0x17, 0x3a, 0x64, 0xf2, 0x20, 0x8e, 0xef,&#xA;  0x9a, 0x7e, 0x7b, 0x00, 0x00, 0x58, 0xbe, 0x7c, 0xd5, 0x09, 0x2e, 0xc4,&#xA;  0xbe, 0xf3, 0x55, 0xe7, 0x2d, 0x00, 0x70, 0xb9, 0xdc, 0x08, 0xf6, 0xe9,&#xA;  0xd3, 0xdb, 0xe3, 0xd5, 0x17, 0x00, 0xc0, 0xcb, 0x2f, 0xaf, 0x1e, 0x4f,&#xA;  0x08, 0x1e, 0x1c, 0x9c, 0x3f, 0x44, 0x13, 0x42, 0x80, 0x73, 0x1b, 0xe7,&#xA;  0xab, 0xaa, 0x5a, 0x63, 0xac, 0x75, 0x55, 0xa7, 0xe4, 0x9b, 0x90, 0xc1,&#xA;  0x14, 0xb6, 0x6b, 0xd8, 0xa4, 0xc5, 0x4e, 0x2a, 0xaf, 0x40, 0xda, 0x97,&#xA;  0x51, 0xf4, 0xf0, 0x47, 0x77, 0x06, 0x00, 0x80, 0xa4, 0x30, 0x16, 0x7c,&#xA;  0x76, 0xea, 0xdf, 0x16, 0xa5, 0x04, 0x9c, 0x73, 0x14, 0x4d, 0xbc, 0xd7,&#xA;  0x45, 0x08, 0x7d, 0xfe, 0x85, 0x17, 0x5e, 0x08, 0xaa, 0x9a, 0xb6, 0x75,&#xA;  0x6a, 0xf1, 0x0c, 0xa7, 0x65, 0x59, 0x50, 0x14, 0x86, 0x23, 0x47, 0x0f,&#xA;  0x25, 0x6c, 0xce, 0x4b, 0x42, 0x25, 0xa1, 0x68, 0xa7, 0xe0, 0x3a, 0x7b,&#xA;  0x23, 0x38, 0xe8, 0x3e, 0x9f, 0x27, 0x7b, 0x04, 0x44, 0xaa, 0x0c, 0x52,&#xA;  0x08, 0x48, 0xc9, 0x7b, 0x06, 0xb0, 0x6a, 0xf1, 0xaa, 0x2b, 0x04, 0xe4,&#xA;  0xa5, 0x93, 0x9f, 0x9d, 0x68, 0xa5, 0x94, 0xc0, 0xb6, 0x6d, 0x14, 0x16,&#xA;  0x8e, 0xd3, 0x74, 0xa7, 0xba, 0x3b, 0x2b, 0xdb, 0xdf, 0xdf, 0xed, 0xf6,&#xA;  0x10, 0x29, 0x25, 0x22, 0x8d, 0x11, 0x11, 0x8b, 0xc5, 0xbe, 0x59, 0xb6,&#xA;  0xe4, 0x99, 0xed, 0x1d, 0xc7, 0x97, 0x6d, 0xc6, 0x03, 0x8a, 0xea, 0x7d,&#xA;  0x28, 0x77, 0xe4, 0x63, 0x0e, 0x9e, 0xd8, 0x0f, 0xc1, 0x53, 0x10, 0x42,&#xA;  0xe0, 0x93, 0x77, 0x67, 0xf5, 0x0c, 0x00, 0x00, 0x34, 0xc5, 0xb1, 0xae,&#xA;  0xba, 0xba, 0x3a, 0x66, 0x5a, 0x26, 0xa4, 0x94, 0x18, 0x98, 0x97, 0xaf,&#xA;  0x51, 0x4a, 0x26, 0x8c, 0x1c, 0x3e, 0xd2, 0x6d, 0xdb, 0x36, 0x74, 0x5d,&#xA;  0xc3, 0xc7, 0x47, 0x0f, 0xa6, 0x6c, 0xd3, 0xfc, 0x3d, 0x21, 0x44, 0xa6,&#xA;  0xc7, 0x7d, 0xba, 0x05, 0xd9, 0x84, 0xb2, 0x6d, 0x43, 0x27, 0x2d, 0x74,&#xA;  0x4a, 0xab, 0x0a, 0xdc, 0xac, 0x81, 0xe0, 0x02, 0x82, 0x73, 0x4c, 0x98,&#xA;  0xb3, 0xb3, 0xe7, 0x00, 0x25, 0x25, 0x25, 0x86, 0x6d, 0xda, 0x4f, 0x1c,&#xA;  0x3a, 0x74, 0x20, 0xae, 0xaa, 0x2a, 0x4c, 0xd3, 0xc4, 0xfd, 0xc5, 0xd3,&#xA;  0xf0, 0xc5, 0x99, 0x72, 0x00, 0x40, 0x45, 0xe5, 0x59, 0x83, 0x73, 0xb9,&#xA;  0x73, 0xd9, 0xb2, 0x95, 0xe5, 0x1d, 0xc7, 0x09, 0xa6, 0x6c, 0xee, 0x3b,&#xA;  0x64, 0xba, 0xcb, 0x99, 0x91, 0x0b, 0xbb, 0xf5, 0x04, 0x2c, 0xd3, 0x02,&#xA;  0xe7, 0x16, 0x84, 0xe0, 0x90, 0xa2, 0x87, 0x53, 0x90, 0xb6, 0xe5, 0xcb,&#xA;  0x57, 0xfc, 0xc3, 0x30, 0x52, 0x5f, 0x36, 0x44, 0xae, 0x0b, 0x21, 0x04,&#xA;  0x74, 0x5d, 0x03, 0x63, 0x0a, 0x6a, 0xaf, 0x5d, 0x41, 0x45, 0x65, 0x85,&#xA;  0xc1, 0x48, 0x72, 0x71, 0x47, 0x7d, 0xd9, 0x56, 0xfc, 0x46, 0xd5, 0xb3,&#xA;  0xa6, 0xe6, 0x14, 0xfc, 0x5c, 0xb3, 0xe2, 0x07, 0x20, 0x6c, 0x03, 0x57,&#xA;  0x2f, 0x9e, 0x03, 0x37, 0x2d, 0x08, 0x2e, 0x70, 0x72, 0xf7, 0x2f, 0xbf,&#xA;  0x1b, 0x00, 0x00, 0x98, 0x75, 0x75, 0x0b, 0x8e, 0x1e, 0x3e, 0x48, 0x9d,&#xA;  0x4e, 0x07, 0x52, 0x86, 0x81, 0xc9, 0x45, 0xf7, 0xa2, 0xfc, 0xd8, 0x61,&#xA;  0x69, 0x35, 0x46, 0x4a, 0x17, 0x2d, 0x0a, 0xdd, 0xd8, 0x78, 0x4e, 0x6c,&#xA;  0x43, 0x3f, 0x02, 0xfa, 0xe7, 0x82, 0x09, 0x7f, 0x70, 0x72, 0xa3, 0x02,&#xA;  0xdc, 0xb8, 0x86, 0x78, 0xb4, 0x19, 0xf5, 0x35, 0x61, 0x48, 0xc1, 0x21,&#xA;  0x04, 0xc7, 0xf8, 0x99, 0x9b, 0x3a, 0xc5, 0x56, 0xba, 0x64, 0xeb, 0xc6,&#xA;  0x3c, 0xef, 0xee, 0x58, 0xa6, 0x4c, 0x9c, 0x8c, 0x43, 0xbd, 0xb2, 0xe0,&#xA;  0xfd, 0xf0, 0x7d, 0xb4, 0x9e, 0x3d, 0x03, 0xe7, 0xb5, 0xab, 0xc4, 0xe5,&#xA;  0xeb, 0xf5, 0x14, 0x80, 0x57, 0x00, 0x40, 0x4a, 0x90, 0x13, 0xef, 0x28,&#xA;  0x3b, 0xfa, 0x0d, 0xfd, 0x91, 0x43, 0x77, 0x64, 0xc1, 0x68, 0xde, 0x0d,&#xA;  0x29, 0x6d, 0x84, 0x2b, 0xcf, 0x26, 0x00, 0xb8, 0x05, 0x17, 0x20, 0xe0,&#xA;  0x90, 0xc2, 0xee, 0x39, 0xc0, 0x1e, 0x40, 0xbf, 0xe6, 0x41, 0xbe, 0xbc,&#xA;  0x5a, 0x33, 0x6b, 0x4a, 0xe5, 0x39, 0x7c, 0x23, 0x80, 0xea, 0xfd, 0xfb,&#xA;  0x30, 0xcc, 0x17, 0x44, 0x9f, 0xdc, 0xa1, 0x38, 0x5d, 0x1f, 0xee, 0xbd,&#xA;  0xc1, 0x85, 0x07, 0x9c, 0xad, 0x38, 0x7c, 0x7c, 0x2b, 0x7d, 0xd4, 0xe5,&#xA;  0x0d, 0x14, 0x06, 0x06, 0xcc, 0x54, 0x8c, 0xe8, 0xbf, 0x20, 0x85, 0x8d,&#xA;  0xba, 0xea, 0x4b, 0x36, 0xb7, 0xad, 0xd3, 0x84, 0x92, 0x71, 0x42, 0x08,&#xA;  0x27, 0x21, 0xc0, 0xe7, 0x7b, 0x1e, 0xef, 0x94, 0xa3, 0xcb, 0x14, 0xec,&#xA;  0x02, 0x3c, 0xdb, 0x29, 0x5d, 0xbd, 0x93, 0xd2, 0x6a, 0xcb, 0xed, 0xbe,&#xA;  0xe2, 0xe3, 0x8e, 0x2f, 0x32, 0x6d, 0xcd, 0x99, 0x6c, 0x8e, 0x22, 0xb1,&#xA;  0x77, 0x77, 0x92, 0x12, 0xba, 0xf1, 0x52, 0xa2, 0x31, 0x19, 0x6f, 0x6d,&#xA;  0xc5, 0x88, 0xec, 0xbb, 0x9c, 0x4e, 0xa6, 0x7e, 0xd8, 0xd7, 0x9f, 0x5d,&#xA;  0x13, 0x59, 0xa2, 0xbd, 0x1e, 0xdb, 0x98, 0xed, 0x8a, 0x9e, 0x2f, 0x03,&#xA;  0x37, 0x23, 0x48, 0xc6, 0x63, 0x68, 0xb8, 0x5a, 0x63, 0x9a, 0x92, 0xcf,&#xA;  0x05, 0x00, 0x21, 0x38, 0x04, 0x17, 0x18, 0x33, 0xe3, 0xb5, 0x5b, 0x57,&#xA;  0x60, 0x3b, 0x70, 0x3f, 0x18, 0xdb, 0x91, 0x17, 0x0c, 0xfa, 0xdc, 0x9a,&#xA;  0xa6, 0x9a, 0xb6, 0x0d, 0x4d, 0xd3, 0x00, 0x21, 0x50, 0x71, 0xf9, 0x92,&#xA;  0x6c, 0xd5, 0xf9, 0x3b, 0xf3, 0xe2, 0x62, 0xde, 0x26, 0x2f, 0xf1, 0x36,&#xA;  0xd8, 0xad, 0x0f, 0x06, 0x4d, 0xaa, 0x0c, 0xf3, 0xe7, 0xd0, 0x2c, 0xb7,&#xA;  0xd7, 0xa7, 0x32, 0x86, 0xd4, 0x25, 0x0b, 0x27, 0x7f, 0xfc, 0x01, 0xfa,&#xA;  0x3f, 0x1e, 0x84, 0x35, 0xb2, 0x36, 0x21, 0x09, 0x9e, 0xbd, 0x6f, 0x2e,&#xA;  0x2e, 0x96, 0x6d, 0x05, 0x84, 0x10, 0x20, 0x00, 0x84, 0xb0, 0xba, 0xaf,&#xA;  0xc0, 0x16, 0x60, 0x9a, 0xee, 0x74, 0xbe, 0x5f, 0x90, 0x9b, 0x1b, 0x48,&#xA;  0x24, 0x93, 0x66, 0x65, 0x38, 0x5c, 0x73, 0xb1, 0xb6, 0xf6, 0x4f, 0x95,&#xA;  0xe1, 0xcb, 0x11, 0x49, 0x08, 0x72, 0x7c, 0xbd, 0xa4, 0x92, 0xc0, 0x69,&#xA;  0x00, 0xa8, 0x8e, 0xf2, 0x5f, 0xd5, 0xb6, 0x34, 0x71, 0xa2, 0x50, 0x44,&#xA;  0x92, 0x31, 0xb3, 0x6a, 0x40, 0xd8, 0xfe, 0x46, 0x8f, 0xa3, 0x26, 0x5a,&#xA;  0x8f, 0xd1, 0x39, 0xf9, 0xa8, 0xdb, 0x14, 0x41, 0xe4, 0x03, 0xa3, 0xe5,&#xA;  0xaa, 0x43, 0xac, 0x4f, 0xc7, 0x17, 0x9c, 0x43, 0x70, 0x8e, 0x2f, 0xf7,&#xA;  0x3f, 0xdd, 0x15, 0x60, 0x3b, 0xe0, 0xd7, 0x15, 0xe5, 0xef, 0x03, 0x02,&#xA;  0x81, 0xcc, 0x9a, 0xfa, 0xfa, 0x96, 0x48, 0x4b, 0xcb, 0xd6, 0x3e, 0x42,&#xA;  0x0c, 0xfc, 0x19, 0xe7, 0x25, 0xb6, 0x90, 0xeb, 0x0c, 0xd3, 0x94, 0xba,&#xA;  0xc3, 0x41, 0x15, 0x4a, 0x87, 0x00, 0x40, 0x08, 0xb0, 0xbd, 0x52, 0x4f,&#xA;  0xd8, 0x90, 0x48, 0x58, 0x31, 0x75, 0xfc, 0xfa, 0xa7, 0x94, 0x71, 0x6f,&#xA;  0x17, 0x21, 0xb0, 0xd0, 0x8b, 0x33, 0xd7, 0x2e, 0x60, 0x44, 0x70, 0x20,&#xA;  0x5a, 0xff, 0xa9, 0xb9, 0x93, 0x3f, 0xc5, 0x8d, 0xc3, 0x47, 0xdb, 0x1e,&#xA;  0x20, 0x30, 0xe2, 0xbe, 0xe7, 0xba, 0x02, 0x50, 0x4a, 0x57, 0xe6, 0xfa,&#xA;  0xfd, 0x59, 0x49, 0xc3, 0xe0, 0xf1, 0x54, 0xea, 0xe8, 0x2f, 0x84, 0x98,&#xA;  0x5f, 0x0c, 0xd8, 0x00, 0xa0, 0x53, 0xfa, 0x03, 0x4d, 0x51, 0x48, 0xd2,&#xA;  0x30, 0x52, 0xdc, 0xb6, 0x3f, 0xef, 0x70, 0x47, 0xf1, 0x60, 0x86, 0x0f,&#xA;  0x8c, 0x39, 0x08, 0x6f, 0x49, 0xc0, 0x4c, 0x54, 0xc0, 0x5f, 0x9c, 0x09,&#xA;  0x6d, 0xba, 0x69, 0xd6, 0x36, 0x47, 0xec, 0x31, 0x83, 0x87, 0x78, 0x3d,&#xA;  0xba, 0xbe, 0x26, 0xad, 0x97, 0xed, 0x3b, 0xe1, 0xcd, 0xab, 0x80, 0x02,&#xA;  0x80, 0x24, 0xe4, 0x21, 0x87, 0xa6, 0xd1, 0xeb, 0xcd, 0xcd, 0x11, 0x8b,&#xA;  0xf3, 0x1b, 0x27, 0xd6, 0xb7, 0x81, 0xd1, 0x9a, 0xaa, 0x4e, 0xd1, 0x54,&#xA;  0x15, 0xd7, 0x1b, 0x1b, 0xe3, 0x75, 0xc0, 0x47, 0x00, 0x18, 0x00, 0xa6,&#xA;  0x16, 0xf2, 0x48, 0x4b, 0x6b, 0x1c, 0xb9, 0x19, 0x01, 0x7c, 0xf5, 0xdc,&#xA;  0x4e, 0x08, 0xce, 0x11, 0x6d, 0x6a, 0x90, 0xae, 0x62, 0xab, 0xf6, 0xe2,&#xA;  0xd5, 0xda, 0x26, 0x8f, 0xae, 0x13, 0x00, 0xf7, 0x00, 0x80, 0x4c, 0x3f,&#xA;  0x84, 0x82, 0xa3, 0xe2, 0x68, 0x69, 0x57, 0x00, 0x02, 0xb8, 0x08, 0x00,&#xA;  0xcb, 0xb6, 0xd9, 0x5c, 0xa0, 0x16, 0x80, 0x73, 0x1d, 0x30, 0x4d, 0x57,&#xA;  0xd5, 0xfd, 0x63, 0x0b, 0x0a, 0xb2, 0xae, 0x47, 0xa3, 0x89, 0x46, 0x29,&#xA;  0xb7, 0x2d, 0x06, 0x9c, 0x00, 0x72, 0x4a, 0xe7, 0x63, 0x8e, 0x98, 0x8d,&#xA;  0xe1, 0x5f, 0x37, 0xd5, 0x21, 0xe0, 0xce, 0x80, 0x71, 0xc2, 0xc0, 0x57,&#xA;  0xaf, 0xd5, 0xe0, 0xc2, 0xd7, 0x61, 0x12, 0x37, 0x45, 0x1e, 0xc9, 0x92,&#xA;  0x01, 0x0a, 0x40, 0xef, 0xa5, 0xf4, 0xfe, 0xf8, 0x2f, 0x90, 0x10, 0xd2,&#xA;  0x99, 0x7e, 0x17, 0x0c, 0x99, 0xb8, 0xa4, 0x13, 0x40, 0x7a, 0x15, 0xc4,&#xA;  0x02, 0x3e, 0x5f, 0x56, 0x34, 0x99, 0x54, 0xb7, 0x37, 0x35, 0x1d, 0x00,&#xA;  0x21, 0x19, 0x01, 0x8f, 0x27, 0x7f, 0x58, 0xff, 0xfe, 0x19, 0x97, 0x1a,&#xA;  0x1a, 0x52, 0x35, 0x8d, 0x8d, 0x15, 0x8b, 0x6d, 0x7b, 0x33, 0x80, 0xde,&#xA;  0x03, 0x73, 0x90, 0xd1, 0x3b, 0x9b, 0x6e, 0x60, 0x39, 0xf7, 0xe8, 0xfa,&#xA;  0x7c, 0xa0, 0xfc, 0x8d, 0x53, 0x18, 0xdb, 0x77, 0x10, 0xaa, 0xcb, 0x1a,&#xA;  0x70, 0xe5, 0x80, 0x03, 0x8e, 0x7c, 0x07, 0x02, 0x9a, 0x0e, 0x55, 0x55,&#xA;  0xc1, 0x21, 0x11, 0xbc, 0x7b, 0x08, 0x54, 0x06, 0x48, 0x22, 0x21, 0x85,&#xA;  0x84, 0xe0, 0x9d, 0x57, 0x01, 0x01, 0x80, 0x1d, 0x8c, 0x3d, 0xe6, 0xcf,&#xA;  0xcc, 0x7c, 0x75, 0x78, 0x6e, 0x6e, 0x86, 0x68, 0xbf, 0x98, 0xb2, 0x2c,&#xA;  0x59, 0x5e, 0x55, 0x15, 0x6d, 0x16, 0x62, 0xdf, 0x52, 0xcb, 0x2a, 0x6d,&#xA;  0x6a, 0xab, 0x96, 0xf2, 0xca, 0x12, 0xb2, 0xba, 0xef, 0x5d, 0xfd, 0xa6,&#xA;  0xf6, 0xce, 0x9b, 0xa6, 0x99, 0xb1, 0x4f, 0xc0, 0x2b, 0x5b, 0x60, 0x6c,&#xA;  0x6a, 0xc2, 0x50, 0x7f, 0x2e, 0x02, 0x9e, 0x4c, 0x48, 0x29, 0xa1, 0xab,&#xA;  0x2a, 0x2e, 0x34, 0xd5, 0x21, 0x36, 0x21, 0x8e, 0xbe, 0xbf, 0xf5, 0x82,&#xA;  0x31, 0x40, 0x4a, 0x00, 0x52, 0xe2, 0x5a, 0xf8, 0x02, 0x00, 0x20, 0xfd,&#xA;  0x5d, 0x70, 0xe3, 0xc3, 0x64, 0x07, 0xa5, 0x0b, 0x18, 0x63, 0x4b, 0x28,&#xA;  0x63, 0x4c, 0x08, 0x41, 0x84, 0x10, 0xe5, 0x95, 0xb6, 0xfd, 0x7c, 0x08,&#xA;  0xa8, 0x6a, 0xaf, 0x14, 0x7d, 0x65, 0x09, 0x66, 0x14, 0xe4, 0xa9, 0x6f,&#xA;  0xe6, 0x8d, 0x7a, 0xd4, 0x61, 0x25, 0xbf, 0x85, 0x9d, 0x0a, 0x83, 0x10,&#xA;  0x09, 0x18, 0x1c, 0xb1, 0xf7, 0x62, 0x48, 0x7e, 0x9a, 0x02, 0x03, 0x83,&#xA;  0x6d, 0xdb, 0xe8, 0x75, 0xbf, 0x0b, 0x39, 0x8f, 0x78, 0x01, 0x22, 0xdb,&#xA;  0x1e, 0x02, 0x48, 0x48, 0x29, 0xe1, 0xf6, 0x4f, 0xc7, 0xc5, 0xf2, 0x8d,&#xA;  0x5d, 0x01, 0xee, 0x64, 0x87, 0xb6, 0xc3, 0xaf, 0x59, 0xe4, 0xdb, 0xbe,&#xA;  0x05, 0x3f, 0xf4, 0xb9, 0xb3, 0x0a, 0x01, 0x69, 0x00, 0x84, 0x41, 0x4a,&#xA;  0x09, 0x48, 0x01, 0x09, 0x09, 0x08, 0xde, 0xd6, 0x4a, 0x01, 0x29, 0x05,&#xA;  0x00, 0x01, 0x48, 0x09, 0x29, 0xdb, 0x4f, 0x42, 0xed, 0xfd, 0xcb, 0x67,&#xA;  0xb6, 0xde, 0x00, 0xe8, 0xd1, 0xcb, 0x08, 0x00, 0x54, 0x03, 0x9b, 0x25,&#xA;  0x91, 0xbe, 0x2b, 0xe7, 0xf6, 0x02, 0xd8, 0xdb, 0xd3, 0x61, 0xb7, 0x0d,&#xA;  0x09, 0xc0, 0xea, 0x71, 0x05, 0xd0, 0x06, 0xab, 0x01, 0xd0, 0xdb, 0x5b,&#xA;  0xb5, 0x43, 0x9b, 0x76, 0x86, 0xff, 0xee, 0xae, 0x1c, 0x6d, 0x7b, 0x89,&#xA;  0xd5, 0xc1, 0xcd, 0x76, 0x4f, 0xb6, 0xb7, 0xf6, 0x77, 0x01, 0xb8, 0xd9,&#xA;  0x48, 0x7b, 0x32, 0xda, 0xde, 0x4f, 0x7b, 0xda, 0x64, 0x07, 0x6f, 0x9f,&#xA;  0x0f, 0x48, 0xfc, 0xbf, 0xd9, 0x7f, 0x00, 0x76, 0x69, 0xe5, 0x89, 0x4b,&#xA;  0x1e, 0x7c, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae,&#xA;  0x42, 0x60, 0x82,&#xA;}&#xA;&#xA;var __32x32_places_folder_png = []byte{&#xA;  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,&#xA;  0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20,&#xA;  0x08, 0x06, 0x00, 0x00, 0x00, 0x73, 0x7a, 0x7a, 0xf4, 0x00, 0x00, 0x00,&#xA;  0x04, 0x73, 0x42, 0x49, 0x54, 0x08, 0x08, 0x08, 0x08, 0x7c, 0x08, 0x64,&#xA;  0x88, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0d,&#xA;  0xd7, 0x00, 0x00, 0x0d, 0xd7, 0x01, 0x42, 0x28, 0x9b, 0x78, 0x00, 0x00,&#xA;  0x00, 0x19, 0x74, 0x45, 0x58, 0x74, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61,&#xA;  0x72, 0x65, 0x00, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x6e, 0x6b, 0x73, 0x63,&#xA;  0x61, 0x70, 0x65, 0x2e, 0x6f, 0x72, 0x67, 0x9b, 0xee, 0x3c, 0x1a, 0x00,&#xA;  0x00, 0x04, 0x15, 0x49, 0x44, 0x41, 0x54, 0x58, 0x85, 0xed, 0x97, 0x3d,&#xA;  0x6f, 0x1c, 0x45, 0x18, 0xc7, 0x7f, 0x33, 0xbb, 0x77, 0x7b, 0xaf, 0xf6,&#xA;  0x39, 0x91, 0x30, 0x09, 0x05, 0x56, 0x94, 0xc2, 0x1f, 0x00, 0x09, 0x05,&#xA;  0x21, 0x53, 0x6e, 0x95, 0x82, 0x1a, 0x89, 0x02, 0x5a, 0x3a, 0x3e, 0x40,&#xA;  0x24, 0x3e, 0x40, 0x4a, 0x84, 0x44, 0x85, 0x68, 0xa1, 0x43, 0x48, 0xa7,&#xA;  0x40, 0x17, 0xc9, 0x8a, 0x02, 0x8a, 0xd2, 0x45, 0xc2, 0xc6, 0xc4, 0x28,&#xA;  0x16, 0xc6, 0xf7, 0xba, 0x77, 0xde, 0x97, 0x99, 0x9d, 0x19, 0x8a, 0x7b,&#xA;  0xc9, 0x3a, 0x77, 0x8e, 0x13, 0x72, 0x52, 0x28, 0xf8, 0x4b, 0x8f, 0x76,&#xA;  0x76, 0x76, 0xf7, 0x79, 0x7e, 0xf3, 0x3c, 0x33, 0xb3, 0xbb, 0x22, 0x0c,&#xA;  0x43, 0x5e, 0xa7, 0xe4, 0x6b, 0x8d, 0xfe, 0x5f, 0x00, 0xf0, 0x01, 0x6e,&#xA;  0xdc, 0xb8, 0xe1, 0x2b, 0xa5, 0x7e, 0x36, 0xc6, 0xbc, 0x77, 0xd1, 0x03,&#xA;  0x42, 0x88, 0xdc, 0x5a, 0xfb, 0xf9, 0xc3, 0x87, 0x0f, 0xbf, 0x5c, 0x19,&#xA;  0x40, 0x9a, 0xa6, 0x5b, 0x95, 0x4a, 0xe5, 0x9d, 0x9b, 0x37, 0x6f, 0xfa,&#xA;  0x49, 0x92, 0xe0, 0x9c, 0x03, 0xc0, 0x5a, 0x0b, 0x30, 0x3f, 0x9f, 0xb6,&#xA;  0xfd, 0x3b, 0x77, 0xee, 0xdc, 0xde, 0xde, 0xde, 0xfe, 0xfe, 0xd1, 0xa3,&#xA;  0x47, 0xc7, 0x2b, 0x01, 0x50, 0x4a, 0x65, 0xd5, 0x6a, 0xd5, 0x1d, 0x1d,&#xA;  0x1d, 0xd1, 0xe9, 0x74, 0x70, 0xce, 0x2d, 0x35, 0x00, 0x21, 0x04, 0x9b,&#xA;  0x9b, 0x9b, 0xf9, 0xc1, 0xc1, 0xc1, 0x47, 0xc0, 0xed, 0x95, 0x00, 0x68,&#xA;  0xad, 0xd3, 0x2c, 0xcb, 0xc4, 0xa5, 0x4b, 0x1b, 0x18, 0x63, 0xb0, 0xd6,&#xA;  0x9e, 0x09, 0x5c, 0xcc, 0x84, 0x10, 0x82, 0x6a, 0xb5, 0x5a, 0x3f, 0x3c,&#xA;  0x3c, 0xfc, 0x62, 0x7b, 0x7b, 0xfb, 0xd6, 0xac, 0x7f, 0x99, 0x9c, 0x73,&#xA;  0xda, 0x5a, 0xfb, 0xf1, 0xde, 0xde, 0xde, 0x8f, 0xcf, 0x05, 0x00, 0xb2,&#xA;  0x2c, 0xcb, 0xbc, 0x4e, 0xa7, 0x4b, 0xa7, 0xd3, 0x99, 0x03, 0xcc, 0x8e,&#xA;  0xb3, 0x20, 0xc5, 0x40, 0x5b, 0x5b, 0x5b, 0xf5, 0x46, 0xa3, 0x41, 0xb3,&#xA;  0xd9, 0x44, 0x08, 0x81, 0x10, 0x02, 0x00, 0x29, 0xe5, 0xbc, 0x1d, 0x45,&#xA;  0x11, 0xf7, 0xee, 0xdd, 0xbb, 0x05, 0x3c, 0x1f, 0xe0, 0xf2, 0xe5, 0xcb,&#xA;  0x69, 0xbf, 0xdf, 0xf7, 0x36, 0x36, 0x5a, 0x68, 0xad, 0x17, 0x00, 0x96,&#xA;  0x95, 0x62, 0xa6, 0x38, 0x8e, 0x01, 0xe6, 0x10, 0x45, 0x8b, 0xe3, 0x18,&#xA;  0x63, 0x4c, 0xed, 0xbc, 0xe0, 0x73, 0x80, 0xdd, 0xdd, 0x5d, 0x75, 0xed,&#xA;  0xda, 0x35, 0xd9, 0xeb, 0xf5, 0xe6, 0x19, 0x00, 0x96, 0x82, 0xcc, 0xb2,&#xA;  0x51, 0xd4, 0x6c, 0xc4, 0xc5, 0xe0, 0x52, 0xca, 0x19, 0x40, 0xe5, 0x42,&#xA;  0x00, 0x00, 0x63, 0x8c, 0x6d, 0x36, 0xd7, 0x64, 0x9a, 0x66, 0xdc, 0x3f,&#xA;  0xb4, 0xdc, 0xdd, 0x3f, 0x1b, 0xe4, 0xbc, 0x3a, 0x3f, 0xab, 0x19, 0xcc,&#xA;  0xe4, 0x99, 0x16, 0xce, 0x5d, 0xb9, 0xce, 0xdb, 0x1f, 0xe8, 0xe2, 0x3d,&#xA;  0x9e, 0x27, 0xbe, 0x5d, 0xff, 0xfd, 0x9b, 0x4f, 0xce, 0x00, 0x38, 0xe7,&#xA;  0x74, 0xb7, 0xdb, 0xf5, 0xbb, 0xdd, 0x2e, 0x8f, 0x3b, 0x0d, 0x3e, 0xfd,&#xA;  0xf0, 0x5d, 0xae, 0xbf, 0xb5, 0x51, 0x70, 0x36, 0x3d, 0x3e, 0x2f, 0xfa,&#xA;  0x12, 0xc8, 0x69, 0xcf, 0x3c, 0xce, 0x93, 0xce, 0x98, 0xaf, 0xbe, 0xbb,&#xA;  0xff, 0xfe, 0xec, 0xbc, 0x98, 0x01, 0xdd, 0x68, 0xd4, 0xab, 0x5a, 0x6b,&#xA;  0xd4, 0x1f, 0x92, 0x66, 0xb5, 0xcc, 0xfe, 0xdf, 0x63, 0xa2, 0x38, 0x9f,&#xA;  0x8c, 0x6c, 0xe9, 0x68, 0xcf, 0x23, 0x11, 0x0b, 0x4d, 0x01, 0x34, 0x2a,&#xA;  0x3e, 0x2a, 0xd3, 0x08, 0x41, 0x67, 0x76, 0x79, 0xbe, 0x15, 0x1b, 0x63,&#xA;  0x74, 0xbf, 0x3f, 0xa0, 0xdb, 0xed, 0x12, 0x67, 0x96, 0x7a, 0xb5, 0x84,&#xA;  0x35, 0x93, 0x1b, 0xe4, 0xd4, 0xc1, 0xb3, 0x86, 0x3b, 0xcf, 0xdc, 0x53,&#xA;  0xb3, 0x13, 0xb3, 0xd6, 0x91, 0x64, 0x86, 0x34, 0xcb, 0xc1, 0x89, 0xf9,&#xA;  0x06, 0x56, 0x2c, 0x41, 0x56, 0xa9, 0x04, 0xb4, 0x5a, 0x2d, 0x32, 0x23,&#xA;  0xa8, 0x05, 0x25, 0xac, 0x53, 0x78, 0x72, 0x35, 0xaf, 0x8b, 0x71, 0x9a,&#xA;  0x53, 0x6f, 0xfa, 0x8c, 0x86, 0x39, 0xd6, 0xba, 0x27, 0x0b, 0x00, 0x79,&#xA;  0x9e, 0xab, 0x28, 0x1a, 0xd1, 0xef, 0x0f, 0xd0, 0xe6, 0x0d, 0xaa, 0x81,&#xA;  0x8f, 0x73, 0x0e, 0x4f, 0x9e, 0x9b, 0xe7, 0x17, 0x93, 0x83, 0x51, 0xaa,&#xA;  0xd1, 0xb9, 0x25, 0xf0, 0x25, 0x71, 0xaa, 0xad, 0x31, 0xf9, 0xd1, 0x02,&#xA;  0x80, 0x31, 0x26, 0x2b, 0x97, 0x4b, 0x54, 0x9b, 0x1b, 0xac, 0xd5, 0xca,&#xA;  0x38, 0x40, 0x0a, 0xb1, 0xbc, 0xf8, 0x2f, 0x28, 0xe3, 0x1c, 0xa3, 0x54,&#xA;  0x93, 0x5b, 0x87, 0xe7, 0x09, 0x82, 0xb2, 0xc7, 0x69, 0x92, 0x29, 0x21,&#xA;  0xc4, 0xc9, 0x02, 0x80, 0xb5, 0x36, 0x1b, 0x8d, 0xc6, 0x1c, 0x0f, 0x14,&#xA;  0xeb, 0xf5, 0x4b, 0xe8, 0xdc, 0xbe, 0xd2, 0xe8, 0x33, 0x6d, 0x89, 0x33,&#xA;  0x03, 0x4e, 0xe0, 0x4f, 0xfd, 0x94, 0x3d, 0xc9, 0xe8, 0x54, 0xe5, 0x82,&#xA;  0xa7, 0x93, 0xb0, 0x98, 0x81, 0xd4, 0xf7, 0x7d, 0xbc, 0x20, 0xa0, 0x49,&#xA;  0x99, 0x4c, 0xd9, 0x0b, 0x83, 0x4c, 0xe6, 0x98, 0xc3, 0xba, 0xc9, 0x3e,&#xA;  0x61, 0xec, 0xc4, 0x54, 0x6e, 0x97, 0xad, 0x48, 0x9c, 0x83, 0xc1, 0x28,&#xA;  0xb5, 0xb9, 0x73, 0x8b, 0x00, 0xd6, 0xda, 0x64, 0x3c, 0x1e, 0xd3, 0x19,&#xA;  0xf8, 0x54, 0x5a, 0x65, 0xa2, 0x44, 0x93, 0xe9, 0xe9, 0x4b, 0x08, 0xc8,&#xA;  0x8d, 0x45, 0x1b, 0x87, 0xce, 0x2d, 0xb9, 0x99, 0x6e, 0xcb, 0x2f, 0x99,&#xA;  0x95, 0x44, 0x19, 0x86, 0xe3, 0xc4, 0x13, 0xd2, 0x5b, 0x5a, 0x82, 0x54,&#xA;  0x08, 0x81, 0x0c, 0x1a, 0x94, 0x4a, 0x3e, 0xa3, 0x44, 0x13, 0x25, 0x9a,&#xA;  0x54, 0x19, 0x94, 0xb6, 0x2f, 0x1d, 0x6c, 0x99, 0xe2, 0x2c, 0xe7, 0x34,&#xA;  0xd1, 0x3e, 0xe7, 0x94, 0x20, 0x8e, 0xe3, 0x53, 0x7a, 0x51, 0x85, 0x4a,&#xA;  0x0d, 0x1e, 0x9f, 0xc4, 0x0c, 0x63, 0xbd, 0xd4, 0xd1, 0xbf, 0x91, 0x00,&#xA;  0x86, 0xb1, 0x42, 0x19, 0x53, 0xfa, 0xf5, 0xea, 0x5e, 0x2f, 0x7c, 0xfc,&#xA;  0x0c, 0x80, 0xb5, 0x36, 0x06, 0x81, 0xf5, 0x6b, 0x64, 0xb9, 0x25, 0x8a,&#xA;  0x35, 0x4a, 0x5f, 0x3c, 0x0f, 0x5e, 0x54, 0x52, 0x0a, 0x4e, 0x86, 0x09,&#xA;  0x52, 0xc8, 0x38, 0xdc, 0xdd, 0x9d, 0x3b, 0x3e, 0x33, 0x07, 0x92, 0x24,&#xA;  0x21, 0x4a, 0x0c, 0x57, 0xaf, 0x04, 0x54, 0x03, 0x8f, 0xa0, 0xbc, 0xba,&#xA;  0x6f, 0x56, 0x29, 0x04, 0x69, 0xaa, 0x90, 0x52, 0x0c, 0x8b, 0xfd, 0xc5,&#xA;  0x12, 0x24, 0x00, 0x9a, 0x12, 0xeb, 0x55, 0x8f, 0x7a, 0x69, 0x15, 0x55,&#xA;  0x7f, 0x2a, 0xe7, 0x1c, 0xfd, 0x24, 0x41, 0x58, 0x3b, 0x58, 0x00, 0x68,&#xA;  0xb7, 0xdb, 0x62, 0x67, 0x67, 0xc7, 0x44, 0xb1, 0x62, 0x70, 0xea, 0xf8,&#xA;  0xf3, 0x64, 0x88, 0xec, 0xbe, 0xe2, 0x0e, 0xb8, 0x44, 0xc7, 0xc7, 0x43,&#xA;  0x9b, 0x24, 0xc3, 0x07, 0xbb, 0xed, 0x76, 0x2d, 0x0c, 0xc3, 0x78, 0x0e,&#xA;  0x00, 0x78, 0x51, 0x14, 0xfd, 0xf4, 0xcb, 0xa1, 0xf8, 0x4c, 0xad, 0xe3,&#xA;  0xff, 0xb6, 0xff, 0xca, 0x1f, 0xbb, 0x67, 0xe4, 0xc0, 0x02, 0x58, 0x9d,&#xA;  0x1e, 0x1c, 0x3f, 0xf8, 0xe1, 0xeb, 0xe2, 0x35, 0x31, 0xfb, 0x35, 0x6b,&#xA;  0xb7, 0xdb, 0xcd, 0x60, 0x6d, 0xed, 0xcd, 0x5a, 0xd0, 0xda, 0x74, 0x38,&#xA;  0x29, 0x85, 0x5c, 0xc9, 0x12, 0xc8, 0x8d, 0x31, 0x2a, 0x4b, 0x6b, 0xb9,&#xA;  0x10, 0x79, 0x3e, 0x3a, 0xe9, 0x01, 0x7f, 0x85, 0x61, 0xd8, 0x5b, 0x00,&#xA;  0x98, 0x42, 0x48, 0x20, 0x60, 0x92, 0x99, 0x7c, 0x15, 0x00, 0x53, 0x05,&#xA;  0x40, 0x0a, 0xa8, 0x30, 0x0c, 0xcf, 0x2c, 0x2d, 0xf1, 0xff, 0xcf, 0xe9,&#xA;  0xeb, 0x06, 0xf8, 0x07, 0xbc, 0x32, 0xa5, 0x97, 0xcb, 0x08, 0x37, 0x2b,&#xA;  0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,&#xA;}&#xA;&#xA;var __32x32_mimetypes_x_office_spreadsheet_png = []byte{&#xA;  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,&#xA;  0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20,&#xA;  0x08, 0x06, 0x00, 0x00, 0x00, 0x73, 0x7a, 0x7a, 0xf4, 0x00, 0x00, 0x00,&#xA;  0x04, 0x73, 0x42, 0x49, 0x54, 0x08, 0x08, 0x08, 0x08, 0x7c, 0x08, 0x64,&#xA;  0x88, 0x00, 0x00, 0x05, 0xa5, 0x49, 0x44, 0x41, 0x54, 0x58, 0x85, 0xe5,&#xA;  0x97, 0xcd, 0x6b, 0x54, 0x57, 0x18, 0xc6, 0x7f, 0xe7, 0xde, 0x3b, 0x93,&#xA;  0x51, 0x67, 0x92, 0x8c, 0x66, 0x32, 0x6a, 0x26, 0x4d, 0x94, 0x18, 0x27,&#xA;  0xa9, 0x50, 0xbf, 0x5a, 0x2d, 0x94, 0x76, 0xd1, 0x85, 0x05, 0x41, 0x8b,&#xA;  0x60, 0x75, 0x53, 0x70, 0x21, 0x0a, 0x55, 0xba, 0x71, 0x51, 0xa8, 0xb4,&#xA;  0x7f, 0x40, 0xd7, 0xd5, 0x45, 0xa5, 0x90, 0x6e, 0x5a, 0xa8, 0x20, 0x34,&#xA;  0x15, 0x0a, 0x6d, 0xa1, 0x25, 0x58, 0x2c, 0xa4, 0xd6, 0x42, 0x4d, 0xa2,&#xA;  0xf9, 0x20, 0xc9, 0xc4, 0x64, 0x3e, 0x4c, 0xa2, 0x13, 0x93, 0xcc, 0xdc,&#xA;  0xef, 0x2e, 0x32, 0xf7, 0xf4, 0xde, 0xc9, 0x97, 0x59, 0x74, 0xd5, 0x03,&#xA;  0x87, 0x7b, 0xde, 0xf3, 0x9e, 0x73, 0xde, 0xe7, 0x3c, 0xef, 0xf3, 0xde,&#xA;  0xb9, 0x03, 0xff, 0xf7, 0x26, 0xaa, 0x27, 0xae, 0x5d, 0xbb, 0x76, 0x4a,&#xA;  0xd3, 0xb4, 0x2e, 0x20, 0xa6, 0xaa, 0x2a, 0x8a, 0xa2, 0xe0, 0x38, 0x0e,&#xA;  0xb6, 0x6d, 0xcb, 0x6e, 0x59, 0x96, 0x7c, 0xfa, 0xc7, 0x6b, 0xcd, 0x01,&#xA;  0xcf, 0x2d, 0xcb, 0x3a, 0xd7, 0xd5, 0xd5, 0x75, 0xcb, 0x1f, 0x4f, 0x5b,&#xA;  0x86, 0x48, 0x88, 0x2f, 0xcf, 0x9f, 0x3f, 0x1f, 0xab, 0x8c, 0xe5, 0xbc,&#xA;  0xeb, 0xba, 0x81, 0x75, 0x7e, 0xfb, 0x05, 0xc7, 0xb1, 0x4b, 0x97, 0x2e,&#xA;  0x7d, 0x09, 0xac, 0x0d, 0xc0, 0xb6, 0xed, 0x7a, 0x80, 0xd1, 0xd1, 0x51,&#xA;  0x84, 0x10, 0x12, 0x84, 0xff, 0xe9, 0x07, 0xe6, 0x1f, 0xaf, 0x64, 0x7b,&#xA;  0x40, 0x1a, 0x1b, 0x1b, 0x31, 0x0c, 0xa3, 0xbe, 0xda, 0xb7, 0x0c, 0x80,&#xA;  0xeb, 0xba, 0x32, 0xc8, 0x8d, 0x1b, 0x37, 0x48, 0x24, 0x12, 0x81, 0xa0,&#xA;  0xf9, 0x7c, 0x9e, 0x64, 0x32, 0x29, 0xed, 0x42, 0xa1, 0x40, 0x32, 0x99,&#xA;  0x94, 0xfb, 0x0b, 0x85, 0x02, 0x8d, 0x8d, 0x8d, 0xd2, 0x9e, 0x9e, 0x9e,&#xA;  0xe6, 0xc2, 0x85, 0x0b, 0xcb, 0x40, 0xad, 0x0a, 0xc0, 0x71, 0x1c, 0x79,&#xA;  0x93, 0x54, 0x2a, 0x45, 0x2a, 0x95, 0x0a, 0xdc, 0xaa, 0xa6, 0xa6, 0x26,&#xA;  0x30, 0x17, 0x89, 0x44, 0x48, 0xa5, 0x52, 0x72, 0x8f, 0xdf, 0xf6, 0xfc,&#xA;  0xde, 0xda, 0xea, 0x34, 0xae, 0x0a, 0xc0, 0x63, 0xc1, 0x3b, 0xb4, 0xfa,&#xA;  0x59, 0x9d, 0x9a, 0x95, 0x68, 0xf7, 0xb7, 0xb5, 0xfc, 0x2b, 0x69, 0x40,&#xA;  0x8e, 0xa7, 0xa6, 0xa6, 0xb0, 0x6d, 0x3b, 0x10, 0xac, 0x50, 0x28, 0x04,&#xA;  0xd6, 0xe4, 0xf3, 0x79, 0x4c, 0xd3, 0x94, 0xfe, 0x7c, 0x3e, 0xef, 0xa9,&#xA;  0x5e, 0xfa, 0x37, 0xcc, 0x80, 0x77, 0xd8, 0xce, 0x9d, 0x3b, 0x03, 0xf4,&#xA;  0x0a, 0x21, 0xd0, 0x34, 0x8d, 0xe3, 0xc7, 0x8f, 0xcb, 0x43, 0x47, 0x46,&#xA;  0x46, 0x68, 0x6b, 0x6b, 0x93, 0x6b, 0x86, 0x87, 0x87, 0xa5, 0x0d, 0x30,&#xA;  0x3c, 0x3c, 0x8c, 0xa2, 0x28, 0x2f, 0x0e, 0xc0, 0xbb, 0x9d, 0x10, 0x82,&#xA;  0x6c, 0x36, 0x8b, 0xe3, 0x38, 0xcb, 0x44, 0x38, 0x34, 0x34, 0x24, 0xd7,&#xA;  0x4f, 0x4c, 0x4c, 0x04, 0x40, 0x67, 0x32, 0x19, 0x69, 0x03, 0x64, 0x32,&#xA;  0x19, 0xd2, 0xe9, 0xf4, 0xc6, 0x01, 0x00, 0xec, 0xd8, 0xb1, 0x83, 0xe6,&#xA;  0xe6, 0xe6, 0x00, 0x00, 0x55, 0x55, 0xd9, 0xbb, 0x77, 0xaf, 0xb4, 0x43,&#xA;  0xa1, 0x50, 0x80, 0x01, 0x4d, 0xd3, 0x02, 0x0c, 0x68, 0x9a, 0xb6, 0xb1,&#xA;  0x14, 0xd8, 0xb6, 0x2d, 0x45, 0x98, 0xcb, 0xe5, 0x96, 0x6d, 0x28, 0x14,&#xA;  0x0a, 0x0c, 0x0e, 0x0e, 0xca, 0x80, 0xff, 0x19, 0x03, 0x9e, 0x06, 0x9a,&#xA;  0x9b, 0x9b, 0xa5, 0x4f, 0x08, 0x41, 0x28, 0x14, 0x92, 0x07, 0x7a, 0xb6,&#xA;  0x9f, 0x01, 0x55, 0x55, 0xd9, 0xb3, 0x67, 0x8f, 0xdc, 0xa3, 0xaa, 0xaa,&#xA;  0x64, 0xc0, 0x0f, 0x6c, 0x5d, 0x00, 0x80, 0xd4, 0x80, 0x77, 0xb8, 0xa7,&#xA;  0xf2, 0x47, 0x8f, 0x1e, 0x49, 0x3b, 0x93, 0xc9, 0x04, 0x40, 0xaf, 0xc4,&#xA;  0x40, 0x47, 0x47, 0xc7, 0xc6, 0x18, 0xf0, 0x52, 0xe0, 0x55, 0x81, 0xbf,&#xA;  0xf6, 0x55, 0x55, 0x25, 0x9d, 0x4e, 0x07, 0xec, 0xf6, 0xf6, 0x76, 0x09,&#xA;  0x40, 0xd3, 0xb4, 0x00, 0x03, 0x7e, 0x0d, 0xbc, 0x10, 0x03, 0xfe, 0x1a,&#xA;  0xf6, 0xbf, 0x07, 0xbc, 0x9e, 0xcb, 0xe5, 0x02, 0x1a, 0x18, 0x1f, 0x1b,&#xA;  0x23, 0x7b, 0xef, 0x1e, 0xf9, 0xfb, 0xf7, 0x79, 0x36, 0x32, 0xc2, 0x7c,&#xA;  0x2e, 0x47, 0x44, 0x51, 0x70, 0x34, 0x8d, 0xf0, 0xd6, 0xad, 0x28, 0x89,&#xA;  0x04, 0xe1, 0x73, 0xe7, 0xe8, 0x7c, 0xfb, 0xed, 0x8d, 0xa5, 0xc0, 0xaf,&#xA;  0x81, 0xea, 0x2a, 0x48, 0xa7, 0xd3, 0xd8, 0xa6, 0x49, 0xef, 0x57, 0x5f,&#xA;  0x31, 0x70, 0xfd, 0x3a, 0xfb, 0x1a, 0x1a, 0x78, 0x6b, 0xd7, 0x2e, 0x5a,&#xA;  0x3a, 0x3b, 0x89, 0x1d, 0x3a, 0x84, 0xeb, 0x38, 0x38, 0xa6, 0x49, 0x71,&#xA;  0x6e, 0x8e, 0xb1, 0x5c, 0x8e, 0xbe, 0x2b, 0x57, 0xe8, 0x2e, 0x97, 0x89,&#xA;  0xd4, 0xd5, 0x71, 0x1a, 0xc2, 0x37, 0xc1, 0x58, 0x17, 0x80, 0xc7, 0xc0,&#xA;  0x4a, 0xef, 0x81, 0x3f, 0x7b, 0x7a, 0xb8, 0xf3, 0xc9, 0x27, 0x1c, 0x88,&#xA;  0x46, 0xb9, 0x7a, 0xf2, 0x24, 0x9b, 0xc3, 0x61, 0x60, 0x29, 0xc7, 0xb6,&#xA;  0x61, 0xe0, 0x98, 0x26, 0x8e, 0x69, 0x12, 0x11, 0x82, 0xf6, 0x86, 0x06,&#xA;  0xda, 0xea, 0xea, 0x58, 0x58, 0x5c, 0xe4, 0xa7, 0x81, 0x01, 0xee, 0xc2,&#xA;  0x6f, 0x1f, 0xc0, 0xa9, 0xeb, 0x30, 0xb1, 0x2a, 0x00, 0x4f, 0x03, 0x4d,&#xA;  0x4d, 0x4d, 0x92, 0x01, 0x8f, 0x15, 0x61, 0x9a, 0xdc, 0xbd, 0x7a, 0x95,&#xA;  0x77, 0x3b, 0x3b, 0x39, 0xdc, 0xd6, 0x06, 0x95, 0x94, 0x39, 0xa6, 0x89,&#xA;  0x6d, 0x59, 0x32, 0xb8, 0x63, 0x9a, 0xd8, 0xbe, 0x71, 0xc8, 0xb2, 0x78,&#xA;  0xa7, 0xb5, 0x95, 0x44, 0x28, 0x74, 0xf8, 0xbb, 0xe1, 0xe1, 0x1f, 0x2f,&#xA;  0xc0, 0xd1, 0x2f, 0xa0, 0xb8, 0xae, 0x06, 0x3c, 0x06, 0x3c, 0x00, 0x43,&#xA;  0x37, 0x6f, 0x72, 0x28, 0x1e, 0xe7, 0x70, 0x47, 0x07, 0xe8, 0x3a, 0x8e,&#xA;  0x6d, 0xaf, 0x18, 0x30, 0x30, 0xe7, 0x03, 0xb6, 0x2f, 0x1e, 0x67, 0x68,&#xA;  0xdb, 0xb6, 0x74, 0xff, 0xcc, 0xcc, 0x47, 0xc0, 0xc7, 0x6b, 0xa6, 0xa0,&#xA;  0x5a, 0x03, 0x42, 0x08, 0xfa, 0x1f, 0x3e, 0xe4, 0xf5, 0xb3, 0x67, 0x71,&#xA;  0x2d, 0x0b, 0xbb, 0x54, 0x5a, 0x37, 0xe0, 0x32, 0x50, 0xae, 0xcb, 0x81,&#xA;  0x44, 0x82, 0xbe, 0x99, 0x99, 0xb3, 0xab, 0x02, 0xf0, 0xea, 0x75, 0x6a,&#xA;  0x6a, 0x4a, 0x8e, 0x3d, 0x16, 0xf4, 0xe9, 0x69, 0x6a, 0x6b, 0x6b, 0xb1,&#xA;  0x9e, 0x3e, 0xc5, 0x29, 0x95, 0xfe, 0x0d, 0x50, 0x09, 0x6a, 0x9b, 0x26,&#xA;  0xe3, 0x6f, 0xec, 0xe7, 0xdb, 0xf2, 0x6b, 0xe0, 0xba, 0x98, 0x86, 0x81,&#xA;  0x6e, 0x18, 0x58, 0x86, 0x81, 0x6e, 0x98, 0x38, 0xb6, 0x49, 0xab, 0x53,&#xA;  0x44, 0x3c, 0xfc, 0xf4, 0x25, 0x40, 0x59, 0x93, 0x01, 0x4f, 0x03, 0x32,&#xA;  0xff, 0x42, 0x70, 0xdf, 0x75, 0x79, 0x92, 0xcd, 0xb2, 0x79, 0xcb, 0x16,&#xA;  0xec, 0x72, 0x79, 0xd9, 0x0d, 0x6d, 0xd7, 0xa6, 0xfc, 0x7e, 0x03, 0xdb,&#xA;  0xba, 0x8b, 0xfc, 0xb9, 0x98, 0x46, 0xd7, 0x0d, 0x0c, 0x43, 0x47, 0xd7,&#xA;  0x0d, 0x74, 0xdd, 0x20, 0xa2, 0xb9, 0x44, 0x67, 0x17, 0x01, 0x54, 0x20,&#xA;  0xba, 0xaa, 0x06, 0x84, 0x10, 0x4c, 0x4e, 0x4e, 0x06, 0xde, 0x84, 0x00,&#xA;  0x4a, 0x2c, 0x46, 0x6f, 0x4f, 0x0f, 0xc9, 0x33, 0x67, 0x50, 0x66, 0x66,&#xA;  0xb0, 0xab, 0x58, 0x28, 0xbe, 0x12, 0x27, 0x17, 0xce, 0xb2, 0x6b, 0xff,&#xA;  0xdf, 0xf4, 0xf6, 0xec, 0xc2, 0xb2, 0xec, 0x4a, 0xb7, 0x08, 0x6b, 0xd0,&#xA;  0x1e, 0xd1, 0xc9, 0x67, 0xc6, 0x88, 0x43, 0x1e, 0x88, 0x28, 0x6b, 0xa5,&#xA;  0xa0, 0xa9, 0xa9, 0x89, 0x96, 0x96, 0x16, 0xd9, 0x5b, 0x5b, 0x5b, 0xa9,&#xA;  0xdd, 0xb7, 0x8f, 0x81, 0xc9, 0x49, 0xfe, 0xf8, 0xe1, 0x07, 0x4a, 0xc9,&#xA;  0x24, 0x6e, 0x32, 0xb9, 0xf4, 0xe9, 0x5d, 0x2e, 0x63, 0x95, 0x4a, 0x64,&#xA;  0x0e, 0x0b, 0xa6, 0xf5, 0x31, 0x1e, 0xef, 0x78, 0xcc, 0x2b, 0xa1, 0xaf,&#xA;  0x97, 0x2e, 0xe4, 0xda, 0x6c, 0x8f, 0x6f, 0xe2, 0xb5, 0x58, 0x99, 0xc1,&#xA;  0xc7, 0x05, 0xe2, 0x7d, 0x3f, 0x53, 0x82, 0x3b, 0x80, 0xbd, 0x6a, 0x0a,&#xA;  0x5c, 0xd7, 0x5d, 0x91, 0x01, 0xf7, 0xe0, 0x41, 0x9e, 0xf7, 0xf5, 0x71,&#xA;  0x6f, 0x74, 0x94, 0x85, 0x62, 0x91, 0x9d, 0xbb, 0x77, 0xb3, 0xbd, 0xad,&#xA;  0x8d, 0x70, 0xa9, 0x84, 0x3d, 0x37, 0x4b, 0xf6, 0x48, 0x84, 0xb2, 0x55,&#xA;  0xc4, 0xb2, 0x75, 0xa2, 0x6f, 0x3d, 0xe0, 0xe5, 0xde, 0xd3, 0xd4, 0x1b,&#xA;  0x30, 0x3d, 0xd8, 0x47, 0xcf, 0xa2, 0xc6, 0x9e, 0xde, 0x6e, 0xc8, 0x8f,&#xA;  0x3c, 0xfb, 0x0b, 0x3e, 0x07, 0x16, 0xd6, 0x2c, 0xc3, 0x8b, 0x17, 0x2f,&#xA;  0x06, 0x2a, 0x40, 0x08, 0x81, 0x7d, 0xe2, 0x04, 0x03, 0x6f, 0xbe, 0xc9,&#xA;  0xed, 0xcb, 0x97, 0x79, 0x9e, 0xcf, 0xb3, 0xd7, 0x30, 0x98, 0xe8, 0xef,&#xA;  0x67, 0x53, 0x34, 0x8a, 0x95, 0x8e, 0x32, 0xf7, 0x57, 0x8c, 0x90, 0x02,&#xA;  0xb8, 0xb0, 0x50, 0xd6, 0x31, 0xfe, 0xee, 0xe2, 0xfb, 0x85, 0xa3, 0x34,&#xA;  0x17, 0xb3, 0xec, 0xef, 0xbd, 0x85, 0x9e, 0x1b, 0x99, 0x7e, 0x00, 0x1f,&#xA;  0x3e, 0x80, 0x7e, 0xa0, 0x5c, 0x0d, 0x20, 0xa6, 0x28, 0xca, 0x9c, 0xeb,&#xA;  0xba, 0xb5, 0xf5, 0xf5, 0xff, 0x7e, 0xc2, 0x57, 0x7f, 0x54, 0x1e, 0x3a,&#xA;  0x76, 0x8c, 0x86, 0xdb, 0xb7, 0xf9, 0xe5, 0xb3, 0xcf, 0xf8, 0xbd, 0xbb,&#xA;  0x9b, 0x58, 0x28, 0x44, 0x52, 0xd7, 0x51, 0x1f, 0x2f, 0x30, 0x3e, 0xfe,&#xA;  0x0c, 0x67, 0x93, 0xc0, 0x71, 0x5d, 0x42, 0x33, 0x16, 0x4a, 0x5f, 0x3f,&#xA;  0xaf, 0x3e, 0xfc, 0x15, 0xa7, 0x58, 0xa0, 0xb0, 0x75, 0xab, 0x75, 0x07,&#xA;  0x2e, 0x66, 0xa1, 0x17, 0x78, 0x02, 0xc1, 0xbf, 0x66, 0x31, 0x20, 0x71,&#xA;  0xe4, 0xc8, 0x91, 0xf7, 0x5a, 0x5a, 0x5a, 0x3e, 0x05, 0x36, 0x55, 0xb3,&#xA;  0xe3, 0x6f, 0xae, 0xeb, 0x62, 0x18, 0x06, 0xd6, 0xfc, 0x3c, 0x35, 0x93,&#xA;  0x93, 0x44, 0x66, 0x67, 0xa9, 0x99, 0x9f, 0x47, 0x33, 0x0c, 0x14, 0xcb,&#xA;  0xc2, 0xd1, 0x34, 0xcc, 0x50, 0x08, 0x3d, 0x1a, 0xa5, 0x14, 0x8f, 0x53,&#xA;  0xda, 0xbe, 0xdd, 0x18, 0xcd, 0xe5, 0xbe, 0x18, 0x1c, 0x1c, 0xfc, 0x06,&#xA;  0x18, 0x07, 0xb2, 0x80, 0xe3, 0x07, 0x10, 0x06, 0x92, 0xc0, 0x36, 0xa0,&#xA;  0x1e, 0xa8, 0x61, 0xa9, 0x54, 0xd6, 0x6b, 0x0a, 0x10, 0x01, 0x36, 0x57,&#xA;  0xf6, 0x68, 0x95, 0x39, 0x00, 0x87, 0xa5, 0x1f, 0x9e, 0xa7, 0x80, 0x0e,&#xA;  0x3c, 0x03, 0x66, 0x59, 0xfa, 0x1d, 0x98, 0xaf, 0x66, 0xc0, 0x6b, 0x35,&#xA;  0x95, 0x03, 0xc3, 0xab, 0xf8, 0xd7, 0x6b, 0xa2, 0xd2, 0xbd, 0xaf, 0x0f,&#xA;  0xb7, 0x02, 0xc4, 0xac, 0x80, 0xd0, 0x7d, 0x3e, 0xfe, 0x01, 0x9f, 0x1e,&#xA;  0x98, 0x64, 0x1e, 0x77, 0xb2, 0x47, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45,&#xA;  0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>GDB</title>
      <link>http://www.nljb.net/default/GDB/</link>
      <pubDate>2014-08-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;GDB&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;r(run)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;要想运行准备调试的程序，可使用run命令，在它后面可以跟随发给该程序的任何参数.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你使用不带参数的run命令，gdb就再次使用你给予前一条run命令的参数，这是很有用的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;利用set args 命令就可以修改发送给程序的参数，而使用show args 命令就可以查看其缺省参数的列表。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;attach PID&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;众所周知，GDB有附着（attach）到正在运行的进程的功能，即attach &lt;pid&gt;命令。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此我们可以利用该命令attach到子进程然后进行调试。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gdb attach PID&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同样可以命令行启动&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;info threads &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示当前可调试的所有线程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;前面有*的是当前调试的线程。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;thread ID &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;切换当前调试的线程为指定ID的线程。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;bt(backtrace)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;列出调用栈&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;启动GDB后，首先就是要设置断点，程序中断后才能调试。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;断点（BreakPoint）：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在代码的指定位置中断，这个是我们用得最多的一种。设置断点的命令是break，它通常有如下方式：&#xA;// 在进入指定函数时停住&#xA;break &amp;lt;function&amp;gt; &#xA;// 在指定行号停住。&#xA;break &amp;lt;linenum&amp;gt;&#xA;// 在当前行号的前面或后面的offset行停住。offiset为自然数。&#xA;break +/-offset&#xA;// 在源文件filename的linenum行处停住。&#xA;break filename:linenum &#xA;// ...可以是上述的参数，condition表示条件，在条件成立时停住。&#xA;// 比如在循环境体中，可以设置break if i=100，表示当i为100时停住程序。&#xA;break ... if &amp;lt;condition&amp;gt; &#xA;&#xA;可以通过info breakpoints [n]命令查看当前断点信息。此外，还有如下几个配套的常用命令：&#xA;// 删除所有断点&#xA;delete&#xA;// 删除某个断点&#xA;delete breakpoint [n]&#xA;// 禁用某个断点&#xA;disable breakpoint [n] &#xA;// 使能某个断点&#xA;enable breakpoint [n]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在gdb中，和调试步进相关的命令主要有如下几条：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 继续运行程序直到下一个断点（类似于VS里的F5）&#xA;continue &#xA;// 逐过程步进，不会进入子函数（类似VS里的F10）&#xA;next &#xA;// 逐语句步进，会进入子函数（类似VS里的F11）&#xA;setp &#xA;// 运行至当前语句块结束&#xA;until&#xA;// 运行至函数结束并跳出，并打印函数的返回值（类似VS的Shift+F11）&#xA;finish&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Arduino Hello World</title>
      <link>http://www.nljb.net/default/Arduino-Hello-World/</link>
      <pubDate>2014-08-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Hello World 作为所有编程语言的起始，占据着无法改变的地位。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“Hello, world&amp;rdquo;程序是指在计算机屏幕上输出“Hello,world”这行字符串的计算机程序&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“hello, world”的中文意思是“世界，你好”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在本教程中，计算机就是Arduino uno控制板，屏幕就是串口监视器。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要的元器件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Arduino开发板,USB线&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Arduino-Hello-World/1.png&#34; alt=&#34;&#34; width=&#34;438&#34; height=&#34;162&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;输入代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void setup()&#xA;{&#xA;    Serial.begin(9600);&#xA;    // 设置波特率为9600，这里要跟软件设置相一致。&#xA;    // 当接入特定设备（如：蓝牙）时，我们也要跟其他设备的波特率达到一致。&#xA;}&#xA;void loop()&#xA;{&#xA;    Serial.println(&amp;quot;Hello World!&amp;quot;);&#xA;    //显示“Hello World！”字符串&#xA;    delay(5000);&#xA;    // 延迟5秒&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;代码回顾&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Arduino-Hello-World/2.png&#34; alt=&#34;&#34; width=&#34;400&#34; height=&#34;400&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开Arduino IDE，笔者是在Ubuntu上做的测试，其实在哪个操作系统下没什么太多区别&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有一点需要注意的是Arduino板连接的是哪个电脑接口，当你把Arduino板插上电脑USB口后，Arduino IDE自动识别到COM口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Tools-Serial Port中选择识别到的接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;把程序拷贝粘贴在IDE中，点击Verify进行编译，验证程序是否正确&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这时程序还没有被写入Arduino板，然后点击upload，可以看到Arduino板LED闪烁几下，IDE提示Done uploading。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;完成上传后，点击Tools-Serial Monitor：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Arduino-Hello-World/3.png&#34; alt=&#34;&#34; width=&#34;400&#34; height=&#34;400&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;显示输出“Hello,world！”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Arduino-Hello-World/4.jpg&#34; alt=&#34;&#34; width=&#34;371&#34; height=&#34;230&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;代码进阶&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你也可以做些交互，例如当你在Serial Monitor中输入“h”时，才会输出“Hello,world！”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int val;&#xA;//定义变量val&#xA;int ledpin=13;&#xA;//定义数字接口13&#xA;&#xA;void setup()&#xA;{&#xA;    Serial.begin(9600);&#xA;    // 设置波特率为9600，这里要跟软件设置相一致。&#xA;    // 当接入特定设备（如：蓝牙）时，我们也要跟其他设备的波特率达到一致。&#xA;    pinMode(ledpin,OUTPUT);&#xA;    // 设置数字13 口为输出接口，Arduino 上我们用到的I/O 口都要进行类似这样的定义。&#xA;}&#xA;&#xA;void loop()&#xA;{&#xA;    val=Serial.read();&#xA;    // 读取PC 机发送给Arduino 的指令或字符，并将该指令或字符赋给val&#xA;    if(val==&#39;h&#39;)&#xA;    // 判断接收到的指令或字符是否是“h”。&#xA;    {&#xA;    // 如果接收到的是“h”字符&#xA;        digitalWrite(ledpin,HIGH);&#xA;        // 点亮数字13 口LED。&#xA;        delay(500);&#xA;        // 延迟5毫秒&#xA;        digitalWrite(ledpin,LOW);&#xA;        // 熄灭数字13 口LED&#xA;        delay(500);&#xA;        Serial.println(&amp;quot;Hello World!&amp;quot;);&#xA;        // 显示“Hello World！”字符串&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-GPIO</title>
      <link>http://www.nljb.net/default/Linux-GPIO/</link>
      <pubDate>2014-08-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;可以使用系统中的GPIOLIB模块在用户空间提供的sysfs接口，实现应用层对GPIO的独立控制。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用 Linux Kernel 提供的 sysfs 來控制 GPIO&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在要寫程式之前，我們先來使用 Linux Kernel 提供的 sysfs 來控制 GPIO。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;用户空间gpio的调用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用户空间访问gpio,即通过sysfs接口访问gpio,下面是/sys/class/gpio目录下的文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;--export/unexport文件&#xA;--gpioN指代具体的gpio引脚&#xA;--gpio_chipN指代gpio控制器&#xA;// 必须知道以上接口没有标准device文件和它们的链接。 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;(1) export/unexport文件接口：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/sys/class/gpio/export，该接口只能写不能读&#xA;// 用户程序通过写入gpio的编号来向内核申请将某个gpio的控制权导出到用户空间&#xA;&#xA;比如  echo 19 &amp;gt; export &#xA;// 上述操作会为19号gpio创建一个节点gpio19，此时目录下生成gpio19的目录&#xA;// 和(unexport)导出的效果相反。 &#xA;&#xA;比如 echo 19 &amp;gt; unexport&#xA;// 上述操作将会移除gpio19这个节点。 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;(2) /sys/class/gpio/gpioN&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 指代某个具体的gpio端口,里边有如下属性文件&#xA;direction 表示gpio端口的方向，读取结果是in或out。&#xA;// 该文件也可以写，写入out 时该gpio设为输出同时电平默认为低。&#xA;// 写入low或high则不仅可以设置为输出 还可以设置输出的电平。 &#xA;// 当然如果内核不支持或者内核代码不愿意，将不会存在这个属性&#xA;// 比如内核调用了gpio_export(N,0)就表示内核不愿意修改gpio端口方向属性 &#xA;&#xA;value 表示gpio引脚的电平,0(低电平)1（高电平）&#xA;// 如果gpio被配置为输出，这个值是可写的，记住任何非零的值都将输出高电平,&#xA;// 如果某个引脚能并且已经被配置为中断,则可以调用poll(2)函数监听该中断,中断触发后poll(2)函数就会返回。&#xA;&#xA;edge 表示中断的触发方式，edge文件有如下四个值：&amp;quot;none&amp;quot;, &amp;quot;rising&amp;quot;, &amp;quot;falling&amp;quot;，&amp;quot;both&amp;quot;。&#xA;// none表示引脚为输入，不是中断引脚&#xA;// rising表示引脚为中断输入，上升沿触发&#xA;// falling表示引脚为中断输入，下降沿触发&#xA;// both表示引脚为中断输入，边沿触发&#xA;// 这个文件节点只有在引脚被配置为输入引脚的时候才存在。 当值是none时可以通过如下方法将变为中断引脚&#xA;// echo &amp;quot;both&amp;quot; &amp;gt; edge;对于是both,falling还是rising依赖具体硬件的中断的触发方式。&#xA;// 此方法即用户态gpio转换为中断引脚的方式&#xA;&#xA;active_low &#xA;// 相互调换高低电平设置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;(3) /sys/class/gpio/gpiochipN&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gpiochipN表示的就是一个gpio_chip,用来管理和控制一组gpio端口的控制器： &#xA;// base   和N相同，表示控制器管理的最小的端口编号。 &#xA;// lable   诊断使用的标志（并不总是唯一的） &#xA;// ngpio  表示控制器管理的gpio端口数量（端口范围是：N ~ N+ngpio-1） &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 首先先將 GPIO4 設定成可以用 sysfs 控制&#xA;echo 4 &amp;gt; /sys/class/gpio/export&#xA;&#xA;2. 設定 GPIO4 為輸出腳&#xA;echo out &amp;gt; /sys/class/gpio/gpio4/direction&#xA;&#xA;3. 設定 GPIO4 輸出值為 1 (0: 低電位, 1: 高電位)&#xA;echo 1 &amp;gt; /sys/class/gpio/gpio4/value&#xA;&#xA;4. 設定 GPIO4 輸出值為 0 (0: 低電位, 1: 高電位)&#xA;echo 0 &amp;gt; /sys/class/gpio/gpio4/value&#xA;&#xA;5. 取消建立出來的 GPIO4 node&#xA;echo 4 &amp;gt; /sys/class/gpio/unexport&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在你執行以上第 3 步的時候，你可以看到 LED 亮了起來，直到第 4 步時，才又變回原本的狀態。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若想要使用 Bash 來控制 GPIO，則可以採用此種方式。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;使用 debugfs 來觀看目前的 GPIO 設定&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我們可以使用 debugfs 來察看目前的 GPIO 設定，首先掛載 debugfs&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mount -t debugfs debug /d&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接著就可以使用&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cat /d/gpio&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;來取得目前 GPIO 的狀況&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi:/home/pi#&#xA;cat /d/gpio&#xA;GPIOs 0-53, bcm2708_gpio:&#xA;gpio-4  (sysfs                ) out hi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux ACPI 启动参数</title>
      <link>http://www.nljb.net/default/Linux-ACPI-%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/</link>
      <pubDate>2014-08-12 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;    acpi=           [HW,ACPI,X86]&#xA;                    Advanced Configuration and Power Interface&#xA;                    Format: { force | off | strict | noirq | rsdt }&#xA;                    force -- enable ACPI if default was off&#xA;                    off -- disable ACPI if default was on&#xA;                    noirq -- do not use ACPI for IRQ routing&#xA;                    strict -- Be less tolerant of platforms that are not&#xA;                            strictly ACPI specification compliant.&#xA;                    rsdt -- prefer RSDT over (default) XSDT&#xA;                    copy_dsdt -- copy DSDT to memory&#xA;                    See also Documentation/power/pm.txt, pci=noacpi&#xA;    acpi_apic_instance=     [ACPI, IOAPIC]&#xA;                    Format: &amp;lt;int&amp;gt;&#xA;                    2: use 2nd APIC table, if available&#xA;                    1,0: use 1st APIC table&#xA;                    default: 0&#xA;    acpi_backlight= [HW,ACPI]&#xA;                    acpi_backlight=vendor&#xA;                    acpi_backlight=video&#xA;                    If set to vendor, prefer vendor specific driver&#xA;                    (e.g. thinkpad_acpi, sony_acpi, etc.) instead&#xA;                    of the ACPI video.ko driver.&#xA;    acpi.debug_layer=       [HW,ACPI,ACPI_DEBUG]&#xA;    acpi.debug_level=       [HW,ACPI,ACPI_DEBUG]&#xA;                    Format: &amp;lt;int&amp;gt;&#xA;                    CONFIG_ACPI_DEBUG must be enabled to produce any ACPI&#xA;                    debug output.  Bits in debug_layer correspond to a&#xA;                    _COMPONENT in an ACPI source file, e.g.,&#xA;                        #define COMPONENT ACPIPCI_COMPONENT&#xA;                    Bits in debug_level correspond to a level in&#xA;                    ACPI_DEBUG_PRINT statements, e.g.,&#xA;                        ACPI_DEBUG_PRINT((ACPI_DB_INFO, ...&#xA;                    The debug_level mask defaults to &amp;quot;info&amp;quot;.  See&#xA;                    Documentation/acpi/debug.txt for more information about&#xA;                    debug layers and levels.&#xA;                    Enable processor driver info messages:&#xA;                        acpi.debug_layer=0x20000000&#xA;                    Enable PCI/PCI interrupt routing info messages:&#xA;                        acpi.debug_layer=0x400000&#xA;                    Enable AML &amp;quot;Debug&amp;quot; output, i.e., stores to the Debug&#xA;                    object while interpreting AML:&#xA;                        acpi.debug_layer=0xffffffff acpi.debug_level=0x2&#xA;                    Enable all messages related to ACPI hardware:&#xA;                        acpi.debug_layer=0x2 acpi.debug_level=0xffffffff&#xA;                    Some values produce so much output that the system is&#xA;                    unusable.  The &amp;quot;log_buf_len&amp;quot; parameter may be useful&#xA;                    if you need to capture more output.&#xA;    acpi_display_output=    [HW,ACPI]&#xA;                    acpi_display_output=vendor&#xA;                    acpi_display_output=video&#xA;                    See above.&#xA;    acpi_irq_balance [HW,ACPI]&#xA;                    ACPI will balance active IRQs&#xA;                    default in APIC mode&#xA;    acpi_irq_nobalance [HW,ACPI]&#xA;                    ACPI will not move active IRQs (default)&#xA;                    default in PIC mode&#xA;    acpi_irq_isa=   [HW,ACPI] If irq_balance, mark listed IRQs used by ISA&#xA;                    Format: &amp;lt;irq&amp;gt;,&amp;lt;irq&amp;gt;...&#xA;    acpi_irq_pci=   [HW,ACPI] If irq_balance, clear listed IRQs for&#xA;                    use by PCI&#xA;                    Format: &amp;lt;irq&amp;gt;,&amp;lt;irq&amp;gt;...&#xA;    acpi_no_auto_ssdt       [HW,ACPI] Disable automatic loading of SSDT&#xA;    acpi_os_name=   [HW,ACPI] Tell ACPI BIOS the name of the OS&#xA;                    Format: To spoof as Windows 98: =&amp;quot;Microsoft Windows&amp;quot;&#xA;    acpi_osi=       [HW,ACPI] Modify list of supported OS interface strings&#xA;                    acpi_osi=&amp;quot;string1&amp;quot;      # add string1 -- only one string&#xA;                    acpi_osi=&amp;quot;!string2&amp;quot;     # remove built-in string2&#xA;                    acpi_osi=               # disable all strings&#xA;    acpi_pm_good    [X86]&#xA;                    Override the pmtimer bug detection: force the kernel&#xA;                    to assume that this machine&#39;s pmtimer latches its value&#xA;                    and always returns good values.&#xA;    acpi_sci=       [HW,ACPI] ACPI System Control Interrupt trigger mode&#xA;                    Format: { level | edge | high | low }&#xA;    acpi_serialize  [HW,ACPI] force serialization of AML methods&#xA;    acpi_skip_timer_override [HW,ACPI]&#xA;                    Recognize and ignore IRQ0/pin2 Interrupt Override.&#xA;                    For broken nForce2 BIOS resulting in XT-PIC timer.&#xA;    acpi_sleep=     [HW,ACPI] Sleep options&#xA;                    Format: { s3_bios, s3_mode, s3_beep, s4_nohwsig,&#xA;                              old_ordering, s4_nonvs, sci_force_enable }&#xA;                    See Documentation/power/video.txt for information on&#xA;                    s3_bios and s3_mode.&#xA;                    s3_beep is for debugging; it makes the PC&#39;s speaker beep&#xA;                    as soon as the kernel&#39;s real-mode entry point is called.&#xA;                    s4_nohwsig prevents ACPI hardware signature from being&#xA;                    used during resume from hibernation.&#xA;                    old_ordering causes the ACPI 1.0 ordering of the _PTS&#xA;                    control method, with respect to putting devices into&#xA;                    low power states, to be enforced (the ACPI 2.0 ordering&#xA;                    of PTS is used by default).&#xA;                    nonvs prevents the kernel from saving/restoring the&#xA;                    ACPI NVS memory during suspend/hibernation and resume.&#xA;                    sciforce_enable causes the kernel to set SCI_EN directly&#xA;                    on resume from S1/S3 (which is against the ACPI spec,&#xA;                    but some broken systems don&#39;t work without it).&#xA;    acpi_use_timer_override [HW,ACPI]&#xA;                    Use timer override. For some broken Nvidia NF5 boards&#xA;                    that require a timer override, but don&#39;t have HPET&#xA;    acpi_enforce_resources= [ACPI]&#xA;                    { strict | lax | no }&#xA;                    Check for resource conflicts between native drivers&#xA;                    and ACPI OperationRegions (SystemIO and SystemMemory&#xA;                    only). IO ports and memory declared in ACPI might be&#xA;                    used by the ACPI subsystem in arbitrary AML code and&#xA;                    can interfere with legacy drivers.&#xA;                    strict (default): access to resources claimed by ACPI&#xA;                    is denied; legacy drivers trying to access reserved&#xA;                    resources will fail to bind to device using them.&#xA;                    lax: access to resources claimed by ACPI is allowed;&#xA;                    legacy drivers trying to access reserved resources&#xA;                    will bind successfully but a warning message is logged.&#xA;                    no: ACPI OperationRegions are not marked as reserved,&#xA;                    no further checks are performed.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[HW,ACPI,X86-64,i386]&#xA;acpi={force|off|ht|strict|noirq}&#xA;// ACPI的总开关&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;force表示强制启用；off表示强制禁用；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;noirq表示不要将ACPI用于IRQ路由；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ht表示只运行足够的ACPI来支持超线程；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;strict表示降低对不严格遵循ACPI规格的平台的兼容性。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;acpi_sleep={s3_bios,s3_mode}&#xA;// ACPI休眠选项。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在从S3状态(挂起到内存)恢复的时候，硬件需要被正确的初始化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这对大多数硬件都不成问题，除了显卡之外，因为显卡是由BIOS初始化的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;内核无法获取必要的恢复信息(仅存在于BIOS中，内核无法读取)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个选项允许内核以两种方式尝试使用ACPI子系统来恢复显卡的状态。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[HW,ACPI]&#xA;acpi_sci={level|edge|high|low}&#xA;// ACPI系统控制终端触发器模式&#xA;// (System Control Interrupt trigger mode)。&#xA;&#xA;[HW,ACPI]&#xA;acpi_irq_balance&#xA;// 使ACPI对中断请求进行平衡，在APIC模式下为默认值&#xA;&#xA;acpi_irq_nobalance&#xA;// ACPI不对中断请求进行平衡(默认)，PIC模式下为默认值&#xA;&#xA;// acpi_irq_pci=&amp;lt;irq&amp;gt;,&amp;lt;irq&amp;gt;...&#xA;// 如果启用了irq_balance则将列出的中断号标记为已经被PCI子系统使用，可用于屏蔽某些中断。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[HW,ACPI]&#xA;acpi_os_name=&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;告诉ACPI BIOS操作系统的名称。&#xA;常常用来哄骗某些老旧的BIOS以为运行的是Windows系统。比如&amp;rdquo;Microsoft 2001&amp;rdquo;表示WinXP，&amp;rdquo;Microsoft Windows&amp;rdquo;表示Win98。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[HW,ACPI]&#xA;acpi_serialize&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;强制串行化ACPI机器语言(ACPI Machine Language)方法，操作系统使用这种语言与BIOS打交道。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[HW,ACPI]&#xA;acpi_use_timer_override&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于某些有毛病的 Nvidia NF5 主板需要使用此选项才能正常使用，不过此时 HPET 将失效。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[IA-32,X86-64]&#xA;acpi_pm_good &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;跳过pmtimer的bug检测，强制内核假设这台机器的pmtimer没有毛病。用于解决某些有缺陷的BIOS。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[KNL,ACPI]&#xA;memmap=nn[KMG]#ss[KMG]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;将从ss开始的nn长度的内存区域标记为ACPI数据。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;memmap=nn[KMG]$ss[KMG]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;将从ss开始的nn长度的内存区域标记为&amp;rdquo;保留&amp;rdquo;。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[ACPI]&#xA;pnpacpi=off&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;禁用ACPI的即插即用功能，而使用PNPBIOS来代替。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[HW,ACPI]&#xA;processor.max_cstate={0|1|2|3|4|5|6|7|8|9}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;无视ACPI表报告的值，强制制定CPU的最大C-state值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里的数字必须是一个有效的C-state值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如Yonah处理器支持&amp;rdquo;0-4&amp;rdquo;五个级别：C0为正常状态，其他则为不同的省电模式(数字越大表示CPU休眠的程度越深/越省电)。&#xA;&amp;ldquo;9&amp;rdquo;表示超越所有的DMI黑名单限制。你的CPU的 95%的时间应该处于最深度的idle状态。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;processor.nocst&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;不使用_CST方法来侦测C-state值，而是使用传统的FADT方法。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-旋转-拉伸-放大-缩小-图片</title>
      <link>http://www.nljb.net/default/Golang-%E6%97%8B%E8%BD%AC-%E6%8B%89%E4%BC%B8-%E6%94%BE%E5%A4%A7-%E7%BC%A9%E5%B0%8F-%E5%9B%BE%E7%89%87/</link>
      <pubDate>2014-08-12 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 本例引用z库,引用graphics库&#xA;// z &amp;quot;github.com/nutzam/zgo&amp;quot;&#xA;// &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;&#xA;// 打开图片&#xA;src, err := z.ImageJPEG(file)&#xA;// 打开失败&#xA;if err != nil {&#xA;    // 踢出&#xA;    return err&#xA;}&#xA;&#xA;// 创建一张图片&#xA;dst := z.ImageRGBA(1920x1080);&#xA;if dst == nil {&#xA;    // 异常返回&#xA;    return fmt.Errorf(&amp;quot;image rgba fail&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;旋转图片&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// 注意 SnapshotRotate 为选择角度&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-旋转-拉伸-放大-缩小-图片/1.jpg&#34; alt=&#34;&#34; width=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 旋转图片(从src到dst)&#xA;if err := graphics.Rotate(dst, src, &amp;amp;graphics.RotateOptions{SnapshotRotate}); err != nil {&#xA;    // 返回错误&#xA;    return err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;拉伸,放大,缩小图片&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 将src图片,缩小,放大,拉伸到dst图片大小&#xA;if err := graphics.Scale(dst, src); err != nil {&#xA;    return nil, err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;保存图片&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 保存,具体参数请参考z库,(0-100)为图片质量&#xA;// 也可以使用 z.ImageEncodePNG ...&#xA;if err := z.ImageEncodeJPEG(&amp;quot;/dev/shm/snap.jpg&amp;quot;, dst, 50); err != nil {&#xA;    return nil, err&#xA;}   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-在结构体的框架中加入WEB服务</title>
      <link>http://www.nljb.net/default/Golang-%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%8A%A0%E5%85%A5WEB%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>2014-08-08 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 当你创建了一个结构体,并拥有结构体方法,例如&#xA;type Server struct {&#xA;    addr string&#xA;}&#xA;&#xA;func (this *Server) system() {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当你想方便的在WEB中使用全局信息,例如(addr)时&#xA;// 在结构中加入WEB服务是最好的办法&#xA;// 对于属于你的结构体创建WEB只有一个要求&#xA;// 那就是指定给http.ListenAndServe的结构里面有ServeHTTP方法&#xA;&#xA;func (this *Server) Web(ch chan int) {&#xA;    // 循环保护&#xA;    for {&#xA;        // 开始监听Web请求&#xA;        log.Printf(&amp;quot;web api listen [%s]&amp;quot;, this.addr)&#xA;        // 建立监听&#xA;        if e := http.ListenAndServe(&amp;quot;:&amp;quot;+this.addr, this); e != nil {&#xA;            // 输出错误&#xA;            log.Printf(&amp;quot;web api exception [%s]&amp;quot;, e.Error())&#xA;            // 休息一下,别太频繁&#xA;            time.Sleep(1 * time.Second)&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&#xA;// Web API 的主接口方法&#xA;func (this *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    // 设置路由&#xA;    switch r.URL.Path {&#xA;    // 路由接口&#xA;    case &amp;quot;/api/snapshot&amp;quot;:&#xA;        ma.WebSnapshot(w, r)&#xA;    default:&#xA;        http.NotFound(w, r)&#xA;    }&#xA;}&#xA;&#xA;// 可以在 Server 里面为所欲为的增加方法了&#xA;// 截图&#xA;func (this *Server) WebSnapshot(w http.ResponseWriter, r *http.Request) {&#xA;    // 发现请求&#xA;    log.Printf(&amp;quot;web snapshot find request from [%s]&amp;quot;, r.RemoteAddr)&#xA;    // 返回结构&#xA;    resp := new(WebResp)&#xA;    // 初始化参数&#xA;    resp.OK = true&#xA;    // 执行&#xA;    data, err := this.system()&#xA;    // 判断是否执行异常&#xA;    if err != nil {&#xA;        // 返回状态&#xA;        resp.OK = false&#xA;        resp.Data = err.Error()&#xA;        ResponseWriter(w, resp)&#xA;        return&#xA;    }&#xA;    // 状态&#xA;    resp.Data = data&#xA;    // 返回&#xA;    ResponseWriter(w, resp)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 你可能没有发现上面的优点,那看看普通的HTTP如何创建吧&#xA;&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/admin/&amp;quot;, adminHandler)&#xA;    http.HandleFunc(&amp;quot;/login/&amp;quot;,loginHandler)&#xA;    http.HandleFunc(&amp;quot;/ajax/&amp;quot;,ajaxHandler)&#xA;    http.HandleFunc(&amp;quot;/&amp;quot;,NotFoundHandler)&#xA;    http.ListenAndServe(&amp;quot;:8888&amp;quot;, nil)   &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-做自己的动态网站</title>
      <link>http://www.nljb.net/default/Golang-%E5%81%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</link>
      <pubDate>2014-08-08 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 制作自己的动态网站&#xA;&#xA;// 动态文件的路由和静态文件的路由是分开的&#xA;// 动态文件使用http.HandleFunc进行设置&#xA;// 静态文件使用http.Handle进行设置,需要使用http.FileServer&#xA;&#xA;// 在主方法中通过http.Handle增加静态路径&#xA;// 在主方法中通过http.HandleFunc增加动态路径&#xA;&#xA;func main() {&#xA;&#xA;    // 设置CPU核心数量&#xA;    runtime.GOMAXPROCS(runtime.NumCPU())&#xA;&#xA;    // 设置日志的结构&#xA;    log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime | log.Lmicroseconds)&#xA;&#xA;    http.Handle(&amp;quot;/css/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;    http.Handle(&amp;quot;/js/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;    http.Handle(&amp;quot;/files/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;    http.Handle(&amp;quot;/images/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;    http.HandleFunc(&amp;quot;/&amp;quot;, index)&#xA;&#xA;    // 建立监听&#xA;    if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;        // 踢出错误&#xA;        log.Panic(err)&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 其中 http.HandleFunc(&amp;quot;/&amp;quot;, index) 中 index 为:&#xA;&#xA;// 通过 r.ParseForm() 解码GET参数,如果出现admin则保存到cookie&#xA;&#xA;func index(w http.ResponseWriter, r *http.Request) {&#xA;&#xA;    // 解析参数&#xA;    r.ParseForm()&#xA;&#xA;    // 增加 cookie&#xA;    if _, ok := r.Form[&amp;quot;admin&amp;quot;]; ok {&#xA;        // cookie&#xA;        cookie := http.Cookie{Name: &amp;quot;username&amp;quot;, &#xA;                    Value: &amp;quot;admin&amp;quot;,&#xA;                    Expires: time.Now().Add(24 * time.Hour)}&#xA;        // cookie&#xA;        http.SetCookie(w, &amp;amp;cookie)&#xA;    }&#xA;&#xA;    // 读取 cookie&#xA;    if cookie, err := r.Cookie(&amp;quot;username&amp;quot;); err == nil {&#xA;        // 权限&#xA;        if cookie.Value == &amp;quot;admin&amp;quot; {&#xA;            // 管理员&#xA;            admin = &amp;quot;admin&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;&#xA;    // 解析主页面&#xA;    t, err := template.ParseFiles(&amp;quot;template/index.html&amp;quot;)&#xA;    if err != nil {&#xA;        // 输出错误信息&#xA;        http.Error(w, err.Error(), 500)&#xA;        return&#xA;    }&#xA;&#xA;    // 执行&#xA;    t.Execute(w, nil)&#xA;&#xA;    // 返回&#xA;    return&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 看到以上例子,你可能会想如何将内容放到动态网页的&amp;quot;template/index.html&amp;quot;中呢&#xA;// 可以通过 t.Execute(w, nil) 中的,第二个参数&#xA;&#xA;// 下面是个列出目录文件到页面的例子&#xA;&#xA;type I struct {&#xA;    Id   int&#xA;    Name string&#xA;    Size string&#xA;    Date string&#xA;    Stat string&#xA;}&#xA;&#xA;type D struct {&#xA;    // 文件列表&#xA;    Files []*I&#xA;}&#xA;&#xA;// 构造&#xA;func NewD() *D {&#xA;    d := new(D)&#xA;    d.Files = make([]*I, 0)&#xA;    return d&#xA;}&#xA;&#xA;// 文件列表&#xA;func filelist(w http.ResponseWriter, r *http.Request) {&#xA;&#xA;    // 管理员&#xA;    var admin string&#xA;&#xA;    // cookie&#xA;    if cookie, err := r.Cookie(&amp;quot;username&amp;quot;); err == nil {&#xA;        // 权限&#xA;        if cookie.Value == &amp;quot;admin&amp;quot; {&#xA;            // 管理员&#xA;            admin = &amp;quot;admin&amp;quot;&#xA;        }&#xA;    }&#xA;&#xA;    // 解析参数&#xA;    r.ParseForm()&#xA;&#xA;    // 获取文件名称&#xA;    fname := z.Trim(r.FormValue(&amp;quot;f&amp;quot;))&#xA;&#xA;    // 创建返回对象&#xA;    d := NewD()&#xA;&#xA;    // ID&#xA;    var id int&#xA;&#xA;    // 遍历本地文件&#xA;    filepath.Walk(&amp;quot;files&amp;quot;, func(ph string, f os.FileInfo, err error) error {&#xA;        // 文件不存在&#xA;        if f == nil {&#xA;            return nil&#xA;        }&#xA;        // 跳过文件夹&#xA;        if f.IsDir() {&#xA;            return nil&#xA;        }&#xA;        // 判断文件是否存在&#xA;        if z.IsBlank(fname) {&#xA;            // 累加&#xA;            id++&#xA;            // 记录文件&#xA;            d.Files = append(d.Files,&#xA;                     &amp;amp;I{id, f.Name(),&#xA;                     fmt.Sprintf(&amp;quot;%d&amp;quot;, f.Size()), f.ModTime().String(), admin})&#xA;        } else {&#xA;            // 检查包含&#xA;            if strings.Contains(strings.ToLower(f.Name()), strings.ToLower(fname)) {&#xA;                // 累加&#xA;                id++&#xA;                // 记录文件&#xA;                d.Files = append(d.Files, &#xA;                         &amp;amp;I{id, f.Name(),&#xA;                         fmt.Sprintf(&amp;quot;%d&amp;quot;, f.Size()), f.ModTime().String(), admin})&#xA;            }&#xA;        }&#xA;        // 返回&#xA;        return nil&#xA;    })&#xA;&#xA;    // 解析主页面&#xA;    t, err := template.ParseFiles(&amp;quot;template/files/filelist.html&amp;quot;)&#xA;    if err != nil {&#xA;        // 输出错误信息&#xA;        http.Error(w, err.Error(), 500)&#xA;        return&#xA;    }&#xA;&#xA;    // 执行&#xA;    t.Execute(w, d)&#xA;&#xA;    // 返回&#xA;    return&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 而HTML页面是这样的 &amp;quot;template/files/filelist.html&amp;quot;&#xA;// 对于判断来首,{ #去掉本注释# if .Stat}},是以,空,非空,来判断的&#xA;&#xA;&amp;lt;table&amp;gt;&#xA;&amp;lt;tr&amp;gt;&#xA;&amp;lt;td&amp;gt;&#xA;&amp;lt;/tr&amp;gt;  &#xA;&amp;lt;tr&amp;gt;&#xA;&amp;lt;td&amp;gt;编号&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;文件名称&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;文件大小&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;创建日期&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;下载&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;操作&amp;lt;/td&amp;gt;&#xA;&amp;lt;/tr&amp;gt;&#xA;{ #去掉本注释# {range .Files}} &#xA;&amp;lt;tr&amp;gt;  &#xA;&amp;lt;td&amp;gt;{ #去掉本注释# {.Id}}&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;{ #去掉本注释# {.Name}}&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;{ #去掉本注释# {.Size}}&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;{ #去掉本注释# {.Date}}&amp;lt;/td&amp;gt;&#xA;&amp;lt;td&amp;gt;&amp;lt;a href=&amp;quot;../download.go?f={ #去掉本注释# {.Name}}&amp;quot;&amp;gt;下载&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;&#xA;{ #去掉本注释# {if .Stat}}&#xA;&amp;lt;td&amp;gt;&amp;lt;a href=&amp;quot;../rmfile.go?f={ #去掉本注释# {.Name}}&amp;quot;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;&#xA;{ #去掉本注释# {else}}&#xA;&amp;lt;td&amp;gt;删除&amp;lt;/td&amp;gt;&#xA;{ #去掉本注释# {end}}&#xA;&amp;lt;/tr&amp;gt;&#xA;{ #去掉本注释# {end}} &#xA;&amp;lt;/table&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;通过ServeMux方式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;github.com/gorilla/sessions&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;runtime&amp;quot;&#xA;)&#xA;&#xA;// sessions&#xA;var store *sessions.CookieStore&#xA;&#xA;func main() {&#xA;&#xA;    // 设置CPU核心数量&#xA;    runtime.GOMAXPROCS(runtime.NumCPU())&#xA;&#xA;    // 设置日志的结构&#xA;    log.SetFlags(log.Lshortfile | log.Ldate | log.Ltime | log.Lmicroseconds)&#xA;&#xA;    // sessions&#xA;    store = sessions.NewCookieStore([]byte(&amp;quot;something-very-secret&amp;quot;))&#xA;&#xA;    // ServeMux&#xA;    mux := http.NewServeMux()&#xA;&#xA;    // Handle&#xA;    mux.Handle(&amp;quot;/images/&amp;quot;, http.FileServer(http.Dir(&amp;quot;template&amp;quot;)))&#xA;&#xA;    // HandleFunc&#xA;    mux.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {&#xA;        switch r.URL.Path {&#xA;        case &amp;quot;/&amp;quot;:&#xA;            index(w, r)&#xA;        default:&#xA;            http.NotFound(w, r)&#xA;        }&#xA;    })&#xA;&#xA;    // Listen&#xA;    if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, mux); err != nil {&#xA;        log.Panic(err)&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// sessions&#xA;session, _ := store.Get(r, &amp;quot;get_name_session&amp;quot;)&#xA;session.Values[&amp;quot;name&amp;quot;] = username&#xA;session.Save(r, w)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-X.ORG-Screenshot-截屏</title>
      <link>http://www.nljb.net/default/Golang-X.ORG-Screenshot-%E6%88%AA%E5%B1%8F/</link>
      <pubDate>2014-08-08 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 所谓 x-go-binding 也就是 x-c-binding 的 GO 版本&#xA;&#xA;import (&#xA;    &amp;quot;github.com/BurntSushi/xgb&amp;quot;&#xA;    &amp;quot;github.com/BurntSushi/xgb/xproto&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;)&#xA;&#xA;// 截图&#xA;func CaptureScreen() (*image.RGBA, error) {&#xA;&#xA;    // 屏幕连接&#xA;    var c *xgb.Conn&#xA;&#xA;    // 判断是否连接到了屏幕&#xA;    if sl.xgbConn == nil {&#xA;        // 建立连接&#xA;        conn, err := xgb.NewConn()&#xA;        // 判断是否连接成功&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        // 成功保存全局&#xA;        sl.xgbConn = conn&#xA;        // 赋值&#xA;        c = conn&#xA;    } else {&#xA;        // 已经连接&#xA;        c = sl.xgbConn&#xA;    }&#xA;&#xA;    screen := xproto.Setup(c).DefaultScreen(c)&#xA;&#xA;    rect := image.Rect(0, 0, &#xA;        int(screen.WidthInPixels), int(screen.HeightInPixels))&#xA;&#xA;    // ------------------------------------------ //&#xA;&#xA;    x, y := rect.Dx(), rect.Dy()&#xA;    xImg, err := xproto.GetImage(c, &#xA;            xproto.ImageFormatZPixmap,&#xA;            xproto.Drawable(screen.Root), &#xA;            int16(rect.Min.X),&#xA;            int16(rect.Min.Y), &#xA;            uint16(x), &#xA;            uint16(y), &#xA;            0xffffffff).Reply()&#xA;    if err != nil {&#xA;        return nil, err&#xA;    }&#xA;&#xA;    data := xImg.Data&#xA;    for i := 0; i &amp;lt; len(data); i += 4 {&#xA;        data[i], data[i+2], data[i+3] = data[i+2], data[i], 255&#xA;    }&#xA;&#xA;    img := &amp;amp;image.RGBA{data, 4 * x, image.Rect(0, 0, x, y)}&#xA;    return img, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 生成 image.RGBA 数据&#xA;// 想要保存为文件参考Z库方法&#xA;// z &amp;quot;github.com/nutzam/zgo&amp;quot;&#xA;&#xA;// JPEG将编码生成图片&#xA;// 选择编码参数,质量范围从1到100,更高的是更好 &amp;amp;jpeg.Options{90}&#xA;func ImageEncodeJPEG(ph string, img image.Image, option int) error {&#xA;    // 确保文件父目录存在&#xA;    FcheckParents(ph)&#xA;    // 打开文件等待写入&#xA;    f := FileW(ph)&#xA;    // 保证文件正常关闭&#xA;    defer f.Close()&#xA;    // 写入文件&#xA;    return jpeg.Encode(f, img, &amp;amp;jpeg.Options{option})&#xA;}&#xA;&#xA;// PNG将编码生成图片&#xA;func ImageEncodePNG(ph string, img image.Image) error {&#xA;    // 确保文件父目录存在&#xA;    FcheckParents(ph)&#xA;    // 打开文件等待写入&#xA;    f := FileW(ph)&#xA;    // 保证文件正常关闭&#xA;    defer f.Close()&#xA;    // 写入文件&#xA;    return png.Encode(f, img)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang 计算矩形相交区域</title>
      <link>http://www.nljb.net/default/Golang-%E8%AE%A1%E7%AE%97%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>2014-08-07 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 计算矩形相较区域&#xA;&#xA;// 矩阵&#xA;type Rect struct {&#xA;    x0 int // 左定点X&#xA;    y0 int // 左顶点Y&#xA;    x1 int // 右底点X&#xA;    y1 int // 右底点Y&#xA;}&#xA;&#xA;// 计算矩形交点&#xA;func NodeIntersectRect(a *Rect, b *Rect) *Rect {&#xA;    // 对象&#xA;    rect := new(Rect)&#xA;    // 计算&#xA;    rect.x0 = int(math.Max(float64(a.x0), float64(b.x0)))&#xA;    rect.y0 = int(math.Max(float64(a.y0), float64(b.y0)))&#xA;    rect.x1 = int(math.Min(float64(a.x1), float64(b.x1)))&#xA;    rect.y1 = int(math.Min(float64(a.y1), float64(b.y1)))&#xA;    // 判断是否相交&#xA;    if rect.x0 &amp;gt;= rect.x1 || rect.y0 &amp;gt;= rect.y1 {&#xA;        // 不相交&#xA;        return nil&#xA;    }&#xA;    // 相交区域&#xA;    return rect&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang 正坐标转换为反坐标</title>
      <link>http://www.nljb.net/default/Golang-%E6%AD%A3%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%8D%E5%9D%90%E6%A0%87/</link>
      <pubDate>2014-08-07 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// C 为两个矩阵相交区域&#xA;&#xA;// 矩阵&#xA;type Rect struct {&#xA;    x0 int // 左定点X&#xA;    y0 int // 左顶点Y&#xA;    x1 int // 右底点X&#xA;    y1 int // 右底点Y&#xA;}&#xA;&#xA;func NodeChangeRect(b, c *Rect) (x0, y0, x1, y1 float32) {&#xA;    // 对象宽高&#xA;    b_width := b.x1 - b.x0&#xA;    b_height := b.y1 - b.y0&#xA;    c_width := c.x1 - c.x0&#xA;    c_height := c.y1 - c.y0&#xA;    // 计算&#xA;    x0 = float32(c.x0-b.x0) / float32(b_width)&#xA;    y0 = float32(b_height-((c.y0-b.y0)+c_height)) / float32(b_height)&#xA;    x1 = float32(c.x0-b.x0+c_width) / float32(b_width)&#xA;    y1 = float32(b_height-(c.y0-b.y0)) / float32(b_height)&#xA;    // 返回&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang TCP C+S I+O Event+File 框架</title>
      <link>http://www.nljb.net/default/Golang-TCP-C%2BS-I%2BO-Event%2BFile-%E6%A1%86%E6%9E%B6/</link>
      <pubDate>2014-08-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;介绍:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;框架针对C/S模式,一个Server与多个Client&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一,支持Server向多个Client同时(并发)发送事件通知&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二,支持Server向多个Client同时(并发)发送数据文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;三,支持Server接收(并发)多个Client发送的事件通知&lt;/p&gt;&#xA;&#xA;&lt;p&gt;四,支持Server接收(并发)多个Client发送的数据文件&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Server 结构(如何发送消息事件与文件):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意:(socket.TCP)来自import&#xA;// socket &amp;quot;github.com/nulijiabei/msocket&amp;quot;&#xA;&#xA;// 根据 TCP 实现接口&#xA;type TCP struct {&#xA;    Addr     string       // 要连接地址&#xA;    Port     string       // 要连接端口&#xA;    Conn     *net.TCPConn // 当前的连接，如果 nil 表示没有连接&#xA;    maxRetry int          // 最大重试次数&#xA; }&#xA;&#xA;// 初始化时需要登记Client的IP和端口与连接&#xA;// 请约定好 Server -&amp;gt; Client 所是用的端口&#xA;// 请约定好 Client -&amp;gt; Server 所使用的端口&#xA;&#xA;// 在 Server 中全局保存 Client 连接&#xA;SlaConn map[int]*socket.TCP // Slaver-TCP [节点]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 多线程内各线程状态&#xA;type NodeStatus struct {&#xA;    Ok   bool        `json:&amp;quot;ok&amp;quot;`&#xA;    ID   int         `json:&amp;quot;id&amp;quot;`&#xA;    IP   string      `json:&amp;quot;ip&amp;quot;`&#xA;    Data interface{} `json:&amp;quot;data&amp;quot;`&#xA;}&#xA;&#xA;// 处理所有连接并返回报告&#xA;func ControlConns(callback func(id int, tcp *socket.TCP) error) map[string]NodeStatus {&#xA;    // 返回结构&#xA;    maxData := make(map[string]NodeStatus)&#xA;    // 通过程道控制线程在所有client发送结束后继续&#xA;    maxSla := make(chan NodeStatus)&#xA;    // 遍历所有连接，发送结构&#xA;    for k, v := range SlaConn {&#xA;        // 线程中对所有机器发送&#xA;        go (func(id int, tcp *socket.TCP, ch chan NodeStatus) {&#xA;            // 返回结构&#xA;            ns := new(NodeStatus)&#xA;            ns.Ok = true&#xA;            ns.ID = id&#xA;            ns.IP = tcp.Addr&#xA;            // 闭包&#xA;            if err := callback(id, tcp); err != nil {&#xA;                ns.Ok = false&#xA;                ns.Data = err.Error()&#xA;            }&#xA;            // 保证在退出时告知称道&#xA;            defer (func() {&#xA;                ch &amp;lt;- *ns&#xA;            })()&#xA;        })(k, v, maxSla)&#xA;    }&#xA;    // 线程计数器&#xA;    var i int = len(SlaConn)&#xA;    for i != 0 {&#xA;        select {&#xA;        case rd := &amp;lt;-maxSla:&#xA;            maxData[rd.IP] = rd&#xA;            i -= 1&#xA;        }&#xA;    }&#xA;    // 完成返回&#xA;    return maxData&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 通过 ControlConns 闭包多线程,高效的处理连接&#xA;&#xA;// 通过闭包,并发处理连接&#xA;ControlConns(func(id int, tcp *socket.TCP) error {&#xA;    // 发送结构&#xA;    if err := tcp.ReadWrite(func(conn *net.TCPConn) error {&#xA;        // 协议发送&#xA;        return ProtocolSend(conn, &amp;quot;event&amp;quot;, map[string]string{&amp;quot;data&amp;quot;: &amp;quot;hello&amp;quot;, &amp;quot;&amp;quot;)&#xA;    }); err != nil {&#xA;        // 判断是否异常&#xA;        return err&#xA;    }&#xA;}&#xA;&#xA;// 使用 ProtocolSend 发送事件消息与文件方法&#xA;// func ProtocolSend(conn net.Conn, types string, head map[string]string, file string) error&#xA;// 通过以上声明可以知道,head参数为MAP,可以将消息事件封装为一个MAP来进行&#xA;// 将KEY作为事件名称,例如:&amp;quot;名字:NLJB&amp;quot;&#xA;// 其中&amp;quot;Event&amp;quot;为必填项,在Client中可以通过这个必填项类型,来决定消息发给哪个函数&#xA;// 当然,你也可以同时发送一个文件过去,将文件路径(&amp;quot;/root/file&amp;quot;)作为参数即可&#xA;ProtocolSend(conn, &amp;quot;event&amp;quot;, map[string]string{&amp;quot;name&amp;quot;: &amp;quot;nljb&amp;quot;, &amp;quot;/root/file&amp;quot;)&#xA;&#xA;// 需要注意是,快速事件不建议携带文件,文件可以单独发送&#xA;// 因为,处理文件会减慢,事件的处理时间&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Server 结构(如何接收消息事件与文件):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这里将(8080)作为Client-&amp;gt;Server的端口号,所以Server要监听这个端口&#xA;&#xA;// 接收 Client 发来的所有TCP请求&#xA;func doReadTcpSla(ch chan int) {&#xA;&#xA;    // 监听TCP端口等待注册&#xA;    lis, err := socket.NewListen(&amp;quot;&amp;quot;, &amp;quot;8080&amp;quot;, 3).ListenTCP()&#xA;    if err != nil {&#xA;        log.Fatalln(err)&#xA;    }&#xA;    // 保证监听正常关闭&#xA;    defer lis.Close()&#xA;&#xA;    // 等待连接&#xA;    for {&#xA;        // 等待 client 连接&#xA;        conn, err := lis.Accept()&#xA;        if err != nil {&#xA;            log.Println(err)&#xA;            continue&#xA;        }&#xA;        // 接收连接线程&#xA;        go (func(conn net.Conn) {&#xA;            // 连接交给解释器&#xA;            res, err := ProtocolReceive(conn)&#xA;            if err != nil {&#xA;                log.Println(err)&#xA;            } else {&#xA;                // 结果交给被动事件处理&#xA;                err := Passive(conn.RemoteAddr().String(), res)&#xA;                if err != nil {&#xA;                    log.Println(err)&#xA;                }&#xA;            }&#xA;        })(conn)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 连接被接收后会送到,中间件ProtocolReceive处理,处理后送给Passive&#xA;// 在这里你就可以为所欲为了&#xA;&#xA;// 我是这样做的,把所以类型定义为方法,保存到handlers里&#xA;// 通过事件中的&amp;quot;type&amp;quot;来调用,将其余参数发给这个函数(event)&#xA;&#xA;// 被动事件处理&#xA;func Passive(addr string, res map[string]string) error {&#xA;    // 获取事件类型(所有事件均需要存在)&#xA;    label, _ := res[&amp;quot;type&amp;quot;]&#xA;    // 从MAP中取出执行方法&#xA;    handler, hasHandler := handlers[label]&#xA;    // 判断方法是否存在&#xA;    if !hasHandler {&#xA;        return fmt.Errorf(fmt.Sprintf(&amp;quot;unknowns func [%s]&amp;quot;), label)&#xA;    }&#xA;    // 执行方法&#xA;    err := handler(addr, res)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    // 成功,返回&#xA;    return nil&#xA;}&#xA;&#xA;// 看到这里如果你还不知道如何拿到你上面发出来的{&amp;quot;data&amp;quot;:&amp;quot;hello&amp;quot;} ...&#xA;// res map[string]string 里面存储的就是你发出来的所有(KEY:VALUE)了&#xA;// addr 里面存储的是谁发过来的消息(IP)&#xA;&#xA;// 至于文件呢,中间件会添加两个KEY,你可以通过内容得到路径&#xA;    -&amp;gt; head[&amp;quot;file&amp;quot;] = file&#xA;    -&amp;gt; head[&amp;quot;md5&amp;quot;] = z.MD5(file)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Client 结构(如何发送消息事件与文件):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 你可能已经了解了Server是如何发送消息的,其实,Client也是相同的方法&#xA;// 唯独不同的是,没有多个Server,只有一个&#xA;MasConn *socket.TCP // master-TCP 网络连接&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Client 结构(如何接收消息事件与文件):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 同样,你也看过了,Server是如何接收Client的消息的&#xA;&#xA;// 这里将(9090)作为Server-&amp;gt;Client的端口号,所以Client要监听这个端口&#xA;&#xA;// 同样的ProtocolReceive解析,和Passive处理,只是少了多线程&#xA;&#xA;// 接收 Server 所有TCP请求&#xA;func doReadTcpMas(ch chan int) {&#xA;&#xA;    // 监听TCP端口等待注册&#xA;    lis, err := socket.NewListen(&amp;quot;&amp;quot;, &amp;quot;9090&amp;quot;, 3).ListenTCP()&#xA;    if err != nil {&#xA;        log.Fatalln(err)&#xA;    }&#xA;    // 保证监听正常关闭&#xA;    defer lis.Close()&#xA;&#xA;    // 等待连接&#xA;    for {&#xA;&#xA;        // 等待 client 连接&#xA;        conn, err := lis.Accept()&#xA;        if err != nil {&#xA;            log.Println(err)&#xA;            continue&#xA;        }&#xA;&#xA;        // 解释数据&#xA;        res, err := ProtocolReceive(conn)&#xA;        if err != nil {&#xA;            // 打印错误&#xA;            log.Println(err)&#xA;        } else {&#xA;            // 被动事件处理&#xA;            err := Passive(conn.RemoteAddr().String(), res)&#xA;            if err != nil {&#xA;                // 打印错误&#xA;                log.Println(err)&#xA;            }&#xA;        }&#xA;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 同样的同样 ...&#xA;// 被动事件处理&#xA;func Passive(addr string, res map[string]string) error {&#xA;    // 获取事件类型&#xA;    label, _ := res[&amp;quot;type&amp;quot;]&#xA;    // 从MAP中取出执行方法&#xA;    handler, hasHandler := handlers[label]&#xA;    // 判断方法是否存在&#xA;    if !hasHandler {&#xA;        return fmt.Errorf(fmt.Sprintf(&amp;quot;unknowns func [%s]&amp;quot;, label))&#xA;    }&#xA;    // 执行方法&#xA;    err := handler(addr, res)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    // 成功,返回&#xA;    return nil&#xA;}   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;中间件结构(发送):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 注意:引入 z 库方法&#xA;// z &amp;quot;github.com/nutzam/zgo&amp;quot;&#xA;&#xA;// 本协议适用 Server 与 Client ,负责发送结构数据&#xA;func ProtocolSend(conn net.Conn, types string, head map[string]string, file string) error {&#xA;    // 发送数据&#xA;    var data string&#xA;    // Header&#xA;    if head == nil {&#xA;        // Make&#xA;        src := make(map[string]string)&#xA;        // 赋值&#xA;        head = src&#xA;    }&#xA;    // 提取本地IP地址&#xA;    x := strings.LastIndex(fmt.Sprintf(&amp;quot;%s&amp;quot;, conn.LocalAddr()), &amp;quot;:&amp;quot;)&#xA;    // 保存本地IP地址&#xA;    head[&amp;quot;ip&amp;quot;] = fmt.Sprintf(&amp;quot;%s&amp;quot;, conn.LocalAddr())[:x]&#xA;    // Header Type&#xA;    head[&amp;quot;type&amp;quot;] = types&#xA;    // 需发送的文件是否存在&#xA;    if !z.IsBlank(file) &amp;amp;&amp;amp; !z.Exists(file) {&#xA;        return fmt.Errorf(&amp;quot;not found file&amp;quot;)&#xA;    }&#xA;    // 如需发送文件添加标签,设置头信息&#xA;    if !z.IsBlank(file) {&#xA;        head[&amp;quot;file&amp;quot;] = file&#xA;        head[&amp;quot;md5&amp;quot;] = z.MD5(file)&#xA;    }&#xA;    // 遍历,组合头信息&#xA;    for k, v := range head {&#xA;        data += (k + &amp;quot;#WWW.NLJB.NET#&amp;quot; + v + &amp;quot;\n&amp;quot;)&#xA;    }&#xA;    // 如需发送文件添加标签,组合头信息&#xA;    if !z.IsBlank(file) {&#xA;        data += &amp;quot;\n\n&amp;quot;&#xA;    }&#xA;    // 发送文件头&#xA;    _, err := conn.Write([]byte(data))&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    // 判断是否有文件需要发送&#xA;    // [0] 远端文件不存在需要发送&#xA;    // [1] 远端文件存在不需要发送&#xA;    if !z.IsBlank(file) {&#xA;        // 等待是否需要发送消息&#xA;        line, _ := bufio.NewReader(conn).ReadString(&#39;\n&#39;)&#xA;        // 判断是否需要发送&#xA;        if z.ToInt(z.Trim(line), 1) == 0 {&#xA;            // 打开文件&#xA;            f := z.FileR(file)&#xA;            // 判断是否打开成功&#xA;            if f != nil {&#xA;                // 建立读取流&#xA;                rd := bufio.NewReader(f)&#xA;                // 建立写入流&#xA;                wd := bufio.NewWriter(conn)&#xA;                // 写入&#xA;                _, err := io.Copy(wd, rd)&#xA;                if err != nil {&#xA;                    return err&#xA;                }&#xA;                // 把缓冲区的数据强行输出&#xA;                wd.Flush()&#xA;                // 保证文件正常关闭&#xA;                f.Close()&#xA;            }&#xA;        }&#xA;    }&#xA;    // 发送完成&#xA;    return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;中间件结构(接收):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 本协议适用 Server 与 Client ,解析TCP传输结构&#xA;func ProtocolReceive(conn net.Conn) (map[string]string, error) {&#xA;    // 存放解释后的结构&#xA;    var res map[string]string = make(map[string]string)&#xA;    // 建立读取流&#xA;    rd := bufio.NewReader(conn)&#xA;    // 空行计数器&#xA;    var i int = 0&#xA;    // 在循环中进行读取&#xA;    for {&#xA;        // 按行读取&#xA;        data, err := rd.ReadString(&#39;\n&#39;)&#xA;        if err == io.EOF { // 遇到结尾跳出&#xA;            break&#xA;        } else if err != nil { //遇到错误&#xA;            return nil, err&#xA;        }&#xA;        // 去除字符串结尾的换行&#xA;        var str string = z.Trim(data)&#xA;        // 如果出现空行,计数器加一&#xA;        if z.IsBlank(str) {&#xA;            i += 1&#xA;        } else { // 否则计数器,归零&#xA;            i = 0&#xA;        }&#xA;        // 如果没有出现空行&#xA;        if i == 0 {&#xA;            // 拆分字符串&#xA;            value := strings.Split(str, &amp;quot;#WWW.NLJB.NET#&amp;quot;)&#xA;            // 将字符串存入结构&#xA;            res[value[0]] = value[1]&#xA;        }&#xA;        // 如果出现两个空行,则开始写入文件&#xA;        if i == 2 {&#xA;            // 获取文件名称&#xA;            fname, _ := res[&amp;quot;file&amp;quot;]&#xA;            // 获取文件MD5&#xA;            fmd5, _ := res[&amp;quot;md5&amp;quot;]&#xA;            // 判断文件是否存在&#xA;            // [0] 远端文件不存在需要发送&#xA;            // [1] 远端文件存在不需要发送&#xA;            if !z.Exists(fname) || z.MD5(fname) != fmd5 {&#xA;                // 需要这个文件&#xA;                conn.Write([]byte(&amp;quot;0\n&amp;quot;))&#xA;                // 收取文件&#xA;                f := z.FileW(fname)&#xA;                // 建立写入流&#xA;                wd := bufio.NewWriter(f)&#xA;                // 从连接读取并写入&#xA;                _, err := io.Copy(wd, rd)&#xA;                if err != nil {&#xA;                    return nil, err&#xA;                }&#xA;                // 把缓冲区的数据强行输出&#xA;                wd.Flush()&#xA;                // 关闭文件&#xA;                f.Close()&#xA;            } else {&#xA;                // 不需要这个文件&#xA;                conn.Write([]byte(&amp;quot;1\n&amp;quot;))&#xA;                // 跳出&#xA;                break&#xA;            }&#xA;            // 验证&#xA;            if z.Exists(fname) &amp;amp;&amp;amp; z.MD5(fname) == fmd5 {&#xA;                break&#xA;            } else {&#xA;                return nil, fmt.Errorf(&amp;quot;file finger fail&amp;quot;)&#xA;            }&#xA;        }&#xA;    }&#xA;    // 返回&#xA;    return res, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>对齐分区</title>
      <link>http://www.nljb.net/default/%E5%AF%B9%E9%BD%90%E5%88%86%E5%8C%BA/</link>
      <pubDate>2014-08-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用 fdisk 的另一种方法是通过&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;fdisk -H 224 -S 56 /dev/sda 启动它&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这会更改 cylinder/head/sector (CHS) 几何参数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从而确保在将程序与柱面对齐时有合理的 4096 字节对齐，这也是默认情形。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;fdisk 系列是大多数 util-linux-ng 分发包附带的一部分&lt;/p&gt;&#xA;&#xA;&lt;p&gt;支持直接编辑 MBR 数据结构，但它不能创建或修改文件系统。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过 util-linux-ng 2.17，fdisk 对分区的 8 扇区对齐不提供任何直接支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过 2.17.2 及其以上版本（我写本文时是最新版本），默认对齐仍然是基于柱面的。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;不过，您可以使用任何版本的 fdisk 合理对齐分区。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为此，您应该在主菜单输入 u ， 将默认单元从柱面更改为扇区。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后输入初始扇区值，应为 8 的倍数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在理论上，为实现合理对齐，您可以将第一个分区的扇区数设为 8；&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;但是，最好将第一个分区设置为 64 或更高的值，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为 MBR 与第一个分区之间的未分配空间中的装载引导程序代码留出空间。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Microsoft 面向 Windows Vista 和 Windows 7 的分区工具将第一个分区起始于扇区 2048，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从跨平台角度来讲，这里是开始分区的安全地带。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;事实上，从 util-linux-ng 2.17.1 开始&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当您通过在主菜单输入 c 来禁用 DOS 兼容性模式时，这就是默认设置。我建议保持该设置。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;但是，要注意，fdisk 不自动对齐随后的分区。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果您指定以兆字节或更大字节为单位的分区大小，然后接受随后分区的默认值，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;随后的分区可能会被对齐，但这不一定。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;出于安全考虑， 您不应检验以 8 的倍数为初始值的每个分区。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Home-Ftp-Server</title>
      <link>http://www.nljb.net/default/Home-Ftp-Server/</link>
      <pubDate>2014-08-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Home FTP Server&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;是一款简单易用的免费FTP软件，可以让你的朋友共享FTP服务器上的资料。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;它可以为用户提供单独的虚拟目录，实时监测在线用户，使用浏览器模式管理FTP服务器。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Home-Ftp-Server/1.jpg&#34; alt=&#34;&#34; width=&#34;400&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-联通ICCID数据请求</title>
      <link>http://www.nljb.net/default/Golang-%E8%81%94%E9%80%9AICCID%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</link>
      <pubDate>2014-08-05 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// ICCID&#xA;func ICCID(iccid string) (string, error) {&#xA;    // 上传数据&#xA;    resp, e := http.PostForm(&amp;quot;http://iservice.10010.com/ehallService/helpCenter/wireless/execute&amp;quot;,&#xA;        url.Values{&#xA;            &amp;quot;iccid&amp;quot;:    {iccid},&#xA;            &amp;quot;proId&amp;quot;:    {&amp;quot;011&amp;quot;},&#xA;            &amp;quot;backData&amp;quot;: {&amp;quot;noname&amp;quot;},&#xA;            &amp;quot;callBack&amp;quot;: {&amp;quot;wirelessCard.processData&amp;quot;}})&#xA;    if e != nil {&#xA;        // 返回空&#xA;        return &amp;quot;&amp;quot;, e&#xA;    }&#xA;    // 保证I/O正常关闭&#xA;    defer resp.Body.Close()&#xA;    log.Println(resp.StatusCode, http.StatusOK)&#xA;    // 判断返回状态&#xA;    if resp.StatusCode == http.StatusOK {&#xA;        // 读取返回的数据&#xA;        data, err := ioutil.ReadAll(resp.Body)&#xA;        if err != nil {&#xA;            // 读取异常,返回错误&#xA;            return &amp;quot;&amp;quot;, err&#xA;        }&#xA;        log.Println(&amp;quot;--&amp;gt;&amp;quot;, string(data))&#xA;    }&#xA;    return &amp;quot;&amp;quot;, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ICCID(iccid string) (string, error) {&#xA;    // 上传数据&#xA;    req, e := http.NewRequest(&amp;quot;POST&amp;quot;,&#xA;         &amp;quot;http://iservice.10010.com/ehallService/helpCenter/wireless/execute&amp;quot;, nil)&#xA;    if e != nil {&#xA;        // 返回空&#xA;        return &amp;quot;&amp;quot;, e&#xA;    }&#xA;    // 设置 Header&#xA;    req.Header.Set(&amp;quot;Referer&amp;quot;,&#xA;         &amp;quot;http://iservice.10010.com/oftenInfo.html?menuId=000400010006&amp;quot;)&#xA;    req.Header.Set(&amp;quot;User-Agent&amp;quot;,&#xA;         &amp;quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36&amp;quot;)&#xA;    req.Header.Set(&amp;quot;X-Requested-With&amp;quot;, &amp;quot;XMLHttpRequest&amp;quot;)&#xA;    req.Header.Set(&amp;quot;Origin&amp;quot;, &amp;quot;http://iservice.10010.com&amp;quot;)&#xA;    req.Header.Set(&amp;quot;Accept-Language&amp;quot;, &amp;quot;zh-CN,zh;q=0.8&amp;quot;)&#xA;    form := url.Values{&#xA;        &amp;quot;iccid&amp;quot;:    {iccid},&#xA;        &amp;quot;proId&amp;quot;:    {&amp;quot;011&amp;quot;},&#xA;        &amp;quot;backData&amp;quot;: {&amp;quot;noname&amp;quot;},&#xA;        &amp;quot;callBack&amp;quot;: {&amp;quot;wirelessCard.processData&amp;quot;}}&#xA;    //对form进行编码&#xA;    req.Body = ioutil.NopCloser(strings.NewReader(form.Encode()))&#xA;    // 设置 TimeOut&#xA;    DefaultClient := http.Client{&#xA;        Transport: &amp;amp;http.Transport{&#xA;            Dial: func(netw, addr string) (net.Conn, error) {&#xA;                deadline := time.Now().Add(60 * time.Second)&#xA;                c, err := net.DialTimeout(netw, addr, time.Second*60)&#xA;                if err != nil {&#xA;                    return nil, err&#xA;                }&#xA;                c.SetDeadline(deadline)&#xA;                return c, nil&#xA;            },&#xA;        },&#xA;    }&#xA;    // 执行&#xA;    resp, ee := DefaultClient.Do(req)&#xA;    if ee != nil {&#xA;        // 提交异常,返回错误&#xA;        return &amp;quot;&amp;quot;, ee&#xA;    }&#xA;    // 保证I/O正常关闭&#xA;    defer resp.Body.Close()&#xA;    log.Println(resp.StatusCode, http.StatusOK)&#xA;    // 判断返回状态&#xA;    //if resp.StatusCode == http.StatusOK {&#xA;    // 读取返回的数据&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        // 读取异常,返回错误&#xA;        return &amp;quot;&amp;quot;, err&#xA;    }&#xA;    log.Println(&amp;quot;--&amp;gt;&amp;quot;, string(data))&#xA;    //}&#xA;    return &amp;quot;&amp;quot;, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>CME-ERROR</title>
      <link>http://www.nljb.net/default/CME-ERROR/</link>
      <pubDate>2014-08-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;CME ERROR&amp;rsquo;s (GSM Equipment related codes)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Error Description&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 0 Phone failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 1 No connection to phone&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 2 Phone adapter link reserved&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 3 Operation not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 4 Operation not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 5 PH_SIM PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 6 PH_FSIM PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 7 PH_FSIM PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 10 SIM not inserted&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 11 SIM PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 12 SIM PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 13 SIM failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 14 SIM busy&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 15 SIM wrong&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 16 Incorrect password&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 17 SIM PIN2 required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 18 SIM PUK2 required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 20 Memory full&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 21 Invalid index&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 22 Not found&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 23 Memory failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 24 Text string too long&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 25 Invalid characters in text string&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 26 Dial string too long&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 27 Invalid characters in dial string&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 30 No network service&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 31 Network timeout&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 32 Network not allowed, emergency calls only&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 40 Network personalization PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 41 Network personalization PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 42 Network subset personalization PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 43 Network subset personalization PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 44 Service provider personalization PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 45 Service provider personalization PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 46 Corporate personalization PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 47 Corporate personalization PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 48 PH-SIM PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 100 Unknown error&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 103 Illegal MS&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 106 Illegal ME&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 107 GPRS services not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 111 PLMN not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 112 Location area not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 113 Roaming not allowed in this location area&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 126 Operation temporary not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 132 Service operation not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 133 Requested service option not subscribed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 134 Service option temporary out of order&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 148 Unspecified GPRS error&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 149 PDP authentication failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 150 Invalid mobile class&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 256 Operation temporarily not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 257 Call barred&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 258 Phone is busy&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 259 User abort&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 260 Invalid dial string&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 261 SS not executed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 262 SIM Blocked&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 263 Invalid block&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CME ERROR: 772 SIM powered down&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR&amp;rsquo;s (GSM Network related codes)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Error Description&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 1 Unassigned number&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 8 Operator determined barring&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 10 Call bared&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 21 Short message transfer rejected&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 27 Destination out of service&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 28 Unindentified subscriber&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 29 Facility rejected&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 30 Unknown subscriber&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 38 Network out of order&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 41 Temporary failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 42 Congestion&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 47 Recources unavailable&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 50 Requested facility not subscribed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 69 Requested facility not implemented&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 81 Invalid short message transfer reference value&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 95 Invalid message unspecified&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 96 Invalid mandatory information&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 97 Message type non existent or not implemented&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 98 Message not compatible with short message protocol&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 99 Information element non-existent or not implemente&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 111 Protocol error, unspecified&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 127 Internetworking , unspecified&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 128 Telematic internetworking not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 129 Short message type 0 not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 130 Cannot replace short message&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 143 Unspecified TP-PID error&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 144 Data code scheme not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 145 Message class not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 159 Unspecified TP-DCS error&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 160 Command cannot be actioned&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 161 Command unsupported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 175 Unspecified TP-Command error&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 176 TPDU not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 192 SC busy&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 193 No SC subscription&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 194 SC System failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 195 Invalid SME address&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 196 Destination SME barred&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 197 SM Rejected-Duplicate SM&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 198 TP-VPF not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 199 TP-VP not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 208 D0 SIM SMS Storage full&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 209 No SMS Storage capability in SIM&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 210 Error in MS&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 211 Memory capacity exceeded&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 212 Sim application toolkit busy&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 213 SIM data download error&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 255 Unspecified error cause&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 300 ME Failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 301 SMS service of ME reserved&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 302 Operation not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 303 Operation not supported&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 304 Invalid PDU mode parameter&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 305 Invalid Text mode parameter&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 310 SIM not inserted&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 311 SIM PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 312 PH-SIM PIN required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 313 SIM failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 314 SIM busy&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 315 SIM wrong&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 316 SIM PUK required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 317 SIM PIN2 required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 318 SIM PUK2 required&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 320 Memory failure&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 321 Invalid memory index&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 322 Memory full&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 330 SMSC address unknown&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 331 No network service&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 332 Network timeout&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 340 No +CNMA expected&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 500 Unknown error&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 512 User abort&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 513 Unable to store&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 514 Invalid Status&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 515 Device busy or Invalid Character in string&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 516 Invalid length&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 517 Invalid character in PDU&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 518 Invalid parameter&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 519 Invalid length or character&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 520 Invalid character in text&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 521 Timer expired&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 522 Operation temporary not allowed&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 532 SIM not ready&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 534 Cell Broadcast error unknown&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CMS ERROR: 535 Protocol stack busy&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>delete和delete[]区别</title>
      <link>http://www.nljb.net/default/delete%E5%92%8Cdelete%5B%5D%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2014-07-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;C++告诉我们在&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;回收用 new 分配的单个对象的内存空间的时候用 delete&lt;/p&gt;&#xA;&#xA;&lt;p&gt;回收用 new[] 分配的一组对象的内存空间的时候用 delete[]。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;关于 new[] 和 delete[]，其中又分为两种情况：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(1) 为基本数据类型分配和回收空间；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(2) 为自定义类型分配和回收空间。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;请看下面的程序。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;;&#xA;using namespace std;&#xA;&#xA;class T {&#xA;public:&#xA;  T() { cout &amp;lt;&amp;lt; &amp;quot;constructor&amp;quot; &amp;lt;&amp;lt; endl; }&#xA;  ~T() { cout &amp;lt;&amp;lt; &amp;quot;destructor&amp;quot; &amp;lt;&amp;lt; endl; }&#xA;};&#xA;&#xA;int main()&#xA;{&#xA;  const int NUM = 3;&#xA;&#xA;  T* p1 = new T[NUM];&#xA;  cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; endl;&#xA;  //  delete[] p1;&#xA;  delete p1;&#xA;&#xA;  T* p2 = new T[NUM];&#xA;  cout &amp;lt;&amp;lt; p2 &amp;lt;&amp;lt; endl;&#xA;  delete[] p2;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;大家可以自己运行这个程序，看一看 delete p1 和 delete[] p1 的不同结果，我就不在这里贴运行结果了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从运行结果中我们可以看出，delete p1 在回收空间的过程中，只有 p1[0] 这个对象调用了析构函数，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其它对象如 p1[1]、p1[2] 等都没有调用自身的析构函数，这就是问题的症结所在。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果用 delete[]，则在回收空间之前所有对象都会首先调用自己的析构函数。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是对于类对象数组，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>libev-学习笔记</title>
      <link>http://www.nljb.net/default/libev-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>2014-07-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;针对(ev_io)分析理解&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Libev是一个event loop:向libev注册感兴趣的events&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如Socket可读事件,libev会对所注册的事件的源进行管理,并在事件发生时触发相应的程序。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// ev_default_loop,初始化一个不是线程安全的loop&#xA;// ev_loop_new,初始化一个线程安全但不能捕捉信号和子进程的监视&#xA;struct ev_loop *loop = ev_default_loop(0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 建立一个(ev_io)结构&#xA;struct ev_io ev;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 其中(libev)定义了如下类型的:&#xA;ev_io&#xA;ev_timer&#xA;ev_periodic&#xA;ev_signal&#xA;ev_child&#xA;ev_stat&#xA;ev_idle&#xA;ev_prepare and ev_check&#xA;ev_embed&#xA;ev_fork&#xA;ev_cleanup&#xA;ev_async&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 初始化 &#xA;ev_io_init(ev, cb, fd, events);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 其中,(ev)为(ev_io)结构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 当标准输入上有可读取的数据时，将调用下面这个回调函数&#xA;// 其中,(cb)为回调:&#xA;void cb(struct ev_loop *loop, struct ev_io *watcher, int revents);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 其中,(fd)为文件描述符(STDIN_FILENO)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 其中,(events)为(EV_READ)-(EV_IO),也可以为以下类型:&#xA;&#xA;/* eventmask, revents, events... */&#xA;enum {&#xA;  EV_UNDEF    = (int)0xFFFFFFFF, /* guaranteed to be invalid */&#xA;  EV_NONE     =            0x00, /* no events */&#xA;  EV_READ     =            0x01, /* ev_io detected read will not block */&#xA;  EV_WRITE    =            0x02, /* ev_io detected write will not block */&#xA;  EV__IOFDSET =            0x80, /* internal use only */&#xA;  EV_IO       =         EV_READ, /* alias for type-detection */&#xA;  EV_TIMER    =      0x00000100, /* timer timed out */&#xA;#if EV_COMPAT3&#xA;  EV_TIMEOUT  =        EV_TIMER, /* pre 4.0 API compatibility */&#xA;#endif&#xA;  EV_PERIODIC =      0x00000200, /* periodic timer timed out */&#xA;  EV_SIGNAL   =      0x00000400, /* signal was received */&#xA;  EV_CHILD    =      0x00000800, /* child/pid had status change */&#xA;  EV_STAT     =      0x00001000, /* stat data changed */&#xA;  EV_IDLE     =      0x00002000, /* event loop is idling */&#xA;  EV_PREPARE  =      0x00004000, /* event loop about to poll */&#xA;  EV_CHECK    =      0x00008000, /* event loop finished poll */&#xA;  EV_EMBED    =      0x00010000, /* embedded event loop needs sweep */&#xA;  EV_FORK     =      0x00020000, /* event loop resumed in child */&#xA;  EV_CLEANUP  =      0x00040000, /* event loop resumed in child */&#xA;  EV_ASYNC    =      0x00080000, /* async intra-loop signal */&#xA;  EV_CUSTOM   =      0x01000000, /* for use by user code */&#xA;  EV_ERROR    = (int)0x80000000  /* sent when an error occurs */&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 执行&#xA;ev_io_start(loop, ev);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 守护&#xA;while (1)&#xA;{&#xA;    // 开始事件循环&#xA;    ev_loop(loop, 0);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 而且还可以在回调函数内增加事件&#xA;void cb(struct ev_loop *loop, struct ev_io *watcher, int revents)&#xA;{&#xA;&#xA;    // ------------------------ //&#xA;    // (ev_io)结构创建说明&#xA;&#xA;    // 一,全局使用一个(ev_io)&#xA;    struct ev_io ev;&#xA;&#xA;    // 二,对每次子事件分配不同的(ev_io)&#xA;    ev_io *ev = new(ev_io);&#xA;&#xA;    // ------------------------ //&#xA;&#xA;    // 错误处理&#xA;    if(EV_ERROR &amp;amp; revents)&#xA;    return;&#xA;&#xA;    ev_io_init(ev, cb, fd, events);&#xA;    ev_io_start(loop, ev);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 针对Libev实现Socket事件,阻塞方式&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;ev.h&amp;gt;&#xA;#include &amp;lt;netinet/in.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;#define PORT 9999&#xA;#define BUFFER_SIZE 1024&#xA;&#xA;// accept,事件的回调&#xA;void accept_cb(struct ev_loop *loop, struct ev_io *watcher, int revents);&#xA;&#xA;// read,事件的回调&#xA;void read_cb(struct ev_loop *loop, struct ev_io *watcher, int revents);&#xA;&#xA;// 上帝在此&#xA;int main()&#xA;{&#xA;&#xA;    /* ev_default_loop,初始化一个不是线程安全的loop&#xA;       ev_loop_new,初始化一个线程安全但不能捕捉信号和子进程的监视 */&#xA;    struct ev_loop *loop = ev_default_loop(0);&#xA;&#xA;    // STDIN_FILENO&#xA;    int sd;&#xA;&#xA;    // IO,事件&#xA;    struct ev_io socket_accept;&#xA;&#xA;    // ----------------------------------------------- //&#xA;&#xA;    // 地址结构,socket&#xA;    struct sockaddr_in addr;&#xA;&#xA;    // 建立,socekt&#xA;    if( (sd = socket(PF_INET, SOCK_STREAM, 0)) &amp;lt; 0 )&#xA;    {&#xA;    printf(&amp;quot;socket error&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    // ----------------------------------------------- //&#xA;&#xA;    // 置零&#xA;    bzero(&amp;amp;addr, sizeof(addr));&#xA;&#xA;    // 地址族&#xA;    addr.sin_family = AF_INET;&#xA;&#xA;    /* 必须要采用网络数据格式&#xA;       普通数字可以用htons()函数转换成网络数据格式的数字 */&#xA;    addr.sin_port = htons(PORT);&#xA;&#xA;    /* IP,地址结构&#xA;       INADDR_ANY,就是指定地址为0.0.0.0的地址 */&#xA;    addr.sin_addr.s_addr = INADDR_ANY;&#xA;&#xA;    // ----------------------------------------------- //&#xA;&#xA;    // 绑定&#xA;    if (bind(sd, (struct sockaddr*) &amp;amp;addr, sizeof(addr)) != 0)&#xA;    {&#xA;    printf(&amp;quot;bind error&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    // 建立监听,及设置请求连接队列的最大长度,用于限制排队请求的个数&#xA;    if (listen(sd, 5) &amp;lt; 0)&#xA;    {&#xA;    printf(&amp;quot;listen error&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    // ----------------------------------------------- /&#xA;&#xA;    // 开始监听了io事件&#xA;    ev_io_init(&amp;amp;socket_accept, accept_cb, sd, EV_IO);&#xA;    ev_io_start(loop, &amp;amp;socket_accept);&#xA;&#xA;    // 循环&#xA;    while (1)&#xA;    {&#xA;    // 开始事件循环&#xA;    ev_loop(loop, 0);&#xA;    }&#xA;&#xA;    // 返回&#xA;    return 0;&#xA;&#xA;}&#xA;&#xA;// accept 事件的回调&#xA;void accept_cb(struct ev_loop *loop, struct ev_io *watcher, int revents)&#xA;{&#xA;&#xA;    // 地址结构,socket&#xA;    struct sockaddr_in client_addr;&#xA;&#xA;    // 地址结构长度,socket&#xA;    socklen_t client_len = sizeof(client_addr);&#xA;&#xA;    // STDIN_FILENO&#xA;    int client_sd;&#xA;&#xA;    // 分派客户端的ev_io结构&#xA;    ev_io *w_client = new(ev_io);&#xA;&#xA;    // libev,错误处理&#xA;    if(EV_ERROR &amp;amp; revents)&#xA;    {&#xA;    printf(&amp;quot;error event in accept&amp;quot;);&#xA;    return;&#xA;    }&#xA;&#xA;    // accept,普通写法&#xA;    client_sd = accept(watcher-&amp;gt;fd, (struct sockaddr *)&amp;amp;client_addr, &amp;amp;client_len);&#xA;    if (client_sd &amp;lt; 0)&#xA;    {&#xA;    printf(&amp;quot;accept error&amp;quot;);&#xA;    return;&#xA;    }&#xA;&#xA;    printf(&amp;quot;someone connected.\n&amp;quot;);&#xA;&#xA;    // 开始监听读事件了,有客户端信息就会被监听到&#xA;    ev_io_init(w_client, read_cb, client_sd, EV_IO);&#xA;    ev_io_start(loop, w_client);&#xA;&#xA;&#xA;}&#xA;&#xA;// read 事件的回调&#xA;void read_cb(struct ev_loop *loop, struct ev_io *watcher, int revents){&#xA;&#xA;    // 缓冲区&#xA;    char buffer[BUFFER_SIZE];&#xA;&#xA;    // 命令区&#xA;    char command[BUFFER_SIZE];&#xA;&#xA;    // 读取到的字节数&#xA;    ssize_t read;&#xA;&#xA;    // libev,错误处理&#xA;    if(EV_ERROR &amp;amp; revents)&#xA;    {&#xA;    printf(&amp;quot;error event in read&amp;quot;);&#xA;    return;&#xA;    }&#xA;&#xA;    // 铁人三项&#xA;    bool iCmdBegin = false; // 命令状态&#xA;    int index = 0;          // 命令下标&#xA;    string cmdType;         // 命令类型&#xA;&#xA;    // xxx&#xA;    while(1) {&#xA;&#xA;    // 最后记得置零&#xA;    bzero(buffer, BUFFER_SIZE);&#xA;&#xA;    // 读取本次输入数据&#xA;    read = recv(watcher-&amp;gt;fd, buffer, BUFFER_SIZE, 0);&#xA;&#xA;    // 分析数据&#xA;    for(int i=0;i &amp;lt; read ;i++){&#xA;&#xA;        // 寻找事件&#xA;        if(buffer[i] == &#39;#&#39;){&#xA;        cout &amp;lt;&amp;lt; &amp;quot;find #&amp;quot; &amp;lt;&amp;lt; (int)buffer[i-1]&amp;lt;&amp;lt; endl;&#xA;        // 事件开始&#xA;        iCmdBegin = true;&#xA;        // 继续&#xA;        continue;&#xA;        }&#xA;&#xA;        // 事件末尾&#xA;        if(iCmdBegin &amp;amp;&amp;amp; buffer[i] == &#39;\n&#39;) {&#xA;&#xA;        cout &amp;lt;&amp;lt; &amp;quot;find -&amp;gt;&amp;quot; &amp;lt;&amp;lt; cmdType &amp;lt;&amp;lt; endl;&#xA;&#xA;        printf(&amp;quot;get the message:\n%s\n&amp;quot;,command);&#xA;&#xA;        // 处理&#xA;        if (cmdType.compare(&amp;quot;End\r&amp;quot;) == 0){&#xA;            cout&amp;lt;&amp;lt; &amp;quot;#End&amp;quot; &amp;lt;&amp;lt; endl;&#xA;            // 播放事件&#xA;        }&#xA;&#xA;        if (cmdType.compare(&amp;quot;Close\r&amp;quot;) == 0){&#xA;            cout &amp;lt;&amp;lt; &amp;quot;#Close&amp;quot; &amp;lt;&amp;lt; endl;&#xA;            // 断开连接&#xA;            close(watcher-&amp;gt;fd);&#xA;            // 每一次事件都必须用对应的停止函数，手动停止&#xA;            ev_io_stop(loop, watcher);&#xA;            // 释放内存&#xA;            delete(watcher);&#xA;            // 跳出&#xA;            return;&#xA;        }&#xA;&#xA;        if (cmdType.compare(&amp;quot;Quit\r&amp;quot;) == 0){&#xA;            cout &amp;lt;&amp;lt; &amp;quot;#Quit&amp;quot; &amp;lt;&amp;lt; endl;&#xA;            // 断开连接&#xA;            close(watcher-&amp;gt;fd);&#xA;            // 每一次事件都必须用对应的停止函数，手动停止&#xA;            ev_io_stop(loop, watcher);&#xA;            // 释放内存&#xA;            delete(watcher);&#xA;            // 跳出&#xA;            return;&#xA;        }&#xA;&#xA;        // 重置&#xA;        iCmdBegin = false;&#xA;        cmdType = &amp;quot;&amp;quot;;&#xA;        index = 0;&#xA;        bzero(command, BUFFER_SIZE);&#xA;&#xA;        // 返回&#xA;        continue;&#xA;        }&#xA;&#xA;        // 状态&#xA;        if(iCmdBegin) {&#xA;        // 事件&#xA;        cmdType += buffer[i];&#xA;        } else {&#xA;        // 命令&#xA;        command[index] = buffer[i];&#xA;        // 增加&#xA;        index++;&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    // 原信息返回,也可以自己写信息,都一样.&#xA;    // send(watcher-&amp;gt;fd, buffer, read, 0);&#xA;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>尽量用new和delete代替malloc和free</title>
      <link>http://www.nljb.net/default/%E5%B0%BD%E9%87%8F%E7%94%A8new%E5%92%8Cdelete%E4%BB%A3%E6%9B%BFmalloc%E5%92%8Cfree/</link>
      <pubDate>2014-07-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在C语言中，我们已经熟悉利用malloc/free来管理动态内存&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;而在C++中，我们又有了新的工具：new/delete。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;你不禁会产生疑问—有了malloc/free为什么还要new/delete 呢？&#xA;使用malloc/free和使用new/delete又有什么区别呢？&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;首先来分析一下下面的代码片段：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Object&#xA;{&#xA;    public:&#xA;        Object() &#xA;        {&#xA;            cout &amp;lt;&amp;lt; &amp;quot;Hello, I was born.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;        }&#xA;        ~Object()&#xA;        {&#xA;            cout &amp;lt;&amp;lt; &amp;quot;Bye, I am died.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;        }&#xA;        void Hello()&#xA;        {&#xA;            cout &amp;lt;&amp;lt; &amp;quot;I am Object.&amp;quot;&amp;lt;&amp;lt;endl;&#xA;        }&#xA;        };&#xA;        int main()&#xA;        {&#xA;            cout &amp;lt;&amp;lt; &amp;quot; Using Malloc &amp;amp; Free... &amp;quot;&amp;lt;&amp;lt;endl;&#xA;            Object* pObjectA = (Object*)malloc(sizeof(Object));&#xA;            pObjectA-&amp;gt;Hello();&#xA;            free pObjectA;&#xA;            cout &amp;lt;&amp;lt; &amp;quot; Using New &amp;amp; Delete... &amp;quot;&amp;lt;&amp;lt;endl;&#xA;            Object* pObjectB = new Object;&#xA;            pObjectB-&amp;gt;Hello();&#xA;            delete pObjectB;&#xA;            return 0;&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码运行的结果为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;UsingMalloc &amp;amp; Free...&#xA;I am Object.&#xA;Using New &amp;amp; Delete...&#xA;Hello, I was born.&#xA;I am Object. &#xA;Bye, I am died.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过结果我们可以得知：new/delete在管理内存的同时调用了构造和析构函数；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而malloc/free仅仅实现了内存分配与释放。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;接下来，我们进行详细讨论。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;malloc/free是C/C++语言的标准库函数，而new/delete是C++的运算符。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它们都可用于申请动态内存和释放内存。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于malloc/free是库函数，所以需要对应的头文件库函数支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于非内置数据类型的对象，用malloc/free无法满足创建动态对象的要求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是因为对象在创建的同时要自动执行构造函数，对象在消亡之前则要自动执行析构函数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于malloc/free不是运算符，不受编译器的控制管辖，所以不能够把执行构造函数和析构函数的任务强加于malloc/free上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而new/delete就不同了，它们是保留字，是操作符，它们和“+”、“-”、“*”、“/”有着一样的地位。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;new不仅能完成动态内存分配，还能完成初始化工作，稳妥地构造对象；delete不仅&lt;/p&gt;&#xA;&#xA;&lt;p&gt;能完成内存的释放，还能进行对象的清理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举个形象的例子：通过new建造出来的是一栋房子，可以直接居住；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而通过malloc申请到的仅仅是一块地皮，要想成为房子，还需要做出另外的努力。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;malloc的语法是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;指针名=（数据类型*）malloc（长度）; //（数据类型*）表示指针&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;new的语法是:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;指针名= new 类型(参数); // 单个对象&#xA;指针名= new 类型[个数]; // 对象数组&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;malloc函数返回的是void &lt;em&gt;类型，如果写成：ClassA&lt;/em&gt; p = malloc (sizeof(ClassA));，程序则无法通过编译，会抛出这样的错误信息：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“不能将 void* 赋值给 ClassA * 类型变量”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以必须通过 (ClassA *) 来进行强制转型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相较而言，new则不存在强制转型的问题，而且书写更为简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总结起来，malloc与new之间的区别主要有以下几点：new是C++运算符，而malloc则是C标准库函数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过new创建的东西是具有类型的，而malloc函数返回的则是void*，需要进行强制转型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;new可以自动调用对象的构造函数，而malloc不会。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;new失败时会调用new_handler处理函数，而malloc失败则直接返回NULL。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;free与delete之间的区别则只有以下两点：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;delete是C++运算符，free是C标准库函数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;delete可以自动调用对象的析构函数，而malloc不会。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;针对内置类型而言，因为没有对象的构造与析构&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以malloc/free除了需要强制转型之外，和new/delete所做的工作无异，用哪一个只是涉及个人喜好而已。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//declaring native type&#xA;int* i1 = new int;&#xA;delete i1;&#xA;int* i2 = (int*) malloc(sizeof(int));&#xA;free(i2);&#xA;//declaring native type array&#xA;char* c1 = new char[10];&#xA;delete[] c1;&#xA;char* c2 = (char*) malloc(sizeof(char)*10);&#xA;free(c2);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;既然提到了malloc/free，不能不提一下realloc。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用realloc函数可以重新设置内存块的大小，而在C++中没有类似于realloc这样的替代品。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果出现上述需求，所做的就是，释放原来的内存，再重新申请。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然new/delete的功能不仅赶上而且超越了malloc/free，那为什么C++标准中没有把malloc/free淘汰出局呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是因为C++要遵守“对C兼容”的承诺，要让一些有价值的包含malloc/free函数库的C程序在C++中得到重用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以，在C++中，new/delete和malloc/free一直并存着。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，将malloc/free和new/delete混合使用绝对不是什么好主意。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remember that, to new is C++; to malloc is C; and to mix them is sin.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果用free来释放通过new创建的动态对象，或者用delete释放通过malloc申请的动态内存，其结果都是未定义的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;换句话说，不能保证它会出现什么问题。如果程序在关键时刻就因为这个在重要客户面前出现问题，那么懊悔恐怕已经来不及了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;请记住：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;（1）不要企图用malloc/free 来完成动态对象的内存管理，应该用new/delete。&#xA;（2）请记住：new是C++的，而malloc是c的。如果混淆了它们，那将是件蠢事。&#xA;    所以new/delete必须配对使用，malloc/free也一样。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Libev-初识</title>
      <link>http://www.nljb.net/default/Libev-%E5%88%9D%E8%AF%86/</link>
      <pubDate>2014-07-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Libev是一个event loop：事件驱动的库。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过向libev注册感兴趣的events，比如socket可读事件&#xA;libev会对所注册的事件的源进行管理并在事件发生时触发相应的回调函数。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;通过event watcher来注册事件。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;libev通过分配和注册watcher对不同类型的事件进行监听。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;不同事件类型的watcher又对应不同的数据类型&#xA;watcher的定义模式是struct ev_TYPE或者ev_TYPE，其中TYPE为具体的类型。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;当前libev定义了如下类型的watcher：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ev_io&#xA;ev_timer&#xA;ev_periodic&#xA;ev_signal&#xA;ev_child&#xA;ev_stat&#xA;ev_idle&#xA;ev_prepare and ev_check&#xA;ev_embed&#xA;ev_fork&#xA;ev_cleanup&#xA;ev_async&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;ev_init对一个watcher的与具体类型无关的部分进行初始化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_io_set对watcher的与io类型相关的部分进行初始化，如果是TYPE类型那么相应的函数就是ev_TYPE_set。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以采用ev_TYPE_init函数来替代ev_init和ev_TYPE_set。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_io_start激活相应的watcher&lt;/p&gt;&#xA;&#xA;&lt;p&gt;watcher只有被激活的时候才能接收事件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_io_stop停止已经激活的watcher。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_run、ev_break以及ev_loop_default都是event loop控制函数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;event loop定义为struct ev_loop。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有两种类型的event loop，分别是default类型和dynamically created类型，区别是前者支持子进程事件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ev_default_loop和ev_loop_new函数分别用于创建default类型或者dynamically created类型的event loop。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;event_run函数告诉系统应用程序开始对事件进行处理，有事件发生时就调用watcher callbacks。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;除非调用了ev_break或者不再有active的watcher，否则会一直重复这个过程。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct　ev_loop　*ev_default_loop　(unsigned　int　flags)　&#xA;struct　ev_loop　*ev_loop_new　(unsigned　int　flags)　&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;默认初始化一个loop，区别是第一个不是线程安全的，第二个不能捕捉信号和子进程的watcher。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;参数flags可以为下面几种类型：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#define EVFLAG_AUTO　　　　0x00000000U /* not quite a mask */ &#xA;/* flag bits */ &#xA;#define EVFLAG_NOENV　　　 0x01000000U /* do NOT consult environment */ &#xA;#define EVFLAG_FORKCHECK　 0x02000000U /* check for a fork in each iteration */ &#xA;/* method bits to be ored together */ &#xA;#define EVBACKEND_SELECT　 0x00000001U /* about anywhere */ &#xA;#define EVBACKEND_POLL　　　 0x00000002U /* !win */ &#xA;#define EVBACKEND_EPOLL　　  0x00000004U /* linux */ &#xA;#define EVBACKEND_KQUEUE　   0x00000008U /* bsd */ &#xA;#define EVBACKEND_DEVPOLL    0x00000010U /* solaris 8 */ /* NYI */ &#xA;#define EVBACKEND_PORT　　　 0x00000020U /* solaris 10 */&#xA;&#xA;ev_default_fork　()　&#xA;ev_loop_fork　(loop)&#xA;// 当你在子进程里需要使用libev的函数的之前必须要调用。&#xA;// 区别是第二个函数是当使用ev_loop_new创建的loop时，才用第二个函数,也就是说重用父进程创建的loop。&#xA;&#xA;ev_loop　(loop,　int　flags)&#xA;// 开始事件循环。&#xA;&#xA;ev_TYPE_init　(ev_TYPE　*watcher,　callback,　[args])&#xA;// 初始化一个watcher。TYPE也就是libev支持的事件类型，比如io，比如time。&#xA;&#xA;// 第一个参数为一个watcher,第二个回调函数，第三个句柄，第四个事件类型。包含下面几种：&#xA;#define EV_UNDEF　　　　　　　　　　　 -1 /* guaranteed to be invalid */ &#xA;#define EV_NONE　　　　　　　　　　 0x00 /* no events */ &#xA;#define EV_READ　　　　　　　　　　 0x01 /* ev_io detected read will not block */ &#xA;#define EV_WRITE　　　　　　　　　 0x02 /* ev_io detected write will not block */ &#xA;#define EV_IOFDSET　　　　　　　 0x80 /* internal use only */ &#xA;#define EV_TIMEOUT　     0x00000100 /* timer timed out */ &#xA;#define EV_PERIODIC     0x00000200 /* periodic timer timed out */ &#xA;#define EV_SIGNAL　　     0x00000400 /* signal was received */ &#xA;#define EV_CHILD　　　     0x00000800 /* child/pid had status change */ &#xA;#define EV_STAT　　　　 0x00001000 /* stat data changed */ &#xA;#define EV_IDLE　　　　 0x00002000 /* event loop is idling */ &#xA;#define EV_PREPARE　 0x00004000 /* event loop about to poll */ &#xA;#define EV_CHECK　　　     0x00008000 /* event loop finished poll */ &#xA;#define EV_EMBED　　　     0x00010000 /* embedded event loop needs sweep */ &#xA;#define EV_FORK　　　　 0x00020000 /* event loop resumed in child */ &#xA;#define EV_ASYNC　　　     0x00040000 /* async intra-loop signal */ &#xA;#define EV_ERROR　　　     0x80000000 /* sent when an error occurs */&#xA;&#xA;ev_TYPE_start (loop *, ev_TYPE *watcher)&#xA;// 启动一个watcher。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include　&amp;lt;ev.h&amp;gt;　&#xA;#include　&amp;lt;stdio.h&amp;gt;　&#xA;　　&#xA;　　//不同的watcher　&#xA;　　ev_io　stdin_watcher;　&#xA;　　ev_timer　timeout_watcher;　&#xA;　　ev_timer　timeout_watcher_child;　&#xA;　　　&#xA;　　//标准输入的回调函数　&#xA;　　static　void　&#xA;　　stdin_cb　(EV_P_　ev_io　*w,　int　revents)　&#xA;　　{　&#xA;　　　puts　(&amp;quot;stdin　ready&amp;quot;);　&#xA;　　　ev_io_stop　(EV_A_　w);　&#xA;　　　ev_unloop　(EV_A_　EVUNLOOP_ALL);　&#xA;　　}　&#xA;　　&#xA;　　//父进程的定时器回调函数　&#xA;　　static　void　&#xA;　　timeout_cb　(EV_P_　ev_timer　*w,　int　revents)　&#xA;　　{　&#xA;　　　puts　(&amp;quot;timeout&amp;quot;);　&#xA;　　　ev_unloop　(EV_A_　EVUNLOOP_ONE);　&#xA;　　}　&#xA;　　//子进程的定时器回调函数　&#xA;　　static　void　&#xA;　　timeout_cb_child　(EV_P_　ev_timer　*w,　int　revents)　&#xA;　　{　&#xA;　　　puts　(&amp;quot;child　timeout&amp;quot;);　&#xA;　　　ev_unloop　(EV_A_　EVUNLOOP_ONE);　&#xA;　　}　&#xA;&#xA;int　main　(void)　&#xA;{　&#xA;　　//创建一个backend为select的loop　&#xA;　　struct　ev_loop　*loop　=　ev_loop_new(EVBACKEND_SELECT);　&#xA;　　　&#xA;　　　//初始化并启动父进程的watcher　&#xA;　　ev_timer_init(&amp;amp;timeout_watcher,　timeout_cb,　10,　0.);　&#xA;　　ev_timer_start(loop,　&amp;amp;timeout_watcher);　&#xA;　　switch　(fork())　{　&#xA;　　　　　　　　case　-1:　&#xA;　　　　　　　　　　return　-1;　&#xA;　　　　　　　　case　0:　&#xA;　　　　　　　　　//使用父进程loop。　&#xA;　　　　　　　　　　ev_loop_fork(loop);　&#xA;　　　　　　　　　　//子进程的loop　&#xA;　　　　　　　　　　struct　ev_loop　*loop_child　=　ev_loop_new　(EVBACKEND_SELECT);　&#xA;　　　　　　　　　　ev_io_init　(&amp;amp;stdin_watcher,　stdin_cb,　/*STDIN_FILENO*/　0,　EV_READ);　&#xA;　　　　　　　　　　ev_io_start　(loop,　&amp;amp;stdin_watcher);　&#xA;　　　　　　　　　　ev_timer_init(&amp;amp;timeout_watcher_child,　timeout_cb_child,　5.5,　0.);　&#xA;　　　　　　　　　　ev_timer_start(loop_child,　&amp;amp;timeout_watcher_child);　&#xA;　　　　　　　　　　ev_loop(loop_child,0);　&#xA;　　　}　&#xA;　　　&#xA;　　　//等待事件　&#xA;　　　ev_loop　(loop,　0);　&#xA;　　　return　0;　&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>udev-mount-umount</title>
      <link>http://www.nljb.net/default/udev-mount-umount/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;ACTION==&amp;quot;add|change&amp;quot;, SUBSYSTEM==&amp;quot;block&amp;quot;, BUS==&amp;quot;usb&amp;quot;, KERNEL==&amp;quot;sd[a-z][0-9]&amp;quot;, RUN+=&amp;quot;/danoo/bin/addusb.sh %k&amp;quot;&#xA;ACTION==&amp;quot;remove&amp;quot;, SUBSYSTEM==&amp;quot;block&amp;quot;, BUS==&amp;quot;usb&amp;quot;, RUN+=&amp;quot;/danoo/bin/removeusb.sh&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Xorg</title>
      <link>http://www.nljb.net/default/Xorg/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Xorg 配置备份 针对 Nvidia 显卡  &amp;hellip;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# nvidia-xconfig: X configuration file generated by nvidia-xconfig&#xA;# nvidia-xconfig:  version 260.19.44  (buildmeister@swio-display-x86-rhel47-04.nvidia.com)  Sun Feb 27 21:50:39 PST 2011&#xA;&#xA;Section &amp;quot;ServerLayout&amp;quot;&#xA;    InputDevice &amp;quot;irtouch&amp;quot; &amp;quot;SendCoreEvents&amp;quot;&#xA;    Identifier     &amp;quot;Layout0&amp;quot;&#xA;    Screen      0  &amp;quot;Screen0&amp;quot;&#xA;    InputDevice    &amp;quot;Keyboard0&amp;quot; &amp;quot;CoreKeyboard&amp;quot;&#xA;    InputDevice    &amp;quot;Mouse0&amp;quot; &amp;quot;CorePointer&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Files&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;InputDevice&amp;quot;&#xA;    # generated from default&#xA;    Identifier     &amp;quot;Mouse0&amp;quot;&#xA;    Driver         &amp;quot;mouse&amp;quot;&#xA;    Option         &amp;quot;Protocol&amp;quot; &amp;quot;auto&amp;quot;&#xA;    Option         &amp;quot;Device&amp;quot; &amp;quot;/dev/psaux&amp;quot;&#xA;    Option         &amp;quot;Emulate3Buttons&amp;quot; &amp;quot;no&amp;quot;&#xA;    Option         &amp;quot;ZAxisMapping&amp;quot; &amp;quot;4 5&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;InputDevice&amp;quot;&#xA;    # generated from default&#xA;    Identifier     &amp;quot;Keyboard0&amp;quot;&#xA;    Driver         &amp;quot;kbd&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Monitor&amp;quot;&#xA;    Identifier     &amp;quot;Monitor0&amp;quot;&#xA;    VendorName     &amp;quot;Unknown&amp;quot;&#xA;    ModelName      &amp;quot;Unknown&amp;quot;&#xA;#   HorizSync       28.0 - 33.0&#xA;#   VertRefresh     43.0 - 72.0&#xA;    Option         &amp;quot;DPMS&amp;quot;&#xA;    Modeline &amp;quot;2560x1080_40.00&amp;quot; 147.10  2560 2680 2944 3328  1080 1081 1084 1105 -HSync +Vsync&#xA;    Modeline &amp;quot;2560x1080_50.00&amp;quot;  188.75  2560 2712 2976 3392  1080 1083 1093 1114 -hsync +vsync&#xA;    Modeline &amp;quot;2560x1080_60.00&amp;quot;  230.00  2560 2720 2992 3424  1080 1083 1093 1120 -hsync +vsync&#xA;    Modeline &amp;quot;2560x1080_45.00&amp;quot;  167.75  2560 2696 2960 3360  1080 1083 1093 1111 -hsync +vsync&#xA;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Device&amp;quot;&#xA;#-&amp;gt; rotate label start -&amp;gt; Do not move&#xA;#    Option         &amp;quot;Rotate&amp;quot; &amp;quot;CW&amp;quot;&#xA;#-&amp;gt; rotate label end -&amp;gt; Do not move&#xA;    Identifier     &amp;quot;Device0&amp;quot;&#xA;    Driver         &amp;quot;nvidia&amp;quot;&#xA;    VendorName     &amp;quot;NVIDIA Corporation&amp;quot;&#xA;    Option         &amp;quot;UseEDIDFreqs&amp;quot; &amp;quot;False&amp;quot;&#xA;    Option         &amp;quot;ExactModeTimingsDVI&amp;quot; &amp;quot;True&amp;quot;&#xA;    Option         &amp;quot;ModeValidation&amp;quot; &amp;quot;NoDFPNativeResolutionCheck&amp;quot;&#xA;    Option         &amp;quot;FlatPanelProperties&amp;quot; &amp;quot;Scaling=Native&amp;quot;&#xA;EndSection&#xA;&#xA;Section &amp;quot;Screen&amp;quot;&#xA;      Identifier     &amp;quot;Screen0&amp;quot;&#xA;      Device         &amp;quot;Device0&amp;quot;&#xA;      Monitor        &amp;quot;Monitor0&amp;quot;&#xA;      Option         &amp;quot;TwinView&amp;quot; &amp;quot;1&amp;quot;&#xA;      Option         &amp;quot;TwinViewXineramaInfoOrder&amp;quot; &amp;quot;DFP-1,DFP-2&amp;quot;&#xA;      Option         &amp;quot;metamodes&amp;quot; &amp;quot;DFP-1: 2560x1080_40.00 +0+1080, DFP-2: 2560X1080_40.00 +0+0&amp;quot;&#xA;      SubSection     &amp;quot;Display&amp;quot;&#xA;      Depth     24&#xA;      EndSubSection&#xA;EndSection&#xA;&#xA;### Touch Configuration Beginning ###&#xA;Section &amp;quot;InputDevice&amp;quot;&#xA;    Identifier &amp;quot;irtouch&amp;quot;&#xA;    Driver &amp;quot;irtouch&amp;quot;&#xA;    Option &amp;quot;ScrenNumber&amp;quot; &amp;quot;0&amp;quot;&#xA;    Option &amp;quot;SendCoreEvents&amp;quot;&#xA;    Option &amp;quot;MinX&amp;quot; &amp;quot;0&amp;quot;&#xA;    Option &amp;quot;MinY&amp;quot; &amp;quot;0&amp;quot;&#xA;    Option &amp;quot;MaxX&amp;quot; &amp;quot;4095&amp;quot;&#xA;    Option &amp;quot;MaxY&amp;quot; &amp;quot;4095&amp;quot;&#xA;    Option &amp;quot;SwapXY&amp;quot; &amp;quot;0&amp;quot;&#xA;EndSection&#xA;### Touch Configuration End ##&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-文件操作</title>
      <link>http://www.nljb.net/default/Golang-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go语言，在Package io中，定义了io.Reader和io.Writer两个interface&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go以组合、委派等面向对象的方式，让其它的对象定义具体的实现&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果对一个文件每次读取一行(Readline)的话，就可以使用bufio.ReadString来实现，下边是一个简单的例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;////////////////////////////////源代码////////////////////////////////&#xA;package main&#xA;&#xA;import (&#xA;   &amp;quot;os&amp;quot;&#xA;   &amp;quot;bufio&amp;quot;&#xA;   &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main(){   &#xA;    //打开文件，并进行相关处理&#xA;   f , err := os.Open(&amp;quot;test.txt&amp;quot;,os.O_RDONLY,0)&#xA;   if err != nil{&#xA;       fmt.Printf(&amp;quot;%v\n&amp;quot;,err)&#xA;       os.Exit(1)&#xA;   }&#xA;   //文件关闭&#xA;   defer f.Close() &#xA;&#xA;    //将文件作为一个io.Reader对象进行buffered I/O操作&#xA;   br := bufio.NewReader(f)&#xA;   for{&#xA;       //每次读取一行&#xA;       line , err := br.ReadString(&#39;\n&#39;)&#xA;       if err == os.EOF {&#xA;       break&#xA;       }else{&#xA;       fmt.Printf(&amp;quot;%v&amp;quot;,line)&#xA;       }&#xA;   }&#xA;}&#xA;////////////////////////////////源代码////////////////////////////////&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;两个包具有文件操作的相关方法，一个是os,一个是syscall,其中os中的相关方法是对syscall相关方法的封装，推荐使用os中的相关方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件的打开文件的第一步操作实际上是创建，但是由于文件的打开方法也可以创建，实际中使用创建方法的地方不多。文件打开有两个方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//以只读方式打开一个存在的文件，打开就可以读取了。&#xA;func Open(name string) (file *File, err error)&#xA;&#xA;//以各种方式打开各种存在不存在的文件，具体怎么样看flag和perm。&#xA;func OpenFile(name string, flag int, perm FileMode) (file *File, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;flag可选值（掩码）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    O_RDONLY int = syscall.O_RDONLY // open the file read-only.&#xA;    O_WRONLY int = syscall.O_WRONLY // open the file write-only.&#xA;    O_RDWR   int = syscall.O_RDWR   // open the file read-write.&#xA;    O_APPEND int = syscall.O_APPEND // 在文件末尾追加，打开后cursor在文件结尾位置&#xA;    O_CREATE int = syscall.O_CREAT  // 如果不存在则创建&#xA;    O_EXCL   int = syscall.O_EXCL   //与O_CREATE一起用，构成一个新建文件的功能，它要求文件必须不存在&#xA;    O_SYNC   int = syscall.O_SYNC   // 同步方式打开，没有缓存，这样写入内容直接写入硬盘，系统掉电文件内容有一定保证&#xA;    O_TRUNC  int = syscall.O_TRUNC  // 打开并清空文件&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;perm是文件的unix权限位，可以直接用数字写，如0644。可选值有：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    // The single letters are the abbreviations&#xA;    // used by the String method&#39;s formatting.&#xA;    ModeDir        FileMode = 1 &amp;lt;&amp;lt; (32 - 1 - iota) // d: is a directory&#xA;    ModeAppend                                     // a: append-only&#xA;    ModeExclusive                                  // l: exclusive use&#xA;    ModeTemporary                                  // T: temporary file (not backed up)&#xA;    ModeSymlink                                    // L: symbolic link&#xA;    ModeDevice                                     // D: device file&#xA;    ModeNamedPipe                                  // p: named pipe (FIFO)&#xA;    ModeSocket                                     // S: Unix domain socket&#xA;    ModeSetuid                                     // u: setuid&#xA;    ModeSetgid                                     // g: setgid&#xA;    ModeCharDevice                                 // c: Unix character device, when ModeDevice is set&#xA;    ModeSticky&#xA;&#xA;    // Mask for the type bits. For regular files, none will be set.&#xA;    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice&#xA;&#xA;    ModePerm FileMode = 0777 // permission bits&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述可选值是权限位的高有效位，低有效位的值还是要用户自己写数字。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件的写入&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (f *File) Write(b []byte) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;// 该函数写入len(b)个字节。如果返回值值n!=len(b)，则表明没写进去，err将!=nil。&#xA;// 可能有人会疑惑，write函数为什么不指定写入的个数呢？C语言的对应函数就是指定的。&#xA;// 其实go不一样啦，因为go有slice，如果你想写入8个字节，你可以Write(b)。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (f *File) WriteAt(b []byte, off int64) (n int, err error) //WriteAt实际上是省略了seek的步骤。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;示例代码（该代码只写入http)：package main&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import (&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fd,_:=os.OpenFile(&amp;quot;a.txt&amp;quot;,os.O_RDWR|os.O_CREATE,0644)&#xA;    buf:=[]byte(&amp;quot;http://www.usr.cc&amp;quot;)&#xA;    fd.Write(buf)&#xA;    fd.Close()&#xA;}&#xA;&#xA;// 从光标的当前位置开始读len(b)个字节，返回值n是实际上读到的字节数。&#xA;// 读取操作可能遇到EOF而停止，此时计数n为０，err为io.EOF.&#xA;文件的读取func (f *File) Read(b []byte) (n int, err error)&#xA;&#xA;// 这个不多说了。&#xA;func (f *File) ReadAt(b []byte, off int64) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面的示例代码写入&lt;a href=&#34;http://www.usr.cc，读到的是http：package&#34;&gt;http://www.usr.cc，读到的是http：package&lt;/a&gt; main&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fd,_:=os.OpenFile(&amp;quot;a.txt&amp;quot;,os.O_RDWR|os.O_CREATE,0644)&#xA;    buf:=[]byte(&amp;quot;http://www.usr.cc&amp;quot;)&#xA;    fd.Write(buf)&#xA;    rx_buf:=make([]byte,4)&#xA;    fd.ReadAt(rx_buf,0)&#xA;    fmt.Println(string(rx_buf))&#xA;    fd.Close()&#xA;}&#xA;&#xA;// 文件的关闭fb.Close()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;写程序离不了文件操作，这里总结下go语言文件操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一、建立与打开&lt;/p&gt;&#xA;&#xA;&lt;p&gt;建立文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Create(name string) (file *File, err Error)&#xA;func NewFile(fd int, name string) *File&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#Create&#34;&gt;http://golang.org/pkg/os/#Create&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Open(name string) (file *File, err Error)&#xA;func OpenFile(name string, flag int, perm uint32) (file *File, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#Open&#34;&gt;http://golang.org/pkg/os/#Open&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、写文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Write(b []byte) (n int, err Error)&#xA;func (file *File) WriteAt(b []byte, off int64) (n int, err Error)&#xA;func (file *File) WriteString(s string) (ret int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#File.Write&#34;&gt;http://golang.org/pkg/os/#File.Write&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main &#xA;import(&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    )&#xA;&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fout,err := os.Create(userFile)&#xA;    deferfout.Close()&#xA;    if err != nil{&#xA;        fmt.Println(userFile,err)&#xA;        return&#xA;    }&#xA;    for i:= 0;i&amp;lt;10;i++ {&#xA;        fout.WriteString(&amp;quot;Just a test!\r\n&amp;quot;)&#xA;        fout.Write([]byte(&amp;quot;Just a test!\r\n&amp;quot;))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;三、读文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Read(b []byte) (n int, err Error)&#xA;func (file *File) ReadAt(b []byte, off int64) (n int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#File.Read&#34;&gt;http://golang.org/pkg/os/#File.Read&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import(&amp;quot;os&amp;quot;&#xA;&amp;quot;fmt&amp;quot;&#xA;)&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fin,err := os.Open(userFile)&#xA;    deferfin.Close()&#xA;    if err != nil{&#xA;    fmt.Println(userFile,err)&#xA;    return&#xA;    }&#xA;    buf := make([]byte, 1024)&#xA;    for{&#xA;      n, _ := fin.Read(buf)&#xA;     if0== n { break}os.Stdout.Write(buf[:n])&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;四、删除文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;函数：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func Remove(name string) Error&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-使用命令行参数</title>
      <link>http://www.nljb.net/default/Golang-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Golang有两个标准包中都有获得命令行参数的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[*]os/Args可以简单地获得一个类似Ｃ语言中的argv结构&#xA;[*]flag则提供了一个更为复杂的标志与值的方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;os.Argsos.Args返回一个字符串数组[] string.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用方法很简单：package main&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fmt.Println(os.Args)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用命令：go run test.go arg1 arg2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可见返回了一个三个元素的数组，第０个元素是程序的名字包括路径，os.Args就第一个参数，os.Args就是第二个参数。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;flag包flag包提供的功能非常复杂。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它将命令行参数分为非标志类参数(nonflag arguments)和Flags，标志参数是这样的-flagname=x，比如说-baudrate=1200。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;非标志类参数为arg1 arg2。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;flag参数处理流程由于标志类参数是参数的一部分，但又特殊，为了将标志类参数区别处理&lt;/p&gt;&#xA;&#xA;&lt;p&gt;flag包有两类方法，一类是flag处理方法，另一类是正常的参数处理方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正常的参数处理方法正常参数处理方法与os.Args差不多，这里是一个方法，flag.Args()，返回也是[]string.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;/*    &amp;quot;os/exec&amp;quot;&#xA;    &amp;quot;bytes&amp;quot;*/&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    flag.Parse()&#xA;    fmt.Println(flag.Args())&#xA;} &#xA;&#xA;go run test.go arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果有标志类参数呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go run test.go arg1 arg2　-baudrate=1200&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里充分证明了标志类参数也是参数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;标志类参数Parse前定义如果使用标志类参数，要提前定义,定义之后再调用Parse才能解析出来：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    flag.Parse()&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;标志类参数必须在Parse之定义，否则会出错：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    flag.Parse()&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&#xA;flag provided but not defined: -baudrate&#xA;&#xA;Usage of /tmp/go-build944578075/command-line-arguments/_obj/a.out:&#xA;exit status 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;flag.Int返回的是地址&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要注意的是这里flag.Int返回的值为一个地址，你可以随时到这个地址里去取值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但在Parse之前取值，取到的是默认值，Parse之后去随值，取到的才是真正的值：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    flag.Parse()&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;标志类参数顺序&lt;/p&gt;&#xA;&#xA;&lt;p&gt;标志类参数之间的前后顺序可以改变，但是似乎标志类参数非要放到非标志类参数之前才能正确解析。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    flag.Parse()&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面的命令正确解析了，调换了baudrate和databits的顺序&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go run test.go arg1 -baudrate=9600 -databits=8  arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上前这里没能正确解析，可以baudrate和databits得到的还是默认值，而非标志类参数获取到了所有的参数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;ndash;help&lt;/p&gt;&#xA;&#xA;&lt;p&gt;flag.Int的最后一个参数是help信息：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go run test.go --help&#xA;&#xA;Usage of /tmp/go-build327358548/command-line-arguments/_obj/a.out:&#xA;  -baudrate=1200: help message for flagname&#xA;  -databits=10: number of data bits&#xA;exit status 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;flag.String传入的参数显然不能都是数字，实际go语言提供的类型都支持，与flag.Int类似，所有其他函数都有：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;flag.String flag.Uint flag.Float64....&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;flag.IntVarflag.Int返回的是指针，用起来可以有点不太好，flag.IntVar可能用起来更好的些：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var baudrate int&#xA;flag.IntVar(&amp;amp;baudrate,&amp;quot;baudrate&amp;quot;,1200,&amp;quot;baudrate of serial port&amp;quot;)&#xA;flag.Parse()&#xA;fmt.Println(baudrate)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当前你一样可以用flag.UintVar flag.Float64Var  flag.StringVar&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参数个数参数个数也分为标志类参数的非标志类参数，两个方法为NArg和NFlag,&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;flag&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    databits:=flag.Int(&amp;quot;databits&amp;quot;,10,&amp;quot;number of data bits&amp;quot;)&#xA;    baudrate:=flag.Int(&amp;quot;baudrate&amp;quot;,1200, &amp;quot;help message for flagname&amp;quot;)&#xA;    flag.Parse()&#xA;    fmt.Println(*baudrate)&#xA;    fmt.Println(*databits)&#xA;    fmt.Println(flag.Args())&#xA;    fmt.Println(flag.NArg())&#xA;    fmt.Println(flag.NFlag())&#xA;}&#xA;&#xA;go run test.go -baudrate=9600 -databits=8 arg1 arg2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Time</title>
      <link>http://www.nljb.net/default/Golang-Time/</link>
      <pubDate>2014-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go的time包是标准库中的包之一&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不用说，几乎是开发必须用到的包之一。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;time包的说明文档在：&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;http://golang.org/pkg/time/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看看godoc文档，最大的数据类型就是Time了，这个Time类型最微小可以表示到nanosecond（微毫秒，十亿份之一秒）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Time的比较是使用Before,After和Equal方法。看一眼After：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (t Time) After(u Time) bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;很好，返回的是bool类型，是我们所需要的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Sub方法返回的是两个时间点之间的时间距离，看上图看到它返回的是Duration结构，这个结构的具体类型和操作也在godoc中&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Add方法和Sub方法是相反的，获取t0和t1的时间距离d是使用Sub，将t0加d获取t1就是使用Add方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;IsZero方法：Time的zero时间点是January 1, year 1, 00:00:00 UTC，这个函数判断一个时间是否是zero时间点&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Local，UTC，Ln是用来显示和计算地区时间的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面从几个需求直接看time的使用1 请打出当前时间的时间戳，然后将时间戳格式为年月日时分秒的形式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    //时间戳&#xA;    t := time.Now().Unix()&#xA;    fmt.Println(t)&#xA;&#xA;    //时间戳到具体显示的转化&#xA;    fmt.Println(time.Unix(t, 0).String())&#xA;&#xA;    //带纳秒的时间戳&#xA;    t = time.Now().UnixNano()&#xA;    fmt.Println(t)&#xA;    fmt.Println(&amp;quot;------------------&amp;quot;)&#xA;&#xA;    //基本格式化的时间表示&#xA;    fmt.Println(time.Now().String())&#xA;&#xA;    fmt.Println(time.Now().Format(&amp;quot;2006year 01month 02day&amp;quot;))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;特别是Format这个函数，可以好好使用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;输出当前星期几？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    //时间戳&#xA;    t := time.Now()&#xA;    fmt.Println(t.Weekday().String())&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/3.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文档中对这个Weekday类型就没有说明!!没法，直接看代码可以看到：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/4.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Weekday有一个String()方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了，看到这里外带我们有一个推测：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当一个结构中有定义String()函数的时候，fmt.Println()是会调用String的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例子如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;type MyStruct struct{&#xA;}&#xA;&#xA;func (d MyStruct)String() string {return &amp;quot;mystruct&amp;quot;}&#xA;&#xA;func main() {&#xA;    me := new(MyStruct)&#xA;    fmt.Println(me)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-Time/5.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go的Time之旅结束！！&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>old_passwords</title>
      <link>http://www.nljb.net/default/old_passwords/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/old_passwords/1.jpg&#34; alt=&#34;&#34; width=&#34;800&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Tinycore-Linux</title>
      <link>http://www.nljb.net/default/Tinycore-Linux/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://wiki.tinycorelinux.net/wiki:remastering&#34;&gt;http://wiki.tinycorelinux.net/wiki:remastering&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Tinycore-Linux/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Tinycore-Linux/2_0.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Tinycore-Linux/3_0.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Shell-删除文件中某一行方法</title>
      <link>http://www.nljb.net/default/Shell-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%90%E4%B8%80%E8%A1%8C%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果有一个abc.txt文件，内容是:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aaa&#xA;bbb&#xA;ccc&#xA;ddd&#xA;eee&#xA;fff&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果要删除aaa，那么脚本可以这样写：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sed -i &#39;/aaa/d&#39; abc.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果删除的是一个变量的值，假如变量是var，应该写成：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sed -i &#39;/&#39;&amp;quot;$var&amp;quot;&#39;/d&#39; abc.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>MBR-引导区文件</title>
      <link>http://www.nljb.net/default/MBR-%E5%BC%95%E5%AF%BC%E5%8C%BA%E6%96%87%E4%BB%B6/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;查看硬盘分区信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;parted /dev/sda print&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;备份MBR，linux下使用如下命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dd if=/dev/hda of=/root/linux.bin bs=512 count=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里注意使用if=/dev/hda备份MBR中数据，如果grub安装具体某个分区，则要自己选择了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写入mbr:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dd if=/mnt/windows/linux.lnx of=/dev/hda bs=512 count=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果以上有什么不懂的可以在终端下输入 dd &amp;ndash;help查看帮助。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-正则-regexp</title>
      <link>http://www.nljb.net/default/Golang-%E6%AD%A3%E5%88%99-regexp/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;regexp&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    resp, err := http.Get(&amp;quot;http://www.baidu.com&amp;quot;)&#xA;&#xA;    // resp, err := http.Get(&amp;quot;http://www.163.com&amp;quot;)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;http get error.&amp;quot;)&#xA;    }&#xA;&#xA;    defer resp.Body.Close()&#xA;    body, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;http read error&amp;quot;)&#xA;    }&#xA;&#xA;    src := string(body)&#xA;&#xA;    //将HTML标签全转换成小写&#xA;    re, _ := regexp.Compile(&amp;quot;\\&amp;lt;[\\S\\s]+?\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllStringFunc(src, strings.ToLower)&#xA;&#xA;    //去除STYLE&#xA;    re, _ = regexp.Compile(&amp;quot;\\&amp;lt;style[\\S\\s]+?\\&amp;lt;/style\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;&amp;quot;)&#xA;&#xA;    //去除SCRIPT&#xA;    re, _ = regexp.Compile(&amp;quot;\\&amp;lt;script[\\S\\s]+?\\&amp;lt;/script\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;&amp;quot;)&#xA;&#xA;    //去除所有尖括号内的HTML代码，并换成换行符&#xA;    re, _ = regexp.Compile(&amp;quot;\\&amp;lt;[\\S\\s]+?\\&amp;gt;&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;\n&amp;quot;)&#xA;&#xA;    //去除连续的换行符&#xA;    re, _ = regexp.Compile(&amp;quot;\\s{2,}&amp;quot;)&#xA;    src = re.ReplaceAllString(src, &amp;quot;\n&amp;quot;)&#xA;&#xA;    fmt.Println(strings.TrimSpace(src))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-标准库解读-基本的IO接口</title>
      <link>http://www.nljb.net/default/Golang-%E6%A0%87%E5%87%86%E5%BA%93%E8%A7%A3%E8%AF%BB-%E5%9F%BA%E6%9C%AC%E7%9A%84IO%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;io 包为I/O原语提供了基本的接口。它主要包装了这些原语的已有实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在io包中最重要的是两个接口：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Reader和Writer接口。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;本章所提到的各种IO包，都跟这两个接口有关，也就是说，只要实现了这两个接口，它就有了IO的功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Reader接口Reader接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Reader interface {    Read(p []byte) (n int, err error)}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Read 将 len(p) 个字节读取到 p 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)） 以及任何遇到的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即使 Read 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当 Read 在成功读取 n &amp;gt; 0 个字节后遇到一个错误或EOF（end-of-file），它就会返回读取的字节数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（同时 n == 0）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，同时返回的err不是EOF就是nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无论如何，下一个 Read 都应当返回 0, EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;调用者应当总在考虑到错误 err 前处理 n &amp;gt; 0 的字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I/O错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，当Read方法返回错误时，不代表没有读取到任何数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;调用者应该处理返回的任何数据，之后才处理可能的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据Go语言中关于接口和实现了接口的类型的定义（Interface_types），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们知道Reader接口的方法集（Method_sets）只包含一个Read方法，因此，所有实现了Read方法的类型都实现了io.Reader接口，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，在所有需要io.Reader的地方，可以传递实现了Read()方法的类型的实例。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面，我们通过具体例子来谈谈该接口的用法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadFrom(reader io.Reader, num int) ([]byte, error) {&#xA;    p := make([]byte, num)&#xA;    n, err := reader.Read(p)&#xA;    if n &amp;gt; 0 {&#xA;    return p[:n], nil&#xA;    }&#xA;    return p, err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;ReadFrom函数将io.Reader作为参数，也就是说，ReadFrom可以从任意的地方读取数据，只要来源实现了io.Reader接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 从标准输入读取&#xA;data, err = ReadFrom(os.Stdin, 11)&#xA;// 从普通文件读取，其中file是os.File的实例&#xA;data, err = ReadFrom(file, 9)&#xA;// 从字符串读取&#xA;type Writer interface {&#xA;    Write(p []byte) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;完整的演示例子源码见&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/code/src/chapter01/io/reader.go&#34;&gt;https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/code/src/chapter01/io/reader.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;io.EOF 变量的定义：var EOF = errors.New(&amp;ldquo;EOF&amp;rdquo;)，是error类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据reader接口的说明，在 n &amp;gt; 0 且数据被读完了的情况下，返回的error有可能是EOF也有可能是nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Writer接口Writer接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Writer interface {&#xA;    Write(p []byte) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Write 将 len(p) 个字节从 p 中写入到基本数据流中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回从 p 中被写入的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的引起写入提前停止的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 Write 返回的 n &amp;lt; len(p)，它就必须返回一个非nil的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样的，所有实现了Write方法的类型都实现了io.Writer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在上个例子中，我们是自己实现一个函数接收一个io.Reader类型的参数。这里，我们通过标准库的例子来学习。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在fmt标准库中，有一组函数：Fprint/Fprintf/Fprintln，它们接收一个io.Wrtier类型参数（第一个参数），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说它们将数据格式化输出到io.Writer中。那么，调用这组函数时，该如何传递这个参数呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们以fmt.Fprintln为例，同时看一下fmt.Println函数的源码。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Println(a ...interface{}) (n int, err error) {&#xA;    return Fprintln(os.Stdout, a...)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;实现了io.Reader接口或io.Writer接口的类型初学者看到函数参数是一个接口类型，很多时候有些束手无策，不知道该怎么传递参数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还有人问：标准库中有哪些类型实现了io.Reader或io.Writer接口？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var (&#xA;    Stdin  = NewFile(uintptr(syscall.Stdin), &amp;quot;/dev/stdin&amp;quot;)&#xA;    Stdout = NewFile(uintptr(syscall.Stdout), &amp;quot;/dev/stdout&amp;quot;)&#xA;    Stderr = NewFile(uintptr(syscall.Stderr), &amp;quot;/dev/stderr&amp;quot;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过本节上面的例子，我们可以知道，os.File同时实现了这两个接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们还看到 os.Stdin/Stdout这样的代码，它们似乎分别实现了 io.Reader/io.Writer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;没错，实际上在os包中有这样的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var (&#xA;    Stdin  = NewFile(uintptr(syscall.Stdin), &amp;quot;/dev/stdin&amp;quot;)&#xA;    Stdout = NewFile(uintptr(syscall.Stdout), &amp;quot;/dev/stdout&amp;quot;)&#xA;    Stderr = NewFile(uintptr(syscall.Stderr), &amp;quot;/dev/stderr&amp;quot;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也就是说，Stdin/Stdout/Stderr 只是三个特殊的文件（即都是os.File的实例），自然也实现了io.Reader和io.Writer。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目前，Go文档中还没发直接列出实现了某个接口的所有类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，我们可以通过查看标准库文档，列出实现了io.Reader或io.Writer接口的类型（导出的类型）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;os.File 同时实现了io.Reader和io.Writer&#xA;strings.Reader 实现了io.Reader&#xA;bufio.Reader/Writer 分别实现了io.Reader和io.Writer&#xA;bytes.Buffer 同时实现了io.Reader和io.Writer&#xA;bytes.Reader 实现了io.Reader&#xA;compress/gzip.Reader/Writer 分别实现了io.Reader和io.Writer&#xA;crypto/cipher.StreamReader/StreamWriter 分别实现了io.Reader和io.Writer&#xA;crypto/tls.Conn 同时实现了io.Reader和io.Writer&#xA;encoding/csv.Reader/Writer 分别实现了io.Reader和io.Writer&#xA;mime/multipart.Part 实现了io.Reader&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;除此之外，io包本身也有这两个接口的实现类型。如：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实现了Reader的类型：LimitedReader、PipeReader、SectionReader&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实现了Writer的类型：PipeWriter以上类型中，常用的类型有：os.File、strings.Reader、bufio.Reader/Writer、bytes.Buffer、bytes.Reader&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从接口名称很容易猜到，一般地，Go中接口的命名约定：接口名以er结尾。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意，这里并非强行要求，你完全可以不以 er 结尾。标准库中有些接口也不是以 er 结尾的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReaderAt和WriterAt接口ReaderAt接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ReaderAt interface {&#xA;    ReadAt(p []byte, off int64) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回读取的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当 ReadAt 返回的 n &amp;lt; len(p) 时，它就会返回一个非nil的错误来解释 为什么没有返回更多的字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这一点上，ReadAt 比 Read 更严格。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即使 ReadAt 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若一些数据可用但不到 len(p) 字节，ReadAt 就会阻塞直到所有数据都可用或产生一个错误。 在这一点上 ReadAt 不同于 Read。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 n = len(p) 个字节在输入源的的结尾处由 ReadAt 返回，那么这时 err == EOF 或者 err == nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 ReadAt 按查找偏移量从输入源读取，ReadAt 应当既不影响基本查找偏移量也不被它所影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadAt 的客户端可对相同的输入源并行执行 ReadAt 调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可见，ReaderAt接口使得可以从指定偏移量处开始读取数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单示例代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;)&#xA;p := make([]byte, 6)&#xA;n, err := reader.ReadAt(p, 2)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;fmt.Printf(&amp;quot;%s, %d\n&amp;quot;, p, n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;WriterAt接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type WriterAt interface {&#xA;    WriteAt(p []byte, off int64) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回从 p 中被写入的字节数 n（0 &amp;lt;= n &amp;lt;= len(p)）以及任何遇到的引起写入提前停止的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 WriteAt 返回的 n &amp;lt; len(p)，它就必须返回一个非nil的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 WriteAt 按查找偏移量写入到目标中，WriteAt 应当既不影响基本查找偏移量也不被它所影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若区域没有重叠，WriteAt 的客户端可对相同的目标并行执行 WriteAt 调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以通过该接口将数据写入数据流的特定偏移量之后。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过简单示例来演示WriteAt方法的使用（os.File实现了WriterAt接口）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;writeAt.txt&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer file.Close()&#xA;file.WriteString(&amp;quot;Golang中文社区——这里是多余的&amp;quot;)&#xA;n, err := file.WriteAt([]byte(&amp;quot;Go语言学习园地&amp;quot;), 24)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;fmt.Println(n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开文件WriteAt.txt，内容是：Golang中文社区——Go语言学习园地。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;分析：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;file.WriteString(&amp;ldquo;Golang中文社区——这里是多余的&amp;rdquo;) 往文件中写入Golang中文社区——这里是多余的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之后file.WriteAt([]byte(&amp;ldquo;Go语言学习园地&amp;rdquo;), 24) 在文件流的offset=24处写入Go语言学习园地（会覆盖该位置的内容）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReaderFrom 和 WriterTo 接口ReaderFrom的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ReaderFrom interface {&#xA;    ReadFrom(r Reader) (n int64, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果 ReaderFrom 可用，Copy 函数就会使用它。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：ReadFrom方法不会返回err == EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的例子简单的实现将文件中的数据全部读取（显示在标准输出）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Open(&amp;quot;writeAt.txt&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer file.Close()&#xA;writer := bufio.NewWriter(os.Stdout)&#xA;writer.ReadFrom(file)&#xA;writer.Flush()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当然，我们可以通过ioutil包的ReadFile函数获取文件全部内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实，跟踪一下ioutil.ReadFile的源码，会发现其实也是通过ReadFrom方法实现（用的是bytes.Buffer，它实现了ReaderFrom接口）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果不通过ReadFrom接口来做这件事，而是使用io.Reader接口，我们有两种思路：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先获取文件的大小（File的Stat方法），之后定义一个该大小的[]byte，通过Read一次性读取&lt;/p&gt;&#xA;&#xA;&lt;p&gt;定义一个小的[]byte，不断的调用Read方法直到遇到EOF，将所有读取到的[]byte连接到一起&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里不给出实现代码了，有兴趣的可以实现以下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提示&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过查看 bufio.Writer或strings.Buffer 类型的ReadFrom方法实现，会发现，其实它们的实现和上面说的第2种思路类似。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriterTo的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type WriterTo interface {&#xA;    WriteTo(w Writer) (n int64, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在写入过程中遇到的任何错误也将被返回。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果 WriterTo 可用，Copy 函数就会使用它。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读者是否发现，其实ReaderFrom和WriterTo接口的方法接收的参数是io.Reader和io.Writer类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据io.Reader和io.Writer接口的讲解，对该接口的使用应该可以很好的掌握。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里只提供简单的一个示例代码：将一段文本输出到标准输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := bytes.NewReader([]byte(&amp;quot;Go语言学习园地&amp;quot;))&#xA;reader.WriteTo(os.Stdout)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过io.ReaderFrom和io.WriterTo的学习，我们知道，如果这样的需求，可以考虑使用这两个接口：“一次性从某个地方读或写到某个地方去。”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Seeker接口接口定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Seeker interface {&#xA;    Seek(offset int64, whence int) (ret int64, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;官方文档中关于该接口方法的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Seek 设置下一次 Read 或 Write 的偏移量为 offset&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Seek 返回新的偏移量和一个错误，如果有的话。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，Seek方法用于设置偏移量的，这样可以从某个特定位置开始操作数据流。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;听起来和ReaderAt/WriteAt接口有些类似，不过Seeker接口更灵活，可以更好的控制读写数据流的位置。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单的示例代码：获取倒数第二个字符（需要考虑UTF-8编码，这里的代码只是一个示例）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;)&#xA;reader.Seek(-6, os.SEEK_END)&#xA;r, _, _ := reader.ReadRune()&#xA;fmt.Printf(&amp;quot;%c\n&amp;quot;, r)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;whence的值，在os包中定义了相应的常量，应该使用这些常量&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    SEEK_SET int = 0 // seek relative to the origin of the file&#xA;    SEEK_CUR int = 1 // seek relative to the current offset&#xA;    SEEK_END int = 2 // seek relative to the end&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Closer接口接口定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Closer interface {&#xA;    Close() error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;该接口比较简单，只有一个Close()方法，用于关闭数据流。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件(os.File)、归档（压缩包）、数据库连接、Socket等需要手动关闭的资源都实现了Closer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实际编程中，经常将Close方法的调用放在defer语句中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小提示&lt;/p&gt;&#xA;&#xA;&lt;p&gt;初学者容易写出这样的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Open(&amp;quot;studygolang.txt&amp;quot;)&#xA;defer file.Close()&#xA;if err != nil {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当文件 studygolang.txt 不存在或找不到时，file.Close()会panic，因为file是nil。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，应该将defer file.Close()放在错误检查之后。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他接口ByteReader和ByteWriter通过名称大概也能猜出这组接口的用途：读或写一个字节。接口定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ByteReader interface {&#xA;    ReadByte() (c byte, err error)&#xA;}&#xA;&#xA;type ByteWriter interface {&#xA;    WriteByte(c byte) error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在标准库中，有如下类型实现了io.ByteReader或io.ByteWriter:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;bufio.Reader/Writer 分别实现了io.ByteReader和io.ByteWriter&#xA;bytes.Buffer 同时实现了io.ByteReader和io.ByteWriter&#xA;bytes.Reader 实现了io.ByteReader&#xA;strings.Reader 实现了io.ByteReader&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接下来的示例中，我们通过bytes.Buffer来一次读取或写入一个字节（主要代码）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var ch byte&#xA;fmt.Scanf(&amp;quot;%c\n&amp;quot;, &amp;amp;ch)&#xA;&#xA;buffer := new(bytes.Buffer)&#xA;err := buffer.WriteByte(ch)&#xA;if err == nil {&#xA;    fmt.Println(&amp;quot;写入一个字节成功！准备读取该字节……&amp;quot;)&#xA;    newCh, _ := buffer.ReadByte()&#xA;    fmt.Printf(&amp;quot;读取的字节：%c\n&amp;quot;, newCh)&#xA;} else {&#xA;    fmt.Println(&amp;quot;写入错误&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;程序从标准输入接收一个字节（ASCII字符），调用buffer的WriteByte将该字节写入buffer中，之后通过ReadByte读取该字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;完整的代码见：code/src/chapter01/io/byterwer.go&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般地，我们不会使用bytes.Buffer来一次读取或写入一个字节。那么，这两个接口有哪些用处呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在标准库encoding/binary中，实现Google-ProtoBuf中的Varints读取，ReadVarint就需要一个io.ByteReader类型的参数，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，它需要一个字节一个字节的读取。关于encoding/binary包在后面会详细介绍。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在标准库image/jpeg中，Encode函数的内部实现使用了ByteWriter写入一个字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;小贴士&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以通过在Go语言源码src/pkg中搜索&amp;rdquo;io.ByteReader&amp;rdquo;或&amp;rdquo;io.ByteWiter&amp;rdquo;，获得哪些地方用到了这两个接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你会发现，这两个接口在二进制数据或归档压缩时用的比较多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ByteScanner、RuneReader和RuneScanner将这三个接口放在一起，是考虑到与ByteReader相关或相应。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ByteScanner接口的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ByteScanner interface {&#xA;    ByteReader&#xA;    UnreadByte() error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可见，它内嵌了ByteReader接口（可以理解为继承了ByteReader接口），UnreadByte方法的意思是：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将上一次ReadByte的字节还原，使得再次调用ReadByte返回的结果和上一次调用相同，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，UnreadByte是重置上一次的ReadByte。注意，UnreadByte调用之前必须调用了ReadByte，且不能连续调用UnreadByte。即：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;buffer := bytes.NewBuffer([]byte{&#39;a&#39;, &#39;b&#39;})&#xA;err := buffer.UnreadByte()&#xA;和&#xA;buffer := bytes.NewBuffer([]byte{&#39;a&#39;, &#39;b&#39;})&#xA;buffer.ReadByte()&#xA;err := buffer.UnreadByte()&#xA;err = buffer.UnreadByte()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;err都非nil，错误为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;bytes.Buffer: UnreadByte: previous operation was not a read&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;RuneReader接口和ByteReader类似，只是ReadRune方法读取单个UTF-8字符，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;返回其rune和该字符占用的字节数。该接口在regexp包有用到。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之前有人在QQ群中问道：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;strings.Index(“行业交流群”,“交流”) 返回的是单字节字符的位置：6。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是想要的是unicode字符的位置：2。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当时以为strings.IndexRune可以，然而IndexRune还不如Index，一方面第二个参数是rune类型；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一方面返回的结果跟Index是一样的。这里通过RuneReader接口来实现这个需求，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// strings.Index的UTF-8版本// 即 Utf8Index(&amp;quot;Go语言学习园地&amp;quot;, &amp;quot;学习&amp;quot;) 返回 4，而不是strings.Index的 8&#xA;&#xA;func Utf8Index(str, substr string) int {&#xA;    asciiPos := strings.Index(str, substr)&#xA;    if asciiPos == -1 || asciiPos == 0 {&#xA;    return asciiPos&#xA;    }&#xA;    pos := 0&#xA;    totalSize := 0&#xA;    reader := strings.NewReader(str)&#xA;    for _, size, err := reader.ReadRune(); err == nil; _, size, err = reader.ReadRune(){&#xA;    totalSize += size&#xA;    pos++&#xA;    // 匹配到&#xA;    if totalSize == asciiPos {&#xA;        return pos&#xA;    }&#xA;    }&#xA;    return pos&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;该实现借助了strings.Index。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外，此处的strings.NewReader可以换成bytes.NewBufferString，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，根据strings.NewReader的文档，strings.Reader比bytes.Buffer效率更高，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;只是strings.Reader是只读的，而bytes.Buffer是可读写的（从前面介绍的实现的接口可以知道）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于bytes和strings包，后面章节会详细介绍。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;RuneScanner接口和ByteScanner类似，就不赘述了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser和WriteSeeker接口&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些接口是上面介绍的接口的两个或三个组合而成的新接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例如ReadWriter接口：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ReadWriter interface {&#xA;    Reader&#xA;    Writer&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这是Reader接口和Writer接口的简单组合（内嵌）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可见，io包中有大量的&amp;rdquo;小接口&amp;rdquo;，这样方便组合为&amp;rdquo;大接口&amp;rdquo;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SectionReader 类型SectionReader是一个struct（没有任何导出的字段），实现了 Read, Seek 和 ReadAt，同时，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;内嵌了 ReaderAt 接口。结构定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type SectionReader struct {&#xA;    r     ReaderAt  // 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现&#xA;    base  int64     // NewSectionReader 会将 base 设置为 off&#xA;    off   int64     // 从 r 中的 off 偏移处开始读取数据&#xA;    limit int64     // limit - off = SectionReader 流的长度&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从名称我们可以猜到，该类型读取数据流中部分数据。看一下&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader&lt;/code&gt;的文档说明就知道了：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，SectionReader 只是内部（内嵌）ReaderAt表示的数据流的一部分：从 off 开始后的n个字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个类型的作用是：方便重复操作某一段(section)数据流；或者同时需要ReadAt和Seek的功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于该类型所支持的操作，前面都有介绍，因此提供示例代码了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于该类型在标准库中的使用，我们在 8.5 archive/zip — zip归档访问 会讲到。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;LimitedReader 类型LimitedReader 类型定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type LimitedReader struct {&#xA;    R Reader // underlying reader，最终的读取操作通过 R.Read 完成&#xA;    N int64  // max bytes remaining&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;文档说明如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从 R 读取但将返回的数据量限制为 N 字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;每调用一次 Read 都将更新 N 来反应新的剩余数量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，最多只能返回 N 字节数据。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;LimitedReader只实现了Read方法（Reader接口）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用示例如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;content := &amp;quot;This Is LimitReader Example&amp;quot;&#xA;reader := strings.NewReader(content)&#xA;limitReader := &amp;amp;io.LimitedReader{R: reader, N: 8}&#xA;for limitReader.N &amp;gt; 0 {&#xA;    tmp := make([]byte, 2)&#xA;    limitReader.Read(tmp)&#xA;    fmt.Printf(&amp;quot;%s&amp;quot;, tmp)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可见，通过该类型可以达到 只允许读取一定长度数据 的目的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在io包中，LimitReader 函数的实现其实就是调用 LimitedReader：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func LimitReader(r Reader, n int64) Reader { return &amp;amp;LimitedReader{r, n} }&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PipReader 和 PipWriter 类型PipReader（一个没有任何导出字段的struct）是管道的读取端。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它实现了io.Reader和io.Closer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于 Read 方法的说明：从管道中读取数据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该方法会堵塞，直到管道写入端开始写入数据或写入端关闭了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果写入端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是写入端传递的error；否则err为EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PipWriter（一个没有任何导出字段的struct）是管道的写入端。它实现了io.Writer和io.Closer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于 Write 方法的说明：写数据到管道中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该方法会堵塞，直到管道读取端读完所有数据或读取端关闭了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果读取端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是读取端传递的error；否则err为 ErrClosedPipe。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他方法的使用通过例子一起讲解：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    Pipe()&#xA;}&#xA;&#xA;func Pipe() {&#xA;    pipeReader, pipeWriter := io.Pipe()&#xA;    go PipeWrite(pipeWriter)&#xA;    go PipeRead(pipeReader)&#xA;    time.Sleep(1e7)&#xA;}&#xA;&#xA;func PipeWrite(pipeWriter *io.PipeWriter) {&#xA;    var (&#xA;    i   = 0&#xA;    err error&#xA;    n int&#xA;    )&#xA;    data := []byte(&amp;quot;Go语言学习园地&amp;quot;)&#xA;    for _, err = pipeWriter.Write(data); err == nil; n, err = pipeWriter.Write(data) {&#xA;    i++&#xA;    if i == 3 {&#xA;        pipeWriter.CloseWithError(errors.New(&amp;quot;输出3次后结束&amp;quot;))&#xA;    }&#xA;    }&#xA;    fmt.Println(&amp;quot;close 后输出的字节数：&amp;quot;, n, &amp;quot; error：&amp;quot;,  err)&#xA;}&#xA;&#xA;func PipeRead(pipeReader *io.PipeReader) {&#xA;    var (&#xA;    err error&#xA;    n   int&#xA;    )&#xA;    data := make([]byte, 1024)&#xA;    for n, err = pipeReader.Read(data); err == nil; n, err = pipeReader.Read(data) {&#xA;    fmt.Printf(&amp;quot;%s\n&amp;quot;, data[:n])&#xA;    }&#xA;    fmt.Println(&amp;quot;writer 端 closewitherror后：&amp;quot;, err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;writer 端 closewitherror后： 输出3次后结束close 后输出的字节数： 20  error： io: read/write on closed pipe&lt;/p&gt;&#xA;&#xA;&lt;p&gt;细心的读者可能发现：不是输出3此后结束吗？怎么“Go语言学习园地”却输出了4次？这个问题我们稍候讨论。我们先来分析一下例子代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;io.Pipe()用于创建创建一个同步的内存管道（synchronous in-memory pipe），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;函数签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Pipe() (*PipeReader, *PipeWriter)它将 io.Reader 连接到 io.Writer。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它对于并行调用 Read 和 Write 以及其它函数或 Close 来说都是安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一旦等待的I/O结束，Close 就会完成。并行调用 Read 或并行调用 Write 也同样安全： 同种类的调用将按顺序进行控制。稍候我们会分析管道相关的源码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正因为是*同步*的，因此不能在一个goroutine中进行读和写。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在 PipeWrite 函数中，我们循环往管道中写数据，写第三次时，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们调用 CloseWithError 方法关闭管道的写入端，之后再一次调用 Write 方法，发现返回了error，于是退出了循环。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可是，从输出结果中，我们发现，最后一次写虽然返回error（返回的n并非0），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是读取端却能读到最后一次写的数据，这让人很费解。下面我们一起来探索一下相关源码，分析问题的原因。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;io 包 管道（pipe） 源码分析从上文知道，PipWriter 和 PipeReader 都没有导出成员。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;查看源码发现，两者都只有一个成员：p *pipe，这两种类型的所有方法都是调用了 pipe 类型对应的方法实现的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;pipe类型的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// A pipe is the shared pipe structure underlying PipeReader and PipeWriter.&#xA;&#xA;type pipe struct {&#xA;    rl    sync.Mutex // gates readers one at a time&#xA;    wl    sync.Mutex // gates writers one at a time&#xA;    l     sync.Mutex // protects remaining fields&#xA;    data  []byte     // data remaining in pending write&#xA;    rwait sync.Cond  // waiting reader&#xA;    wwait sync.Cond  // waiting writer&#xA;    rerr  error      // if reader closed, error to give writes&#xA;    werr  error      // if writer closed, error to give reads&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;字段说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rl/wl 用于控制同一时刻只能有一个读取器或写入器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;l 用于保护其他字段&lt;/p&gt;&#xA;&#xA;&lt;p&gt;data 在管道中的数据&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rwait/wwait sync.Cond类型（后续会讲解），分别控制读取器或写入器等待&lt;/p&gt;&#xA;&#xA;&lt;p&gt;rerr/werr 读取器（写入器）关闭，该错误会被Write（Read）方法返回&lt;/p&gt;&#xA;&#xA;&lt;p&gt;pipe的read方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (p *pipe) read(b []byte) (n int, err error) {&#xA;    // One reader at a time.（控制一次只能一个读取器）&#xA;    p.rl.Lock()&#xA;    defer p.rl.Unlock()&#xA;&#xA;    // 保护其他字段的读写&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;    for {&#xA;    // Reader端关闭后，再Read，则返回ErrClosedPipe&#xA;    if p.rerr != nil {&#xA;        return 0, ErrClosedPipe&#xA;    }&#xA;    // 管道中有数据，退出循环&#xA;    if p.data != nil {&#xA;        break&#xA;    }&#xA;    // Writer端关闭，返回p.werr&#xA;    if p.werr != nil {&#xA;        return 0, p.werr&#xA;    }&#xA;    // 没有数据或管道没有关闭，读取端等待&#xA;    p.rwait.Wait()&#xA;    }&#xA;    // 管道中有数据，将其copy一份到b中&#xA;    n = copy(b, p.data)&#xA;    p.data = p.data[n:]&#xA;    // 如果管道数据被读光，需要唤醒在等待的Writer&#xA;    if len(p.data) == 0 {&#xA;    p.data = nil&#xA;    p.wwait.Signal()&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;加上的代码注释已经很清楚了，因此不再赘述。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;pipe的write方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (p *pipe) write(b []byte) (n int, err error) {&#xA;    // pipe uses nil to mean not available&#xA;    if b == nil {&#xA;    // zero的定义为：var zero [0]byte&#xA;    b = zero[:]&#xA;    }&#xA;&#xA;    // One writer at a time.&#xA;    p.wl.Lock()&#xA;    defer p.wl.Unlock()&#xA;&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;    // 上面说的问题来了：不管三七二十一，一上来些将数据放进管道中&#xA;    p.data = b&#xA;    // 唤醒在等待的Reader&#xA;    p.rwait.Signal()&#xA;    for {&#xA;    // 数据被读走，退出循环&#xA;    if p.data == nil {&#xA;        break&#xA;    }&#xA;    // Reader端关闭，设置err = p.rerr，退出循环&#xA;    if p.rerr != nil {&#xA;        err = p.rerr&#xA;        break&#xA;    }&#xA;    // Writer端关闭后，再Writer，设置err = ErrClosedPipe&#xA;    if p.werr != nil {&#xA;        err = ErrClosedPipe&#xA;    }&#xA;    // 数据没被读走（全部）或管道读取端没关闭，则等待&#xA;    p.wwait.Wait()&#xA;    }&#xA;    // 计算写入的字节数&#xA;    n = len(b) - len(p.data)&#xA;    p.data = nil // in case of rerr or werr&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过上面两个方法的代码注释，应该清楚例子中为啥输出4次了吧？我们再分析一下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当i == 3，调用CloseWithError之后，程序执行 for 中的 n, err = pipeWriter.Write(data)，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据上面pipe.write方法，p.data 会被设置上数据，这个时候，Reader被唤醒，将数据读走（第4次）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于异步，多goroutine，跟调度有关系，这个时候Writer可能在等待，也可能在Reader读完数据后将其唤醒，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总之，Writer会执行到 if p.werr != nil，即例子中Write循环结束；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而Reader被唤醒之后，首先判断的是p.data != nil，而不是 p.werr != nil，因此数据被正常读取，且没错误被返回，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这时执行下一次循环，当然，这时候由于没有Write，且 p.werr != nil，于是Read方法返回err(=p.werr)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个人认为这是一个bug，已经向官方提出：issue5330，修复处：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在pipe.write方法的defer p.l.Unlock()后面增加如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 写端关闭了，不让写入数据&#xA;if p.werr != nil {&#xA;    p.rwait.Signal()&#xA;    err = ErrClosedPipe&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同时，for循环中如下代码没有必要，删除：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Writer端关闭后，再Writer，设置err = ErrClosedPipe&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if p.werr != nil {&#xA;    err = ErrClosedPipe&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;pipe.read方法中，调整检查p.werr和p.data的顺序，即改为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if p.werr != nil {&#xA;    return 0, p.werr&#xA;}&#xA;if p.data != nil {&#xA;    break&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样不至于有错误时还把数据读走。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外，对于管道的close方法（非CloseWithError时），err会被置为EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Copy 和 CopyN 函数Copy 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Copy(dst Writer, src Reader) (written int64, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数，如果有的话，还会返回在复制时遇到的第一个错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;成功的 Copy 返回 err == nil，而非 err == EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此外，若 dst 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;io.Copy(os.Stdout, strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;))直接将内容输出（写入Stdout中）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们甚至可以这么做：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    io.Copy(os.Stdout, os.Stdin)&#xA;    fmt.Println(&amp;quot;Got EOF -- bye&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行：echo &amp;ldquo;Hello, World&amp;rdquo; | go run main.go&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CopyN 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func CopyN(dst Writer, src Reader, n int64) (written int64, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CopyN 将 n 个字节从 src 复制到 dst。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数以及在复制时遇到的最早的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于 Read 可以返回要求的全部数量及一个错误（包括 EOF），因此 CopyN 也能如此。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;io.CopyN(os.Stdout, strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;), 8)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Go语言ReadAtLeast 和 ReadFull 函数ReadAtLeast 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadAtLeast 将 r 读取到 buf 中，直到读了最少 min 个字节为止。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数，如果读取的字节较少，还会返回一个错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若没有读取到字节，错误就只是 EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果一个 EOF 发生在读取了少于 min 个字节之后，ReadAtLeast 就会返回 ErrUnexpectedEOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若 min 大于 buf 的长度，ReadAtLeast 就会返回 ErrShortBuffer。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于返回值，当且仅当 err == nil 时，才有 n &amp;gt;= min。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般可能不太会用到这个函数。使用时需要注意返回的error判断。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadFull 函数的签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadFull(r Reader, buf []byte) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ReadFull 精确地从 r 中将 len(buf) 个字节读取到 buf 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它返回复制的字节数，如果读取的字节较少，还会返回一个错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了一些但不是所有的字节后，ReadFull 就会返回 ErrUnexpectedEOF&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于返回值，当且仅当 err == nil 时，才有 n == len(buf)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意该函数和ReadAtLeast的区别：ReadFull 将buf读满；而ReadAtLeast是最少读取min个字节。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WriteString 函数这是为了方便写入string类型提供的函数，函数签名：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func WriteString(w Writer, s string) (n int, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当 w 实现了 WriteString 方法时，直接调用该方法，否则执行w.Write([]byte(s))。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MultiReader 和 MultiWriter 函数这两个函数的定义分别是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func MultiReader(readers ...Reader) Reader&#xA;func MultiWriter(writers ...Writer) Writer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;它们接收多个Reader或Writer，返回一个Reader或Writer。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以猜想到这两个函数就是操作多个Reader或Writer就像操作一个。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;事实上，在io包中定义了两个非导出类型：mutilReader和multiWriter，它们分别实现了io.Reader和io.Writer接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类型定义为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type multiReader struct {&#xA;    readers []Reader&#xA;}&#xA;&#xA;type multiWriter struct {&#xA;    writers []Writer&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于这两种类型对应的实现方法（Read和Write方法）的使用，我们通过例子来演示。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MultiReader的使用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;readers := []io.Reader{&#xA;    strings.NewReader(&amp;quot;from strings reader&amp;quot;),&#xA;    bytes.NewBufferString(&amp;quot;from bytes buffer&amp;quot;),&#xA;}&#xA;reader := io.MultiReader(readers...)&#xA;data := make([]byte, 0, 1024)&#xA;var (&#xA;    err error&#xA;    n   int&#xA;)&#xA;for err != io.EOF {&#xA;    tmp := make([]byte, 512)&#xA;    n, err = reader.Read(tmp)&#xA;    if err == nil {&#xA;    data = append(data, tmp[:n]...)&#xA;    } else {&#xA;    if err != io.EOF {&#xA;        panic(err)&#xA;    }&#xA;    }&#xA;}&#xA;fmt.Printf(&amp;quot;%s\n&amp;quot;, data)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;from strings readerfrom bytes buffer代码中首先构造了一个io.Reader的slice，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由 strings.Reader 和 bytes.Buffer 两个实例组成，然后通过MultiReader得到新的Reader，循环读取新Reader中的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从输出结果可以看到，第一次调用Reader的Read方法获取到的是slice中第一个元素的内容&lt;/p&gt;&#xA;&#xA;&lt;p&gt;……也就是说，MultiReader只是逻辑上将多个Reader组合起来，并不能通过调用一次Read方法获取所有Reader的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在所有的Reader内容都被读完后，Reader会返回EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MultiWriter的使用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;tmp.txt&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer file.Close()&#xA;writers := []io.Writer{&#xA;    file,&#xA;    os.Stdout,&#xA;}&#xA;writer := io.MultiWriter(writers...)&#xA;writer.Write([]byte(&amp;quot;Go语言学习园地&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这段程序执行后在生成tmp.txt文件，同时在文件和屏幕中都输出：Go语言学习园地。这和Unix中的tee命令类似。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;动手试试&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go实现Unix中tee命令的功能很简单吧。multiWriter的write方法是如何实现的？有兴趣可以自己实现一个，然后对着源码比较一下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;TeeReader函数函数签名如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func TeeReader(r Reader, w Writer) ReaderTeeReader 返回一个 Reader，它将从 r 中读到的数据写入 w 中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所有经由它处理的从 r 的读取都匹配于对应的对 w 的写入。它没有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也就是说，我们通过Reader读取内容后，会自动写入到Writer中去。例子代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reader := io.TeeReader(strings.NewReader(&amp;quot;Go语言学习园地&amp;quot;), os.Stdout)&#xA;reader.Read(make([]byte, 20))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出结果：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go语言学习园地这种功能的实现其实挺简单，无非是在Read完后执行Write。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至此，io所有接口、类型和函数都讲解完成。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-反射篇</title>
      <link>http://www.nljb.net/default/Golang-%E5%8F%8D%E5%B0%84%E7%AF%87/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go语言的基本语法的使用已经在前几篇陆陆续续学完了，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面可能想写一些Go的标准库的使用了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先是reflect库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;reflect库的godoc在&lt;a href=&#34;http://golang.org/pkg/reflect/&#34;&gt;http://golang.org/pkg/reflect/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Type和Value&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先，reflect包有两个数据类型我们必须知道，一个是Type，一个是Value。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Type就是定义的类型的一个数据类型，Value是值的类型&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体的Type和Value里面包含的方法就要看文档了：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://golang.org/pkg/reflect/&#34;&gt;http://golang.org/pkg/reflect/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import(&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;)&#xA;&#xA;type MyStruct struct{&#xA;    name string&#xA;}&#xA;&#xA;func (this *MyStruct)GetName() string {&#xA;    return this.name&#xA;}&#xA;&#xA;func main() {&#xA;    s := &amp;quot;this is string&amp;quot;&#xA;    fmt.Println(reflect.TypeOf(s))&#xA;    fmt.Println(&amp;quot;-------------------&amp;quot;)&#xA;&#xA;    fmt.Println(reflect.ValueOf(s))&#xA;    var x float64 = 3.4&#xA;    fmt.Println(reflect.ValueOf(x))&#xA;    fmt.Println(&amp;quot;-------------------&amp;quot;)&#xA;&#xA;    a := new(MyStruct)&#xA;    a.name = &amp;quot;yejianfeng&amp;quot;&#xA;    typ := reflect.TypeOf(a)&#xA;&#xA;    fmt.Println(typ.NumMethod())&#xA;    fmt.Println(&amp;quot;-------------------&amp;quot;)&#xA;&#xA;    b := reflect.ValueOf(a).MethodByName(&amp;quot;GetName&amp;quot;).Call([]reflect.Value{})&#xA;    fmt.Println(b[0])&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出结果：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-反射篇/1_0.jpg&#34; alt=&#34;&#34; width=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个程序看到几点：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1 TypeOf和ValueOf是获取Type和Value的方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2 ValueOf返回的&lt;float64 Value&gt;是为了说明这里的value是float643 第三个b的定义实现了php中的string-&amp;gt;method的方法，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为什么返回的是reflect.Value[]数组呢？当然是因为Go的函数可以返回多个值的原因了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Value的方法和属性&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-反射篇/2.jpg&#34; alt=&#34;&#34; width=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了，我们看到Value的Type定义了这么多Set方法：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面看这么个例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import(&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;reflect&amp;quot;&#xA;)&#xA;&#xA;type MyStruct struct{&#xA;    name string&#xA;}&#xA;&#xA;func (this *MyStruct)GetName() string {&#xA;    return this.name&#xA;}&#xA;&#xA;func main() {&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    var a MyStruct&#xA;    b := new(MyStruct)&#xA;    fmt.Println(reflect.ValueOf(a))&#xA;    fmt.Println(reflect.ValueOf(b))&#xA;&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    a.name = &amp;quot;yejianfeng&amp;quot;&#xA;    b.name = &amp;quot;yejianfeng&amp;quot;&#xA;    val := reflect.ValueOf(a).FieldByName(&amp;quot;name&amp;quot;)&#xA;&#xA;    //painc: val := reflect.ValueOf(b).FieldByName(&amp;quot;name&amp;quot;)&#xA;    fmt.Println(val)&#xA;&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    fmt.Println(reflect.ValueOf(a).FieldByName(&amp;quot;name&amp;quot;).CanSet())&#xA;    fmt.Println(reflect.ValueOf(&amp;amp;(a.name)).Elem().CanSet())&#xA;&#xA;    fmt.Println(&amp;quot;--------------&amp;quot;)&#xA;    var c string = &amp;quot;yejianfeng&amp;quot;&#xA;    p := reflect.ValueOf(&amp;amp;c)&#xA;    fmt.Println(p.CanSet())   //false&#xA;    fmt.Println(p.Elem().CanSet())  //true&#xA;    p.Elem().SetString(&amp;quot;newName&amp;quot;)&#xA;    fmt.Println(c)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;返回：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-反射篇/3.jpg&#34; alt=&#34;&#34; width=&#34;300&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这段代码能有一些事情值得琢磨：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1 为什么a和b的ValueOf返回的是不一样的？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a是一个结构，b是一个指针。好吧，在Go中，指针的定义和C中是一样的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2 reflect.ValueOf(a).FieldByName(&amp;ldquo;name&amp;rdquo;)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;这是一个绕路的写法，其实和a.name是一样的意思，主要是要说明一下Value.FieldByName的用法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3 val := reflect.ValueOf(b).FieldByName(&amp;ldquo;name&amp;rdquo;) 是有error的，为什么？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;b是一个指针，指针的ValueOf返回的是指针的Type，它是没有Field的，所以也就不能使用FieldByName&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4 fmt.Println(reflect.ValueOf(a).FieldByName(&amp;ldquo;name&amp;rdquo;).CanSet())为什么是false?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看文档中的解释：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好吧，什么是addressable，and was not obtained by the use of unexported struct fields?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CanSet当Value是可寻址的时候，返回true，否则返回false&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看到第二个c和p的例子，我们可以这么理解：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当前面的CanSet是一个指针的时候（p）它是不可寻址的，但是当是p.Elem()(实际上就是*p)，它就是可以寻址的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个确实有点绕。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总而言之，reflect包是开发过程中几乎必备的包之一。能合理和熟练使用它对开发有很大的帮助&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Date-命令设置系统时间的方法</title>
      <link>http://www.nljb.net/default/Date-%E5%91%BD%E4%BB%A4%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;名称 : date&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用权限 : 所有使用者&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用方式 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;date&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[-u]&#xA;[-d datestr]&#xA;[-s datestr]&#xA;[--utc]&#xA;[--universal]&#xA;[--date=datestr] &#xA;[--set=datestr] &#xA;[--help] &#xA;[--version] &#xA;[+FORMAT] &#xA;[MMDDhhmm[[CC]YY][.ss]]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;date 可以用来显示或设定系统的日期与时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中可用的标记列表如下 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;时间方面 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;% : 印出 %&#xA;%n : 下一行&#xA;%t : 跳格&#xA;%H : 小时(00..23)&#xA;%I : 小时(01..12)&#xA;%k : 小时(0..23)&#xA;%l : 小时(1..12)&#xA;%M : 分钟(00..59)&#xA;%p : 显示本地 AM 或 PM&#xA;%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)&#xA;%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数&#xA;%S : 秒(00..61)&#xA;%T : 直接显示时间 (24 小时制)&#xA;%X : 相当于 %H:%M:%S&#xA;%Z : 显示时区&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;日期方面 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;%a : 星期几 (Sun..Sat)&#xA;%A : 星期几 (Sunday..Saturday)&#xA;%b : 月份 (Jan..Dec)&#xA;%B : 月份 (January..December)&#xA;%c : 直接显示日期与时间&#xA;%d : 日 (01..31)&#xA;%D : 直接显示日期 (mm/dd/yy)&#xA;%h : 同 %b&#xA;%j : 一年中的第几天 (001..366)&#xA;%m : 月份 (01..12)&#xA;%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)&#xA;%w : 一周中的第几天 (0..6)&#xA;%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)&#xA;%x : 直接显示日期 (mm/dd/yy)&#xA;%y : 年份的最后两位数字 (00.99)&#xA;%Y : 完整年份 (0000..9999)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;若是不以加号作为开头，则表示要设定时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而时间格式为 MMDDhhmm[[CC]YY][.ss]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参数 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-d datestr : 显示 datestr 中所设定的时间 (非系统时间)&#xA;--help : 显示辅助讯息&#xA;-s datestr : 将系统时间设为 datestr 中所设定的时间&#xA;-u : 显示目前的格林威治时间&#xA;--version : 显示版本编号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;例子 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;显示时间后跳行，再显示目前日期 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date &#39;+%T%n%D&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示月份与日数 :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date &#39;+%B %d&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示日期与设定时间(12:34:56) :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date --date &#39;12:34:56&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意 :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当你不希望出现无意义的 0 时(比如说 &lt;sup&gt;1999&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/07)，则可以在标记中插入 - 符号&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如说 date &amp;lsquo;+%-H:%-M:%-S&amp;rsquo; 会把时分秒中无意义的 0 给去掉&lt;/p&gt;&#xA;&#xA;&lt;p&gt;像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当你以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样下次重新开机时系统时间才会持续抱持最新的正确值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例子：修改日期时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在命令行输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;显示当前时间 Fri Aug 3 14:15:16 CST 2007&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date -s &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;按字符串方式修改时间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以只修改日期,不修改时间,输入: date -s 2007-08-03&lt;/p&gt;&#xA;&#xA;&lt;p&gt;只修改时间,输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date -s 14:15:00&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同时修改日期时间,注意要加双引号,日期与时间之间有一空格,输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;date -s &amp;quot;2007-08-03 14:15:00&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改完后,记得输入:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;clock -w &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;把系统时间写入CMOS&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>3G-网卡适配</title>
      <link>http://www.nljb.net/default/3G-%E7%BD%91%E5%8D%A1%E9%80%82%E9%85%8D/</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Content:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一、查看上网卡信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# pacman -S usbutils&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;插入上网卡前后比对，我的信息如下&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#lsusb&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 001 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 002 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 001 Device 003: ID 04fc:2801 Sunplus Technology Co., Ltd &#xA;Bus 001 Device 004: ID 20b9:1682  &#xA;Bus 002 Device 003: ID 192f:0916 Avago Technologies, Pte.&#xA;&#xA;# lsusb&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 001 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 002 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub&#xA;Bus 001 Device 003: ID 04fc:2801 Sunplus Technology Co., Ltd &#xA;Bus 001 Device 005: ID 05c6:1000 Qualcomm, Inc. Mass Storage Device&#xA;Bus 002 Device 003: ID 192f:0916 Avago Technologies, Pte.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看出 Bus 001 Device 005: ID 05c6:1000 Qualcomm, Inc. Mass Storage Device 这个就是上网卡的信息了&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看到上网卡的 idVendor 05c6 和 idProduct 1000，格式是 idVendor:idProduct&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、把上网卡从cd-rom设备转换到modem设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# pacman -S usb_modeswitch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装好后到/etc/usb_modeswitch.d/目录运行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#head -n 2 * 就可以看到当前版本usb_modeswitch支持的3g上网卡的型号了&#xA;&#xA;# usb_modeswitch -c /etc/usb_modeswitch.setup&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;试试成功不，如果不成功，那么试试这个&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# usb_modeswitch -v 05c6 -p 1000 -M 5553424312345678000000000000061b000000020000000000000000000000 -R 1&#xA;# modprobe usbserial vendor=0x05c6 product=0x1000&#xA;# ls /dev/tty*&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看能不能看的到ttyUSB0这些，如果有则继续，如果无请另寻它法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;三、开始拨号&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# pacman -S wvdial&#xA;&#xA;# wvdialconf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;会自动生成 /etc/wvdial.conf&lt;/p&gt;&#xA;&#xA;&lt;p&gt;再添加下面几行进去&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（电信cdma的例子，电话号码：#777 用户名：(或是card) 密码: vnet.mobi (或是card)）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Phone = #777&#xA;Username = &#xA;Password = vnet.mobi&#xA;Stupid Mode = 1&#xA;&#xA;#wvdial&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-绘图技术-image-draw-包介绍</title>
      <link>http://www.nljb.net/default/Golang-%E7%BB%98%E5%9B%BE%E6%8A%80%E6%9C%AF-image-draw-%E5%8C%85%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;image/draw 包仅仅定义了一个操作：通过可选的蒙版图（mask image）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;把一个原始图片绘制到目标图片上，这个操作是出奇的灵活，可以优雅和高效的执行很多常见的图像处理任务。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Draw calls DrawMask with a nil mask.&#xA;func Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)&#xA;func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)&#xA;第一个函数Draw是没有使用蒙版mask的调用方法，它内部其实就是调用的mask为 nil的方法。&#xA;&#xA;它的参数描述如下：&#xA;dst  绘图的背景图。&#xA;r 是背景图的绘图区域&#xA;src 是要绘制的图&#xA;sp 是 src 对应的绘图开始点（绘制的大小 r变量定义了）&#xA;mask 是绘图时用的蒙版，控制替换图片的方式。&#xA;mp 是绘图时蒙版开始点（绘制的大小 r变量定义了）&#xA;op Op is a Porter-Duff compositing operator.  参考文章：http://blog.csdn.net/ison81/article/details/5468763 &#xA;Porter-Duff 等式12种规则可以看这篇博客：http://www.blogjava.net/onedaylover/archive/2008/01/16/175675.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下图就是几个相关的例子：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;mask 蒙版是渐变&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;给一个矩形填充颜色&#xA;使用 Draw方法的逻辑效果图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;m := image.NewRGBA(image.Rect(0, 0, 640, 480))&#xA;blue := color.RGBA{0, 0, 255, 255}&#xA;draw.Draw(m, m.Bounds(), &amp;amp;image.Uniform{blue}, image.ZP, draw.Src)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;拷贝图片的一部分&#xA;效果特效如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/3.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;r := image.Rectangle{dp, dp.Add(sr.Size())}  // 获得更换区域&#xA;draw.Draw(dst, r, src, sr.Min, draw.Src)&#xA;&#xA;如果是复制整个图片，则更简单：&#xA;&#xA;sr = src.Bounds()         // 获取要复制图片的尺寸&#xA;r := sr.Sub(sr.Min).Add(dp)   // 目标图的要剪切区域&#xA;draw.Draw(dst, r, src, sr.Min, draw.Src)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;图片滚动效果&#xA;效果如下图:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/4.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;假设我们需要把图片 m 上移20个像素.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;b := m.Bounds()&#xA;p := image.Pt(0, 20)&#xA;// Note that even though the second argument is b,&#xA;// the effective rectangle is smaller due to clipping.&#xA;draw.Draw(m, b, m, b.Min.Add(p), draw.Src)&#xA;dirtyRect := b.Intersect(image.Rect(b.Min.X, b.Max.Y-20, b.Max.X, b.Max.Y))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;把一个图片转成RGBA格式&#xA;效果图:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/5.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;b := src.Bounds()&#xA;m := image.NewRGBA(b)&#xA;draw.Draw(m, b, src, b.Min, draw.Src)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过蒙版画特效&#xA;效果图&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/6.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type circle struct {&#xA;    p image.Point&#xA;    r int&#xA;}&#xA;&#xA;func (c *circle) ColorModel() color.Model {&#xA;    return color.AlphaModel&#xA;}&#xA;&#xA;func (c *circle) Bounds() image.Rectangle {&#xA;    return image.Rect(c.p.X-c.r, c.p.Y-c.r, c.p.X+c.r, c.p.Y+c.r)&#xA;}&#xA;&#xA;func (c *circle) At(x, y int) color.Color {&#xA;    xx, yy, rr := float64(x-c.p.X)+0.5, float64(y-c.p.Y)+0.5, float64(c.r)&#xA;    if xx*xx+yy*yy &amp;lt; rr*rr {&#xA;    return color.Alpha{255}&#xA;    }&#xA;    return color.Alpha{0}&#xA;}&#xA;&#xA;draw.DrawMask(dst, dst.Bounds(), src, image.ZP, &amp;amp;circle{p, r}, image.ZP, draw.Over)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意,一个image对象只需要实现下面几个就可,这也就是Go接口强大的地方.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Image interface {&#xA;    // ColorModel returns the Image&#39;s color model.&#xA;    ColorModel() color.Model&#xA;    // Bounds returns the domain for which At can return non-zero color.&#xA;    // The bounds do not necessarily contain the point (0, 0).&#xA;    Bounds() Rectangle&#xA;    // At returns the color of the pixel at (x, y).&#xA;    // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.&#xA;    // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.&#xA;    At(x, y int) color.Color&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;画一个字体&#xA;效果图，画一个蓝色背景的字体。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图技术-image-draw-包介绍/7.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关伪代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;src := &amp;amp;image.Uniform{color.RGBA{0, 0, 255, 255}}&#xA;mask := theGlyphImageForAFont()&#xA;mr := theBoundsFor(glyphIndex)&#xA;draw.DrawMask(dst, mr.Sub(mr.Min).Add(p), src, image.ZP, mask, mr.Min, draw.Over)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面例子完整的代码请看：&#xA;&lt;a href=&#34;http://golang.org/doc/progs/image_draw.go&#34;&gt;http://golang.org/doc/progs/image_draw.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参考：&#xA;&lt;a href=&#34;http://blog.golang.org/go-imagedraw-package&#34;&gt;http://blog.golang.org/go-imagedraw-package&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-绘图基础-绘制简单图形</title>
      <link>http://www.nljb.net/default/Golang-%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80-%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上一节的例子效果是通过设置每一个点的的RGBA属性来实现的,这是最基础的方式，通过这种方式我们可以绘制任意形状的图形。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、设置点的颜色一个简单例子：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;效果如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/1_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下，跟最初我们的代码唯一不同的是设置点颜色时，多了一个条件判断语句：if x%8 == 0 ，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下，这种情况下，其实我们通过算法简单的实现了画垂直线的效果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    const (&#xA;    dx = 300&#xA;    dy = 500&#xA;    )&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 123&#xA;    imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;    defer imgfile.Close()&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    for y := 0; y &amp;lt; dy; y++ {&#xA;    for x := 0; x &amp;lt; dx; x++ {&#xA;&#xA;        if x%8 == 0 {&#xA;        // 设置某个点的颜色，依次是 RGBA&#xA;        img.Set(x, y, color.RGBA{uint8(x % 256), uint8(y % 256), 0, 255})&#xA;        }&#xA;    }&#xA;    }&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err := png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;比如下面一个函数就是简单的画水平线的代码函数。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 画 水平线&#xA;func (img *Image) drawHorizLine(color color.Color, fromX, toX, y int) {&#xA;    // 遍历画每个点&#xA;    for x := fromX; x &amp;lt;= toX; x++ {&#xA;    img.Set(x, y, color)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、划线&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Golang 官方库没有提供划线的库，不过既然有了画点的方法，我们就可以根据一套算法画出点&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的效果和代码是按照 Bresenham&amp;rsquo;s line algorithm 算法画的线。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&#34;&gt;http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个算法画的线简单可以用下面图来标示：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/2_0.jpg&#34; alt=&#34;&#34; width=&#34;240&#34; height=&#34;120&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面演示代码画出来的效果图如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意，为了便于看到效果， 图的左右都画了一条竖线，斜线是按照上面算法画出来的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/3_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里的代码借鉴了下面的代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/akavel/polyclip-go/blob/9b07bdd6e0a784f7e5d9321bff03425ab3a98beb/polyutil/draw.go&#34;&gt;https://github.com/akavel/polyclip-go/blob/9b07bdd6e0a784f7e5d9321bff03425ab3a98beb/polyutil/draw.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;// Putpixel describes a function expected to draw a point on a bitmap at (x, y) coordinates.&#xA;type Putpixel func(x, y int)&#xA;&#xA;// 求绝对值&#xA;func abs(x int) int {&#xA;    if x &amp;gt;= 0 {&#xA;    return x&#xA;    }&#xA;    return -x&#xA;}&#xA;&#xA;// Bresenham&#39;s algorithm, http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&#xA;// https://github.com/akavel/polyclip-go/blob/9b07bdd6e0a784f7e5d9321bff03425ab3a98beb/polyutil/draw.go&#xA;// TODO: handle int overflow etc.&#xA;func drawline(x0, y0, x1, y1 int, brush Putpixel) {&#xA;    dx := abs(x1 - x0)&#xA;    dy := abs(y1 - y0)&#xA;    sx, sy := 1, 1&#xA;    if x0 &amp;gt;= x1 {&#xA;    sx = -1&#xA;    }&#xA;    if y0 &amp;gt;= y1 {&#xA;    sy = -1&#xA;    }&#xA;    err := dx - dy&#xA;&#xA;    for {&#xA;    brush(x0, y0)&#xA;    if x0 == x1 &amp;amp;&amp;amp; y0 == y1 {&#xA;        return&#xA;    }&#xA;    e2 := err * 2&#xA;    if e2 &amp;gt; -dy {&#xA;        err -= dy&#xA;        x0 += sx&#xA;    }&#xA;    if e2 &amp;lt; dx {&#xA;        err += dx&#xA;        y0 += sy&#xA;    }&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    const (&#xA;    dx = 300&#xA;    dy = 500&#xA;    )&#xA;&#xA;    // 需要保存的文件&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    drawline(5, 5, dx-8, dy-10, func(x, y int) {&#xA;    img.Set(x, y, color.RGBA{uint8(x), uint8(y), 0, 255})&#xA;    })&#xA;&#xA;    // 左右都画一条竖线&#xA;    for i := 0; i &amp;lt; dy; i++ {&#xA;    img.Set(0, i, color.Black)&#xA;    img.Set(dx-1, i, color.Black)&#xA;    }&#xA;&#xA;    imgcounter := 250&#xA;    imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err := png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、特殊图形&#xA;这次绘制出来的图形效果如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-绘制简单图形/4_0.jpg&#34; alt=&#34;&#34; width=&#34;240&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里的代码借鉴了下面的代码：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/xMachinae/pallinda13/blob/master/uppg2.go&#34;&gt;https://github.com/xMachinae/pallinda13/blob/master/uppg2.go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA; import (&#xA;     &amp;quot;fmt&amp;quot;&#xA;     &amp;quot;image&amp;quot;&#xA;     &amp;quot;image/png&amp;quot;&#xA;     &amp;quot;log&amp;quot;&#xA;     &amp;quot;os&amp;quot;&#xA; )&#xA;&#xA; func Pic(dx, dy int) [][]uint8 {&#xA;     pic := make([][]uint8, dx)&#xA;     for i := range pic {&#xA;     pic[i] = make([]uint8, dy)&#xA;     for j := range pic[i] {&#xA;         pic[i][j] = uint8(i * j)&#xA;     }&#xA;     }&#xA;     return pic&#xA; }&#xA;&#xA; func main() {&#xA;     Show(Pic)&#xA; }&#xA;&#xA; func Show(f func(int, int) [][]uint8) {&#xA;     const (&#xA;     dx = 256&#xA;     dy = 256&#xA;     )&#xA;     data := f(dx, dy) // 图片坐标点的颜色二维数组。&#xA;     m := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;     for y := 0; y &amp;lt; dy; y++ {&#xA;     for x := 0; x &amp;lt; dx; x++ {&#xA;         v := data[y][x]&#xA;         i := y*m.Stride + x*4&#xA;         m.Pix[i] = v&#xA;         m.Pix[i+1] = v&#xA;         m.Pix[i+2] = 255&#xA;         m.Pix[i+3] = 255&#xA;     }&#xA;     }&#xA;     ShowImage(m)&#xA; }&#xA;&#xA; func ShowImage(m image.Image) {&#xA;&#xA;     // 需要保存的文件&#xA;     imgcounter := 1234&#xA;     imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;     defer imgfile.Close()&#xA;&#xA;     // 以PNG格式保存文件&#xA;     err := png.Encode(imgfile, m)&#xA;     if err != nil {&#xA;     log.Fatal(err)&#xA;     }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更复杂的算法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如下面代码实现了图片简单的上下左右翻转的功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图片旋转的算法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mpl/goexif/blob/a588a5577cedfda71e3645f8137c38495f308f6c/exif/rotate_test.go&#34;&gt;https://github.com/mpl/goexif/blob/a588a5577cedfda71e3645f8137c38495f308f6c/exif/rotate_test.go&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-绘图基础-不同的输出源</title>
      <link>http://www.nljb.net/default/Golang-%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BE%93%E5%87%BA%E6%BA%90/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;先看一个简单代码， 它执行后会产生下面的300*500的png图片文件：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-不同的输出源/1_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA; import (&#xA;     &amp;quot;fmt&amp;quot;&#xA;     &amp;quot;image&amp;quot;&#xA;     &amp;quot;image/color&amp;quot;&#xA;     &amp;quot;image/png&amp;quot;&#xA;     &amp;quot;log&amp;quot;&#xA;     &amp;quot;os&amp;quot;&#xA; )&#xA;&#xA; func main() {&#xA;     const (&#xA;     dx = 300&#xA;     dy = 500&#xA;     )&#xA;&#xA;     // 需要保存的文件&#xA;     imgcounter := 123&#xA;     imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;     defer imgfile.Close()&#xA;&#xA;     // 新建一个 指定大小的 RGBA位图&#xA;     img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;     for y := 0; y &amp;lt; dy; y++ {&#xA;     for x := 0; x &amp;lt; dx; x++ {&#xA;         // 设置某个点的颜色，依次是 RGBA&#xA;         img.Set(x, y, color.RGBA{uint8(x % 256), uint8(y % 256), 0, 255})&#xA;     }&#xA;     }&#xA;&#xA;     // 以PNG格式保存文件&#xA;     err := png.Encode(imgfile, img)&#xA;     if err != nil {&#xA;     log.Fatal(err)&#xA;     }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们再看一个代码，以http文件流的方式展示图片，效果如下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-绘图基础-不同的输出源/2_0.jpg&#34; alt=&#34;&#34; width=&#34;140&#34; height=&#34;240&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func pic(w http.ResponseWriter, req *http.Request) {&#xA;    const (&#xA;    dx = 300&#xA;    dy = 500&#xA;    )&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    for y := 0; y &amp;lt; dy; y++ {&#xA;    for x := 0; x &amp;lt; dx; x++ {&#xA;        // 设置某个点的颜色，依次是 RGBA&#xA;        img.Set(x, y, color.RGBA{uint8(x % 256), uint8(y % 256), 0, 255})&#xA;    }&#xA;    }&#xA;&#xA;    // 图片流方式输出&#xA;    w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;image/png&amp;quot;)&#xA;    png.Encode(w, img)&#xA;}&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/&amp;quot;, pic)&#xA;    s := &amp;amp;http.Server{&#xA;    Addr:           &amp;quot;:82&amp;quot;,&#xA;    ReadTimeout:    30 * time.Second,&#xA;    WriteTimeout:   30 * time.Second,&#xA;    MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20}&#xA;    s.ListenAndServe()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过两种方式来展示图片,我们可以看到,上面两个代码最大的区别就是输出源不一样,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个是到文件,一个是到http流. 而我们的代码也很清晰的展示了这两种方式只需要修改对应的实现即可.其他代码是没有变化的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里代码中的 image.NewNRGBA 返回的 image对象是一个内存中的图片。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-官方图片库</title>
      <link>http://www.nljb.net/default/Golang-%E5%AE%98%E6%96%B9%E5%9B%BE%E7%89%87%E5%BA%93/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;http://blog.golang.org/go-image-package&#xA;&#xA;http://blog.golang.org/go-imagedraw-package&#xA;&#xA;http://blog.golang.org/gif-decoder-exercise-in-go-interfaces&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Golang 的图片出来通过提供操作每一个像素点设置颜色（&lt;a href=&#34;http://www.cnblogs.com/ghj1976/p/3441536.html）&#34;&gt;http://www.cnblogs.com/ghj1976/p/3441536.html）&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提供通过可选蒙版图片重叠操作 （&lt;a href=&#34;http://www.cnblogs.com/ghj1976/p/3443638.html）&#34;&gt;http://www.cnblogs.com/ghj1976/p/3443638.html）&lt;/a&gt; 这两种基础方式&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样任何想要的效果都可以自己实现， 但是旋转、缩放等相关的图像算法也是比较麻烦的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这时候我们就需要借助官方提供的图片包处理了，图片包在：&lt;a href=&#34;https://code.google.com/p/graphics-go&#34;&gt;https://code.google.com/p/graphics-go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取方法： go get code.google.com/p/graphics-go/graphics&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它支持的几个效果举例：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图片旋转&lt;/p&gt;&#xA;&#xA;&lt;p&gt;效果:一个旋转前,一个旋转后&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/1.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 350, 400))&#xA;&#xA;    err = graphics.Rotate(dst, src, &amp;amp;graphics.RotateOptions{3.5})&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 123&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;旋转的参数是顺时针旋转的弧度，弧度相关的介绍如下：(&lt;a href=&#34;http://youthpasses.blog.51cto.com/2909834/799353&#34;&gt;http://youthpasses.blog.51cto.com/2909834/799353&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;每个角度对应的弧度可以看下面图。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/2.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码参考：(&lt;a href=&#34;http://stackoverflow.com/questions/12430874/image-manipulation-in-golang&#34;&gt;http://stackoverflow.com/questions/12430874/image-manipulation-in-golang&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图片模糊处理&lt;/p&gt;&#xA;&#xA;&lt;p&gt;效果：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面一个是清晰版本，一个是模糊出来后的版本。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/3.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;仔细对比细节是可以看到模糊效果的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 350, 400))&#xA;&#xA;    err = graphics.Blur(dst, src, &amp;amp;graphics.BlurOptions{StdDev: 1.1})&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 510&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码说明：&#xA;模糊参数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// BlurOptions are the blurring parameters.&#xA;// StdDev is the standard deviation of the normal, higher is blurrier.&#xA;// StdDev 是正常的标准偏差， 值越大越虚化&#xA;// Size is the size of the kernel. If zero, it is set to Ceil(6 * StdDev).&#xA;//&#xA;type BlurOptions struct {&#xA;    StdDev float64&#xA;    Size   int&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;缩略图&#xA;原始图:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/4.jpg&#34; alt=&#34;&#34; width=&#34;200&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;确保数据完整的缩放,效果如下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/5.jpg&#34; alt=&#34;&#34; width=&#34;20&#34; height=&#34;80&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 缩略图的大小&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 20, 80))&#xA;&#xA;    // 产生缩略图,等比例缩放&#xA;    err = graphics.Scale(dst, src)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 734&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;图片数据可以丢弃的缩放效果:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-官方图片库/6.jpg&#34; alt=&#34;&#34; width=&#34;20&#34; height=80&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    src, err := LoadImage(&amp;quot;348.png&amp;quot;)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 缩略图的大小&#xA;    dst := image.NewRGBA(image.Rect(0, 0, 20, 80))&#xA;&#xA;    // 产生缩略图&#xA;    err = graphics.Thumbnail(dst, src)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 670&#xA;    saveImage(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter), dst)&#xA;}&#xA;&#xA;// LoadImage decodes an image from a file.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&#xA;// 保存Png图片&#xA;func saveImage(path string, img image.Image) (err error) {&#xA;    // 需要保存的文件&#xA;    imgfile, err := os.Create(path)&#xA;    defer imgfile.Close()&#xA;&#xA;    // 以PNG格式保存文件&#xA;    err = png.Encode(imgfile, img)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更多相关资料请看下面地址:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/graphics-go/source/browse/graphics/?r=9a6eb915f43de825cd2a26c8b8866422d0a3f2ec&#34;&gt;https://code.google.com/p/graphics-go/source/browse/graphics/?r=9a6eb915f43de825cd2a26c8b8866422d0a3f2ec&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-字体-FreeType-go</title>
      <link>http://www.nljb.net/default/Golang-%E5%AD%97%E4%BD%93-FreeType-go/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;FreeType库（&lt;a href=&#34;http://www.freetype.org/）是一个完全免费(开源)的、高质量的且可移植的字体引擎&#34;&gt;http://www.freetype.org/）是一个完全免费(开源)的、高质量的且可移植的字体引擎&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它提供统一的接口来访问多种字体格式文件，包括TrueType, OpenType, Type1, CID, CFF, Windows FON/FNT, X11 PCF等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;支持单色位图、反走样位图的渲染。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;freetype-go就是用go语言实现了FreeType驱动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它的项目地址： &lt;a href=&#34;https://code.google.com/p/freetype-go&#34;&gt;https://code.google.com/p/freetype-go&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是使用它绘制的一个字体效果图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-字体-FreeType-go/4bed2e738bd4b31cd3dc1d1f85d6277f9f2ff8b6.jpg&#34; alt=&#34;&#34; width=&#34;100&#34; height=&#34;80&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/freetype-go/freetype&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/color&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;    dx       = 100         // 图片的大小 宽度&#xA;    dy       = 40          // 图片的大小 高度&#xA;    fontFile = &amp;quot;RAVIE.TTF&amp;quot; // 需要使用的字体文件&#xA;    fontSize = 20          // 字体尺寸&#xA;    fontDPI  = 72          // 屏幕每英寸的分辨率&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    // 需要保存的文件&#xA;    imgcounter := 123&#xA;    imgfile, _ := os.Create(fmt.Sprintf(&amp;quot;%03d.png&amp;quot;, imgcounter))&#xA;    defer imgfile.Close()&#xA;&#xA;    // 新建一个 指定大小的 RGBA位图&#xA;    img := image.NewNRGBA(image.Rect(0, 0, dx, dy))&#xA;&#xA;    // 画背景&#xA;    for y := 0; y &amp;lt; dy; y++ {&#xA;    for x := 0; x &amp;lt; dx; x++ {&#xA;        // 设置某个点的颜色，依次是 RGBA&#xA;        img.Set(x, y, color.RGBA{uint8(x), uint8(y), 0, 255})&#xA;    }&#xA;    }&#xA;&#xA;    // 读字体数据&#xA;    fontBytes, err := ioutil.ReadFile(fontFile)&#xA;    if err != nil {&#xA;    log.Println(err)&#xA;    return&#xA;    }&#xA;    font, err := freetype.ParseFont(fontBytes)&#xA;    if err != nil {&#xA;    log.Println(err)&#xA;    return&#xA;    }&#xA;&#xA;    c := freetype.NewContext()&#xA;    c.SetDPI(fontDPI)&#xA;    c.SetFont(font)&#xA;    c.SetFontSize(fontSize)&#xA;    c.SetClip(img.Bounds())&#xA;    c.SetDst(img)&#xA;    c.SetSrc(image.White)&#xA;&#xA;    pt := freetype.Pt(10, 10+int(c.PointToFix32(fontSize)&amp;gt;&amp;gt;8)) // 字出现的位置&#xA;&#xA;    _, err = c.DrawString(&amp;quot;ABCDE&amp;quot;, pt)&#xA;    if err != nil {&#xA;    log.Println(err)&#xA;    return&#xA;    }&#xA;&#xA;     // 以PNG格式保存文件&#xA;     err = png.Encode(imgfile, img)&#xA;     if err != nil {&#xA;     log.Fatal(err)&#xA;     }&#xA;&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Raster-字体颜色</title>
      <link>http://www.nljb.net/default/Golang-Raster-%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;import &amp;quot;code.google.com/p/freetype-go/freetype/raster&amp;quot; &#xA;&#xA;type RGBAPainter&#xA;func NewRGBAPainter(m *image.RGBA) *RGBAPainter&#xA;func (r *RGBAPainter) Paint(ss []Span, done bool)&#xA;func (r *RGBAPainter) SetColor(c color.Color)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The raster package provides an anti-aliasing 2-D rasterizer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is part of the larger Freetype-Go suite of font-related packages&#xA;but the raster package is not specific to font rasterization&#xA;and can be used standalone without any other Freetype-Go package.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Rasterization is done by the same area/coverage accumulation algorithm as the Freetype &amp;ldquo;smooth&amp;rdquo; module&#xA;and the Anti-Grain Geometry library.&#xA;A description of the area/coverage algorithm is at &lt;a href=&#34;http://projects.tuxee.net/cl-vectors/section-the-cl-aa-algorithm&#34;&gt;http://projects.tuxee.net/cl-vectors/section-the-cl-aa-algorithm&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Error-in-service-module</title>
      <link>http://www.nljb.net/default/Error-in-service-module/</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;linux-hiuk:~ # cat  /etc/pam.d/login&#xA;#%PAM-1.0&#xA;auth     requisite      pam_nologin.so&#xA;auth     [user_unknown=ignore success=ok ignore=ignore auth_err=die default=bad]pam_securetty.so&#xA;auth     include        common-auth&#xA;account  include        common-account&#xA;password include        common-password&#xA;session  required       pam_loginuid.so&#xA;session  include        common-session&#xA;#session  required      pam_lastlog.so  nowtmp showfailed&#xA;session  optional       pam_mail.so standard&#xA;session  optional       pam_ck_connector.so&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Systemd-FAQ-简体中文</title>
      <link>http://www.nljb.net/default/Systemd-FAQ-%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87/</link>
      <pubDate>2014-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Systemd FAQ (简体中文)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd_FAQ_(简体中文&#34;&gt;https://wiki.archlinux.org/index.php/Systemd_FAQ_(简体中文&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd_FAQ_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&#34;&gt;https://wiki.archlinux.org/index.php/Systemd_FAQ_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://blip.tv/linuxconfau/beyond-init-systemd-4715015&#34;&gt;http://blip.tv/linuxconfau/beyond-init-systemd-4715015&lt;/a&gt;   (Beyond init: systemd)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Contents&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1 常见问题&#xA;1.1 Q: 为什么控制台上会显示日志信息？&#xA;1.2 Q: 如何修改启用的可登陆的 tty 控制台（getty）数量？&#xA;1.3 Q: 怎样输出更详细的开机信息？&#xA;1.4 Q: 开机后控制台信息会被清空，如何避免？&#xA;1.5 Q: 我不用官方内核，内核版本和编译参数有什么要注意的吗？&#xA;1.6 Q: 怎样知道一个目标需要哪些进程服务？&#xA;1.7 Q: 电脑关闭了但电源没有断。&#xA;1.8 Q: 切换到 systemd 后，为什么 fakeRAID 没有挂载?&#xA;1.9 Q: 如何在启动的时候，运行自定义的一个脚本？&#xA;1.10 Q: .service 状态显示绿色的 &amp;quot;active (exited)&amp;quot; (例如 iptables)&#xA;1.11 Q: Failed to issue method call: File exists 错误&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;常见问题&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Q: 为什么控制台上会显示日志信息？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:请自行设置内核日志等级（loglevel）&#xA;以前，/etc/rc.sysinit 帮我们把 dmesg 的日志等级设置为 3，是比较合适的。&#xA;内核参数中加入 loglevel=3 或 quiet 即可。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 如何修改启用的可登陆的 tty 控制台（getty）数量？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:添加新的 getty：&#xA;在 /etc/systemd/system/getty.target.wants/ 添加新的软链接即可：&#xA;# ln -sf /usr/lib/systemd/system/getty@.service /etc/systemd/system/getty.target.wants/getty@tty9.service&#xA;# systemctl start getty@tty9.service&#xA;移除 getty：&#xA;从 /etc/systemd/system/getty.target.wants/ 删除对应的软链接即可：&#xA;# rm /etc/systemd/system/getty.target.wants/getty@tty5.service /etc/systemd/system/getty.target.wants/getty@tty6.service&#xA;# systemctl stop getty@tty5.service getty@tty6.service&#xA;用户也可以通过编辑/etc/systemd/logind.conf，将NAutoVTs修改为需要的 TTY 个数&#xA;用这种方式，按需启动将会保持，而之前的方式将会在启动时就启动 TTY.&#xA;systemd 不使用 /etc/inittab 文件。&#xA;注意: 自 systemd 版本 30，系统默认只开启一个 getty&#xA;只有切换到别的 tty 时，才会开启新的 getty（socket 激活式）&#xA;但仍可使用上述方法强制添加新的 getty。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 怎样输出更详细的开机信息？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:如果内核信息输出后就什么信息都不输出了，很可能是因为你在内核参数中添加了 quiet&#xA;删除即可，然后你就可以看到一列列绿色的 [ OK ] 和红色的 [ FAILED ]了&#xA;所有信息都记录在系统日志，可以通过 $ systemctl 查看系统状态，通过 journalctl 查看日志。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 开机后控制台信息会被清空，如何避免？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:自己写一个 getty@tty1.service 文件 &#xA;把/usr/lib/systemd/system/getty@.service复制到/etc/systemd/system/getty@tty1.service&#xA;修改 TTYVTDisallocate 为 no.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 电脑关闭了但电源没有断。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:使用 $ systemctl poweroff&#xA;而不是 systemctl halt.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 切换到 systemd 后，为什么 fakeRAID 没有挂载?&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:请确保使用了&#xA;# systemctl enable dmraid.service&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: 如何在启动的时候，运行自定义的一个脚本？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:在/etc/systemd/system中新建一个文件(名称可以为 myscript.service) &#xA;然后在其中写入如下内容：&#xA;&#xA;[Unit]&#xA;Description=My script&#xA;&#xA;[Service]&#xA;ExecStart=/usr/bin/my-script&#xA;&#xA;[Install]&#xA;WantedBy=multi-user.target &#xA;然后开启该守护进程&#xA;# systemctl enable myscript.service&#xA;本例是说当目标multi-usr载入的时候，会启动你这个自定义脚本。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: .service 状态显示绿色的 &amp;ldquo;active (exited)&amp;rdquo; (例如 iptables)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:这很正常，本例中的 iptables 并不是守护进程，而是由内核控制，所以装载完规则后自动退出了。&#xA;通过下面命令检查规则是否正确加载 # iptables --list&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q: Failed to issue method call: File exists 错误&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;A:此错误一般发生在systemctl enable创建系统连接到/etc/systemd/system/的时候&#xA;一般是在切换显示管理器(例如从 GDM 到 KDM)时出现，这时/etc/systemd/system/display-manager.service 已经存在&#xA;要解决此问题，使用 systemctl -f enable 覆盖原有链接。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;在之前是直接将 /etc/inittab 文件中id:5:initdefault 数字修改为  id:3:initdefault 就可以了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在再进入这个文件提示不再使用了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要修改 /etc/systemd/system/default.target 这个软连接文件.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个软连接默认指向第5运行等级(GUI):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/systemd/system/default.target -&amp;gt; /lib/systemd/system/runlevel5.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在只要将这个软连接指向需要的运行等级就行了. 比如命令行界面多用户模式:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /etc/systemd/system&#xA;mv default.target runlevel5.target&#xA;ln -s /lib/systemd/system/runlevel3.target default.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样使默认启动等级的target指向等级为3(CLI)的运行等级target.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/systemd/system/default.target -&amp;gt; /lib/systemd/system/runlevel3.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后重启系统就默认进入命令行多用户模式了,不会再启动GDM了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果想从GUI模式快速重新启动到命令行模式,可以直接使用命令 init 3&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下次如果想要改回去,只要把default.target改下名称,把runlevel5.target再改回default.target就行啦.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mv default.target runlevel3.target&#xA;mv runlevel5.target default.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>通过代码了解-Golang-interface</title>
      <link>http://www.nljb.net/default/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BA%86%E8%A7%A3-Golang-interface/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;func main() {&#xA;    var s []interface{} = []string{&amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;}&#xA;    for _, x := range s.([]string) {&#xA;    println(x)&#xA;    }   &#xA;}&#xA;&#xA;运行会报错：&#xA;cannot use []string literal (type []string) as type []interface {} in assignment&#xA;invalid type assertion: s.([]string) (non-interface type []interface {} on left)&#xA;&#xA;package main&#xA;&#xA;func main() {&#xA;    var s interface{} = []string{&amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;}&#xA;    for _, x := range s.([]string) {&#xA;    println(x)&#xA;    }&#xA;}&#xA;ok&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&amp;quot;fmt&amp;quot;)&#xA;&#xA;type Animal interface {&#xA;    Run()&#xA;}&#xA;&#xA;type Cat struct {&#xA;}&#xA;&#xA;func (cat *Cat) Run() {&#xA;    fmt.Println(&amp;quot;Cat Run&amp;quot;)&#xA;}&#xA;&#xA;type Dog struct {&#xA;}&#xA;&#xA;func (dog *Dog) Run() {&#xA;    fmt.Println(&amp;quot;Dog Run&amp;quot;)&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    var animal Animal&#xA;&#xA;    animal = &amp;amp;Cat{}&#xA;&#xA;    animal.Run()&#xA;&#xA;    animal = &amp;amp;Dog{}&#xA;&#xA;    animal.Run()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>网线八根线的作用</title>
      <link>http://www.nljb.net/default/%E7%BD%91%E7%BA%BF%E5%85%AB%E6%A0%B9%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;网线八根线的作用&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1,2,3,6为有效线，他是负责传输和接受数据的~ ,其他的用于电话~ &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果你拿着RJ-45连接头对着自己，锁扣朝上，那么从左到右各插脚的编号依次是1到8。根据TIA/EIA568规范各插脚的用途如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;插脚编号 作用 &#xA;1 输出数据 (+) &#xA;2 输出数据 (-) &#xA;3 输入数据 (+) &#xA;4 保留为电话使用 &#xA;5 保留为电话使用 &#xA;6 输入数据 (-) &#xA;7 保留为电话使用 &#xA;8 保留为电话使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;网线的接法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;一、PC连HUB （电脑连接上网设备）&#xA;A端：（标准568B）：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;B端：（标准568B）：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;&#xA;二、PC连PC （电脑连接电脑）&#xA;A端：(568A)： 白绿，绿，白橙，蓝，白蓝，橙，白棕，棕；&#xA;B端：（标准568B）：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;&#xA;三、HUB连HUB （上网设备连接上网设备）&#xA;A端：(568A)： 白绿，绿，白橙，蓝，白蓝，橙，白棕，棕；&#xA;B端：（568B）： 白橙，橙，白绿，蓝，白蓝，绿，白棕，棕。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>系统分隔符-Windows-and-Linux</title>
      <link>http://www.nljb.net/default/%E7%B3%BB%E7%BB%9F%E5%88%86%E9%9A%94%E7%AC%A6-Windows-and-Linux/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;const (&#xA;    PathSeparator     = &#39;/&#39; // OS-specific path separator&#xA;    PathListSeparator = &#39;:&#39; // OS-specific path list separator&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>用sshpass实现ssh的自动登陆</title>
      <link>http://www.nljb.net/default/%E7%94%A8sshpass%E5%AE%9E%E7%8E%B0ssh%E7%9A%84%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;用sshpass实现ssh的自动登陆&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要实现ssh自动登录，网上搜了一下，主要有两种方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1、生成公钥。&#xA;2、编写expect脚本。这两种方法，用起来都有点复杂。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在新立得上安装ssh的时候，偶然发现一个sshpass，百度谷歌之，英文资料甚多，而中文资料寥寥。其实sshpass的用法很简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    sshpass 参数 SSH命令(ssh，sftp，scp等)。&#xA;    参数:&#xA;    -p password    //将参数password作为密码。&#xA;    -f passwordfile //提取文件passwordfile的第一行作为密码。&#xA;    -e        //将环境变量SSHPASS作为密码。&#xA;&#xA;    比如说：&#xA;    scp abc@192.168.0.5:/home/xxx/test /root   这个命令的作用是将服务器端文件test传到本地文件夹/root下。&#xA;    利用sshpass，假设密码为efghi，则可写作：&#xA;    ssh -p efghi scp abc@192.168.0.5:/home/xxx/test /root&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;另外，对于ssh的第一次登陆，会提示：“Are you sure you want to continue connecting (yes/no)”，这时用sshpass会不好使&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;可以在ssh命令后面加上 -o StrictHostKeyChecking=no来解决。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;比如说上面的命令，就可以写作ssh -p efghi scp abc@192.168.0.5:/home/xxx/test /root -o StrictHostKeyChecking=no。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>对于WIFI密码中带有英文字符或特殊字符</title>
      <link>http://www.nljb.net/default/%E5%AF%B9%E4%BA%8EWIFI%E5%AF%86%E7%A0%81%E4%B8%AD%E5%B8%A6%E6%9C%89%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E6%88%96%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;对于WIFI密码中带有英文字符或特殊字符需要使用S:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1:iwlist eth1 scanning 查看无线路由 &#xA;2:iwconfig eth1 essid &amp;quot;无线路由的名称&amp;quot; &#xA;3: ifconfig eth1 IP &#xA;4: route add default gw 网关 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于带密码的路由器,设置如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1:iwconfig eth1 key s:密码 &#xA;2:iwconfig eth1 key open &#xA;3:ifconfig eth1 essid &amp;quot;名称&amp;quot; &#xA;4:ifconfig eth1 IP5:route add default gw 网关&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在Golang中获取系统的磁盘内存占用</title>
      <link>http://www.nljb.net/default/%E5%9C%A8Golang%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A3%81%E7%9B%98%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;获取磁盘占用情况(Linux/Mac下有效)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wendal.net/2012/1224.html&#34;&gt;http://wendal.net/2012/1224.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取磁盘占用情况(Linux/Mac下有效)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取内存占用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;很明显,Windows下的支持是最弱的, 当然,还能通过调用win32 API的方式获取缺失的信息&#xA;Golang的API并非完全跨平台, 正如上述的syscall.Statfs_t结构体,在Windows下是没有的&#xA;2013年4月6号更新,windows下获取磁盘空间的方法&#xA;通过调用win32 api&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//读取内存状态信息&#xA;func(ev*Ev)GetMemo()(int,int,int){&#xA;    //内存状态文件路径&#xA;    varmeminfostring=&amp;quot;/proc/meminfo&amp;quot;&#xA;    //存储各状态信息&#xA;    vartotalint&#xA;    varfreeint&#xA;    varusedint&#xA;    //读取文件&#xA;    evolver.FileRF(meminfo,func(f*os.File){&#xA;    //建立文件流&#xA;    rd:=bufio.NewReader(f)&#xA;    for{&#xA;        //按行读取&#xA;        data,err:=rd.ReadString(&#39;\n&#39;)&#xA;        iferr==io.EOF{&#xA;        break&#xA;        }&#xA;        iferr!=nil{&#xA;        break&#xA;        }&#xA;        //判断是否为需要的信息&#xA;        ifstrings.HasPrefix(data,&amp;quot;MemTotal&amp;quot;){&#xA;        totalValue:=strings.Split(evolver.Trim(strings.Split(data,&amp;quot;:&amp;quot;)[1]),&amp;quot;&amp;quot;)[0]&#xA;        total=evolver.ToInt(totalValue,0)&#xA;        }elseifstrings.HasPrefix(data,&amp;quot;MemFree&amp;quot;){&#xA;        freeValue:=strings.Split(evolver.Trim(strings.Split(data,&amp;quot;:&amp;quot;)[1]),&amp;quot;&amp;quot;)[0]&#xA;        free=evolver.ToInt(freeValue,0)&#xA;        }&#xA;        //计算以用空间&#xA;        used=total-free&#xA;    }&#xA;    })&#xA;    //返回结果&#xA;    returnfree,used,total&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>命名规范-Java</title>
      <link>http://www.nljb.net/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Java/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一、(Package)包的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Java包的名字都是由小写单词组成。但是由于Java面向对象编程的特性，每一名Java程序员都可以编写属于自己的Java包，为了保障每个 Java包命名的唯一性，在最新的Java编程规范中，要求程序员在自己定义的包的名称之前加上唯一的前缀。由于互联网上的域名称是不会重复的，所以程序员一般采用自己在互联网上的域名称作为自己程序包的唯一前缀。&#xA;&#xA;例如：    net.frontfree.javagroup&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;二、(Class)类的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;类的名字必须由大写字母开头而单词中的其他字母均为小写；如果类名称由多个单词组成，则每个单词的首字母均应为大写例如TestPage；如果类名称中包含单词缩写，则这个所写词的每个字母均应大写，如：XMLExample,还有一点命名技巧就是由于类是设计用来代表对象的，所以在命名类时应尽量选择名词。&#xA;&#xA;例如：    Circle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;三、方法的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头。&#xA;&#xA;例如：    sendMessge&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;四、参数的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;参数的命名规范和方法的命名规范相同，而且为了避免阅读程序时造成迷惑，请在尽量保证参数名称为一个单词的情况下使参数的命名尽可能明确。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;五、Javadoc注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Java除了可以采用我们常见的注释方式之外，Java语言规范还定义了一种特殊的注释，也就是我们所说的Javadoc注释，它是用来记录我们代码中的API的。Javadoc注释是一种多行注释，以/**开头，而以*/结束，注释可以包含一些HTML标记符和专门的关键词。使用Javadoc 注释的好处是编写的注释可以被自动转为在线文档，省去了单独编写程序文档的麻烦。&#xA;&#xA;　　例如：&#xA;　　/**&#xA;　　*    This    is    an    example    of&#xA;　　*    Javadoc&#xA;　　*&#xA;　　*    @author    darchon&#xA;　　*    @version    0.1,    10/11/2002&#xA;　　*/&#xA;&#xA;在每个程序的最开始部分，一般都用Javadoc注释对程序的总体描述以及版权信息，之后在主程序中可以为每个类、接口、方法、字段添加 Javadoc注释，每个注释的开头部分先用一句话概括该类、接口、方法、字段所完成的功能，这句话应单独占据一行以突出其概括作用，在这句话后面可以跟随更加详细的描述段落。在描述性段落之后还可以跟随一些以Javadoc注释标签开头的特殊段落，例如上面例子中的@auther和@version，这些段落将在生成文档中以特定方式显示。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;六、变量命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;变量命名应该采用首字母小写，其他字母首字母大写的方式。&#xA;&#xA;　　· Static    Final    变量的名字应该都大写，并且指出完整含义。&#xA;　　· 如果需要对变量名进行缩写时，一定要注意整个代码中缩写规则的一致性。例如，如果在代码的某些区域中使用intCnt，而在另一些区域中又使用intCount，就会给代码增加不必要的复杂性。建议变量名中尽量不要出现缩写。&#xA;　　· 通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。例如，请使用 strCustomerFirst和strCustomerLast，而不要使用strFirstCustomer和strLastCustomer。常用的量词后缀有：First（一组变量中的第一个）、Last（一组变量中的最后一个）、Next（一组变量中的下一个变量）、Prev（一组变量中的上一个）、Cur（一组变量中的当前变量）。&#xA;　　· 为每个变量选择最佳的数据类型，这样即能减少对内存的需求量，加快代码的执行速度，又会降低出错的可能性。用于变量的数据类型可能会影响该变量进行计算所产生的结果。在这种情况下，编译器不会产生运行期错误，它只是迫使该值符合数据类型的要求。这类问题极难查找。&#xA;　　· 尽量缩小变量的作用域。如果变量的作用域大于它应有的范围，变量可继续存在，并且在不再需要该变量后的很长时间内仍然占用资源。它们的主要问题是，任何类中的任何方法都能对它们进行修改，并且很难跟踪究竟是何处进行修改的。占用资源是作用域涉及的一个重要问题。对变量来说，尽量缩小作用域将会对应用程序的可靠性产生巨大的影响。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;七、关于常量的命名方法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在JAVA代码中，无论什么时候，均提倡应用常量取代数字、固定字符串。也就是说，程序中除0，1以外，尽量不应该出现其他数字。常量可以集中在程序开始部分定义或者更宽的作用域内，名字应该都使用大写字母，并且指出该常量完整含义。如果一个常量名称由多个单词组成，则应该用下划线“_”来分割这些单词如：NUM_DAYS_IN_WEEK、MAX_VALUE。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;八、推荐的命名&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1、类名推荐&#xA;&#xA;当要区别接口和实现类的时候，可以在类的后面加上“Impl”。例如： interface Container ,class ContainerImpl&#xA;class Container3PImpl&#xA;class ContainerYICTImpl&#xA;&#xA;2、Exception类名推荐&#xA;&#xA;Exception类最好能用“Exception”做为类命名的结尾。例如：&#xA;DataNotFoundException&#xA;InvalidArgumentException&#xA;&#xA;3、抽象类名推荐&#xA;&#xA;抽象类最好能用“Abstract”做为类命名的开头。例如：&#xA;AbstractBeanDefinition&#xA;AbstractBeanFactory&#xA;&#xA;4、Test类名推荐&#xA;&#xA;Test类最好能用“Test”做为类命名的结尾。例如：&#xA;ContainerTest&#xA;&#xA;5、工厂类方法推荐&#xA;&#xA;工厂方法最好能把该方法做要创建的对象类型描述出来。例如：&#xA;public Container createContainer();&#xA;public Location newLocation();&#xA;&#xA;· 虽然为一个设计低劣的程序添加注释不会使其变成好的程序，但是如果按照编程规范编写程序并且为程序添加良好的注释却可以帮助你编写出设计完美，运行效率高且易于理解的程序，尤其是在多人合作完成同一项目时编程规范就变得更加重要。俗话说“磨刀不误砍柴工”，花费一点时间去适应一下Java编程规范是有好处的。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>命名规范-Golang</title>
      <link>http://www.nljb.net/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Golang/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Go中名称不但具有表达含义的功能，同时也具有约束使用的特点。如果一个函数的名称是小写的则表示该函数不能在其他包中使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;命名必须使用骆驼命名法，而不能使用下划线法。&#xA;任何需要对外暴露的名字必须大写字母开头，不需要暴露在包外的名字必须以小写字母开头。&#xA;接口的命令，按照惯例，如果接口只有一个方法，则该接口命名为方法名成加上”ER“后缀。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>命名规范-Bash</title>
      <link>http://www.nljb.net/default/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-Bash/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1 概述&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.1 目的&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;定义Shell脚本命名和编码规范，作为OS裁剪设计、开发以及维护人员的技术参考资料。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1.2 概述&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;本文主要根据Fedora Core 4.0的特点，描述安装脚本、OS初始脚本、补丁制作等方面的代码编写规范。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1.3 开发工具&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;shell脚本是个文件，没有开发环境，FC4图形环境下，可用gedit、vi、vim、joe等，推荐使用gedit，并将环境设置为sh高亮显示；字符界面下，可用vi、joe、vim；Windows下，可用ultraedit。文件保存时，有汉字提示的Shell脚本文件，文件保存时，字符编码必须为GB18030/GBK/GB2132三种格式之一。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2 对象命名规范&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.1 命名约定&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.本文档的命名约定是系统配置文件、脚本文件；&#xA;&#xA;2.文件名、变量名、函数名不超过20个字符； &#xA;&#xA;3.命名只能使用英文字母，数字和下划线，只有一个英文单词时使用全拼，有多个单词时，用下划线连接，长度较长时，可以取单词前3～4个字母。遇到复杂情况大家一起讨论决定； &#xA;&#xA;4.文件名全部以小写命名，不能大小写混用（通过U盘交换文件时，大小写可能会丢失，即：大写文件名可能会全部变成小写文件名）；&#xA;&#xA;5.避免使用Linux的保留字如true、关键字如PWD等（见附表）； &#xA;&#xA;6.从配置文件导出配置时，要注意过滤空行和注释&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.2 Shell脚本命名及规范&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Shell脚本文件包括如下文件：&#xA;&#xA;1、Linux启动初始化文件，如/etc/rc.d/rc.sysinit等&#xA;&#xA;2、隐藏初始化文件，如~/.bash_profile、~/.xinitrc等&#xA;&#xA;3、用户自定义Shell文件，如/root/install/scripts/findtermtype。sh&#xA;&#xA;这些文件的命名长度都不能超过20个字符。脚本命令过长时，以“_”相隔，如rdc09_tianjin.sh、inst_cp86.sh等。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.3 缩进&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;由于Shell没有很好的编辑环境，所以，缩进应该是每行1个TAB，不建议用空格缩进。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.4 页宽&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;每行不要超过80行，如果超出，建议用“\”折行，有管道的命令行除外。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.5 环境变量&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;变量：全部是大写字母&#xA;&#xA;变量引用：全部以变量名加双引号引用，如”$TERMTYPE”，或“${TERMTYPE}”，如果变量类型是数值型不引用，如:&#xA;&#xA;如果需要从配置文件导出变量，则在变量前加一大写字母，以识别导出变量与自定义环境变量的区别，如：&#xA;&#xA;变量值的引用尽量以$开头，如$(ls inst_*.sh)，避免使用`ls inst_*。sh`&#xA;&#xA;循环控制变量可以命名为单个字母， 比如 i、j等。 也可以是更有意义的名称， 比如 UserIndex。&#xA;&#xA;环境变量在脚本开头定义。&#xA;&#xA;函数中使用较多的文件，以环境变量的形式在文件开头定义&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.6 函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;函数以动名词形式存储，且第二个单词首字母要大写，如updateConfig()&#xA;&#xA;每个函数控制在50－100行，超出行数建议分成两个函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.7 语句&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if 语句 &#xA;&#xA;if/then/else 语句中最可能被执行的部分应该放在 then 子句中， 不太可能被执行的部分应该放在 else 子句中。 &#xA;&#xA;如果可能， 尽量不要使用一连串的 if 语句， 而应该以 case 语句替代。 &#xA;&#xA;不要使 if 语句嵌套超过5层以上， 尽量以更清楚的代码替代。 &#xA;&#xA;case 语句 &#xA;&#xA;概要 &#xA;&#xA;case 语句中的单个子句应该以 case 常数的数字顺序或字母顺序排列。 子句中的执行语句应该尽量保持简单， 一般不要超过4到5行代码。 如果执行语句过于复杂， 应该将它放置在独立的函数中。 &#xA;&#xA;case 语句的 *) 子句应该只在正常的默认情况或检测到错误的情况下使用。 &#xA;&#xA;格式 &#xA;&#xA;case 语句遵循同样的缩进和命名约定。 &#xA;&#xA;while 语句 &#xA;&#xA;使用 Exit 过程退出 while 循环是不好的; 如果可能， 应该只使用循环条件来结束循环。 &#xA;&#xA;while 循环的所有初始化代码应该紧贴在进入 while 循环之前， 不要被其他无关语句分隔开。 &#xA;&#xA;循环结束后的处理应该紧跟在循环之后。 &#xA;&#xA;for 语句 &#xA;&#xA;如果需要执行确定次数的增量循环， 应该用 for 语句替代 while 语句。 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.8 信号捕捉&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如果在进行重要配置修改时，应捕捉用户按键，如果用户按下Ctrl+C等重要操作终止程序，则调用回退程序，如：&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.9 关于注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;程序头应加注版本与功能说明的注释。但程序第一行不能汉字。&#xA;&#xA;程序体中应包含必要的注释，注释说明如下：&#xA;&#xA;单行注释，可以放在代码行的尾部或代码行的上部；&#xA;&#xA;多行注释，用于注解复杂的功能说明，可以放在程序体中，也可以放在代码块的开始部分&#xA;&#xA;代码修改时，对修改的内容要加必要版本注释及功能说明，格式参考如下：&#xA;&#xA;不再有用的注释要删除。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>ulimit</title>
      <link>http://www.nljb.net/default/ulimit/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;ulimint -a 用来显示当前的各种用户进程限制&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Linux对于每个用户，系统限制其最大进程数，为提高性能，可以根据设备资源情况&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设置个Linux用户的最大进程数，一些需要设置为无限制：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;数据段长度：ulimit -d unlimited&#xA;最大内存大小：ulimit -m unlimited&#xA;堆栈大小：ulimit -s unlimited&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们在用这个命令的时候主要是为了产生core文件，就是程序运行发行段错误时的文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit -c unlimited   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成core文件&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;查看限制情况 ulimit -a&#xA;可以看到如下信息&#xA;core file size          (blocks, -c) 0&#xA;data seg size           (kbytes, -d) unlimited&#xA;file size               (blocks, -f) unlimited&#xA;pending signals                 (-i) 1024&#xA;max locked memory       (kbytes, -l) 32&#xA;max memory size         (kbytes, -m) unlimited&#xA;open files                      (-n) 1024&#xA;pipe size            (512 bytes, -p) 8&#xA;POSIX message queues     (bytes, -q) 819200&#xA;stack size              (kbytes, -s) 10240&#xA;cpu time               (seconds, -t) unlimited&#xA;max user processes              (-u) 4096&#xA;virtual memory          (kbytes, -v) unlimited&#xA;file locks                      (-x) unlimited&#xA;而我们需要修改的是open files (-n) 1024的值&#xA;于是命令就是limit -n 2048(随各自需要设置)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;功能说明：控制shell程序的资源。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;语　　法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [-aHS][-c &amp;lt;core文件上限&amp;gt;][-d &amp;lt;数据节区大小&amp;gt;][-f &amp;lt;文件大小&amp;gt;][-m &amp;lt;内存大小&amp;gt;][-n &amp;lt;文件数目&amp;gt;][-p &amp;lt;缓冲区大小&amp;gt;][-s &amp;lt;堆叠大小&amp;gt;][-t &amp;lt;CPU时间&amp;gt;][-u &amp;lt;程序数目&amp;gt;][-v &amp;lt;虚拟内存大小&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;补充说明：ulimit为shell内建指令，可用来控制shell执行程序的资源。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参　　数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   -a 　显示目前资源限制的设定。 &#xA;   -c &amp;lt;core文件上限&amp;gt; 　设定core文件的最大值，单位为区块。 &#xA;   -d &amp;lt;数据节区大小&amp;gt; 　程序数据节区的最大值，单位为KB。 &#xA;   -f &amp;lt;文件大小&amp;gt; 　shell所能建立的最大文件，单位为区块。 &#xA;   -H 　设定资源的硬性限制，也就是管理员所设下的限制。 &#xA;   -m &amp;lt;内存大小&amp;gt; 　指定可使用内存的上限，单位为KB。 &#xA;   -n &amp;lt;文件数目&amp;gt; 　指定同一时间最多可开启的文件数。 &#xA;   -p &amp;lt;缓冲区大小&amp;gt; 　指定管道缓冲区的大小，单位512字节。 &#xA;   -s &amp;lt;堆叠大小&amp;gt; 　指定堆叠的上限，单位为KB。 &#xA;   -S 　设定资源的弹性限制。 &#xA;   -t &amp;lt;CPU时间&amp;gt; 　指定CPU使用时间的上限，单位为秒。 &#xA;   -u &amp;lt;程序数目&amp;gt; 　用户最多可开启的程序数目。 &#xA;   -v &amp;lt;虚拟内存大小&amp;gt; 　指定可使用的虚拟内存上限，单位为KB。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1,说明:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit用于shell启动进程所占用的资源.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,类别:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;shell内建命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3,语法格式:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [-acdfHlmnpsStvw] [size]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4,参数介绍:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-H 设置硬件资源限制.&#xA;-S 设置软件资源限制.&#xA;-a 显示当前所有的资源限制.&#xA;-c size:设置core文件的最大值.单位:blocks&#xA;-d size:设置数据段的最大值.单位:kbytes&#xA;-f size:设置创建文件的最大值.单位:blocks&#xA;-l size:设置在内存中锁定进程的最大值.单位:kbytes&#xA;-m size:设置可以使用的常驻内存的最大值.单位:kbytes&#xA;-n size:设置内核可以同时打开的文件描述符的最大值.单位:n&#xA;-p size:设置管道缓冲区的最大值.单位:kbytes&#xA;-s size:设置堆栈的最大值.单位:kbytes&#xA;-t size:设置CPU使用时间的最大上限.单位:seconds&#xA;-v size:设置虚拟内存的最大值.单位:kbytes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5,简单实例:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1]在RH8的环境文件/etc/profile中,我们可以看到系统是如何配置ulimit的:&#xA;&#xA;CODE:&#xA;#grep ulimit /etc/profile&#xA;ulimit -S -c 0 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&#xA;&#xA;这条语句设置了对软件资源和对core文件大小的设置&#xA;&#xA;2]如果我们想要对由shell创建的文件大小作些限制,如:&#xA;&#xA;CODE:&#xA;#ll h&#xA;-rw-r--r-- 1 lee lee 150062 7月 22 02:39 h&#xA;#ulimit -f 100 #设置创建文件的最大块(一块=512字节)&#xA;#cat h&amp;gt;newh&#xA;File size limit exceeded&#xA;#ll newh&#xA;-rw-r--r-- 1 lee lee 51200 11月 8 11:47 newh&#xA;&#xA;文件h的大小是150062字节,而我们设定的创建文件的大小是512字节x100块=51200字节&#xA;当然系统就会根据你的设置生成了51200字节的newh文件.&#xA;&#xA;3]可以像实例1]一样,把你要设置的ulimit放在/etc/profile这个环境文件中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1,可以用ulimit -a查看一下栈的大小:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在内核2.6.20下， stack size 为8192 kbytes&#xA;如果这里没有限制，就栈的大小就只受内存的限制。2G是上限。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,文件 CORE&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;开启或关闭core文件的生成&#xA;ulimit -c 可以查看是否打开此选项，若为0则为关闭；&#xA;ulimit -c 0可手动关闭&#xA;ulimit -c 1000 为设置core文件大小最大为1000k&#xA;ulimit -c unlimited 设置core文件大小为不限制大小&#xA;&#xA;很多系统在默认的情况下是关闭生成core文件的，这个命令可以加到你的profile中去&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;1,说明:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit用于shell启动进程所占用的资源.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,类别:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;shell内建命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3,语法格式:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [-acdfHlmnpsStvw] [size]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4,参数介绍:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-H 设置硬件资源限制.&#xA;-S 设置软件资源限制.&#xA;-a 显示当前所有的资源限制.&#xA;-c size:设置core文件的最大值.单位:blocks&#xA;-d size:设置数据段的最大值.单位:kbytes&#xA;-f size:设置创建文件的最大值.单位:blocks&#xA;-l size:设置在内存中锁定进程的最大值.单位:kbytes&#xA;-m size:设置可以使用的常驻内存的最大值.单位:kbytes&#xA;-n size:设置内核可以同时打开的文件描述符的最大值.单位:n&#xA;-p size:设置管道缓冲区的最大值.单位:kbytes&#xA;-s size:设置堆栈的最大值.单位:kbytes&#xA;-t size:设置CPU使用时间的最大上限.单位:seconds&#xA;-v size:设置虚拟内存的最大值.单位:kbytes 5,简单实例: &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5.举例&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在Linux下写程序的时候，如果程序比较大，经常会遇到“段错误”（segmentation fault）这样的问题，这主要就是由于Linux系统初始的堆栈大小（stack size）太小的缘故，一般为10M。我一般把stack size设置成256M，这样就没有段错误了！&#xA;&#xA;命令为：&#xA;ulimit   -s 262140 &#xA;&#xA;如果要系统自动记住这个配置，就编辑/etc/profile文件，在 “ulimit -S -c 0 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1”行下，添加“ulimit   -s 262140”，保存重启系统就可以了！ &#xA;1]在RH8的环境文件/etc/profile中,我们可以看到系统是如何配置ulimit的:&#xA;&#xA;#grep ulimit /etc/profile&#xA;ulimit -S -c 0 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&#xA;&#xA;这条语句设置了对软件资源和对core文件大小的设置&#xA;&#xA;2]如果我们想要对由shell创建的文件大小作些限制,如:&#xA;&#xA;#ll h&#xA;-rw-r--r-- 1 lee lee 150062 7月 22 02:39 h&#xA;#ulimit -f 100 #设置创建文件的最大块(一块=512字节)&#xA;#cat h&amp;gt;newh&#xA;File size limit exceeded&#xA;#ll newh&#xA;-rw-r--r-- 1 lee lee 51200 11月 8 11:47 newh&#xA;&#xA;文件h的大小是150062字节,而我们设定的创建文件的大小是512字节x100块=51200字节&#xA;&#xA;当然系统就会根据你的设置生成了51200字节的newh文件.&#xA;&#xA;3]可以像实例1]一样,把你要设置的ulimit放在/etc/profile这个环境文件中.&#xA;&#xA;用途,设置或报告用户资源极限。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;语法&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit [ -H ] [ -S ] [ -a ] [ -c ] [ -d ] [ -f ] [ -m ] [ -n ] [ -s ] [ -t ] [ Limit ]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;标志&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-a     列出所有当前资源极限。&#xA;-c     以 512 字节块为单位，指定核心转储的大小。&#xA;-d     以 K 字节为单位指定数据区域的大小。&#xA;-f     使用 Limit 参数时设定文件大小极限（以块计），或者在未指定参数时报告文件大小极限。缺省值为 -f 标志。&#xA;-H     指定设置某个给定资源的硬极限。如果用户拥有 root 用户权限，可以增大硬极限。任何用户均可减少硬极限。&#xA;-m     以 K 字节为单位指定物理存储器的大小。&#xA;-n     指定一个进程可以拥有的文件描述符的数量的极限。&#xA;-s     以 K 字节为单位指定堆栈的大小。&#xA;-S     指定为给定的资源设置软极限。软极限可增大到硬极限的值。如果 -H 和 -S 标志均未指定，极限适用于以上二者。&#xA;-t     指定每个进程所使用的秒数。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;退出状态&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;返回以下退出值：&#xA;0     成功完成。&#xA;&amp;gt;0     拒绝对更高的极限的请求，或发生错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;示例,要将文件大小极限设置为 51,200 字节，输入：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ulimit -f 100&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>exec.Command-status.ExitStatus</title>
      <link>http://www.nljb.net/default/exec.Command-status.ExitStatus/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 可用串口&#xA;&#xA;func (d *Dial) SerialOK(dev []string) string {&#xA;&#xA;    // 遍历设备&#xA;&#xA;    for _, v := range dev {&#xA;&#xA;    // 通过调用程序来判断可用串口&#xA;&#xA;    cmd := exec.Command(&amp;quot;/danoo/bin/danoo_3g_signal&amp;quot;, v)&#xA;&#xA;    // 运行程序&#xA;&#xA;    if err := cmd.Start(); err != nil {&#xA;&#xA;        continue&#xA;&#xA;    }&#xA;&#xA;    // 线程&#xA;&#xA;    chTime := make(chan int)&#xA;&#xA;    // 飞一会干掉他&#xA;&#xA;    go (func(ch chan int, cmd *exec.Cmd) {&#xA;&#xA;        // 让程序飞一会&#xA;&#xA;        time.Sleep(time.Second * 5)&#xA;&#xA;        // 然后干掉它&#xA;        cmd.Process.Kill()&#xA;&#xA;        // 返回&#xA;&#xA;        ch &amp;lt;- 0&#xA;&#xA;    })(chTime, cmd)&#xA;&#xA;    // 等待程序结束&#xA;&#xA;    if err := cmd.Wait(); err != nil {&#xA;&#xA;        if exiterr, ok := err.(*exec.ExitError); ok {&#xA;&#xA;        if status, ok := exiterr.Sys().(syscall.WaitStatus); ok {&#xA;&#xA;            if status.ExitStatus() == 99 {&#xA;&#xA;            return v&#xA;&#xA;            }&#xA;&#xA;        }&#xA;&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    // 返回锁&#xA;&#xA;    &amp;lt;-chTime&#xA;&#xA;    }&#xA;&#xA;    // 返回&#xA;&#xA;    return &amp;quot;&amp;quot;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>SSH-远程登录慢的原因</title>
      <link>http://www.nljb.net/default/SSH-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候在ssh远程登录到其他主机上时发现登录时间太长，要等待很久才会出现输入密码的提示，google了一下，发现主要有两个问题会导致ssh登录慢：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.使用了dns反查，这样的话当ssh某个IP时，系统会试图通过DNS反查相对应的域名，如果DNS中没有这个IP的域名解析，则会等到DNS查询超时才会进行下一步，消耗很长时间。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;修改方式: vim /etc/ssh/sshd_config 增加一行记录：UseDNS no&#xA;&#xA;默认情况下会有一行被注释掉的记录#UseDNS yes，虽然这条记录被注释掉了，但ssh缺省情况下UseDNS的值是yes，所以要显式的指定该值为no。&#xA;&#xA;重新启动ssh服务&#xA;远程登录会快很多。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;这种情况在本地主机或远程主机启动图形的情况下比较明显，该参数似乎是在做图形方面的认证，具体功能还不清楚，但修改以后可以明显提高ssh远程登录速度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;vim /etc/ssh/sshd_config&#xA;修改GSSAPIAuthentication参数为 no，默认是yes&#xA;重新启动ssh服务&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;ssh –vvv&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-vvv的参数可以查看ssh登录的过程，看看当前进行到了哪一步。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>SSH--C-压缩传输</title>
      <link>http://www.nljb.net/default/SSH--C-%E5%8E%8B%E7%BC%A9%E4%BC%A0%E8%BE%93/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;-C&#xA;&#xA;Requests compression of all data (including stdin, stdout, stderr, and data for forwarded X11 and TCP connections).  The compression algorithm is the&#xA;&#xA;same used by gzip(1), and the “level” can be controlled by the CompressionLevel option for protocol version 1.  Compression is desirable on modem&#xA;&#xA;lines and other slow connections, but will only slow down things on fast networks.  The default value can be set on a host-by-host basis in the con‐&#xA;&#xA;figuration files; see the Compression option.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenVPN-时间错误会造成VPN无法正常连接</title>
      <link>http://www.nljb.net/default/OpenVPN-%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF%E4%BC%9A%E9%80%A0%E6%88%90VPN%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;OpenVPN -&amp;gt; 时间错误会造成VPN无法正常连接&lt;/p&gt;&#xA;&#xA;&lt;p&gt;连接openvpn时出现错误提示：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;TLS_ERROR: BIO read tls_read_plaintext error: error:140890B2:&#xA;SSL routines:SSL3_GET_CLIENT_CERTIFICATE:no certificate returned&#xA;TLS Error: TLS object -&amp;gt; incoming plaintext read error&#xA;TLS Error: TLS handshake failed&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个似乎是提示系统时间和证书时间不一致，具体解决措施为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.修改vps时间与本地时间一致&#xA;2.重启vps&#xA;3.重新连接openvpn试试&#xA;4.如果依旧不能连接openvpn，可以在vps上重新生成一个新的证书。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux下Shell脚本输出带颜色文字</title>
      <link>http://www.nljb.net/default/Linux%E4%B8%8BShell%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%96%87%E5%AD%97/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Linux下Shell脚本输出带颜色文字/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;文本终端的颜色可以使用“ANSI非常规字符序列”来生成。举例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;echo -e &amp;quot;\033[44;37;5m ME \033[0m COOL&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上命令设置作用如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;背景色为蓝色，前景色为白色，字体闪烁，输出字符“ME”，然后重新设置屏幕到缺省设置，输出字符 “COOL”。&#xA;“e”是命令 echo 的一个可选项，它用于激活特殊字符的解析器。&#xA;“\033”引导非常规字符序列。&#xA;“m”意味着设置属性然后结束非常规字符序列，这个例子里真正有效的字符是“44;37;5” 和“0”。&#xA;修改“44;37;5”可以生成不同颜色的组合，数值和编码的前后顺序没有关系。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;可以选择的编码如下所示：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　　编码 颜色/动作&#xA;　　0 重新设置属性到缺省设置&#xA;　　1 设置粗体&#xA;　　2 设置一半亮度(模拟彩色显示器的颜色)&#xA;　　4 设置下划线(模拟彩色显示器的颜色)&#xA;　　5 设置闪烁&#xA;　　7 设置反向图象&#xA;　　22 设置一般密度&#xA;　　24 关闭下划线&#xA;　　25 关闭闪烁&#xA;　　27 关闭反向图象&#xA;　　30 设置黑色前景&#xA;　　31 设置红色前景&#xA;　　32 设置绿色前景&#xA;　　33 设置棕色前景&#xA;　　34 设置蓝色前景&#xA;　　35 设置紫色前景&#xA;　　36 设置青色前景&#xA;　　37 设置白色前景&#xA;　　38 在缺省的前景颜色上设置下划线&#xA;　　39 在缺省的前景颜色上关闭下划线&#xA;　　40 设置黑色背景&#xA;　　41 设置红色背景&#xA;　　42 设置绿色背景&#xA;　　43 设置棕色背景&#xA;　　44 设置蓝色背景&#xA;　　45 设置紫色背景&#xA;　　46 设置青色背景&#xA;　　47 设置白色背景&#xA;　　49 设置缺省黑色背景&#xA;　　例如：在编译脚本文件时，对服务启动完成后的OK字符串设置成绿色&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-驱动加载</title>
      <link>http://www.nljb.net/default/Linux-%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;一般使用 modprobe ，因为 insmod 不考虑 mod 的模块依赖问题。&#xA;&#xA;modprobe 会检索模块依赖关系后载入依赖的模块（当然并不是绝对都能……）&#xA;&#xA;不过 modprobe 只能载入 /lib/modules/&amp;lt;kernel ver&amp;gt;/ 里面的模块。而且这个模块必须在这个目录里面的配置文件里面注册了&#xA;&#xA;使用分析可载入模块的相依性 depmod -a&#xA;&#xA;删除模块可以使用rmmod xxx 或者 modprobe -r  xxx 即可&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;　depmod可检测模块的相依性，供modprobe在安装模块时使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/modprobe.d/50-blacklist.conf   ---&amp;gt;   blacklist vt6656_stage&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　depmod [-adeisvV][-m &amp;lt;文件&amp;gt;][--help][模块名称]&#xA;    -a或--all 分析所有可用的模块。&#xA;　　-d或debug 执行排错模式。&#xA;　　-e 输出无法参照的符号。&#xA;　　-i 不检查符号表的版本。&#xA;　　-m&amp;lt;文件&amp;gt;或system-map&amp;lt;文件&amp;gt; 使用指定的符号表文件。&#xA;　　-s或--system-log 在系统记录中记录错误。&#xA;　　-v或--verbose 执行时显示详细的信息。&#xA;　　-V或--version 显示版本信息。&#xA;　　--help 显示帮助。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-通过文件修改密码</title>
      <link>http://www.nljb.net/default/Linux-%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1,/etc/rc.d/rc.local 此文件可以写系统启动后开启的命令&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;如 su – root -c ‘/home/mysql/ultserver/userver &amp;amp;’&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2,/etc/profile 系统环境变量设置点&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/java/jdk1.5.0_06&#xA;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JABA_HOME/lib/tools.jar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3,.bashrc 或 .bash_profile 设置用户而不是系统的环境变量&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4,/etc/shadow 内容包括用户及被加密的密码以及其它/etc/passwd 不能包括的信息，比如用户的有效期限&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;einan:$1$VE.Mq2Xf$2c9Qi7EQ9JP8GKF8gH7PB1:13072:0:99999:7:::&#xA;linuxsir:$1$IPDvUhXP$8R6J/VtPXvLyXxhLWPrnt/:13072:0:99999:7::13108:&#xA;&#xA;第一字段：用户名（也被称为登录名），在/etc/shadow中，用户名和/etc/passwd 是相同的，这样就把passwd 和shadow&#xA;中用的用户记录联系在一起；这个字段是非空的；&#xA;第二字段：密码（已被加密），如果是有些用户在这段是x，表示这个用户不能登录到系统；这个字段是非空的；&#xA;第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），&#xA;您可以通过passwd 来修改用户的密码，然后查看/etc/shadow中此字段的变化；&#xA;第四字段：两次修改口令间隔最少的天数；如果设置为0,则禁用此功能；也就是说用户必须经过多少天才能修改其口令；&#xA;此项功能用处不是太大；默认值是通过/etc/login.defs文件定义中获取，PASS_MIN_DAYS 中有定义；&#xA;第五字段：两次修改口令间隔最多的天数；这个能增强管理员管理用户口令的时效性，应该说在增强了&#xA;系统的安全性；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在 &#xA;PASS_MAX_DAYS 中定义；&#xA;第六字段：提前多少天警告用户口令将过期；当用户登录系统后，系统登录程序提醒用户口令将&#xA;要作废；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，&#xA;在PASS_WARN_AGE 中定义；&#xA;第七字段：在口令过期之后多少天禁用此用户；此字段表示用户口令作废多少天后，&#xA;系统会禁用此用户，也就是说系统会不能再让此用户登录，也不会提示用户过期，是完全禁用；&#xA;第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），&#xA;如果这个字段的值为空，帐号永久可用；&#xA;第九字段：保留字段，目前为空，以备将来Linux发展之用；如果更为详细的，&#xA;请用 man shadow来查看帮助，您会得到更为详尽的资料；&#xA;&#xA;/etc/password 帐户花名册&#xA;&#xA;beinan:x:500:500:beinan sun:/home/beinan:/bin/bash&#xA;linuxsir:x:505:502:linuxsir open,linuxsir office,13898667715:/home/linuxsir:/bin/bash&#xA;beinan:x:500:500:beinan sun:/home/beinan:/bin/bash&#xA;linuxsir:x:501:502::/home/linuxsir:/bin/bash&#xA;&#xA;第一字段：用户名（也被称为登录名）；在上面的例子中，我们看到这两个用户的用户名分别是 &#xA;beinan 和linuxsir；&#xA;第二字段：口令；在例子中我们看到的是一个x，其实密码已被映射到/etc/shadow 文件中；&#xA;第三字段：UID ；请参看本文的UID的解说；&#xA;第四字段：GID；请参看本文的GID的解说；&#xA;第五字段：用户名全称，这是可选的，可以不设置，在beinan这个用户中，用户的全称是beinan sun ；&#xA;而linuxsir 这个用户是没有设置全称；&#xA;第六字段：用户的家目录所在位置；beinan 这个用户是/home/beinan ，而linuxsir 这个用户是&#xA;/home/linuxsir ；&#xA;第七字段：用户所用SHELL 的类型，beinan和linuxsir 都用的是 bash ；所以设置为/bin/bash ； &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5,/etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/etc/init.d/iptables start &#xA;/etc/init.d/iptables stop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;6./etc/inittab 设置启动level，如果要从图形界面启动切换到字符界面就需要修改这个文件&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-通过-proc-查看硬件信息</title>
      <link>http://www.nljb.net/default/Linux-%E9%80%9A%E8%BF%87-proc-%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;用硬件检测程序kudzu探测新硬件：service kudzu start ( or restart)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;查看CPU信息：cat /proc/cpuinfo&#xA;查看板卡信息：cat /proc/pci&#xA;查看PCI信息：lspci (相比cat /proc/pci更直观）&#xA;查看内存信息：cat /proc/meminfo&#xA;查看USB设备：cat /proc/bus/usb/devices&#xA;查看键盘和鼠标:cat /proc/bus/input/devices&#xA;查看系统硬盘信息和使用情况：fdisk &amp;amp; disk - l &amp;amp; df&#xA;查看各设备的中断请求(IRQ):cat /proc/interrupts&#xA;查看系统体系结构：uname -a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在LINUX环境开发驱动程序，首先要探测到新硬件，接下来就是开发驱动程序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;常用命令整理如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;用硬件检测程序kudzu探测新硬件：service kudzu start ( or restart)&#xA;查看CPU信息：cat /proc/cpuinfo&#xA;查看板卡信息：cat /proc/pci&#xA;查看PCI信息：lspci (相比cat /proc/pci更直观）&#xA;查看内存信息：cat /proc/meminfo&#xA;查看USB设备：cat /proc/bus/usb/devices&#xA;查看键盘和鼠标:cat /proc/bus/input/devices&#xA;查看系统硬盘信息和使用情况：fdisk &amp;amp; disk - l &amp;amp; df&#xA;查看各设备的中断请求(IRQ):cat /proc/interrupts&#xA;查看系统体系结构：uname –a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看看系统认出的盘先： cat /proc/partitions&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;dmidecode查看硬件信息，包括bios、cpu、内存等信息&#xA;dmesg | more 查看硬件信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;对于“/proc”中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Cpuinfo 主机CPU信息&#xA;Dma 主机DMA通道信息&#xA;Filesystems 文件系统信息&#xA;Interrupts 主机中断信息&#xA;Ioprots 主机I/O端口号信息&#xA;Meninfo 主机内存信息&#xA;Version Linux内存版本信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-系统时区修改</title>
      <link>http://www.nljb.net/default/Linux-%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA%E4%BF%AE%E6%94%B9/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 执行&#xA;tzselect&#xA;&#xA;// 回车后会有选项提示&#xA;TZ=&#39;Asia/Shanghai&#39;;export TZ&#xA;// 即时生效 亚洲上海CST时间&#xA;&#xA;// 时区设置使重启后依然设生效&#xA;hwclock -w&#xA;&#xA;// 时区配置查询文件&#xA;/etc/sysconfig/clock&#xA;&#xA;// 时区配置文件：&#xA;cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &#xA;&#xA;// 随后保存即可&#xA;hwclock -w&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-内核升级-内核编译步骤</title>
      <link>http://www.nljb.net/default/Linux-%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;执行命令：&#xA;#make clean&#xA;然后是：&#xA;#make mrproper&#xA;进入图形配置界面。在终端敲入以下命令：&#xA;#make menuconfig&#xA;设置完毕，进入编译阶段。如果补丁和配置正确，下面几步不会出错，按顺序执行，等待完成即可。&#xA;#make bzImage&#xA;#make modules&#xA;#make modules_install&#xA;#make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-修改MAC地址方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%BF%AE%E6%94%B9MAC%E5%9C%B0%E5%9D%80%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.用命令行临时解决：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#sudo ifconfig eth0 down&#xA;#sudo ifconfig eth0 hw ether AA:BB:CC:DD:EE:FF&#xA;#sudo ifconfig eth0 up&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.启动自行修改&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#sudo vi /etc/network/interfaces&#xA;在eth0的配置中加入如下&#xA;hwaddress ether AA:BB:CC:DD:EE:FF&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;方法一：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.关闭网卡设备&#xA;ifconfig eth0 down&#xA;&#xA;2.修改MAC地址&#xA;ifconfig eth0 hw ether MAC地址&#xA;&#xA;3.重启网卡&#xA;ifconfig eth0 up&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;方法二：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在./etc/sysconfig/network-scripts/ifcfg-eth0中加入下面一句话：&#xA;&#xA;MACADDR=00:AA:BB:CC:DD:EE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;方法三：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Linux 下如何更改网卡MAC地址 &#xA;&#xA;简单的办法是在/etc/rc.d/rc.sysinit文件中加入那些命令:&#xA;&#xA;ifconfig eth0 down&#xA;ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx&#xA;ifconfig eth0 up&#xA;&#xA;因为这个脚本运行在network之前,所以,MAC跟IP就是对应的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;方法四：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Linux下的MAC地址更改,首先用命令关闭网卡设备。&#xA;&#xA;/sbin/ifconfig eth0 down&#xA;&#xA;然后就可以修改MAC地址了。&#xA;&#xA;/sbin/ifconfig eth0 hw ether xxxxxxxxxx （其中xx是您要修改的地址）&#xA;&#xA;最后重新启用网卡&#xA;&#xA;/sbin/ifconfig eth0 up&#xA;&#xA;网卡的MAC地址更改就完成了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下隐藏鼠标的方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E9%9A%90%E8%97%8F%E9%BC%A0%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近工作需要，调查了一下如何在界面启动以后不显示鼠标光标，但是触摸屏可以正常工作，现将方法总结一下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1,就是使用unclutter,这个可以起作用，但是不是我想要的效果；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;./unclutter: usage:&#xA;    -display &amp;lt;display&amp;gt;&#xA;    -idle &amp;lt;seconds&amp;gt;        time between polls to detect idleness.&#xA;    -keystroke        wait for keystroke before idling.&#xA;    -jitter &amp;lt;pixels&amp;gt;    pixels mouse can twitch without moving&#xA;    -grab            use grabpointer method not createwindow&#xA;    -reset            reset the timer whenever cursor becomes&#xA;            visible even if it hasn&#39;t moved&#xA;     -root                   apply to cursor on root window too&#xA;    -onescreen        apply only to given screen of display&#xA;     -visible               ignore visibility events&#xA;     -noevents              don&#39;t send pseudo events&#xA;    -regex            name or class below is a regular expression&#xA;    -not names...        don&#39;t apply to windows whose wm-name begins.&#xA;        (must be last argument)&#xA;    -notname names...    same as -not names...&#xA;    -notclass classes...    don&#39;t apply to windows whose wm-class begins.&#xA;        (must be last argument, cannot be used with&#xA;        -not or -notname)&#xA;&#xA;原因事它总有一刹那是出现鼠标的；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2：xsetroot -cursor blank.bmp blank.bmp&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;其中blank.bmp是使用bitmap &amp;amp;制作的的一个空白鼠标；&#xA;效果是可以在桌面上起作用，但是在程序界面鼠标依然出现；&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3：setterm -cursor off关闭终端界面的光标；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4：oneko一个类似于unclutter的程序；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;5：在调用startx启动的桌面系统中给XSERVER传递参数serverargs=&amp;rdquo; -nocursor &amp;ldquo;，这个可以起作用；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在211行执行xinit的地方, 在 &amp;quot;$server&amp;quot;后面加上 -nocursor&#xA;xinit &amp;quot;$client&amp;quot; $clientargs -- &amp;quot;$server&amp;quot; -nocursor  $display $serverargs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下添加路由的方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一,使用route 命令添加&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;使用route 命令添加的路由，机器重启或者网卡重启后路由就失效了，方法：&#xA;&#xA;//添加到主机的路由&#xA;# route add –host 192.168.168.110 dev eth0&#xA;# route add –host 192.168.168.119 gw 192.168.168.1&#xA;//添加到网络的路由&#xA;# route add –net IP netmask MASK eth0&#xA;# route add –net IP netmask MASK gw IP&#xA;# route add –net IP/24 eth1&#xA;//添加默认网关&#xA;# route add default gw IP&#xA;//删除路由&#xA;# route del –host 192.168.168.110 dev eth0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;二,在linux下设置永久路由的方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.在/etc/rc.local里添加&#xA;方法：&#xA;route add -net 192.168.3.0/24 dev eth0&#xA;route add -net 192.168.2.0/24 gw 192.168.3.254&#xA;&#xA;2.在/etc/sysconfig/network里添加到末尾&#xA;方法：GATEWAY=gw-ip 或者GATEWAY=gw-dev&#xA;&#xA;3./etc/sysconfig/static-router :&#xA;any net x.x.x.x/24 gw y.y.y.y &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下强制Copy文件</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E5%BC%BA%E5%88%B6Copy%E6%96%87%E4%BB%B6/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux下默认cp命令是有别名的(alias cp=&amp;lsquo;cp -i&amp;rsquo;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无法在复制时强制覆盖，即使你用 -f 参数也无法强制覆盖文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面提供几个从网上找的Linux下cp命令覆盖的方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1) 取消cp的alias（放心这不是永久生效）：&#xA;#unalias cp&#xA;#cp a /test/a&#xA;&#xA;2) 加反斜杠 \cp 执行cp命令时不走alias：&#xA;#\cp a /test/a&#xA;&#xA;3）另外一个有意思的方法：&#xA;#yes|cp a /test/a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-date-命令使用技巧</title>
      <link>http://www.nljb.net/default/Linux-date-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;[root@localhost ~]# date --set &amp;quot;1/1/09 00:01&amp;quot; &amp;lt;== （月/日/年时:分:秒）&#xA;[root@localhost ~]# date 012501012009.30 &amp;lt;== 月日时分年.秒&#xA;Linux查看日期时间命令 date 把系统时间设置为以下时间： date -s 2010-04-07 date -s 10:20:33&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;date命令&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　　date命令的功能是显示和设置系统日期和时间。 &#xA;　　该命令的一般格式为： date [选项] 显示时间格式（以+开头，后面接格式） &#xA;　　date 设置时间格式 &#xA;　　命令中各选项的含义分别为： &#xA;　　-d datestr, --date datestr 显示由datestr描述的日期 &#xA;　　-s datestr, --set datestr 设置datestr 描述的日期 &#xA;　　-u, --universal 显示或设置通用时间 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;时间域&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;　　% H 小时（00..23） &#xA;　　% I 小时（01..12） &#xA;　　% k 小时（0..23） &#xA;　　% l 小时（1..12） &#xA;　　% M 分（00..59） &#xA;　　% p 显示出AM或PM &#xA;　　% r 时间（hh：mm：ss AM或PM），12小时 &#xA;　　% s 从1970年1月1日00：00：00到目前经历的秒数 &#xA;　　% S 秒（00..59） &#xA;　　% T 时间（24小时制）（hh:mm:ss） &#xA;　　% X 显示时间的格式（％H:％M:％S） &#xA;　　% Z 时区 日期域 &#xA;　　% a 星期几的简称（ Sun..Sat） &#xA;　　% A 星期几的全称（ Sunday..Saturday） &#xA;　　% b 月的简称（Jan..Dec） &#xA;　　% B 月的全称（January..December） &#xA;　　% c 日期和时间（ Mon Nov 8 14：12：46 CST 1999） &#xA;　　% d 一个月的第几天（01..31） &#xA;　　% D 日期（mm／dd／yy） &#xA;　　% h 和%b选项相同 &#xA;　　% j 一年的第几天（001..366） &#xA;　　% m 月（01..12） &#xA;　　% w 一个星期的第几天（0代表星期天） &#xA;　　% W 一年的第几个星期（00..53，星期一为第一天） &#xA;　　% x 显示日期的格式（mm/dd/yy） &#xA;　　% y 年的最后两个数字（ 1999则是99） &#xA;　　% Y 年（例如：1970，1996等） &#xA;　　需要特别说明的是，只有超级用户才能用date命令设置时间，一般用户只能用date命令显示时间。 &#xA;　　例1：用指定的格式显示时间。 &#xA;　　$ date ‘+This date now is =&amp;gt;%x ，time is now =&amp;gt;%X ，thank you !&#39; &#xA;　　This date now is =&amp;gt;11/12/99 ，time is now =&amp;gt;17:53:01 ，thank you ! &#xA;　　例2：用预定的格式显示当前的时间。 &#xA;　　# date &#xA;　　Fri Nov 26 15：20：18 CST 1999 &#xA;　　例3：设置时间为下午14点36分。 &#xA;　　# date -s 14:36:00 &#xA;　　Fri Nov 26 14：15：00 CST 1999 &#xA;　　例4：设置时间为1999年11月28号。 &#xA;　　# date -s 991128 &#xA;　　Sun Nov 28 00：00：00 CST 1999 &#xA;    例5：设置一天前&#xA;    date --date &amp;quot;1 days ago&amp;quot; +&amp;quot;%Y-%m-%d&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux ALSA 配置</title>
      <link>http://www.nljb.net/default/Linux-ALSA-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;查看系统audio设备查看audio设备摘要信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aplay -l&#xA;&#xA;**** List of PLAYBACK Hardware Devices ****&#xA;card 0: Intel [HDA Intel], device 0: ALC662 rev1 Analog [ALC662 rev1 Analog]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 0: Intel [HDA Intel], device 1: ALC662 rev1 Digital [ALC662 rev1 Digital]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 3: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 7: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 8: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;card 1: NVidia [HDA NVidia], device 9: HDMI 0 [HDMI 0]&#xA;  Subdevices: 1/1&#xA;  Subdevice #0: subdevice #0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;查看audio详细信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aplay -L&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可能输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;null&#xA;    Discard all samples (playback) or generate zero samples (capture)&#xA;front:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    Front speakers&#xA;surround40:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    4.0 Surround output to Front and Rear speakers&#xA;surround41:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    4.1 Surround output to Front, Rear and Subwoofer speakers&#xA;surround50:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    5.0 Surround output to Front, Center and Rear speakers&#xA;surround51:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    5.1 Surround output to Front, Center, Rear and Subwoofer speakers&#xA;surround71:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Analog&#xA;    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers&#xA;iec958:CARD=Intel,DEV=0&#xA;    HDA Intel, ALC662 rev1 Digital&#xA;    IEC958 (S/PDIF) Digital Audio Output&#xA;hdmi:CARD=NVidia,DEV=0&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;hdmi:CARD=NVidia,DEV=1&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;hdmi:CARD=NVidia,DEV=2&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;hdmi:CARD=NVidia,DEV=3&#xA;    HDA NVidia, HDMI 0&#xA;    HDMI Audio Output&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置文件,最简单的/etc/asound.conf格式如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defaults.ctl.card 0&#xA;defaults.pcm.card 0&#xA;defaults.timer.card 0&#xA;&#xA;pcm.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&#xA;ctl.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&#xA;其中card和device的确定从aplay -l命令得到。对比aplaya -l的输出，可以看到上面的配置文件使用了Intel的音频设备。&#xA;设置默认输出设备&#xA;首先根据aplay -l的输出来确定声卡ID和设备ID&#xA;把Intel模拟输出作为默认的audio输出设备&#xA;&#xA;defaults.ctl.card 0&#xA;defaults.pcm.card 0&#xA;defaults.timer.card 0&#xA;&#xA;pcm.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&#xA;ctl.!default {&#xA;    type hw&#xA;    card 0&#xA;    device 0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;把Nvidia HDMI数字输出作为默认的audio输出设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defaults.ctl.card 1&#xA;defaults.pcm.card 1&#xA;defaults.timer.card 1&#xA;&#xA;pcm.!default {&#xA;    type hw&#xA;    card 1&#xA;    device 7&#xA;}&#xA;&#xA;ctl.!default {&#xA;    type hw&#xA;    card 1&#xA;    device 7&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试audio设备测试指定audio设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;speaker-test -D front:Intel -c2 -r44100 -FS16_LE -twav&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试默认audio设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;speaker-test -c2 -r44100 -FS16_LE -twav&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;调节audio设备&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;alsamixer -c 0 &amp;lt;---[声卡编号]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置文件的保存和还原&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;alsactl store -f /var/lib/alsa/asound.state&#xA;alsactl restore -f /var/lib/alsa/asound.state&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;调节声音&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;amixer set Master 100% &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>HTTP-Client-Transport</title>
      <link>http://www.nljb.net/default/HTTP-Client-Transport/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;RoundTripper接口中包含RoundTrip方法，Transport结构中同样包含RoundTrip方法&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;这样一来，接口声明的对象可以接受所有包含RoundTrip方法的接口 &amp;hellip; 仅开放共有方法 &amp;hellip;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 为什么[Client]结构定义了[RoundTripper]却使用[&amp;amp;http.Transport]赋值&#xA;http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;...&#xA;&#xA;// Client 结构&#xA;type Client struct {&#xA;    // Transport specifies the mechanism by which individual&#xA;    // HTTP requests are made.&#xA;    // If nil, DefaultTransport is used.&#xA;    Transport RoundTripper&#xA;...&#xA;&#xA;// type Transport&#xA;//   func (t *Transport) CancelRequest(req *Request)&#xA;//   func (t *Transport) CloseIdleConnections()&#xA;//   func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)&#xA;//   func (t *Transport) RoundTrip(req *Request) (*Response, error)&#xA;// Transport 结构&#xA;type Transport struct {&#xA;...&#xA;&#xA;// RoundTripper 竟然是个接口&#xA;type RoundTripper interface {&#xA;    // RoundTrip executes a single HTTP transaction, returning&#xA;    // the Response for the request req.  RoundTrip should not&#xA;    // attempt to interpret the response.  In particular,&#xA;    // RoundTrip must return err == nil if it obtained a response,&#xA;    // regardless of the response&#39;s HTTP status code.  A non-nil&#xA;    // err should be reserved for failure to obtain a response.&#xA;    // Similarly, RoundTrip should not attempt to handle&#xA;    // higher-level protocol details such as redirects,&#xA;    // authentication, or cookies.&#xA;    //&#xA;    // RoundTrip should not modify the request, except for&#xA;    // consuming and closing the Body. The request&#39;s URL and&#xA;    // Header fields are guaranteed to be initialized.&#xA;    RoundTrip(*Request) (*Response, error)&#xA;}&#xA;...&#xA;&#xA;// 接口中实现的方法是属于[Transport]的&#xA;func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;所以&amp;hellip;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;// 比如说你定义了一个接口&#xA;type Start interface {&#xA;    // 包含了一个Run方法&#xA;    Run()&#xA;}&#xA;&#xA;// 不同结构包含相同方法&#xA;// A&#xA;type A struct {&#xA;}&#xA;&#xA;func (this *A) Run() {&#xA;    log.Println(&amp;quot;A&amp;quot;)&#xA;}&#xA;&#xA;// B&#xA;type B struct {&#xA;}&#xA;&#xA;func (this *B) Run() {&#xA;    log.Println(&amp;quot;B&amp;quot;)&#xA;}&#xA;&#xA;// C&#xA;type C struct {&#xA;}&#xA;&#xA;func (this *C) Run() {&#xA;    log.Println(&amp;quot;C&amp;quot;)&#xA;}&#xA;&#xA;// 使用 ...&#xA;func MainStart(this Start) {&#xA;    this.Run()&#xA;}&#xA;&#xA;func main() {&#xA;    MainStart(new(A))&#xA;    MainStart(new(B))&#xA;    MainStart(new(C))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-读取文件信息-FileInfo-and-MD5</title>
      <link>http://www.nljb.net/default/Golang-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF-FileInfo-and-MD5/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;import &amp;quot;os&amp;quot;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;crypto/md5&amp;quot;&#xA;import &amp;quot;io&amp;quot;&#xA;&#xA;func main() {&#xA;&#xA;    fi,err:= os.Lstat(&amp;quot;Time.go&amp;quot;) &#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;info ERROR&amp;quot;,err) &#xA;    }&#xA;    fileHandle,err := os.Open(&amp;quot;Time.go&amp;quot;)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;open ERROR&amp;quot;,err) &#xA;    }&#xA;    defer fileHandle.Close()&#xA;    h := md5.New()&#xA;    _, err = io.Copy(h,fileHandle)&#xA;    fmt.Println(fi.Name())&#xA;    fmt.Println(fi.Size())&#xA;    //fmt.Println(fi.Mode().Perm())&#xA;    //fmt.Println(fi.ModTime())&#xA;    //fmt.Println(fi.IsDir())&#xA;    fmt.Printf(&amp;quot;%x&amp;quot;, h.Sum(nil))&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-读取字符串流-ICCID</title>
      <link>http://www.nljb.net/default/Golang-%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81-ICCID/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// CCID&#xA;if *ccid {&#xA;    v := Com(*device, &amp;quot;AT+CRSM=176,12258,0,0,10\r&amp;quot;)&#xA;    d := bytes.NewBuffer(v)&#xA;    for {&#xA;    l, e := d.ReadString(&#39;\n&#39;)&#xA;    if e == io.EOF {&#xA;        break&#xA;    } else if e != nil {&#xA;        os.Exit(2)&#xA;    }&#xA;    if strings.Contains(l, &amp;quot;+CRSM&amp;quot;) {&#xA;        line := strings.Split(z.Trim(l), &amp;quot;,&amp;quot;)&#xA;        id := strings.Trim(z.Trim(line[2]), &amp;quot;\&amp;quot;&amp;quot;)&#xA;        fmt.Printf(&amp;quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n&amp;quot;,&#xA;        (id[1]), (id[0]),&#xA;        (id[3]), (id[2]),&#xA;        (id[5]), (id[4]),&#xA;        (id[7]), (id[6]),&#xA;        (id[9]), (id[8]),&#xA;        (id[11]), (id[10]),&#xA;        (id[13]), (id[12]),&#xA;        (id[15]), (id[14]),&#xA;        (id[17]), (id[16]),&#xA;        (id[19]))&#xA;&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-语言文件操作</title>
      <link>http://www.nljb.net/default/Golang-%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;收集整理了一下的代码.参照着使用吧,自己做个记录.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Open(name string) (file *File, err error),*File 是实现了 io.Reader这个接口&#xA;&#xA;byte[] 转化为 bytes.Buffer:bytes.NewBuffer([]byte).&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一、建立与打开&lt;/p&gt;&#xA;&#xA;&lt;p&gt;建立文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Create(name string) (file *File, err Error)&#xA;&#xA;func NewFile(fd int, name string) *File&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#Create&#34;&gt;http://golang.org/pkg/os/#Create&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Open(name string) (file *File, err Error)&#xA;&#xA;func OpenFile(name string, flag int, perm uint32) (file *File, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#Open&#34;&gt;http://golang.org/pkg/os/#Open&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、写文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Write(b []byte) (n int, err Error)&#xA;&#xA;func (file *File) WriteAt(b []byte, off int64) (n int, err Error)&#xA;&#xA;func (file *File) WriteString(s string) (ret int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#File.Write&#34;&gt;http://golang.org/pkg/os/#File.Write&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fout,err := os.Create(userFile)&#xA;    defer fout.Close()&#xA;    if err != nil {&#xA;        fmt.Println(userFile,err)&#xA;        return&#xA;    }&#xA;    for i:= 0;i&amp;lt;10;i++ {&#xA;        fout.WriteString(&amp;quot;Just a test!\r\n&amp;quot;)&#xA;        fout.Write([]byte(&amp;quot;Just a test!\r\n&amp;quot;))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;三、读文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (file *File) Read(b []byte) (n int, err Error)&#xA;&#xA;func (file *File) ReadAt(b []byte, off int64) (n int, err Error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;具体见官网：&lt;a href=&#34;http://golang.org/pkg/os/#File.Read&#34;&gt;http://golang.org/pkg/os/#File.Read&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;读文件示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;func main() {&#xA;    userFile := &amp;quot;test.txt&amp;quot;&#xA;    fin,err := os.Open(userFile)&#xA;    defer fin.Close()&#xA;    if err != nil {&#xA;        fmt.Println(userFile,err)&#xA;        return&#xA;    }&#xA;    buf := make([]byte, 1024)&#xA;    for{&#xA;        n, _ := fin.Read(buf)&#xA;        if0 == n { break }&#xA;        os.Stdout.Write(buf[:n])&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;四、删除文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Remove(name string) Error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用os库&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fi, err := os.Open(&amp;quot;input.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fi.Close()&#xA;&#xA;    fo, err := os.Create(&amp;quot;output.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fo.Close()&#xA;&#xA;    buf := make([]byte, 1024)&#xA;    for {&#xA;    n, err := fi.Read(buf)&#xA;    if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;    if n == 0 { break }&#xA;&#xA;    if n2, err := fo.Write(buf[:n]); err != nil {&#xA;        panic(err)&#xA;    } else if n2 != n {&#xA;        panic(&amp;quot;error in writing&amp;quot;)&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 这个例子使用了os.Open os.Create。&#xA;&#xA;// 使用bufio库&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;bufio&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fi, err := os.Open(&amp;quot;input.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fi.Close()&#xA;    r := bufio.NewReader(fi)&#xA;&#xA;    fo, err := os.Create(&amp;quot;output.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;    defer fo.Close()&#xA;    w := bufio.NewWriter(fo)&#xA;&#xA;    buf := make([]byte, 1024)&#xA;    for {&#xA;    n, err := r.Read(buf)&#xA;    if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;    if n == 0 { break }&#xA;&#xA;    if n2, err := w.Write(buf[:n]); err != nil {&#xA;        panic(err)&#xA;    } else if n2 != n {&#xA;        panic(&amp;quot;error in writing&amp;quot;)&#xA;    }&#xA;    }&#xA;&#xA;    if err = w.Flush(); err != nil { panic(err) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 使用ioutil库&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;io/ioutil&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    b, err := ioutil.ReadFile(&amp;quot;input.txt&amp;quot;)&#xA;    if err != nil { panic(err) }&#xA;&#xA;    err = ioutil.WriteFile(&amp;quot;output.txt&amp;quot;, b, 0644)&#xA;    if err != nil { panic(err) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-纳秒级别-局域网-广播-时间同步</title>
      <link>http://www.nljb.net/default/Golang-%E7%BA%B3%E7%A7%92%E7%BA%A7%E5%88%AB-%E5%B1%80%E5%9F%9F%E7%BD%91-%E5%B9%BF%E6%92%AD-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;net&amp;quot;&#xA;import &amp;quot;os/exec&amp;quot;&#xA;import &amp;quot;time&amp;quot;&#xA;&#xA;func TimeRead(ch chan string) {&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; TimeRead Start&amp;quot;&#xA;    socket, err := net.ListenUDP(&amp;quot;udp4&amp;quot;,&amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(0,0,0,0),&#xA;    Port: 8888,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,err)&#xA;    }&#xA;    for {&#xA;    data := make([]byte, 32)&#xA;    //read, remoteAddr, err := socket.ReadFromUDP(data)&#xA;    read, _, err := socket.ReadFromUDP(data)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,err)&#xA;        continue&#xA;    }&#xA;    //fmt.Println(read, remoteAddr)&#xA;    cmd := exec.Command(&amp;quot;date&amp;quot;,&amp;quot;-s&amp;quot;,string(data[0:read]))&#xA;    err = cmd.Run()&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,err)&#xA;    }&#xA;    fmt.Println(&amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; TimeRead&amp;quot;,time.Now().String())&#xA;    }&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; TimeRead Down&amp;quot;&#xA;    defer socket.Close()&#xA;}&#xA;&#xA;func Command(ch chan string) {&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; Command Start&amp;quot;&#xA;    socket, err := net.ListenUDP(&amp;quot;udp4&amp;quot;,&amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(0,0,0,0),&#xA;    Port: 9999,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; Command&amp;quot;,err)&#xA;    }&#xA;    for {&#xA;    data := make([]byte, 32)&#xA;    //read, remoteAddr, err := socket.ReadFromUDP(data)&#xA;    read, _, err := socket.ReadFromUDP(data)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err &amp;gt;&amp;gt;&amp;gt; Command&amp;quot;,err)&#xA;        continue&#xA;    }&#xA;    //fmt.Println(read, remoteAddr)&#xA;    ch &amp;lt;- string(data[0:read])&#xA;    }&#xA;    ch &amp;lt;- &amp;quot;LOG &amp;gt;&amp;gt;&amp;gt; Command Down&amp;quot;&#xA;    defer socket.Close()&#xA;}&#xA;&#xA;func main() {&#xA;    timeread := make(chan string)&#xA;    command := make(chan string)&#xA;    go TimeRead(timeread)&#xA;    go Command(command)&#xA;    for {&#xA;    select {&#xA;        case x := &amp;lt;- timeread:&#xA;        fmt.Println(x)&#xA;        case y := &amp;lt;- command:&#xA;        fmt.Println(y)&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;//////////////////////////////////////////////////////////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;net&amp;quot;&#xA;import &amp;quot;time&amp;quot;&#xA;&#xA;func TimeWrite() {&#xA;    socket, err := net.DialUDP(&amp;quot;udp4&amp;quot;, nil, &amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(192,168,24,255),&#xA;    Port: 8888,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err&amp;quot;,err)&#xA;    }&#xA;    defer socket.Close()&#xA;&#xA;    for {&#xA;    senddata := []byte(time.Now().Format(&amp;quot;01/02/2006 15:04:05.999999999&amp;quot;))&#xA;    _, err = socket.Write(senddata)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err&amp;quot;, err)&#xA;    }&#xA;    time.Sleep(time.Second * 5)&#xA;    }&#xA;}&#xA;&#xA;func Command() {&#xA;    socket, err := net.DialUDP(&amp;quot;udp4&amp;quot;, nil, &amp;amp;net.UDPAddr{&#xA;    IP: net.IPv4(192,168,24,255),&#xA;    Port: 9999,&#xA;    })&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;Err&amp;quot;,err)&#xA;    }&#xA;    defer socket.Close()&#xA;&#xA;    for {&#xA;    senddata := []byte(&amp;quot;reboot&amp;quot;)&#xA;    _, err = socket.Write(senddata)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;Err&amp;quot;, err)&#xA;    }&#xA;    time.Sleep(time.Second * 5)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;   go TimeWrite()&#xA;   go Command()&#xA;   time.Sleep(time.Second * 99999999)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-导出内容到-Excel</title>
      <link>http://www.nljb.net/default/Golang-%E5%AF%BC%E5%87%BA%E5%86%85%E5%AE%B9%E5%88%B0-Excel/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;encoding/csv&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    f, err := os.Create(&amp;quot;haha2.xls&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer f.Close()&#xA;&#xA;    f.WriteString(&amp;quot;\xEF\xBB\xBF&amp;quot;) // 写入UTF-8 BOM&#xA;&#xA;    w := csv.NewWriter(f)&#xA;    w.Write([]string{&amp;quot;编号&amp;quot;,&amp;quot;姓名&amp;quot;,&amp;quot;年龄&amp;quot;})&#xA;    w.Write([]string{&amp;quot;1&amp;quot;,&amp;quot;张三&amp;quot;,&amp;quot;23&amp;quot;})&#xA;    w.Write([]string{&amp;quot;2&amp;quot;,&amp;quot;李四&amp;quot;,&amp;quot;24&amp;quot;})&#xA;    w.Write([]string{&amp;quot;3&amp;quot;,&amp;quot;王五&amp;quot;,&amp;quot;25&amp;quot;})&#xA;    w.Write([]string{&amp;quot;4&amp;quot;,&amp;quot;赵六&amp;quot;,&amp;quot;26&amp;quot;})&#xA;    w.Flush()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-字符串操作处理包-Strings</title>
      <link>http://www.nljb.net/default/Golang-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E5%8C%85-Strings/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;// 自己整理的 Golang 帮助方法 &lt;a href=&#34;https://github.com/nulijiabei/goutil&#34;&gt;https://github.com/nulijiabei/goutil&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// 转自网络 &amp;lt;老虞学GoLang笔记-字符串&amp;gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在所有编程语言中都涉及到大量的字符串操作，可见熟悉对字符串的操作是何等重要。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Go中的字符串和C#中的一样，字符串内容在初始化后不可修改。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要注意的是在Go中字符串是有UTF-8编码的，请注意保存文件时将文件编码格式改成UTF-8(特别是在windows下)。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;初始化&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var str string //声明一个字符串&#xA;str = &amp;quot;laoYu&amp;quot;  //赋值&#xA;ch :=str[0]    //获取第一个字符&#xA;len :=len(str) //字符串的长度,len是内置函数 ,len=5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;字符串操作&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;码过程中避免不了中文字符，那我们该如何提取一个中文呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先我们要知道string[index]获取的是字符byte&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就无法像C#中&amp;rdquo;老虞&amp;rdquo;[0]来取到‘老’，在Go中需要将字符串转换成rune数组&lt;/p&gt;&#xA;&#xA;&lt;p&gt;runne数组中就可以通过数组下标获取一个汉字所标识的Unicode码，再将Unicode码按创建成字符串即可。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str :=&amp;quot;laoYu老虞&amp;quot;&#xA;&#xA;for  i:=0;i&amp;lt;len(str);i++ {&#xA;     fmt.Println(str[i])&#xA;}&#xA;&#xA;for  i,s :=  range str {&#xA;    fmt.Println(i,&amp;quot;Unicode(&amp;quot;,s,&amp;quot;) string=&amp;quot;,string(s))&#xA;}&#xA;&#xA;r := []rune(str)&#xA;fmt.Println(&amp;quot;rune=&amp;quot;,r)&#xA;for i:=0;i&amp;lt;len(r) ; i++ {&#xA;       fmt.Println(&amp;quot;r[&amp;quot;,i,&amp;quot;]=&amp;quot;,r[i],&amp;quot;string=&amp;quot;,string(r[i]))&#xA;}&#xA;&#xA;Outut：&#xA;108&#xA;97&#xA;111&#xA;89&#xA;117&#xA;232&#xA;128&#xA;129&#xA;232&#xA;153&#xA;158&#xA;0 Unicode( 108 ) string= l&#xA;1 Unicode( 97 ) string= a&#xA;2 Unicode( 111 ) string= o&#xA;3 Unicode( 89 ) string= Y&#xA;4 Unicode( 117 ) string= u&#xA;5 Unicode( 32769 ) string= 老&#xA;8 Unicode( 34398 ) string= 虞&#xA;rune= [108 97 111 89 117 32769 34398]&#xA;r[ 0 ]= 108 string= l&#xA;r[ 1 ]= 97 string= a&#xA;r[ 2 ]= 111 string= o&#xA;r[ 3 ]= 89 string= Y&#xA;r[ 4 ]= 117 string= u&#xA;r[ 5 ]= 32769 string= 老&#xA;r[ 6 ]= 34398 string= 虞&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;对字符串的操作非常重要，来了解下strings包中提供了哪些函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;获取总字节数 func Len(v type) int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;len函数是Go中内置函数，不引入strings包即可使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;len(string)返回的是字符串的字节数。len函数所支持的入参类型如下：&#xA;len(Array) 数组的元素个数&#xA;len(*Array) 数组指针中的元素个数,如果入参为nil则返回0&#xA;len(Slice) 数组切片中元素个数,如果入参为nil则返回0&#xA;len(map) 字典中元素个数,如果入参为nil则返回0&#xA;len(Channel) Channel buffer队列中元素个数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str :=&amp;quot;laoYu老虞&amp;quot;&#xA;str2 :=&amp;quot;laoYu&amp;quot;&#xA;fmt.Println(&amp;quot;len(&amp;quot;,str,&amp;quot;)=&amp;quot;,len(str))      //len=11=5+6,一个汉字在UTF-8&amp;gt;中占3个字节&#xA;fmt.Println(&amp;quot;len(&amp;quot;,str2,&amp;quot;)=&amp;quot;,len(str2))    //len=5&#xA;fmt.Println(&amp;quot;str[0]=&amp;quot;,str[0])              //l&#xA;&#xA;str :=&amp;quot;str&amp;quot;&#xA;arr :=[5]int{1,2,3}&#xA;slice :=make([]int,5)&#xA;&#xA;m :=make(map[int] string)&#xA;m[2]=&amp;quot;len&amp;quot;&#xA;&#xA;ch :=make(chan int)&#xA;&#xA;fmt.Println(&amp;quot;len(string)=&amp;quot;,len(str))   //3&#xA;fmt.Println(&amp;quot;len(array)=&amp;quot;,len(arr))     //5invalid argument user (type *UserInfo) for len&#xA;&#xA;fmt.Println(&amp;quot;len(slice)=&amp;quot;,len(slice))   //5&#xA;fmt.Println(&amp;quot;len(map)=&amp;quot;,len(m))         //1&#xA;fmt.Println(&amp;quot;len(chat)=&amp;quot;,len(ch))       //0&#xA;&#xA;//user :=&amp;amp;UserInfo{id:1,name:&amp;quot;laoYu&amp;quot;}&#xA;//interger :=2&#xA;//fmt.Println(&amp;quot;len(my struct)=&amp;quot;,len(user))//invalid argument user (type *UserInfo) for len&#xA;//fmt.Println(&amp;quot;len(interger)=&amp;quot;,len(interger))&#xA;&#xA;var str2 string&#xA;var arr2  [5]int&#xA;var slice2  []int&#xA;var  m2 map[int] string&#xA;var  ch2 chan int&#xA;&#xA;fmt.Println(&amp;quot;len(string)=&amp;quot;,len(str2))    //0&#xA;fmt.Println(&amp;quot;len(array)=&amp;quot;,len(arr2))     //5 &#xA;fmt.Println(&amp;quot;len(slice)=&amp;quot;,len(slice2))   //0&#xA;fmt.Println(&amp;quot;len(map)=&amp;quot;,len(m2))         //0&#xA;fmt.Println(&amp;quot;len(chat)=&amp;quot;,len(ch2))       //0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;字符串中是否包含某字符串 func Contains(s, substr string) bool&lt;/p&gt;&#xA;&#xA;&lt;p&gt;确定是否包含某字符串，这是区分大小写的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实际上内部是通过Index(s,sub string) int 实现的。如果索引!=-1则表示包含该字符串。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;空字符串&amp;rdquo;&amp;ldquo;在任何字符串中均存在。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Contains returns true if substr is within s.&#xA;func Contains(s, substr string) bool {&#xA;     return Index(s, substr) != -1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str :=&amp;quot;laoYuStudyGotrue是否包含某字符串&amp;quot;&#xA;fmt.Println(strings.Contains(str,&amp;quot;go&amp;quot;))         //false&#xA;fmt.Println(strings.Contains(str,&amp;quot;Go&amp;quot;))         //true&#xA;fmt.Println(strings.Contains(str,&amp;quot;laoyu&amp;quot;))      //false&#xA;fmt.Println(strings.Contains(str,&amp;quot;是&amp;quot;))         //true&#xA;fmt.Println(strings.Contains(str,&amp;quot;&amp;quot;))           //true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;在实际工作中常需要在不区分大小写的情况下确认是否包含某字符串&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(我们应该减少这种情况，以免每次验证时都需要进行一次大小写转换)。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里我局部修改源代码提供一个验证字符串中是否包含某字符串的函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当然你也可以直接使用strings.Contains(strings.ToLower(s),strings.ToLower(substr))&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str := &amp;quot;laoYuStudyGotrue是否包含某字符串&amp;quot;&#xA;fmt.Println(Contains(str, &amp;quot;go&amp;quot;, true))  //true&#xA;fmt.Println(Contains(str,&amp;quot;go&amp;quot;,false))   //false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//在字符串s中是否包含字符串substr,ignoreCase表示是否忽略大小写&#xA;func Contains(s string, substr string, ignoreCase bool) bool {&#xA;    return Index(s, substr, ignoreCase) != -1&#xA;&#xA;}&#xA;&#xA;//字符串subst在字符串s中的索引位置,ignoreCase表示是否忽略大小写&#xA;func Index(s string, sep string, ignoreCase bool) int {&#xA;&#xA;    n := len(sep)&#xA;    if n == 0 {&#xA;        return 0&#xA;    }&#xA;&#xA;    //to Lower&#xA;    if ignoreCase == true {&#xA;        s = strings.ToLower(s)&#xA;        sep = strings.ToLower(sep)&#xA;    }&#xA;&#xA;    c := sep[0]&#xA;    if n == 1 {&#xA;        // special case worth making fast&#xA;        for i := 0; i &amp;lt; len(s); i++ {&#xA;            if s[i] == c {&#xA;                return i&#xA;            }&#xA;        }&#xA;        return -1&#xA;    }&#xA;    // n &amp;gt; 1&#xA;    for i := 0; i+n &amp;lt;= len(s); i++ {&#xA;        if s[i] == c &amp;amp;&amp;amp; s[i:i+n] == sep {&#xA;            return i&#xA;        }&#xA;    }&#xA;    return -1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;获取字符串sep在字符串s中出现的次数 Count(s,sep string)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：如果sep=&amp;ldquo;&amp;ldquo;，则无论s为何字符串都会返回 len(s)+1&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;fmt.Println(strings.Count(&amp;quot;laoYuStudyGo&amp;quot;, &amp;quot;o&amp;quot;))                 //2&#xA;fmt.Println(strings.Count(&amp;quot;laoYuStudyGo&amp;quot;, &amp;quot;O&amp;quot;))                 //0&#xA;fmt.Println(strings.Count(&amp;quot;laoYuStudyGo&amp;quot;, &amp;quot;&amp;quot;))                  //13=12+1&#xA;fmt.Println(strings.Count(&amp;quot;laoYuStudyGo老虞学习Go语言&amp;quot;, &amp;quot;虞&amp;quot;))  //1&#xA;fmt.Println(strings.Count(&amp;quot;laoYuStudyGo老虞学习Go语言&amp;quot;, &amp;quot;Go&amp;quot;))  //2&#xA;fmt.Println(strings.Count(&amp;quot;laoYuStudyGo老虞学习Go语言&amp;quot;, &amp;quot;老虞&amp;quot;))//1&#xA;fmt.Println(strings.Count(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;))                             //1=0+1&#xA;fmt.Println(strings.Count(&amp;quot;aaaaaaaa&amp;quot;,&amp;quot;aa&amp;quot;))                     //4&#xA;fmt.Println(strings.Count(&amp;quot;laoYuStudyGo_n&amp;quot;,&amp;quot;\n&amp;quot;))               //0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;**使用（多个）空格分割字符串 Fields(s string) ,返回分割后的数组 **&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将字符串分割成数组，其分割符为空格。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;fmt.Println(strings.Fields(&amp;quot;lao Yu Study Go &amp;quot;)) //OutPut: [lao Yu Study Go]&#xA;fmt.Println(strings.Fields(&amp;quot;   Go    &amp;quot;))        //[Go]&#xA;fmt.Println(strings.Fields(&amp;quot;&amp;quot;))                 //[]&#xA;fmt.Println(strings.Fields(&amp;quot; \n go&amp;quot;))           //[go]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;**其实其内部实现调用的是FieldsFunc(s,unicode.IsSpace),我们也可以自定义分割方式 **&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;canSplit := func (c rune)  bool { return c==&#39;#&#39;}&#xA;fmt.Println(strings.FieldsFunc(&amp;quot;lao###Yu#Study####Go#G &amp;quot;,canSplit)) //[lao Yu Study Go G&amp;lt;space&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;检查字符串是否已某字符串开头 HasPrefix(s,prefix string) bool&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果想查看更多关于strings包下的字符串操作函数，请查看&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;&amp;quot;fmt&amp;quot;&#xA;&amp;quot;strings&amp;quot;&#xA;//&amp;quot;unicode/utf8&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    fmt.Println(&amp;quot;查找子串是否在指定的字符串中&amp;quot;)&#xA;    fmt.Println(&amp;quot; Contains 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;foo&amp;quot;)) //true&#xA;    fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;bar&amp;quot;)) //false&#xA;    fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;, &amp;quot;&amp;quot;)) //true&#xA;    fmt.Println(strings.Contains(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;)) //true 这里要特别注意&#xA;    fmt.Println(strings.Contains(&amp;quot;我是中国人&amp;quot;, &amp;quot;我&amp;quot;)) //true&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ContainsAny 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;team&amp;quot;, &amp;quot;i&amp;quot;)) // false&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;failure&amp;quot;, &amp;quot;u &amp;amp; i&amp;quot;)) // true&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;)) // false&#xA;    fmt.Println(strings.ContainsAny(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;)) // false&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ContainsRune 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ContainsRune(&amp;quot;我是中国&amp;quot;, &#39;我&#39;)) // true 注意第二个参数，用的是字符&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Count 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Count(&amp;quot;cheese&amp;quot;, &amp;quot;e&amp;quot;)) // 3 &#xA;    fmt.Println(strings.Count(&amp;quot;five&amp;quot;, &amp;quot;&amp;quot;)) // before &amp;amp; after each rune result: 5 , 源码中有实现&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; EqualFold 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.EqualFold(&amp;quot;Go&amp;quot;, &amp;quot;go&amp;quot;)) //大小写忽略 &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Fields 函数的用法&amp;quot;)&#xA;    fmt.Println(&amp;quot;Fields are: %q&amp;quot;, strings.Fields(&amp;quot; foo bar baz &amp;quot;)) //[&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;] 返回一个列表&#xA;&#xA;    //相当于用函数做为参数，支持匿名函数&#xA;    for _, record := range []string{&amp;quot; aaa*1892*122&amp;quot;, &amp;quot;aaa\taa\t&amp;quot;, &amp;quot;124|939|22&amp;quot;} {&#xA;    fmt.Println(strings.FieldsFunc(record, func(ch rune) bool {&#xA;    switch {&#xA;    case ch &amp;gt; &#39;5&#39;:&#xA;    return true&#xA;    }&#xA;    return false&#xA;    }))&#xA;    }&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; HasPrefix 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.HasPrefix(&amp;quot;NLT_abc&amp;quot;, &amp;quot;NLT&amp;quot;)) //前缀是以NLT开头的&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; HasSuffix 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.HasSuffix(&amp;quot;NLT_abc&amp;quot;, &amp;quot;abc&amp;quot;)) //后缀是以NLT开头的&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Index 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Index(&amp;quot;NLT_abc&amp;quot;, &amp;quot;abc&amp;quot;)) // 返回第一个匹配字符的位置，这里是4&#xA;    fmt.Println(strings.Index(&amp;quot;NLT_abc&amp;quot;, &amp;quot;aaa&amp;quot;)) // 在存在返回 -1&#xA;    fmt.Println(strings.Index(&amp;quot;我是中国人&amp;quot;, &amp;quot;中&amp;quot;)) // 在存在返回 6&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; IndexAny 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.IndexAny(&amp;quot;我是中国人&amp;quot;, &amp;quot;中&amp;quot;)) // 在存在返回 6&#xA;    fmt.Println(strings.IndexAny(&amp;quot;我是中国人&amp;quot;, &amp;quot;和&amp;quot;)) // 在存在返回 -1&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Index 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.IndexRune(&amp;quot;NLT_abc&amp;quot;, &#39;b&#39;)) // 返回第一个匹配字符的位置，这里是4&#xA;    fmt.Println(strings.IndexRune(&amp;quot;NLT_abc&amp;quot;, &#39;s&#39;)) // 在存在返回 -1&#xA;    fmt.Println(strings.IndexRune(&amp;quot;我是中国人&amp;quot;, &#39;中&#39;)) // 在存在返回 6&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Join 函数的用法&amp;quot;)&#xA;    s := []string{&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;}&#xA;    fmt.Println(strings.Join(s, &amp;quot;, &amp;quot;)) // 返回字符串：foo, bar, baz &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; LastIndex 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.LastIndex(&amp;quot;go gopher&amp;quot;, &amp;quot;go&amp;quot;)) // 3&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; LastIndexAny 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.LastIndexAny(&amp;quot;go gopher&amp;quot;, &amp;quot;go&amp;quot;)) // 4&#xA;    fmt.Println(strings.LastIndexAny(&amp;quot;我是中国人&amp;quot;, &amp;quot;中&amp;quot;)) // 6&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Map 函数的用法&amp;quot;)&#xA;    rot13 := func(r rune) rune {&#xA;    switch {&#xA;    case r &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;Z&#39;:&#xA;    return &#39;A&#39; + (r-&#39;A&#39;+13)%26&#xA;    case r &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; r &amp;lt;= &#39;z&#39;:&#xA;    return &#39;a&#39; + (r-&#39;a&#39;+13)%26&#xA;    }&#xA;    return r&#xA;    }&#xA;    fmt.Println(strings.Map(rot13, &amp;quot;&#39;Twas brillig and the slithy gopher...&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Repeat 函数的用法&amp;quot;)&#xA;    fmt.Println(&amp;quot;ba&amp;quot; + strings.Repeat(&amp;quot;na&amp;quot;, 2)) //banana &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Replace 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;ky&amp;quot;, 2))&#xA;    fmt.Println(strings.Replace(&amp;quot;oink oink oink&amp;quot;, &amp;quot;oink&amp;quot;, &amp;quot;moo&amp;quot;, -1))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Split 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;a,b,c&amp;quot;, &amp;quot;,&amp;quot;))&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;a man a plan a canal panama&amp;quot;, &amp;quot;a &amp;quot;))&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot; xyz &amp;quot;, &amp;quot;&amp;quot;))&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(&amp;quot;&amp;quot;, &amp;quot;Bernardo O&#39;Higgins&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; SplitAfter 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitAfter(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; SplitAfterN 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitAfterN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, 2)) //[&amp;quot;/&amp;quot; &amp;quot;home/m_ta/src&amp;quot;]&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitAfterN(&amp;quot;#home#m_ta#src&amp;quot;, &amp;quot;#&amp;quot;, -1)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; SplitN 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, 1))&#xA;&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, 2)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;/home/m_ta/src&amp;quot;, &amp;quot;/&amp;quot;, -1)) //[&amp;quot;&amp;quot; &amp;quot;home&amp;quot; &amp;quot;m_ta&amp;quot; &amp;quot;src&amp;quot;]&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;home,m_ta,src&amp;quot;, &amp;quot;,&amp;quot;, 2)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.SplitN(&amp;quot;#home#m_ta#src&amp;quot;, &amp;quot;#&amp;quot;, -1)) //[&amp;quot;/&amp;quot; &amp;quot;home/&amp;quot; &amp;quot;m_ta/&amp;quot; &amp;quot;src&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Title 函数的用法&amp;quot;) //这个函数，还真不知道有什么用&#xA;    fmt.Println(strings.Title(&amp;quot;her royal highness&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToLower 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ToLower(&amp;quot;Gopher&amp;quot;)) //gopher &#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToLowerSpecial 函数的用法&amp;quot;)&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToTitle 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ToTitle(&amp;quot;loud noises&amp;quot;))&#xA;    fmt.Println(strings.ToTitle(&amp;quot;loud 中国&amp;quot;))&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Replace 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.Replace(&amp;quot;ABAACEDF&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;a&amp;quot;, 2)) // aBaACEDF&#xA;    //第四个参数小于0，表示所有的都替换， 可以看下golang的文档&#xA;    fmt.Println(strings.Replace(&amp;quot;ABAACEDF&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;a&amp;quot;, -1)) // aBaaCEDF&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; ToUpper 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.ToUpper(&amp;quot;Gopher&amp;quot;)) //GOPHER&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; Trim 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;[%q]&amp;quot;, strings.Trim(&amp;quot; !!! Achtung !!! &amp;quot;, &amp;quot;! &amp;quot;)) // [&amp;quot;Achtung&amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; TrimLeft 函数的用法&amp;quot;)&#xA;    fmt.Printf(&amp;quot;[%q]&amp;quot;, strings.TrimLeft(&amp;quot; !!! Achtung !!! &amp;quot;, &amp;quot;! &amp;quot;)) // [&amp;quot;Achtung !!! &amp;quot;]&#xA;&#xA;    fmt.Println(&amp;quot;&amp;quot;)&#xA;    fmt.Println(&amp;quot; TrimSpace 函数的用法&amp;quot;)&#xA;    fmt.Println(strings.TrimSpace(&amp;quot; \t\n a lone gopher \n\t\r\n&amp;quot;)) // a lone gopher&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;清理&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 删除字符串前后的逗号&#xA;arr := strings.Trim(val,&amp;quot;,&amp;quot;)   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;搜索&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 返回s中第一次出现sep的位置，如果没有返回-1.&#xA;func  Index(s,  sep string)  int&#xA;&#xA;fmt.Println(strings.Index(&amp;quot;chicken&amp;quot;,&amp;quot;ken&amp;quot;))&#xA;fmt.Println(strings.Index(&amp;quot;chicken&amp;quot;,&amp;quot;dmr&amp;quot;))&#xA;&#xA;func  LastIndex(s,  sep string)  int&#xA;// 返回在s中最后一次出现sep的位置，不存在返回-1&#xA;&#xA;func  Count(s,  sep string)  int&#xA;// 统计sep在s中出现的次数，非重叠的，比如s=“eeee”，sep=”ee”,结果返回&#xA;&#xA;fmt.Println(strings.Count(&amp;quot;cheese&amp;quot;,&amp;quot;e&amp;quot;))&#xA;fmt.Println(strings.Count(&amp;quot;five&amp;quot;,&amp;quot;&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;包含&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func  Contains(s,  substr string)  bool&#xA;// 如果substr在s中，返回true&#xA;&#xA;fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;,&amp;quot;foo&amp;quot;))&#xA;fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;,&amp;quot;bar&amp;quot;))&#xA;fmt.Println(strings.Contains(&amp;quot;seafood&amp;quot;,&amp;quot;&amp;quot;))&#xA;fmt.Println(strings.Contains(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;连接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func  Join(a []string,  sep string)  string&#xA;// 连接字符串，以sep作为分隔符&#xA;&#xA;s := []string{&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;,&amp;quot;baz&amp;quot;}&#xA;fmt.Println(strings.Join(s,&amp;quot;, &amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;分割&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func  Split(s,  sep string)  []string&#xA;// 分割字符串，sep为空字串时，与上一篇讲到的一样，相当于每个字符之间的间隔&#xA;// s中没有sep，返回值里只有一个元素s&#xA;&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot;a,b,c&amp;quot;,&amp;quot;,&amp;quot;))&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot;a man a plan a canal panama&amp;quot;,&amp;quot;a &amp;quot;))&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot; xyz &amp;quot;,&amp;quot;&amp;quot;))&#xA;fmt.Printf(&amp;quot;%q\n&amp;quot;,strings.Split(&amp;quot;&amp;quot;,&amp;quot;Bernardo O&#39;Higgins&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package strings&#xA;    import &amp;quot;strings&amp;quot;&#xA;&#xA;    Package strings implements simple functions to manipulate strings.&#xA;&#xA;FUNCTIONS&#xA;&#xA;func Contains(s, substr string) bool&#xA;    Contains returns true if substr is within s.&#xA;&#xA;func ContainsAny(s, chars string) bool&#xA;    ContainsAny returns true if any Unicode code points in chars are within&#xA;    s.&#xA;&#xA;func ContainsRune(s string, r rune) bool&#xA;    ContainsRune returns true if the Unicode code point r is within s.&#xA;&#xA;func Count(s, sep string) int&#xA;    Count counts the number of non-overlapping instances of sep in s.&#xA;&#xA;func EqualFold(s, t string) bool&#xA;    EqualFold reports whether s and t, interpreted as UTF-8 strings, are&#xA;    equal under Unicode case-folding.&#xA;&#xA;func Fields(s string) []string&#xA;    Fields splits the string s around each instance of one or more&#xA;    consecutive white space characters, returning an array of substrings of&#xA;    s or an empty list if s contains only white space.&#xA;&#xA;func FieldsFunc(s string, f func(rune) bool) []string&#xA;    FieldsFunc splits the string s at each run of Unicode code points c&#xA;    satisfying f(c) and returns an array of slices of s. If all code points&#xA;    in s satisfy f(c) or the string is empty, an empty slice is returned.&#xA;&#xA;func HasPrefix(s, prefix string) bool&#xA;    HasPrefix tests whether the string s begins with prefix.&#xA;&#xA;func HasSuffix(s, suffix string) bool&#xA;    HasSuffix tests whether the string s ends with suffix.&#xA;&#xA;func Index(s, sep string) int&#xA;    Index returns the index of the first instance of sep in s, or -1 if sep&#xA;    is not present in s.&#xA;&#xA;func IndexAny(s, chars string) int&#xA;    IndexAny returns the index of the first instance of any Unicode code&#xA;    point from chars in s, or -1 if no Unicode code point from chars is&#xA;    present in s.&#xA;&#xA;func IndexFunc(s string, f func(rune) bool) int&#xA;    IndexFunc returns the index into s of the first Unicode code point&#xA;    satisfying f(c), or -1 if none do.&#xA;&#xA;func IndexRune(s string, r rune) int&#xA;    IndexRune returns the index of the first instance of the Unicode code&#xA;    point r, or -1 if rune is not present in s.&#xA;&#xA;func Join(a []string, sep string) string&#xA;    Join concatenates the elements of a to create a single string. The&#xA;    separator string sep is placed between elements in the resulting string.&#xA;&#xA;func LastIndex(s, sep string) int&#xA;    LastIndex returns the index of the last instance of sep in s, or -1 if&#xA;    sep is not present in s.&#xA;&#xA;func LastIndexAny(s, chars string) int&#xA;    LastIndexAny returns the index of the last instance of any Unicode code&#xA;    point from chars in s, or -1 if no Unicode code point from chars is&#xA;    present in s.&#xA;&#xA;func LastIndexFunc(s string, f func(rune) bool) int&#xA;    LastIndexFunc returns the index into s of the last Unicode code point&#xA;    satisfying f(c), or -1 if none do.&#xA;&#xA;func Map(mapping func(rune) rune, s string) string&#xA;    Map returns a copy of the string s with all its characters modified&#xA;    according to the mapping function. If mapping returns a negative value,&#xA;    the character is dropped from the string with no replacement.&#xA;&#xA;func Repeat(s string, count int) string&#xA;    Repeat returns a new string consisting of count copies of the string s.&#xA;&#xA;func Replace(s, old, new string, n int) string&#xA;    Replace returns a copy of the string s with the first n non-overlapping&#xA;    instances of old replaced by new. If n &amp;lt; 0, there is no limit on the&#xA;    number of replacements.&#xA;&#xA;func Split(s, sep string) []string&#xA;    Split slices s into all substrings separated by sep and returns a slice&#xA;    of the substrings between those separators. If sep is empty, Split&#xA;    splits after each UTF-8 sequence. It is equivalent to SplitN with a&#xA;    count of -1.&#xA;&#xA;func SplitAfter(s, sep string) []string&#xA;    SplitAfter slices s into all substrings after each instance of sep and&#xA;    returns a slice of those substrings. If sep is empty, SplitAfter splits&#xA;    after each UTF-8 sequence. It is equivalent to SplitAfterN with a count&#xA;    of -1.&#xA;&#xA;func SplitAfterN(s, sep string, n int) []string&#xA;    SplitAfterN slices s into substrings after each instance of sep and&#xA;    returns a slice of those substrings. If sep is empty, SplitAfterN splits&#xA;    after each UTF-8 sequence. The count determines the number of substrings&#xA;    to return:&#xA;&#xA;    n &amp;gt; 0: at most n substrings; the last substring will be the unsplit remainder.&#xA;    n == 0: the result is nil (zero substrings)&#xA;    n &amp;lt; 0: all substrings&#xA;&#xA;func SplitN(s, sep string, n int) []string&#xA;    SplitN slices s into substrings separated by sep and returns a slice of&#xA;    the substrings between those separators. If sep is empty, SplitN splits&#xA;    after each UTF-8 sequence. The count determines the number of substrings&#xA;    to return:&#xA;&#xA;    n &amp;gt; 0: at most n substrings; the last substring will be the unsplit remainder.&#xA;    n == 0: the result is nil (zero substrings)&#xA;    n &amp;lt; 0: all substrings&#xA;&#xA;func Title(s string) string&#xA;    Title returns a copy of the string s with all Unicode letters that begin&#xA;    words mapped to their title case.&#xA;&#xA;func ToLower(s string) string&#xA;    ToLower returns a copy of the string s with all Unicode letters mapped&#xA;    to their lower case.&#xA;&#xA;func ToLowerSpecial(_case unicode.SpecialCase, s string) string&#xA;    ToLowerSpecial returns a copy of the string s with all Unicode letters&#xA;    mapped to their lower case, giving priority to the special casing rules.&#xA;&#xA;func ToTitle(s string) string&#xA;    ToTitle returns a copy of the string s with all Unicode letters mapped&#xA;    to their title case.&#xA;&#xA;func ToTitleSpecial(_case unicode.SpecialCase, s string) string&#xA;    ToTitleSpecial returns a copy of the string s with all Unicode letters&#xA;    mapped to their title case, giving priority to the special casing rules.&#xA;&#xA;func ToUpper(s string) string&#xA;    ToUpper returns a copy of the string s with all Unicode letters mapped&#xA;    to their upper case.&#xA;&#xA;func ToUpperSpecial(_case unicode.SpecialCase, s string) string&#xA;    ToUpperSpecial returns a copy of the string s with all Unicode letters&#xA;    mapped to their upper case, giving priority to the special casing rules.&#xA;&#xA;func Trim(s string, cutset string) string&#xA;    Trim returns a slice of the string s with all leading and trailing&#xA;    Unicode code points contained in cutset removed.&#xA;&#xA;func TrimFunc(s string, f func(rune) bool) string&#xA;    TrimFunc returns a slice of the string s with all leading and trailing&#xA;    Unicode code points c satisfying f(c) removed.&#xA;&#xA;func TrimLeft(s string, cutset string) string&#xA;    TrimLeft returns a slice of the string s with all leading Unicode code&#xA;    points contained in cutset removed.&#xA;&#xA;func TrimLeftFunc(s string, f func(rune) bool) string&#xA;    TrimLeftFunc returns a slice of the string s with all leading Unicode&#xA;    code points c satisfying f(c) removed.&#xA;&#xA;func TrimRight(s string, cutset string) string&#xA;    TrimRight returns a slice of the string s, with all trailing Unicode&#xA;    code points contained in cutset removed.&#xA;&#xA;func TrimRightFunc(s string, f func(rune) bool) string&#xA;    TrimRightFunc returns a slice of the string s with all trailing Unicode&#xA;    code points c satisfying f(c) removed.&#xA;&#xA;func TrimSpace(s string) string&#xA;    TrimSpace returns a slice of the string s, with all leading and trailing&#xA;    white space removed, as defined by Unicode.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-压缩-解压-Tar.Gz</title>
      <link>http://www.nljb.net/default/Golang-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B-Tar.Gz/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;golang处理压缩包,我最常用的就是tar.gz了,所以今天写了一个测试一下.代码放这里以后浏览.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//压缩文件&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;archive/tar&amp;quot;&#xA;    &amp;quot;compress/gzip&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    // file write&#xA;    fw, err := os.Create(&amp;quot;tar/lin_golang_src.tar.gz&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer fw.Close()&#xA;&#xA;    // gzip write&#xA;    gw := gzip.NewWriter(fw)&#xA;    defer gw.Close()&#xA;&#xA;    // tar write&#xA;    tw := tar.NewWriter(gw)&#xA;    defer tw.Close()&#xA;&#xA;    // 打开文件夹&#xA;    dir, err := os.Open(&amp;quot;file/&amp;quot;)&#xA;    if err != nil {&#xA;    panic(nil)&#xA;    }&#xA;    defer dir.Close()&#xA;&#xA;    // 读取文件列表&#xA;    fis, err := dir.Readdir(0)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;&#xA;    // 遍历文件列表&#xA;    for _, fi := range fis {&#xA;    // 逃过文件夹, 我这里就不递归了&#xA;    if fi.IsDir() {&#xA;        continue&#xA;    }&#xA;&#xA;    // 打印文件名称&#xA;    fmt.Println(fi.Name())&#xA;&#xA;    // 打开文件&#xA;    fr, err := os.Open(dir.Name() + &amp;quot;/&amp;quot; + fi.Name())&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    defer fr.Close()&#xA;&#xA;    // 信息头&#xA;    h := new(tar.Header)&#xA;    h.Name = fi.Name()&#xA;    h.Size = fi.Size()&#xA;    h.Mode = int64(fi.Mode())&#xA;    h.ModTime = fi.ModTime()&#xA;&#xA;    // 写信息头&#xA;    err = tw.WriteHeader(h)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;    // 写文件&#xA;    _, err = io.Copy(tw, fr)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    }&#xA;&#xA;    fmt.Println(&amp;quot;tar.gz ok&amp;quot;)&#xA;}&#xA;解压文件&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    // &amp;quot;time&amp;quot;&#xA;    &amp;quot;archive/tar&amp;quot;&#xA;    &amp;quot;compress/gzip&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    // file read&#xA;    fr, err := os.Open(&amp;quot;tar/lin_golang_src.tar.gz&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer fr.Close()&#xA;&#xA;    // gzip read&#xA;    gr, err := gzip.NewReader(fr)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    defer gr.Close()&#xA;&#xA;    // tar read&#xA;    tr := tar.NewReader(gr)&#xA;&#xA;    // 读取文件&#xA;    for {&#xA;    h, err := tr.Next()&#xA;    if err == io.EOF {&#xA;        break&#xA;    }&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;    // 显示文件&#xA;    fmt.Println(h.Name)&#xA;&#xA;    // 打开文件&#xA;    fw, err := os.OpenFile(&amp;quot;file2/&amp;quot; + h.Name, os.O_CREATE | os.O_WRONLY, 0644/*os.FileMode(h.Mode)*/)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    defer fw.Close()&#xA;&#xA;    // 写文件&#xA;    _, err = io.Copy(fw, tr)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;    }&#xA;&#xA;    fmt.Println(&amp;quot;un tar.gz ok&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;呼呼,以后打包下载东西的时候可以使用了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.dotcoo.com/golang-tar-gzip&#34;&gt;http://www.dotcoo.com/golang-tar-gzip&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解压Tar文件&#xA;func Untar(file,pathstring) error {&#xA;    // 打开文件&#xA;    f,err:=os.Open(file)&#xA;    iferr!= nil {&#xA;    returnerr&#xA;    }&#xA;    deferf.Close()&#xA;    // 读取GZIP&#xA;    gr,err:=gzip.NewReader(f)&#xA;    iferr!= nil {&#xA;    returnerr&#xA;    }&#xA;    defergr.Close()&#xA;    // 读取TAR&#xA;    tr:=tar.NewReader(gr)&#xA;    for {&#xA;    hdr,err:=tr.Next()&#xA;    iferr==io.EOF{&#xA;        break&#xA;    } else iferr!= nil {&#xA;        returnerr&#xA;    }&#xA;    ifhdr.FileInfo().IsDir() {&#xA;        os.MkdirAll(path+string(os.PathSeparator)+hdr.Name,hdr.FileInfo().Mode())&#xA;    } else {&#xA;        fw,err:=os.OpenFile(path+string(os.PathSeparator)+hdr.Name,os.O_CREATE|os.O_WRONLY|os.O_TRUNC,hdr.FileInfo().Mode())&#xA;        iferr!= nil {&#xA;        returnerr&#xA;        }&#xA;        deferfw.Close()&#xA;        _,err=io.Copy(fw,tr)&#xA;        iferr!= nil {&#xA;        returnerr&#xA;        }&#xA;    }&#xA;    }&#xA;    return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-判断文件是否存在</title>
      <link>http://www.nljb.net/default/Golang-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;golang判断文件是否存在有点怪异&lt;/p&gt;&#xA;&#xA;&lt;p&gt;是判断在操作文件时返回的错误信息来判断的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不能直接根据路径判断,感觉怪异.呵呵&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main     &#xA;import (&#xA;     &amp;quot;fmt&amp;quot;&#xA;     &amp;quot;os&amp;quot; &#xA;)&#xA;&#xA;func main() {&#xA;&#xA;     f, err := os.Open(&amp;quot;dotcoo.com.txt&amp;quot;)&#xA;     if err != nil &amp;amp;&amp;amp; os.IsNotExist(err) {&#xA;     fmt.Printf(&amp;quot;file not exist!\n&amp;quot;)&#xA;     return&#xA;     }&#xA;     fmt.Printf(&amp;quot;file exist!\n&amp;quot;)&#xA;     defer f.Close()&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-创建守护进程</title>
      <link>http://www.nljb.net/default/Golang-%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;os/exec&amp;quot;&#xA;    &amp;quot;path/filepath&amp;quot;&#xA;)&#xA;&#xA;if os.Getppid()!=1{&#xA;&#xA;    //判断当其是否是子进程，当父进程return之后，子进程会被 系统1 号进程接管&#xA;    filePath,_:=filepath.Abs(os.Args[0])  //将命令行参数中执行文件路径转换成可用路径&#xA;    cmd:=exec.Command(filePath,os.Args[1:]...)//将其他命令传入生成出的进程&#xA;    cmd.Stdin=os.Stdin //给新进程设置文件描述符，可以重定向到文件中&#xA;    cmd.Stdout=os.Stdout&#xA;    cmd.Stderr=os.Stderr&#xA;    cmd.Start() //开始执行新进程，不等待新进程退出&#xA;    return&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样可以创建守护进程，并且可以接受信号量&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一种方式&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if os.Getppid()!=1{   &#xA;    args:=append([]string{filePath},os.Args[1:]...)&#xA;    os.StartProcess(filePath,args,&amp;amp;os.ProcAttr{Files:[]*os.File{os.Stdin,os.Stdout,os.Stderr}})&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也可以创建守护进程，文档上说startProcess是更底层的接口，cmd是高级的接口&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实还可以更低层&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pid, _, sysErr := syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)&#xA;    if sysErr != 0 {&#xA;    Utils.LogErr(sysErr)&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;go源码中其实就是这么生成新进程的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;直接调用系统函数fork来生成新进程，只是这样不知道为什么总是注册不了信号量处理函数&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-内置的类型和函数</title>
      <link>http://www.nljb.net/default/Golang-%E5%86%85%E7%BD%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;具体见&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://golang.org/pkg/builtin/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;内置类型&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;值类型：&#xA;bool&#xA;int(32 or 64), int8, int16, int32, int64&#xA;uint(32 or 64), uint8(byte), uint16, uint32, uint64&#xA;float32, float64&#xA;string&#xA;complex64, complex128&#xA;array    -- 固定长度的数组&#xA;&#xA;引用类型：(指针类型)&#xA;slice   -- 序列数组(最常用)&#xA;map        -- 映射&#xA;chan    -- 管道&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;内置函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;append  -- 把东西增加到slice里面,返回修改后的slice&#xA;close   -- 关闭channel&#xA;delete    -- 从map中删除key对应的value&#xA;panic    -- 停止常规的goroutine&#xA;recover -- 允许程序定义goroutine的panic动作&#xA;imag    -- 返回complex的实部&#xA;real    -- 返回complex的虚部&#xA;make    -- 返回Type本身(只能应用于slice, map, channel)&#xA;new        -- 返回指向Type的指针&#xA;cap        -- 容量，容积capacity&#xA;copy    -- 复制slice，返回复制的数目&#xA;len        -- 返回长度&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;内置接口&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type error interface {&#xA;    //只要实现了Error()函数，返回值为String的都实现了err接口&#xA;    Error()    String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-上传-and-接收-文件</title>
      <link>http://www.nljb.net/default/Golang-%E4%B8%8A%E4%BC%A0-and-%E6%8E%A5%E6%94%B6-%E6%96%87%E4%BB%B6/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;)&#xA;&#xA;// 获取大小的借口&#xA;type Sizer interface {&#xA;    Size() int64&#xA;}&#xA;&#xA;// hello world, the web server&#xA;func HelloServer(w http.ResponseWriter, r *http.Request) {&#xA;    if &amp;quot;POST&amp;quot; == r.Method {&#xA;    file, _, err := r.FormFile(&amp;quot;userfile&amp;quot;)&#xA;    if err != nil {&#xA;        http.Error(w, err.Error(), 500)&#xA;        return&#xA;    }&#xA;    defer file.Close()&#xA;    f,err:=os.Create(&amp;quot;filenametosaveas&amp;quot;)&#xA;    defer f.Close()&#xA;    io.Copy(f,file)&#xA;fmt.Fprintf(w, &amp;quot;上传文件的大小为: %d&amp;quot;, file.(Sizer).Size())&#xA;    return&#xA;    }&#xA;&#xA;    // 上传页面&#xA;    w.Header().Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html&amp;quot;)&#xA;    w.WriteHeader(200)&#xA;    html := `&#xA;&amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;/hello&amp;quot; method=&amp;quot;POST&amp;quot;&amp;gt;&#xA;    Send this file: &amp;lt;input name=&amp;quot;userfile&amp;quot; type=&amp;quot;file&amp;quot; /&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Send File&amp;quot; /&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;`&#xA;    io.WriteString(w, html)&#xA;}&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/hello&amp;quot;, HelloServer)&#xA;    err := http.ListenAndServe(&amp;quot;:12345&amp;quot;, nil)&#xA;    if err != nil {&#xA;    log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)&#xA;    }&#xA;}&#xA;&#xA;客户端上传文件代码：&#xA; func Upload() (err error) {&#xA;    // Create buffer&#xA;    buf := new(bytes.Buffer) // caveat IMO dont use this for large files, \&#xA;    // create a tmpfile and assemble your multipart from there (not tested)&#xA;    w := multipart.NewWriter(buf)&#xA;    // Create file field&#xA;    fw, err := w.CreateFormFile(&amp;quot;file&amp;quot;, &amp;quot;helloworld.go&amp;quot;) //这里的file很重要，必须和服务器端的FormFile一致&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;c&amp;quot;)&#xA;    return err&#xA;    }&#xA;    fd, err := os.Open(&amp;quot;helloworld.go&amp;quot;)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;d&amp;quot;)&#xA;    return err&#xA;    }&#xA;    defer fd.Close()&#xA;    // Write file field from file to upload&#xA;    _, err = io.Copy(fw, fd)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;e&amp;quot;)&#xA;    return err&#xA;    }&#xA;    // Important if you do not close the multipart writer you will not have a&#xA;    // terminating boundry&#xA;    w.Close()&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;,&amp;quot;http://192.168.2.127/configure.go?portId=2&amp;quot;, buf)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;f&amp;quot;)&#xA;    return err&#xA;    }&#xA;    req.Header.Set(&amp;quot;Content-Type&amp;quot;, w.FormDataContentType())&#xA;      var client http.Client&#xA;    res, err := client.Do(req)&#xA;    if err != nil {&#xA;    fmt.Println(&amp;quot;g&amp;quot;)&#xA;    return err&#xA;    }&#xA;    io.Copy(os.Stderr, res.Body) // Replace this with Status.Code check&#xA;    fmt.Println(&amp;quot;h&amp;quot;)&#xA;    return err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;处理文件上传&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你想处理一个由用户上传的文件，比如你正在建设一个类似Instagram的网站，你需要存储用户拍摄的照片。这种需求该如何实现呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要使表单能够上传文件，首先第一步就是要添加form的&lt;code&gt;enctype&lt;/code&gt;属性，&lt;code&gt;enctype&lt;/code&gt;属性有如下三种情况:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;text/plain 空格转换为 &amp;ldquo;+&amp;rdquo; 加号，但不对特殊字符编码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以，表单的html代码应该类似于:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;&amp;lt;title&amp;gt;上传文件&amp;lt;/title&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&amp;lt;form enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;http://127.0.0.1:9090/upload&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;&#xA; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;uploadfile&amp;quot; /&amp;gt;&#xA; &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;token&amp;quot; value=&amp;quot;{...{.}...}&amp;quot;/&amp;gt;&#xA; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;upload&amp;quot; /&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在服务器端，我们增加一个handlerFunc:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http.HandleFunc(&amp;quot;/upload&amp;quot;, upload)&#xA;&#xA;// 处理/upload 逻辑&#xA;func upload(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Println(&amp;quot;method:&amp;quot;, r.Method) //获取请求的方法&#xA;    if r.Method == &amp;quot;GET&amp;quot; {&#xA;        crutime := time.Now().Unix()&#xA;        h := md5.New()&#xA;        io.WriteString(h, strconv.FormatInt(crutime, 10))&#xA;        token := fmt.Sprintf(&amp;quot;%x&amp;quot;, h.Sum(nil))&#xA;        t, _ := template.ParseFiles(&amp;quot;upload.gtpl&amp;quot;)&#xA;        t.Execute(w, token)&#xA;    } else {&#xA;        r.ParseMultipartForm(32 &amp;lt;&amp;lt; 20)&#xA;        file, handler, err := r.FormFile(&amp;quot;uploadfile&amp;quot;)&#xA;        if err != nil {&#xA;            fmt.Println(err)&#xA;            return&#xA;        }&#xA;        defer file.Close()&#xA;        fmt.Fprintf(w, &amp;quot;%v&amp;quot;, handler.Header)&#xA;        f, err := os.OpenFile(&amp;quot;./test/&amp;quot;+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)&#xA;        if err != nil {&#xA;            fmt.Println(err)&#xA;            return&#xA;        }&#xA;        defer f.Close()&#xA;        io.Copy(f, file)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过上面的代码可以看到，处理文件上传我们需要调用&lt;code&gt;r.ParseMultipartForm&lt;/code&gt;，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;里面的参数表示&lt;code&gt;maxMemory&lt;/code&gt;，调用&lt;code&gt;ParseMultipartForm&lt;/code&gt;之后，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;上传的文件存储在&lt;code&gt;maxMemory&lt;/code&gt;大小的内存里面，如果文件大小超过了&lt;code&gt;maxMemory&lt;/code&gt;，那么剩下的部分将存储在系统的临时文件中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以通过&lt;code&gt;r.FormFile&lt;/code&gt;获取上面的文件句柄，然后实例中使用了&lt;code&gt;io.Copy&lt;/code&gt;来存储文件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取其他非文件字段信息的时候就不需要调用&lt;code&gt;r.ParseForm&lt;/code&gt;，因为在需要的时候Go自动会去调用。而且&lt;code&gt;ParseMultipartForm&lt;/code&gt;调用一次之后，后面再次调用不会再有效果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过上面的实例我们可以看到我们上传文件主要三步处理：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 表单中增加enctype=&amp;quot;multipart/form-data&amp;quot;&#xA;2. 服务端调用`r.ParseMultipartForm`,把上传的文件存储在内存和临时文件中&#xA;3. 使用`r.FormFile`获取文件句柄，然后对文件进行存储等处理。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;文件handler是multipart.FileHeader,里面存储了如下结构信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type FileHeader struct {&#xA;Filename string&#xA;Header   textproto.MIMEHeader&#xA;// contains filtered or unexported fields&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们通过上面的实例代码打印出来上传文件的信息如下&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;![](images/4.5.upload2.png?raw=true)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打印文件上传后服务器端接受的信息&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;客户端上传文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我们上面的例子演示了如何通过表单上传文件，然后在服务器端处理文件，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实Go支持模拟客户端表单功能支持文件上传，详细用法请看如下示例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;&amp;quot;bytes&amp;quot;&#xA;&amp;quot;fmt&amp;quot;&#xA;&amp;quot;io&amp;quot;&#xA;&amp;quot;io/ioutil&amp;quot;&#xA;&amp;quot;mime/multipart&amp;quot;&#xA;&amp;quot;net/http&amp;quot;&#xA;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func postFile(filename string, targetUrl string) error {&#xA;    bodyBuf := &amp;amp;bytes.Buffer{}&#xA;    bodyWriter := multipart.NewWriter(bodyBuf)&#xA;&#xA;    //关键的一步操作&#xA;    fileWriter, err := bodyWriter.CreateFormFile(&amp;quot;uploadfile&amp;quot;, filename)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;error writing to buffer&amp;quot;)&#xA;        return err&#xA;    }&#xA;&#xA;    //打开文件句柄操作&#xA;    fh, err := os.Open(filename)&#xA;    if err != nil {&#xA;        fmt.Println(&amp;quot;error opening file&amp;quot;)&#xA;        return err&#xA;    }&#xA;&#xA;    //iocopy&#xA;    _, err = io.Copy(fileWriter, fh)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;&#xA;    contentType := bodyWriter.FormDataContentType()&#xA;    bodyWriter.Close()&#xA;&#xA;    resp, err := http.Post(targetUrl, contentType, bodyBuf)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    defer resp.Body.Close()&#xA;    resp_body, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    fmt.Println(resp.Status)&#xA;    fmt.Println(string(resp_body))&#xA;    return nil&#xA;}&#xA;&#xA;// sample usage&#xA;func main() {&#xA;    target_url := &amp;quot;http://localhost:9090/upload&amp;quot;&#xA;    filename := &amp;quot;./astaxie.pdf&amp;quot;&#xA;    postFile(filename, target_url)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面的例子详细展示了客户端如何向服务器上传一个文件的例子，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端通过multipart.Write把文件的文本流写入一个缓存中，然后调用http的Post方法把缓存传到服务器。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你还有其他普通字段例如username之类的需要同时写入，那么可以调用multipart的WriteField方法写很多其他类似的字段。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-udp-服务端-and-客户端</title>
      <link>http://www.nljb.net/default/Golang-udp-%E6%9C%8D%E5%8A%A1%E7%AB%AF-and-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;其实udp没有什么服务端和客户端的概念了,只是一个发一个收而已,只是这样叫方便能识别和理解.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务端:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-udp-服务端-and-客户端/1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-udp-服务端-and-客户端/2.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-too_many_open_files-解决方法</title>
      <link>http://www.nljb.net/default/Golang-too_many_open_files-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这是系统资源限制，通常单进程不能超过 1024，我使用cgo来设置，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;/*&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;sys/time.h&amp;gt;&#xA;#include &amp;lt;sys/resource.h&amp;gt;&#xA;&#xA;int rlimit_init() {&#xA;    printf(&amp;quot;setting rlimit\n&amp;quot;);&#xA;&#xA;    struct rlimit limit;&#xA;&#xA;    if (getrlimit(RLIMIT_NOFILE, &amp;amp;limit) == -1) {&#xA;    printf(&amp;quot;getrlimit error\n&amp;quot;);&#xA;    return 1;&#xA;    }&#xA;&#xA;    limit.rlim_cur = limit.rlim_max = 50000;&#xA;&#xA;    if (setrlimit(RLIMIT_NOFILE, &amp;amp;limit) == -1) {&#xA;    printf(&amp;quot;setrlimit error\n&amp;quot;);&#xA;    return 1;&#xA;    }&#xA;&#xA;    printf(&amp;quot;set limit ok\n&amp;quot;);&#xA;    return 0;&#xA;}&#xA;*/&#xA;import &amp;quot;C&amp;quot;&#xA;&#xA;func main() {&#xA;    C.rlimit_init()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者使用 syscall 包&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var rlim syscall.Rlimit&#xA;err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &amp;amp;rlim)&#xA;if err != nil {&#xA;    fmt.Println(&amp;quot;get rlimit error: &amp;quot; + err.Error())&#xA;    os.Exit(1)&#xA;}&#xA;rlim.Cur = 50000&#xA;rlim.Max = 50000&#xA;err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &amp;amp;rlim)&#xA;if err != nil {&#xA;    fmt.Println(&amp;quot;set rlimit error: &amp;quot; + err.Error())&#xA;    os.Exit(1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用 go build 编译后，需要以 root 权限运行。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-strconv</title>
      <link>http://www.nljb.net/default/Golang-strconv/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;a:=strconv.FormatFloat(10.100,&#39;f&#39;,-1,32) 输出:10.1&#xA;&#xA;a := strconv.FormatFloat(10.101, &#39;f&#39;, -1, 64) 输出:10.101&#xA;&#xA;a := strconv.FormatFloat(10.010, &#39;f&#39;, -1, 64) 输出：10.01&#xA;&#xA;a:=strconv.FormatFloat(10.1,&#39;f&#39;,2,64) 输出:10.10&#xA;&#xA;f 参数可以时e,E,g,G&#xA;-1 代表输出的精度小数点后的位数&#xA;如果是&amp;lt;0的值，则返回最少的位数来表示该数，如果是大于0的则返回对应位数的值&#xA;64 为float的类型，go中float分为32和64位，因此就需要传入32或者64&#xA;&#xA;golang strconv.ParseInt 是将字符串转换为数字的函数,功能灰常之强大,看的我口水直流.&#xA;&#xA;func ParseInt(s string, base int, bitSize int) (i int64, err error)&#xA;&#xA;参数1 数字的字符串形式&#xA;&#xA;参数2 数字字符串的进制 比如二进制 八进制 十进制 十六进制&#xA;&#xA;参数3 返回结果的bit大小 也就是int8 int16 int32 int64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    i, err := strconv.ParseInt(&amp;quot;123&amp;quot;, 10, 32)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;    println(i)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-int-转-string</title>
      <link>http://www.nljb.net/default/Golang-int-%E8%BD%AC-string/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;go语言中int类型和string类型都是属于基本数据类型&lt;/p&gt;&#xA;&#xA;&lt;p&gt;两种类型的转化都非常简单&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面为大家提供两种int类型转化成string类型的方法！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go语言的类型转化都在strconv package里面，详情请参考：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://golang.org/pkg/strconv&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面附上转化代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main  &#xA;&#xA;import (  &#xA;    &amp;quot;fmt&amp;quot;  &#xA;    &amp;quot;strconv&amp;quot;  &#xA;)  &#xA;&#xA;var i int = 10  &#xA;&#xA;func main() {  &#xA;    // 通过Itoa方法转换  &#xA;    str1 := strconv.Itoa(i)  &#xA;&#xA;    // 通过Sprintf方法转换  &#xA;    str2 := fmt.Sprintf(&amp;quot;%d&amp;quot;, i)  &#xA;&#xA;    // 打印str1  &#xA;    fmt.Println(str1)  &#xA;    // 打印str2  &#xA;    fmt.Println(str2)  &#xA;}  &#xA;&#xA;%d代表Integer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-cmd.Process</title>
      <link>http://www.nljb.net/default/Golang-cmd.Process/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;d := flag.Bool(&amp;quot;d&amp;quot;, false, &amp;quot;Whether or not to launch in the background(like a daemon)&amp;quot;)&#xA;if *d {&#xA;    cmd := exec.Command(os.Args[0],&#xA;    &amp;quot;-close-fds&amp;quot;,&#xA;    &amp;quot;-addr&amp;quot;, *addr,&#xA;    &amp;quot;-call&amp;quot;, *call,&#xA;    )&#xA;    serr, err := cmd.StderrPipe()&#xA;    if err != nil {&#xA;    log.Fatalln(err)&#xA;    }&#xA;    err = cmd.Start()&#xA;    if err != nil {&#xA;    log.Fatalln(err)&#xA;    }&#xA;    s, err := ioutil.ReadAll(serr)&#xA;    s = bytes.TrimSpace(s)&#xA;    if bytes.HasPrefix(s, []byte(&amp;quot;addr: &amp;quot;)) {&#xA;    fmt.Println(string(s))&#xA;    cmd.Process.Release()&#xA;    } else {&#xA;    log.Printf(&amp;quot;unexpected response from MarGo: `%s` error: `%v`\n&amp;quot;, s, err)&#xA;    cmd.Process.Kill()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* ivan(a.t)mysqlab.net */&#xA;package main&#xA;&#xA;import (&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;syscall&amp;quot;&#xA;)&#xA;&#xA;func daemon(nochdir, noclose int) int {&#xA;    var ret, ret2 uintptr&#xA;    var err uintptr&#xA;&#xA;    darwin := syscall.OS == &amp;quot;darwin&amp;quot;&#xA;&#xA;    // already a daemon&#xA;    if syscall.Getppid() == 1 {&#xA;    return 0&#xA;    }&#xA;&#xA;    // fork off the parent process&#xA;    ret, ret2, err = syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)&#xA;    if err != 0 {&#xA;    return -1&#xA;    }&#xA;&#xA;    // failure&#xA;    if ret2 &amp;lt; 0 {&#xA;    os.Exit(-1)&#xA;    }&#xA;&#xA;    // handle exception for darwin&#xA;    if darwin &amp;amp;&amp;amp; ret2 == 1 {&#xA;    ret = 0&#xA;    }&#xA;&#xA;    // if we got a good PID, then we call exit the parent process.&#xA;    if ret &amp;gt; 0 {&#xA;    os.Exit(0)&#xA;    }&#xA;&#xA;    /* Change the file mode mask */&#xA;    _ = syscall.Umask(0)&#xA;&#xA;    // create a new SID for the child process&#xA;    s_ret, s_errno := syscall.Setsid()&#xA;    if s_errno != 0 {&#xA;    log.Printf(&amp;quot;Error: syscall.Setsid errno: %d&amp;quot;, s_errno)&#xA;    }&#xA;    if s_ret &amp;lt; 0 {&#xA;    return -1&#xA;    }&#xA;&#xA;    if nochdir == 0 {&#xA;    os.Chdir(&amp;quot;/&amp;quot;)&#xA;    }&#xA;&#xA;    if noclose == 0 {&#xA;    f, e := os.OpenFile(&amp;quot;/dev/null&amp;quot;, os.O_RDWR, 0)&#xA;    if e == nil {&#xA;        fd := f.Fd()&#xA;        syscall.Dup2(fd, os.Stdin.Fd())&#xA;        syscall.Dup2(fd, os.Stdout.Fd())&#xA;        syscall.Dup2(fd, os.Stderr.Fd())&#xA;    }&#xA;    }&#xA;&#xA;    return 0&#xA;}&#xA;&#xA;// usage example: daemon(0, 0)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/DisposaBoy/MarGo&#34;&gt;https://github.com/DisposaBoy/MarGo&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.mysqlab.net/blog/2011/12/daemon-function-for-go-language/&#34;&gt;http://www.mysqlab.net/blog/2011/12/daemon-function-for-go-language/&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-GoSerial</title>
      <link>http://www.nljb.net/default/Golang-GoSerial/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img src=&#34;/assets/media/Golang-GoSerial/e824b899a9014c08f85495470a7b02087af4f4e1.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tarm/goserial&#34;&gt;https://github.com/tarm/goserial&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要预先通过go get github.com/tarm/goserial获取git地址&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后通过,下载&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/tarm/goserial /root/go/src/pkg/github.com/tarm/goserial&#xA;&#xA;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;import &amp;quot;github.com/tarm/goserial&amp;quot;&#xA;&#xA;func main(){&#xA;&#xA;    c := &amp;amp;serial.Config{Name: &amp;quot;/dev/ttyUSB0&amp;quot;, Baud: 115200}&#xA;    s, err := serial.OpenPort(c)&#xA;    if err != nil {&#xA;    fmt.Println(err)&#xA;    }&#xA;    n, err := s.Write([]byte(&amp;quot;ATZ+CSQ\r&amp;quot;))&#xA;    if err != nil {&#xA;    fmt.Println(err)&#xA;    }&#xA;    buf := make([]byte, 2048)&#xA;    n, err = s.Read(buf)&#xA;    if err != nil {&#xA;    fmt.Println(err)&#xA;    }&#xA;    fmt.Printf(&amp;quot;%q&amp;quot;, buf[:n])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后 go build 编译即可，需要安装GCC&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Get-exit-code</title>
      <link>http://www.nljb.net/default/Golang-Get-exit-code/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;os/exec&amp;quot;&#xA;import &amp;quot;log&amp;quot;&#xA;import &amp;quot;syscall&amp;quot;&#xA;&#xA;func main() {&#xA;    cmd := exec.Command(&amp;quot;git&amp;quot;, &amp;quot;blub&amp;quot;)&#xA;&#xA;    if err := cmd.Start(); err != nil {&#xA;    log.Fatalf(&amp;quot;cmd.Start: %v&amp;quot;)&#xA;    }&#xA;&#xA;    if err := cmd.Wait(); err != nil {&#xA;    if exiterr, ok := err.(*exec.ExitError); ok {&#xA;        // The program has exited with an exit code != 0&#xA;&#xA;        // There is no plattform independent way to retrieve&#xA;        // the exit code, but the following will work on Unix&#xA;        if status, ok := exiterr.Sys().(syscall.WaitStatus); ok {&#xA;        log.Printf(&amp;quot;Exit Status: %d&amp;quot;, status.ExitStatus())&#xA;        }&#xA;    } else {&#xA;        log.Fatalf(&amp;quot;cmd.Wait: %v&amp;quot;, err)&#xA;    }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go-ioutil-翻译</title>
      <link>http://www.nljb.net/default/Go-ioutil-%E7%BF%BB%E8%AF%91/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;ioutil包&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;io/ioutil&amp;quot;&#xA;ioutil包含有一些公用的I/O工具函数。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;变量&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var Discard io.Writer = devNull(0)&#xA;Discard是一个io.Writer，对其进行的所有Write呼叫都会成功但不会做任何实际的操作。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func NopCloser&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func NopCloser(r io.Reader) io.ReadCloser&#xA;NopCloser返回一个包装r参数而来的ReadCloser接口，该接口仅提供Close方法。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func ReadAll&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadAll(r io.Reader) ([]byte, error)&#xA;ReadAll从r读取直到遇到error或EOF并返回读取的数据。 成功的调用返回的err为nil，而不是EOF。因为ReadAll定义为从资源读取数据直到EOF，它不会将从r读取的EOF视为应该报告的错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func ReadDir&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadDir(dirname string) ([]os.FileInfo, error)&#xA;ReadDir接受dirname指定的目录，并返回一个有序的、子目录信息的列表。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func ReadFile&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadFile(filename string) ([]byte, error)&#xA;ReadFile从filename指定的文件中读取数据并返回文件的内容。 成功的调用返回的err为nil，而不是EOF。因为ReadFile定义为从资源读取数据直到EOF，它不会将从r读取的EOF视为应该报告的错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func TempDir&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func TempDir(dir, prefix string) (name string, err error)&#xA;TempDir在指定的目录里创建一个新的、使用prfix作为前缀的临时文件夹，并返回文件夹的路径。 如果dir是空字符串，TempDir使用默认用于临时文件的目录（参见os.TempDir函数）。 如果多个程序调用该函数的话，将会创建不同的临时目录（因此是线程安全的）。调用本函数的程序有责任在不需要临时文件夹时摧毁它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func TempFile&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func TempFile(dir, prefix string) (f *os.File, err error)&#xA;TempFile在dir目录下创建一个新的、使用prefix为前缀的临时文件，并以读写模式打开该文件并返回os.File指针。 如果dir是空字符串，TempFile使用默认用于临时文件的目录（参见os.TempDir函数）。 如果多个程序调用该函数的话，将会创建不同的临时文件（因此是线程安全的）。调用本函数的程序有责任在不需要临时文件时摧毁它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;func WriteFile&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func WriteFile(filename string, data []byte, perm os.FileMode) error&#xA;WriteFile向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建该文件，否则本函数会在写入数据之前截断文件（即清空之）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Connection-close</title>
      <link>http://www.nljb.net/default/Connection-close/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;Set(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;) &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Bash-语法参数</title>
      <link>http://www.nljb.net/default/Bash-%E8%AF%AD%E6%B3%95%E5%8F%82%E6%95%B0/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;[ -a FILE ] 如果 FILE 存在则为真。&#xA;[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。&#xA;[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。&#xA;[ -d FILE ] 如果 FILE 存在且是一个目录则为真。&#xA;[ -e FILE ] 如果 FILE 存在则为真。&#xA;[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。&#xA;[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。&#xA;[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。&#xA;[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。&#xA;[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。&#xA;[ -r FILE ] 如果 FILE 存在且是可读的则为真。&#xA;[ -s FILE ] 如果 FILE 存在且大小不为0则为真。&#xA;[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。&#xA;[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。&#xA;[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。&#xA;[ -x FILE ] 如果 FILE 存在且是可执行的则为真。&#xA;[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。&#xA;[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。&#xA;[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。&#xA;[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。&#xA;[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。&#xA;[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1FILE2 does not则为真。&#xA;exists and [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。&#xA;[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。&#xA;[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。&#xA;[ -z STRING ] “STRING” 的长度为零则为真。&#xA;[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。&#xA;[ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。&#xA;[ STRING1 != STRING2 ] 如果字符串不相等则为真。&#xA;[ STRING1 &amp;lt; STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。&#xA;[ STRING1 &amp;gt; STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。&#xA;[ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers. 表达式可以借以下操作符组合起来，以降序列出：listed in decreasing order of precedence: 表 7.2. 组合表达式操作 效果&#xA;[ ! EXPR ] 如果 EXPR 是false则为真。&#xA;[ ( EXPR ) ] 返回 EXPR的值。这样可以用来忽略正常的操作符优先级。&#xA;[ EXPR1 -a EXPR2 ] 如果 EXPR1 and EXPR2 全真则为真。&#xA;[ EXPR1 -o EXPR2 ] 如果 EXPR1 或者 EXPR2 为真则为真。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;比较字符写法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;-eq 等于&#xA;-ne 不等于&#xA;-gt 大于&#xA;-lt 小于&#xA;-le 小于等于&#xA;-ge 大于等于&#xA;-z 空串&#xA;* = 两个字符相等&#xA;* != 两个字符不等&#xA;* -n 非空串&#xA;&#xA;从大到小排序是:ls -S  /&#xA;从小到大排就加个-r:  ls -Sr  /&#xA;包括隐藏文件就是：ls -aSr  /&#xA;ls -l 是长格式显示&#xA;ls -a 是包含隐藏文件&#xA;所以一般使用ls -la &#xA;&#xA;不可以，sort是处理数据流的，一般以行为单位，把每行按某种条件排列&#xA;如字母顺序、数字大小&#xA;它可以排列从文件内读取的数据&#xA;ls | sort 这个命令排列的也仅是文件名而已&#xA;ls -tr&#xA;-r 对目录反向排序。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>求两个矩阵相交面积</title>
      <link>http://www.nljb.net/default/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BA%A4%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;public class Rectangle&#xA;    {&#xA;        public int x1;&#xA;        public int y1;&#xA;        public int x2;&#xA;        public int y2;&#xA;        public Rectangle(int x1, int y1, int x2, int y2)&#xA;        {&#xA;        this.x1 = x1;&#xA;        this.y1 = y1;&#xA;        this.x2 = x2;&#xA;        this.y2 = y2;&#xA;        }&#xA;    }&#xA;&#xA;    static int RectangleArea(Rectangle r1, Rectangle r2)&#xA;    {&#xA;        int maxx = Math.Max(r1.x1, r2.x1);&#xA;        int minx = Math.Min(r1.x2, r2.x2);&#xA;        int maxy = Math.Max(r1.y1, r2.y1);&#xA;        int miny = Math.Min(r1.y2, r2.y2);&#xA;&#xA;        if (minx&amp;gt;maxx &amp;amp;&amp;amp; miny &amp;gt; maxy )&#xA;        {&#xA;        return (maxx - minx) * (maxy - miny);&#xA;        }&#xA;        else&#xA;        {&#xA;        return 0;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>把Go程序变小的办法</title>
      <link>http://www.nljb.net/default/%E6%8A%8AGo%E7%A8%8B%E5%BA%8F%E5%8F%98%E5%B0%8F%E7%9A%84%E5%8A%9E%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;把Go程序变小的办法是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go build -ldflags “-s -w” (go install类似)&#xA;&#xA;-s去掉符号表（然后panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果）&#xA;&#xA;-w去掉DWARF调试信息，得到的程序就不能用gdb调试了。&#xA;&#xA;&#xA;比如，server.go是一个简单的http server，用了net/http包。&#xA;&#xA;$ go build server.go&#xA;$ ls -l server&#xA;-rwxr-xr-x 1 minux staff 4507004 2012-10-25 14:16 server&#xA;$ go build -ldflags “-s -w” server.go &#xA;$ ls -l server&#xA;-rwxr-xr-x 1 minux staff 2839932 2012-10-25 14:16 server&#xA;&#xA;&#xA;-s和-w也可以分开使用，一般来说如果不打算用gdb调试，-w基本没啥损失。&#xA;&#xA;-s的损失就有点大了。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>内存系统打包方式</title>
      <link>http://www.nljb.net/default/%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;解压方法：&#xA;&#xA;###################################################&#xA;&#xA;cp initrd-2.6.24.img /home/kernel/initrd.gz　&#xA;cd /home/kernel/&#xA;gunzip -dc initrd | cpio -idmv&#xA;&#xA;###################################################&#xA;&#xA;cd /tmp &#xA;mkdir initrd &#xA;cp /boot/initrd-2.6.18-8.el5xen.img /tmp/initrd/initrd-2.6.18-8.el5xen.img.gz &#xA;cd initrd &#xA;gunzip initrd-2.6.18-8.el5xen.img.gz &#xA;cpio -ivdI initrd-2.6.18-8.el5xen.img&#xA;&#xA;########################################################&#xA;&#xA;压缩方法&#xA;find . | cpio -ocv &amp;gt;../initrd.img&#xA;find  .  -print | cpio -covB &amp;gt; [file|device] 将数据备份到文件或设备上&#xA;然后使用&#xA;gzip 压缩生成后的文件&#xA;&#xA;########################################################&#xA;&#xA;解压cpio文件 &#xA;cpio -idmv &amp;lt; filename.cpio&#xA;同样可以解压img文件：&#xA;cpio -idmv &amp;lt; filename.img&#xA;cpio备份命令&#xA;备份：cpio -covB &amp;gt; [file|device] 将数据备份到文件或设备上&#xA;还原：cpio -icduv &amp;lt; [file|device} 将数据还原到系统中&#xA;常用参数：&#xA;-o ：将数据copy到文件或设备上&#xA;-i ：将数据从文件或设备上还原到系统中&#xA;-t ：查看cpio建立的文件或设备内容&#xA;-c ：一种比较新的portable format方式存储&#xA;-v ：在屏幕上显示备份过程中的文件名&#xA;-B ：让预设的blocks可以增加到5120bytes，默认是512bytes，这样可以使备份速度加快&#xA;-d ：自动建立目录，这样还原时才不会出现找不到路径的问题&#xA;-u ：更新，用较新的文件覆盖旧的文件&#xA;cpio常与find 配合使用&#xA;&#xA;###############################################################################&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>一个简单的播放器</title>
      <link>http://www.nljb.net/default/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 简单了解，写了一个播放器&#xA;#include&amp;lt;iostream&amp;gt;&#xA;extern &amp;quot;C&amp;quot; {&#xA;#include &amp;lt;libavcodec/avcodec.h&amp;gt;&#xA;#include &amp;lt;libavformat/avformat.h&amp;gt;&#xA;#include &amp;lt;libswscale/swscale.h&amp;gt;&#xA;#include &amp;lt;SDL/SDL.h&amp;gt;&#xA;#include &amp;lt;SDL/SDL_image.h&amp;gt;&#xA;#include &amp;lt;SDL/SDL_thread.h&amp;gt;&#xA;}&#xA;&#xA;using namespace std;&#xA;&#xA;int main(int argc, char* argv[]) {&#xA;&#xA;    // 注册了所有的文件格式和编解码的库，它们将被自动的使用在被打开的合适格式的文件上&#xA;    av_register_all();&#xA;&#xA;    // AVFormatContext是FFMpeg格式转换过程中实现输入和输出功能、保存相关数据的主要结构。&#xA;    // 每一个输入和输出文件，都在如下定义的指针数组全局变量中有对应的实体。&#xA;    AVFormatContext *pFormatCtx;&#xA;&#xA;    // 其中负责申请一个AVFormatContext结构的内存,并进行简单初始化&#xA;    // avformat_free_context()可以用来释放该结构里的所有东西以及该结构本身&#xA;    // 也是就说使用 avformat_alloc_context()分配的结构,需要使用avformat_free_context()来释放&#xA;    // 有些版本中函数名可能为: av_alloc_format_context();&#xA;    pFormatCtx = avformat_alloc_context();&#xA;&#xA;    // 视频文件&#xA;    char filepath[] = &amp;quot;kaoya.mp4&amp;quot;;&#xA;&#xA;    // avformat_open_input 解析文件头&#xA;    // Open an input stream and read the header&#xA;    if (avformat_open_input(&amp;amp;pFormatCtx, filepath, NULL, NULL) != 0) {&#xA;    printf(&amp;quot;Can&#39;t open the file\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    // 调用 avformat_find_stream_info 解析文件中的流并得到流中一些必须的信息&#xA;    // Retrieve stream information&#xA;    if (avformat_find_stream_info(pFormatCtx, NULL) &amp;lt; 0) {&#xA;    printf(&amp;quot;Couldn&#39;t find stream information.\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    // output file information&#xA;    cout &amp;lt;&amp;lt; &amp;quot;文件信息----------------------------------&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    av_dump_format(pFormatCtx, 0, filepath, 0);&#xA;    cout &amp;lt;&amp;lt; &amp;quot;--------------------------------------------&amp;quot; &amp;lt;&amp;lt; endl;&#xA;&#xA;    // --------------------------------------------------------- //&#xA;&#xA;    //Find the first video stream&#xA;    int i, videoIndex = -1;&#xA;&#xA;    // 视音频流的个数&#xA;    for (i = 0; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; i++) {&#xA;    if (pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) {&#xA;        videoIndex = i;&#xA;        break;&#xA;    }&#xA;    }&#xA;&#xA;    // 不存在则返回&#xA;    if (videoIndex == -1)&#xA;    return -1;&#xA;&#xA;    // --------------------------------------------------------- //&#xA;&#xA;    // 这是一个描述编解码器上下文的数据结构，包含了众多编解码器需要的参数信息&#xA;    AVCodecContext *pCodecCtx;&#xA;&#xA;    // AVCodec是存储编解码器信息的结构体&#xA;    AVCodec *pCodec;&#xA;&#xA;    // Get a pointer to the codec context for the video stream&#xA;    // 流中关于编解码器的信息就是被我们叫做&amp;quot;codec context&amp;quot;（编解码器上下文）&#xA;    // 的东西。这里面包含了流中所使用的关于编解码器的所有信息&#xA;    pCodecCtx = pFormatCtx-&amp;gt;streams[videoIndex]-&amp;gt;codec;&#xA;&#xA;    //Find the decoder for the video stream&#xA;    pCodec = avcodec_find_decoder(pCodecCtx-&amp;gt;codec_id);&#xA;    if (pCodec == NULL) {&#xA;    printf(&amp;quot;Unsupported codec!\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    //Open codec&#xA;    if (avcodec_open2(pCodecCtx, pCodec, NULL) &amp;lt; 0) {&#xA;    printf(&amp;quot;Could not open codec.\n&amp;quot;);&#xA;    return -1;&#xA;    }&#xA;&#xA;    //allocate video frame and set its fileds to default value&#xA;    AVFrame *pFrame, *pFrameYUV;&#xA;    pFrame = av_frame_alloc();&#xA;    pFrameYUV = av_frame_alloc();&#xA;&#xA;    //即使我们申请了一帧的内存，当转换的时候，我们仍然需要一个地方来放置原始&#xA;    //的数据。我们使用avpicture_get_size 来获得我们需要的大小， 然后手工申请&#xA;    //内存空间：&#xA;    uint8_t *out_buffer;&#xA;    int numBytes;&#xA;    numBytes = avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-&amp;gt;width,&#xA;        pCodecCtx-&amp;gt;height);&#xA;&#xA;    //av_malloc 是ffmpeg 的malloc，用来实现一个简单的malloc 的包装，这样来保&#xA;    //证内存地址是对齐的（4 字节对齐或者2 字节对齐）。它并不能保 护你不被内&#xA;    //存泄漏，重复释放或者其它malloc 的问题所困扰。&#xA;    out_buffer = (uint8_t *) av_malloc(numBytes * sizeof(uint8_t));&#xA;&#xA;    //Assign appropriate parts of buffer to image planes in pFrameYUV&#xA;    //Note that pFrameYUV is an AVFrame, but AVFrame is a superset of AVPicture&#xA;    avpicture_fill((AVPicture*) pFrameYUV, out_buffer, PIX_FMT_YUV420P,&#xA;        pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height);&#xA;&#xA;    //----------------SDL--------------------------------------//&#xA;&#xA;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {&#xA;    printf(&amp;quot;Could not initialize SDL -%s\n&amp;quot;, SDL_GetError());&#xA;    exit(1);&#xA;    }&#xA;&#xA;    SDL_Surface *screen;&#xA;    screen = SDL_SetVideoMode(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height, 24, 0);&#xA;    if (!screen) {&#xA;    fprintf(stderr, &amp;quot;SDL: could not set video mode - exiting\n&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    SDL_Overlay *bmp;&#xA;    // Allocate a place to put our YUV image on that screen&#xA;    bmp = SDL_CreateYUVOverlay(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,&#xA;    SDL_YV12_OVERLAY, screen);&#xA;&#xA;    SDL_Rect rect;&#xA;    rect.x = 0, rect.y = 0;&#xA;    rect.w = pCodecCtx-&amp;gt;width;&#xA;    rect.h = pCodecCtx-&amp;gt;height;&#xA;&#xA;    //*************************************************************//&#xA;&#xA;    //通过读取包来读取整个视频流，然后把它解码成帧，最后转换格式并且保存&#xA;    int frameFinished;&#xA;&#xA;    AVPacket packet;&#xA;    av_new_packet(&amp;amp;packet, numBytes);&#xA;&#xA;    int ret;&#xA;    // Convert the image into YUV format that SDL uses&#xA;    static struct SwsContext *img_convert_ctx;&#xA;    img_convert_ctx = sws_getContext(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,&#xA;        pCodecCtx-&amp;gt;pix_fmt, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,&#xA;        PIX_FMT_YUV420P,&#xA;        SWS_BICUBIC, NULL, NULL, NULL);&#xA;&#xA;    // Read the next frame of a stream&#xA;    while (av_read_frame(pFormatCtx, &amp;amp;packet) &amp;gt;= 0) {&#xA;&#xA;    // Is this a packet from the video stream?&#xA;    if (packet.stream_index == videoIndex) {&#xA;&#xA;        // decode video frame of size packet.size from packet.data into picture&#xA;        ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;amp;frameFinished,&#xA;            &amp;amp;packet);&#xA;&#xA;        // Did we get a video frame?&#xA;        if (ret &amp;gt;= 0) {&#xA;&#xA;        // Convert the image from its native format to YUV&#xA;        if (frameFinished) {&#xA;&#xA;            SDL_LockYUVOverlay(bmp);&#xA;&#xA;            AVPicture pict;&#xA;            pict.data[0] = bmp-&amp;gt;pixels[0];&#xA;            pict.data[1] = bmp-&amp;gt;pixels[2];&#xA;            pict.data[2] = bmp-&amp;gt;pixels[1];&#xA;&#xA;            pict.linesize[0] = bmp-&amp;gt;pitches[0];&#xA;            pict.linesize[1] = bmp-&amp;gt;pitches[2];&#xA;            pict.linesize[2] = bmp-&amp;gt;pitches[1];&#xA;&#xA;            sws_scale(img_convert_ctx,&#xA;                (const uint8_t* const *) pFrame-&amp;gt;data,&#xA;                pFrame-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height, pict.data,&#xA;                pict.linesize);&#xA;&#xA;            SDL_UnlockYUVOverlay(bmp);&#xA;&#xA;            SDL_DisplayYUVOverlay(bmp, &amp;amp;rect);&#xA;&#xA;        }&#xA;        }&#xA;    }&#xA;&#xA;    av_free_packet(&amp;amp;packet);&#xA;&#xA;    SDL_Event event;&#xA;    SDL_PollEvent(&amp;amp;event);&#xA;    switch (event.type) {&#xA;    case SDL_QUIT:&#xA;        SDL_Quit();&#xA;        exit(0);&#xA;        break;&#xA;    default:&#xA;        break;&#xA;    }&#xA;    }&#xA;&#xA;    av_frame_free(&amp;amp;pFrame);&#xA;    av_frame_free(&amp;amp;pFrameYUV);&#xA;    avcodec_close(pCodecCtx);&#xA;    avformat_close_input(&amp;amp;pFormatCtx);&#xA;&#xA;    return 0;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>x-go-binding</title>
      <link>http://www.nljb.net/default/x-go-binding/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/x-go-binding/xgb&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    conn, err := xgb.Dial(&amp;quot;:0&amp;quot;)&#xA;    if err != nil {&#xA;    panic(err)&#xA;    }&#xA;&#xA;    // X Windows Width Height&#xA;    fmt.Println(conn.DefaultScreen().WidthInPixels)&#xA;    fmt.Println(conn.DefaultScreen().HeightInPixels)&#xA;&#xA;    // Depth 8 16 24&#xA;    fmt.Println(conn.DefaultScreen().RootDepth)&#xA;&#xA;    fmt.Println(conn.DefaultScreen().Root)&#xA;    fmt.Println(conn.DefaultScreen().DefaultColormap)&#xA;    fmt.Println(conn.DefaultScreen().WhitePixel)&#xA;    fmt.Println(conn.DefaultScreen().BlackPixel)&#xA;    fmt.Println(conn.DefaultScreen().CurrentInputMasks)&#xA;    fmt.Println(conn.DefaultScreen().WidthInMillimeters)&#xA;    fmt.Println(conn.DefaultScreen().HeightInMillimeters)&#xA;    fmt.Println(conn.DefaultScreen().MinInstalledMaps)&#xA;    fmt.Println(conn.DefaultScreen().MaxInstalledMaps)&#xA;    fmt.Println(conn.DefaultScreen().RootVisual)&#xA;    fmt.Println(conn.DefaultScreen().BackingStores)&#xA;    fmt.Println(conn.DefaultScreen().SaveUnders)&#xA;    fmt.Println(conn.DefaultScreen().AllowedDepthsLen)&#xA;    fmt.Println(conn.DefaultScreen().AllowedDepths)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>adb常用命令</title>
      <link>http://www.nljb.net/default/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;adb devices //列出所有的连接设备&#xA;adb connect &amp;lt;host&amp;gt;[:&amp;lt;port&amp;gt;] //通过tcp/ip连接，5555是默认端口&#xA;设备命令：&#xA;adb push &amp;lt;local&amp;gt; &amp;lt;remote&amp;gt;  //拷贝文件/目录到设备&#xA;adb pull &amp;lt;remote&amp;gt; [&amp;lt;local&amp;gt;] //从设备拷贝文件/目录&#xA;adb sync [&amp;lt;directory&amp;gt;] //只有发生改变时从主机拷贝到设备&#xA;adb shell  //运行远端shell交互&#xA;adb shell &amp;lt;command&amp;gt; //运行远端shell 命令&#xA;adb emu &amp;lt;command&amp;gt; //运行仿真控制台命令&#xA;adb logcat [&amp;lt;filter-spec&amp;gt;] //浏览设备日志&#xA;adb forward &amp;lt;local&amp;gt; &amp;lt;remote&amp;gt; //转发套接字连接&#xA;adb install [-l] [-r] [-s] &amp;lt;file&amp;gt; //拷贝文件包到设备并安装&#xA;adb uninstall [-k] &amp;lt;package&amp;gt; //卸载程序包，-k意味着保留数据和缓存&#xA;adb bugreport //返回所有的bugreport信息&#xA;adb help&#xA;adb version&#xA;脚本：&#xA;adb wait-for-device //阻塞直到设备上线&#xA;adb start-server&#xA;adb kill-server&#xA;adb get-state //列印offline|bootloader|device信息&#xA;adb get-serialno&#xA;adb status-window //连续列印设备状态&#xA;adb remount //重装载/system分区&#xA;adb reboot [bootloader|recomry]&#xA;adb reboot-bootloader&#xA;adb root&#xA;adb usb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>PXE引导纯内存OpenSUSE方案</title>
      <link>http://www.nljb.net/default/PXE%E5%BC%95%E5%AF%BC%E7%BA%AF%E5%86%85%E5%AD%98OpenSUSE%E6%96%B9%E6%A1%88/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;mkinitrd：建立要载入ramdisk的映像文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mknod -m 0660 /dev/loop0 b 7 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;emergency() {&#xA;    local plymouth sulogin&#xA;    if plymouth=$(type -p plymouth 2&amp;gt; /dev/null) ; then&#xA;    $plymouth quit&#xA;    $plymouth --wait&#xA;    fi&#xA;    if test -w /proc/splash ; then&#xA;    echo verbose &amp;gt;| /proc/splash&#xA;    fi&#xA;    cd /&#xA;    echo -n &amp;quot;${1+$@} -- &amp;quot;&#xA;    if sulogin=$(type -p sulogin 2&amp;gt; /dev/null); then&#xA;    echo &amp;quot;exiting to $sulogin&amp;quot;&#xA;    PATH=$PATH PS1=&#39;$ &#39; $sulogin /dev/console&#xA;    else&#xA;    echo &amp;quot;exiting to /bin/sh&amp;quot;&#xA;    PATH=$PATH PS1=&#39;$ &#39; /bin/sh -i&#xA;    fi&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// FTP 获取镜像方式（实现无盘)&#xA;echo &amp;quot;#################################&amp;quot;&#xA;&#xA;echo &amp;quot;Server -&amp;gt;&amp;quot; ${addr}&#xA;&#xA;/usr/bin/ftp -nv ${addr} &amp;lt;&amp;lt;!&#xA;user anonymous anonymous&#xA;prompt off&#xA;hash&#xA;bin&#xA;lcd /&#xA;mget image&#xA;close&#xA;!&#xA;&#xA;/sbin/depmod -a&#xA;sleep 1&#xA;&#xA;/sbin/modprobe loop&#xA;sleep 1&#xA;&#xA;/sbin/losetup /dev/loop0 /image &amp;amp;&amp;amp; ls -l /dev/loop0&#xA;sleep 1&#xA;&#xA;/bin/mount /dev/loop0 /root&#xA;sleep 1&#xA;&#xA;echo &amp;quot;#################################&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// git@github.com:nulijiabei/boot.git&#xA;&#xA;// 注：image为根目录打包镜像,不要超过2G,需要LOOP驱动&#xA;&#xA;echo &amp;quot;#################################&amp;quot;&#xA;&#xA;root=/dev/loop0&#xA;rootdev=/dev/loop0&#xA;&#xA;echo &amp;quot; &amp;quot;&#xA;echo &amp;quot;NEW ROOT IS root=&amp;quot;$root&amp;quot;&amp;quot;&#xA;echo &amp;quot;NEW ROOTDEV IS rootdev=&amp;quot;$rootdev&amp;quot;&amp;quot;&#xA;&#xA;echo &amp;quot;depmod&amp;quot;&#xA;/sbin/depmod -a&#xA;&#xA;echo &amp;quot;modprobe&amp;quot;&#xA;/sbin/modprobe loop&#xA;&#xA;echo &amp;quot;ls&amp;quot;&#xA;ls -l /dev/loop0&#xA;&#xA;echo &amp;quot;mount&amp;quot;&#xA;/bin/mount /dev/sda1 /disk&#xA;sleep 5&#xA;&#xA;echo &amp;quot;CP&amp;quot;&#xA;/bin/cp -av /disk/image /image &amp;amp;&amp;amp; ls -l /image&#xA;sleep 5&#xA;&#xA;echo &amp;quot;umount&amp;quot;&#xA;/bin/umount /disk&#xA;sleep 5&#xA;&#xA;echo &amp;quot;losetup&amp;quot;&#xA;/sbin/losetup /dev/loop0 /image&#xA;sleep 5&#xA;&#xA;echo &amp;quot;mount&amp;quot;&#xA;/bin/mount /dev/loop0 /root&#xA;sleep 5&#xA;&#xA;echo &amp;quot;ls&amp;quot;&#xA;ls -l /root&#xA;&#xA;echo &amp;quot;#################################&amp;quot;&#xA;&#xA;&#xA;// 配置项&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;保证工作目录(777)权限&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;安装 vsftpd&#xA;安装 tftp&#xA;安装 dhcp&#xA;安装 dhcp-server&#xA;安装 yast2-tftp-server&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;在 /etc/vsftpd.conf 增加&#xA;&#xA;write_enable=NO&#xA;dirmessage_enable=YES&#xA;nopriv_user=ftpsecure&#xA;local_enable=YES&#xA;anonymous_enable=YES&#xA;anon_world_readable_only=YES&#xA;syslog_enable=NO&#xA;connect_from_port_20=YES&#xA;ascii_upload_enable=YES&#xA;pam_service_name=vsftpd&#xA;ssl_enable=NO&#xA;pasv_min_port=30000&#xA;pasv_max_port=30100&#xA;listen=YES&#xA;anon_mkdir_write_enable=NO&#xA;anon_root=/srv/tftpboot&#xA;anon_upload_enable=NO&#xA;chroot_local_user=NO&#xA;ftpd_banner=Welcome message&#xA;idle_session_timeout=900&#xA;local_root=/srv/tftpboot&#xA;log_ftp_protocol=NO&#xA;max_clients=10&#xA;max_per_ip=3&#xA;pasv_enable=YES&#xA;ssl_sslv2=NO&#xA;ssl_sslv3=NO&#xA;ssl_tlsv1=YES&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /etc/dhcpd.conf&#xA;&#xA;# dhcpd.conf&#xA;option domain-name-servers 202.106.0.20;&#xA;&#xA;ddns-update-style interim;&#xA;&#xA;ignore client-updates;&#xA;&#xA;allow booting;&#xA;allow bootp;&#xA;filename &amp;quot;pxelinux.0&amp;quot;;&#xA;&#xA;default-lease-time 1800;&#xA;max-lease-time 7200;&#xA;&#xA;subnet 192.168.0.0 netmask 255.255.255.0 {&#xA;    option broadcast-address 192.168.0.255;&#xA;    server-name &amp;quot;install-server&amp;quot;;&#xA;    range 192.168.0.10 192.168.0.224;&#xA;    option routers 192.168.0.1;&#xA;}&#xA;&#xA;// 指定IP地址&#xA;host danooplayer {&#xA;       hardware ethernet 00:E0:B4:0B:DD:70;&#xA;       fixed-address 192.168.2.200;&#xA;}   &#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /etc/sysconfig/dhcpd&#xA;&#xA;DHCPD_INTERFACE=&amp;quot;eth0&amp;quot;&#xA;DHCPD6_INTERFACE=&amp;quot;eth0&amp;quot;&#xA;DHCPD_IFUP_RESTART=&amp;quot;&amp;quot;&#xA;DHCPD6_IFUP_RESTART=&amp;quot;&amp;quot;&#xA;DHCPD_RUN_CHROOTED=&amp;quot;yes&amp;quot;&#xA;DHCPD6_RUN_CHROOTED=&amp;quot;yes&amp;quot;&#xA;DHCPD_CONF_INCLUDE_FILES=&amp;quot;&amp;quot;&#xA;DHCPD6_CONF_INCLUDE_FILES=&amp;quot;&amp;quot;&#xA;DHCPD_RUN_AS=&amp;quot;dhcpd&amp;quot;&#xA;DHCPD6_RUN_AS=&amp;quot;dhcpd&amp;quot;&#xA;DHCPD_OTHER_ARGS=&amp;quot;&amp;quot;&#xA;DHCPD6_OTHER_ARGS=&amp;quot;&amp;quot;&#xA;DHCPD_BINARY=&amp;quot;&amp;quot;&#xA;DHCPD6_BINARY=&amp;quot;&amp;quot;&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /etc/xinetd.d/tftp&#xA;&#xA;service tftp&#xA;{&#xA;    socket_type     = dgram&#xA;    protocol        = udp&#xA;    wait            = yes&#xA;    flags           = IPv4&#xA;    user            = root&#xA;    server          = /usr/sbin/in.tftpd&#xA;    server_args     =  -s /srv/tftpboot&#xA;    disable         = no&#xA;}&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 Yast 中 TFTP&#xA;&#xA;Enable&#xA;/srv/tftpboot&#xA;&#xA;// --------------------------------------------- //&#xA;&#xA;配置 /srv/tftpboot 及镜像&#xA;&#xA;目录:&#xA;pxelinux.0&#xA;pxelinux.cfg/default&#xA;danoo/vmlinuz&#xA;danoo/tinycore.gz&#xA;&#xA;文件 pxelinux.cfg/default&#xA;&#xA;default linux&#xA;prompt 1&#xA;timeout 60&#xA;&#xA;label linux&#xA;kernel danoo/vmlinuz&#xA;append ip=dhcp initrd=danoo/tinycore.gz&#xA;&#xA;&#xA;// --------------------------------------------- //&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 解决无盘系统硬盘问题&#xA;&#xA;// 文件共享方案&#xA;yast2-nfs-server&#xA;nfs-kernel-server&#xA;&#xA;// 通过 NFS 共享分区 &#xA;mount -t nfs ${MATRIX_SERVER}:/danoo/content/ /danoo/content/ -o nolock&#xA;sleep 1&#xA;&#xA;// 通过 xinitrc 控制 程序启动&#xA;if [ -e /danoo/content/xinitrc ];then&#xA;    ldconfig&#xA;    cp -aRrf /danoo/content/xinitrc /etc/X11/xinit/xinitrc&#xA;    killall X&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// NTP - /etc/ntp.conf&#xA;################################################################################&#xA;## /etc/ntp.conf&#xA;##&#xA;## Sample NTP configuration file.&#xA;## See package &#39;ntp-doc&#39; for documentation, Mini-HOWTO and FAQ.&#xA;## Copyright (c) 1998 S.u.S.E. GmbH Fuerth, Germany.&#xA;##&#xA;## Author: Michael Andres,  &amp;lt;ma@suse.de&amp;gt;&#xA;##         Michael Skibbe,  &amp;lt;mskibbe@suse.de&amp;gt;&#xA;##&#xA;################################################################################&#xA;&#xA;##&#xA;## Radio and modem clocks by convention have addresses in the &#xA;## form 127.127.t.u, where t is the clock type and u is a unit &#xA;## number in the range 0-3. &#xA;##&#xA;## Most of these clocks require support in the form of a &#xA;## serial port or special bus peripheral. The particular  &#xA;## device is normally specified by adding a soft link &#xA;## /dev/device-u to the particular hardware device involved, &#xA;## where u correspond to the unit number above. &#xA;## &#xA;## Generic DCF77 clock on serial port (Conrad DCF77)&#xA;## Address:     127.127.8.u&#xA;## Serial Port: /dev/refclock-u&#xA;##  &#xA;## (create soft link /dev/refclock-0 to the particular ttyS?)&#xA;##&#xA;# server 127.127.8.0 mode 5 prefer&#xA;&#xA;##&#xA;## Undisciplined Local Clock. This is a fake driver intended for backup&#xA;## and when no outside source of synchronized time is available.&#xA;##&#xA;server 127.127.1.0&#xA;fudge 127.127.1.0 stratum 8 &#xA;&#xA;##&#xA;## Add external Servers using&#xA;## # rcntp addserver &amp;lt;yourserver&amp;gt;&#xA;## &#xA;&#xA;##&#xA;## Miscellaneous stuff&#xA;##&#xA;&#xA;driftfile /var/lib/ntp/drift/ntp.drift # path for drift file&#xA;&#xA;logfile   /var/log/ntp      # alternate log file&#xA;# logconfig =syncstatus + sysevents&#xA;# logconfig =all&#xA;&#xA;# statsdir /tmp/        # directory for statistics files&#xA;# filegen peerstats  file peerstats  type day enable&#xA;# filegen loopstats  file loopstats  type day enable&#xA;# filegen clockstats file clockstats type day enable&#xA;&#xA;#&#xA;# Authentication stuff&#xA;#&#xA;keys /etc/ntp.keys      # path for keys file&#xA;trustedkey 1            # define trusted keys&#xA;requestkey 1            # key (7) for accessing server variables&#xA;# controlkey 15         # key (6) for accessing server variables&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;TinyCore Linux 进行PXE-ROM的启动&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 官方 - http://www.tinycorelinux.net&#xA;Core(11 MB) &#xA;TinyCore(16 MB) &#xA;CorePlus(106 MB)&#xA;&#xA;// 下载镜像文件后解压会获取 &#xA;[BOOT] &#xA;boot - 获取 vmlinuz、core.gz 启动必须文件&#xA;cde &#xA;&#xA;// 修改配置文件 pxelinux.cfg/default 即可&#xA;...&#xA;label linux&#xA;kernel img/vmlinuz&#xA;append ip=dhcp initrd=img/core.gz loglevel=3 base&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-启动时显示详细启动过程</title>
      <link>http://www.nljb.net/default/Linux-%E5%90%AF%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E8%AF%A6%E7%BB%86%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;*. 修改/boot/grub/menu.lst，修改kernel&amp;hellip;那行，将后面的quiet 去掉&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*. 若想显示更信息，还可将splash=silent改为splash=verbose&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*. 例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;kernel /boot/vmlinuz-2.6.31.14-0.8-desktop root=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part2 resume=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part1 splash=silent quiet showopts vga=0x31a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 改为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;kernel /boot/vmlinuz-2.6.31.14-0.8-desktop root=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part2 resume=/dev/disk/by-id/ata-WDC_WD10EALS-00Z8A0_WD-WCATR4066961-part1 splash=verbose showopts vga=0x31a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux-下设置屏幕分辨率方法</title>
      <link>http://www.nljb.net/default/Linux-%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linxu下设置屏幕分辨率方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设置分辨率方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通常情况下在Linux下屏幕分辨的设置方法有两种：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一种是通过图形界面的方式进行设置，但是功能比较单一，不支持自定义设置。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一种是通过命令的形式进行设置，正常情况下可以通过xrandr命令进行设置。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;xrandr 命令行可以很方便地切换双屏，常用方式如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;查询当前显示设备状态&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --same-as LVDS –auto&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器(最高分辨率)，与笔记本液晶屏幕显示同样内容（克隆）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --same-as LVDS --mode  1024x768&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器(分辨率为1024x768)，与笔记本液晶屏幕显示同样内容（克隆）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --right-of LVDS --auto&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器(最高分辨率)，设置为右侧扩展屏幕&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --off&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;关闭外接显示器&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --auto --output LVDS --off&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打开外接显示器，同时关闭笔记本液晶屏幕（只用外接显示器工作）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --off --output LVDS --auto&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;关闭外接显示器，同时打开笔记本液晶屏幕 (只用笔记本液晶屏)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（最后两种情况请小心操作，不要误把两个屏幕都关掉了。。。。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;分辨率强制设置方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当外接显示设备无法正常识别时，可以通过手动指定的方式进行设置，设置方法如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、用cvt命令获取给定分辨率的xrandr所需参数。例如：获取1440x900如下所示。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#cvt 1440 900&#xA;结果如下：&#xA;# 1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz&#xA;Modeline &amp;quot;1440x900_60.00&amp;quot; 106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;Modeline后面的值在下边要用。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、执行xrandr命令查看显示设备对于命名信息。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr&#xA;得到显示器名称，如：VGA1、笔记本为LVDS1等，以此类推，不一定都一样。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、用xrandr创建一个新的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr --newmode &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 15281672 1904  900 903 909 934 -hsync +vsync&#xA;参数就是cvt结果中Modeline后面的那一堆，根据自己的参数调整。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4、查看新添加的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr&#xA;就可以看到新加的那个设置。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5、用xrandr添加一个新的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#sudo xrandr --addmode VGA1 &amp;quot;1440x900_60.00&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;6、使用新添加的显示模式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#xrandr --output VGA1 --mode 1440x900_60.00 --same-as LVDS1&#xA;打开外接显示器,分辨率设为1440x900，--same-as LVDS代表显示和LVDS1显示内容一样（即：镜面屏幕）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意事项：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1. 在使用1440x900_60.00参数时，要写全，必须一致。&#xA;2. VGA1、LVDS1、HDMI-0等可以根据xrandr或者xrandr -q命令查询。&#xA;3. 通过xrandr命令配置的效果不能够在关机后保存，要保留效果，可以将相关的配置命令写在脚步中，在系统启动时执行。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一个简单的示例如见附录“一种保存xrandr配置方法”。附录：一种保存xrandr配置方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、创建一个自启动脚本，添加如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;xrandr--newmode &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 16721904  900 903 909 934 -hsync +vsync;&#xA;xrandr--addmode VGA1 &amp;quot;1440x900_60.00&amp;quot;;&#xA;xrandr--output LVDS1 --mode 1366x768&#xA;xrandr--output VGA1 --mode 1440x900_60.00;&#xA;xrandr--output VGA1 --right-of LVDS1;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、增加该脚本可执行权限，如命名为xrandr-config.sh。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#chmod a+x ./xrandr-config.sh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3、将该脚本设为开机启动，方法有两种：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   第一种方法：在/etc/rc.d/rc.local中追加入上述脚本执行命令，如：&#xA;1）打开rc.local文件。&#xA;    #vim/etc/rc.d/rc.local&#xA;2）在rc.local中添加如下内容。&#xA;    /root/xrandr-config.sh&#xA;第二种方法：可通过图形化的界面来设置，方法如下。&#xA;开始菜单》控制面板》启动应用程序》添加&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可能存在的缺点：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;登录进去之后会有“无法应用原保存的显示器配置”的提示（在使用xorg.conf时），不影响正常使用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为xranr-config.sh文件已配置正确（该项暂未确认）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;LVDS 1280x800&#xA;VGA 1280x1024&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果上下放：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --auto&#xA;xrandr --output VGA --above LVDS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;那么gnome上下两个面板就分别在VGA顶部和LVDS底部,如果左右放：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output VGA --right-of LVDS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;那么gnome的上面面板会延长到占满LVDS+VGA&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而且窗口最大化就会占据LVDS+VGA的整个桌面,怎么设置能让面板不扩展到另外的显示器呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还要使得窗口最大化时只占满当前显示器,也就是VGA出来的是一个空屏幕。。。。。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr --output LVDS --mode 1280x768 --output VGA --mode 1280x1024 \ --above LVDS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;xrandr 介紹&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;xrandr指令可以用來改變X環境的桌面大小和螢幕頻率.&#xA;把桌面解析度調成1024×768:&#xA;$ xrandr -s 1024x768&#xA;把螢幕頻率調成75Hz&#xA;$ xrandr -r 75&#xA;列出目前環境支援的解析度和頻率&#xA;$ xrandr -q&#xA;它列出的訊息, 每行的第一個數字可以用來指定給 -s 參數, 假設有一行這麼寫&#xA;20 640 x 480 ( 347mm x 260mm ) 75&#xA;那麼下&#xA;$ xrandr -s 20&#xA;時, 就會把螢幕調成 640×480 大小, 頻率75Hz&#xA;如果有數個X環境同時運作的話, 可以用 -d 參數去調整別的X環境, -d 後面加的是像 :0 :1 :2 這樣, 例如:&#xA;$ xrandr -s 800x600 -d :0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang之路-定时任务</title>
      <link>http://www.nljb.net/default/Golang%E4%B9%8B%E8%B7%AF-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;timer := time.NewTicker(2 * time.Second)&#xA;for {&#xA;    select {&#xA;    case &amp;lt;-timer.C:&#xA;&#xA;        go func() {&#xA;         log.Println(time.Now())&#xA;        }()&#xA;    }&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-设置系统时间</title>
      <link>http://www.nljb.net/default/Golang-%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// 接收UDP时间广播，并设置系统时间&#xA;func (sl *Slaver) masTimeSync(ch chan int) {&#xA;    // 开始监听广播时间&#xA;    log.Printf(&amp;quot;time sync listen [%s]&amp;quot;, sl.Node.Port.PortUdpSlaTimeSync)&#xA;    for {&#xA;    (func() {&#xA;        // 监听 mas 发来的同步时间&#xA;        lis, err := socket.NewListen(&amp;quot;&amp;quot;, sl.Node.Port.PortUdpSlaTimeSync, 3).ListenUDP()&#xA;        // 判断监听是否建立成功&#xA;        if err != nil {&#xA;        // 异常抛出&#xA;        log.Fatalln(err)&#xA;        }&#xA;        // 保证监听正常关闭&#xA;        defer lis.Close()&#xA;        // 循环接收&#xA;        for {&#xA;        // 每个时间戳大小不超过32字节&#xA;        data := make([]byte, 32)&#xA;        // 读取时间戳&#xA;        read, addr, err := lis.ReadFromUDP(data)&#xA;        // 检查是否接收错误&#xA;        if err != nil {&#xA;            // 错误时从新接收&#xA;            continue&#xA;        }&#xA;        // 判断是否为注册服务器所发&#xA;        if addr != nil &amp;amp;&amp;amp; strings.HasPrefix(addr.String(), sl.MasAddr) {&#xA;            // 转换远程时间戳&#xA;            l, _ := strconv.ParseInt(fmt.Sprintf(&amp;quot;%s&amp;quot;, data[0:read]), 10, 64)&#xA;            //// 转换时间格式&#xA;            //time := syscall.NsecToTimeval(l)&#xA;            //// 设置系统时间 &amp;quot;Linux Private Settimeofday&amp;quot;&#xA;            //if err := syscall.Settimeofday(&amp;amp;time); err != nil {&#xA;            //  // 异常抛出&#xA;            //  log.Fatalln(err)&#xA;            //}&#xA;            // 设置到系统&#xA;            cmd := exec.Command(&amp;quot;date&amp;quot;, &amp;quot;-s&amp;quot;, time.Unix(0, l).Format(&amp;quot;01/02/2006 15:04:05.999999999&amp;quot;))&#xA;            // 设置&#xA;            cmd.Run()&#xA;        }&#xA;        }&#xA;    })()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-实现图片缩放</title>
      <link>http://www.nljb.net/default/Golang-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;graphics&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;strconv&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/&amp;quot;, doImageHandler)&#xA;    http.ListenAndServe(&amp;quot;127.0.0.1:6789&amp;quot;, nil)&#xA;}&#xA;&#xA;func doImageHandler(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Printf(&amp;quot;%q\n&amp;quot;, strings.Split(r.URL.Path, &amp;quot;/&amp;quot;))&#xA;    url := strings.Split(r.URL.Path, &amp;quot;/&amp;quot;)&#xA;    if len(url) != 3 {&#xA;    return&#xA;    }&#xA;    newdx, uerr := strconv.Atoi(url[1])&#xA;    if uerr != nil {&#xA;    log.Fatal(uerr)&#xA;    }&#xA;    src, err := LoadImage(url[2])&#xA;    bound := src.Bounds()&#xA;    dx := bound.Dx()&#xA;    dy := bound.Dy()&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    // 缩略图的大小&#xA;    dst := image.NewRGBA(image.Rect(0, 0, newdx, newdx*dy/dx))&#xA;    // 产生缩略图,等比例缩放&#xA;    err = graphics.Scale(dst, src)&#xA;    if err != nil {&#xA;    log.Fatal(err)&#xA;    }&#xA;    header := w.Header()&#xA;    header.Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;image/jpeg&amp;quot;)&#xA;&#xA;    png.Encode(w, dst)&#xA;}&#xA;&#xA;&#xA;// Load Image decodes an image from a file of image.&#xA;func LoadImage(path string) (img image.Image, err error) {&#xA;    file, err := os.Open(path)&#xA;    if err != nil {&#xA;    return&#xA;    }&#xA;    defer file.Close()&#xA;    img, _, err = image.Decode(file)&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;///////////////////////////////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package mas&#xA;&#xA;import (&#xA;    &amp;quot;code.google.com/p/graphics-go/graphics&amp;quot;&#xA;    &amp;quot;fmt&amp;quot;&#xA;    z &amp;quot;github.com/nutzam/zgo&amp;quot;&#xA;    &amp;quot;image&amp;quot;&#xA;)&#xA;&#xA;func (ma *Master) ActiveImage(pobj string) error {&#xA;&#xA;    // 文件绝对路径&#xA;    var path string = pobj&#xA;&#xA;    // 保留源图Image结构&#xA;    var img image.Image&#xA;&#xA;    // 图片类型&#xA;    typef := z.FileType(path)&#xA;&#xA;    // 按照图片格式加载图片&#xA;    switch typef {&#xA;    // JPEG&#xA;    case &amp;quot;jpeg&amp;quot;:&#xA;    // ImageJPEG&#xA;    img = z.ImageJPEG(path)&#xA;    // JPG&#xA;    case &amp;quot;jpg&amp;quot;:&#xA;    // ImageJPEG&#xA;    img = z.ImageJPEG(path)&#xA;    // PNG&#xA;    case &amp;quot;png&amp;quot;:&#xA;    // ImagePNG&#xA;    img = z.ImagePNG(path)&#xA;    }&#xA;&#xA;    // 判断加载原图片是否成功&#xA;    if img == nil {&#xA;    // 返回错误&#xA;    return fmt.Errorf(&amp;quot;active image decode exception ...&amp;quot;)&#xA;    }&#xA;&#xA;    // -------------------------------------------------------- //&#xA;&#xA;    // 获取屏幕数量&#xA;    moniSize := ma.NodeConf.MonitorSize(ma)&#xA;&#xA;    // 获取屏幕分辨率&#xA;    width := ma.NodeConf.Resolution.Width&#xA;    height := ma.NodeConf.Resolution.Height&#xA;&#xA;    // 获取素材平均值&#xA;    widthMoni := img.Bounds().Dx() / moniSize.Col&#xA;    heightMoni := img.Bounds().Dy() / moniSize.Row&#xA;&#xA;    // -------------------------------------------------------- //&#xA;&#xA;    // 遍历屏幕,切割图片&#xA;    for _, monis := range ma.NodeConf.Layout {&#xA;&#xA;    // 遍历节点屏幕&#xA;    for _, moni := range monis {&#xA;&#xA;        // 获取图片&#xA;        row := moni.Display.Row&#xA;        col := moni.Display.Col&#xA;&#xA;        // 生成目标背景图&#xA;        backgroundSrc := z.ImageRGBA(widthMoni, heightMoni)&#xA;&#xA;        // 生成目标图&#xA;        z.ImageDrawRGBA(backgroundSrc, img, (col-1)*widthMoni, (row-1)*heightMoni)&#xA;&#xA;        // 生成最终背景图&#xA;        background := z.ImageRGBA(width, height)&#xA;&#xA;        // 产生最终图&#xA;        graphics.Scale(background, backgroundSrc)&#xA;&#xA;        // 按照图片格式保存图片&#xA;        switch typef {&#xA;        // JPEG&#xA;        case &amp;quot;jpeg&amp;quot;:&#xA;        // ImageEncodeJPEG&#xA;        z.ImageEncodeJPEG(fmt.Sprintf(&amp;quot;%s.pic_result/%d_%d.%s&amp;quot;, path, col, row, typef), background)&#xA;        // JPG&#xA;        case &amp;quot;jpg&amp;quot;:&#xA;        // ImageEncodeJPEG&#xA;        z.ImageEncodeJPEG(fmt.Sprintf(&amp;quot;%s.pic_result/%d_%d.%s&amp;quot;, path, col, row, typef), background)&#xA;        // PNG&#xA;        case &amp;quot;png&amp;quot;:&#xA;        // ImageEncodePNG&#xA;        z.ImageEncodePNG(fmt.Sprintf(&amp;quot;%s.pic_result/%d_%d.%s&amp;quot;, path, col, row, typef), background)&#xA;        }&#xA;&#xA;    }&#xA;&#xA;    }&#xA;&#xA;    // 返回&#xA;    return nil&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;///////////////////////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package z&#xA;&#xA;import (&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;image/draw&amp;quot;&#xA;    &amp;quot;image/jpeg&amp;quot;&#xA;    &amp;quot;image/png&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;// 读取JPEG图片返回image.Image对象&#xA;func ImageJPEG(ph string) image.Image {&#xA;    // 打开图片文件&#xA;    f, fileErr := os.Open(ph)&#xA;    if fileErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 退出时关闭文件&#xA;    defer f.Close()&#xA;    // 解码&#xA;    j, jErr := jpeg.Decode(f)&#xA;    if jErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 返回解码后的图片&#xA;    return j&#xA;}&#xA;&#xA;// 读取PNG图片返回image.Image对象&#xA;func ImagePNG(ph string) image.Image {&#xA;    // 打开图片文件&#xA;    f, fileErr := os.Open(ph)&#xA;    if fileErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 退出时关闭文件&#xA;    defer f.Close()&#xA;    // 解码&#xA;    p, pErr := png.Decode(f)&#xA;    if pErr != nil {&#xA;    return nil&#xA;    }&#xA;    // 返回解码后的图片&#xA;    return p&#xA;}&#xA;&#xA;// 按照分辨率创建一张空白图片对象&#xA;func ImageRGBA(width, height int) *image.RGBA {&#xA;    // 建立图像,image.Rect(最小X,最小Y,最大X,最小Y)&#xA;    return image.NewRGBA(image.Rect(0, 0, width, height))&#xA;}&#xA;&#xA;// 将图片绘制到图片&#xA;func ImageDrawRGBA(img *image.RGBA, imgcode image.Image, x, y int) {&#xA;    // 绘制图像&#xA;    // image.Point A点的X,Y坐标,轴向右和向下增加{0,0}&#xA;    // image.ZP ZP is the zero Point&#xA;    // image.Pt Pt is shorthand for Point{X, Y}&#xA;    draw.Draw(img, img.Bounds(), imgcode, image.Pt(x, y), draw.Over)&#xA;}&#xA;&#xA;// JPEG将编码生成图片&#xA;// 选择编码参数,质量范围从1到100,更高的是更好 &amp;amp;jpeg.Options{90}&#xA;func ImageEncodeJPEG(ph string, img image.Image) error {&#xA;    // 确保文件父目录存在&#xA;    FcheckParents(ph)&#xA;    // 打开文件等待写入&#xA;    f := FileW(ph)&#xA;    // 保证文件正常关闭&#xA;    defer f.Close()&#xA;    // 写入文件&#xA;    return jpeg.Encode(f, img, &amp;amp;jpeg.Options{100})&#xA;}&#xA;&#xA;// PNG将编码生成图片&#xA;func ImageEncodePNG(ph string, img image.Image) error {&#xA;    // 确保文件父目录存在&#xA;    FcheckParents(ph)&#xA;    // 打开文件等待写入&#xA;    f := FileW(ph)&#xA;    // 保证文件正常关闭&#xA;    defer f.Close()&#xA;    // 写入文件&#xA;    return png.Encode(f, img)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang 传递 小抄</title>
      <link>http://www.nljb.net/default/Golang-%E4%BC%A0%E9%80%92-%E5%B0%8F%E6%8A%84/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;一些学习总结&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;1、GoLang里面interface类型式一切类型的基类型，一个函数的参数如果始inteface{}&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明可以接受一切类型，只要这个类型中包含需要的那个方法，调用时候就不会失败；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func test(i interface{}){&#xA;    i.Get()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2、方法定义中可以制定某个类型（或者指针）是其调用者，方法的返回可以按照名称返回；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (p *A) test(i int){&#xA;&#xA;}&#xA;&#xA;func test()(p int){&#xA;    p:=1&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;3、switch流程可以强制穿透功能；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;4、语意上对并发的支持，用go关键词；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;5、make关键词只能创建channel,数组类型；其它对象的创建用new关键词；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;6、方法内用new关键词创建的对象（指针）可以返回，用&amp;amp;标记也可以返回本地指针；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;7、方法参数如果是数字，除了类型相同外，大小必须明确，否则视为slice类型；&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;数组传参是按照值传递，map、slice按照引用传递；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;8、数组，slice，map结构的遍历用range实现；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;9、不支持指针地址的++操作；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;10、type  A struct{} 、type B A 、type  C struct{A} 三个类型中A和C可以共享方法，B和A不共享方法；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;11、反射（自省）可以获得类型的字段和方法信息，和Python/Java/CSharp类似，没有深入研究；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;12、defer 在方法返回时调用，如果方法中有多个go 方法，会在每个go 方法调用完后被执行；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;13、类型转换，基本类型(string,bytes,int,float）之间的转换通过内置方法实现&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;struct通过 struct名称(变量名称)，也可以通过reflect及switch实现(接口变量名.(type))；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;14、change/select/chan 类似与Unix中的管道概念，支持读、写操作；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;15、对于复杂类型的格式化输出可以用 %#v ，这个格式化出来的信息比较全面；&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang http 超时设置方法</title>
      <link>http://www.nljb.net/default/Golang-http-%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;c := http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;        Dial: func(netw, addr string) (net.Conn, error) {&#xA;        deadline := time.Now().Add(25 * time.Second)&#xA;        c, err := net.DialTimeout(netw, addr, time.Second*20)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        c.SetDeadline(deadline)&#xA;        return c, nil&#xA;        },&#xA;    },&#xA;    }&#xA;&#xA;c.Get(&amp;quot;http://www.qq.com&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;//////////////////////////////////////////////&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 上载请求&#xA;func NetUploadJson(addr string, buf interface{}) (*[]byte, *int, error) {&#xA;    // 将需要上传的JSON转为Byte&#xA;    v, _ := json.Marshal(buf)&#xA;    // 上传JSON数据&#xA;    req, e := http.NewRequest(&amp;quot;POST&amp;quot;, addr, bytes.NewReader(v))&#xA;    if e != nil {&#xA;    // 提交异常,返回错误&#xA;    return nil, nil, e&#xA;    }&#xA;    // Body Type&#xA;    req.Header.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)&#xA;    // 完成后断开连接&#xA;    req.Header.Set(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)&#xA;    // -------------------------------------------&#xA;    // 设置 TimeOut&#xA;    DefaultClient := http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;        Dial: func(netw, addr string) (net.Conn, error) {&#xA;        deadline := time.Now().Add(30 * time.Second)&#xA;        c, err := net.DialTimeout(netw, addr, time.Second*30)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        c.SetDeadline(deadline)&#xA;        return c, nil&#xA;        },&#xA;    },&#xA;    }&#xA;    // -------------------------------------------&#xA;    // 执行&#xA;    resp, ee := DefaultClient.Do(req)&#xA;    if ee != nil {&#xA;    // 提交异常,返回错误&#xA;    return nil, nil, ee&#xA;    }&#xA;    // 保证I/O正常关闭&#xA;    defer resp.Body.Close()&#xA;    // 判断返回状态&#xA;    if resp.StatusCode == http.StatusOK {&#xA;    // 读取返回的数据&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        // 读取异常,返回错误&#xA;        return nil, nil, err&#xA;    }&#xA;    // 将收到的数据与状态返回&#xA;    return &amp;amp;data, &amp;amp;resp.StatusCode, nil&#xA;    } else if resp.StatusCode != http.StatusOK {&#xA;    // 返回异常状态&#xA;    return nil, &amp;amp;resp.StatusCode, nil&#xA;    }&#xA;    // 不会到这里&#xA;    return nil, nil, nil&#xA;}&#xA;&#xA;// 下载文件&#xA;func NetDownloadFile(addr string) (*[]byte, *int, *http.Header, error) {&#xA;    // 上传JSON数据&#xA;    req, e := http.NewRequest(&amp;quot;GET&amp;quot;, addr, nil)&#xA;    if e != nil {&#xA;    // 返回异常&#xA;    return nil, nil, nil, e&#xA;    }&#xA;    // 完成后断开连接&#xA;    req.Header.Set(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)&#xA;    // -------------------------------------------&#xA;    // 设置 TimeOut&#xA;    DefaultClient := http.Client{&#xA;    Transport: &amp;amp;http.Transport{&#xA;        Dial: func(netw, addr string) (net.Conn, error) {&#xA;        deadline := time.Now().Add(30 * time.Second)&#xA;        c, err := net.DialTimeout(netw, addr, time.Second*30)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        c.SetDeadline(deadline)&#xA;        return c, nil&#xA;        },&#xA;    },&#xA;    }&#xA;    // -------------------------------------------&#xA;    // 执行&#xA;    resp, ee := DefaultClient.Do(req)&#xA;    if ee != nil {&#xA;    // 返回异常&#xA;    return nil, nil, nil, ee&#xA;    }&#xA;    // 保证I/O正常关闭&#xA;    defer resp.Body.Close()&#xA;    // 判断请求状态&#xA;    if resp.StatusCode == 200 {&#xA;    data, err := ioutil.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        // 读取错误,返回异常&#xA;        return nil, nil, nil, err&#xA;    }&#xA;    // 成功，返回数据及状态&#xA;    return &amp;amp;data, &amp;amp;resp.StatusCode, &amp;amp;resp.Header, nil&#xA;    } else {&#xA;    // 失败，返回状态&#xA;    return nil, &amp;amp;resp.StatusCode, nil, nil&#xA;    }&#xA;    // 不会到这里&#xA;    return nil, nil, nil, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang-Screenshot</title>
      <link>http://www.nljb.net/default/Golang-Screenshot/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;// http://godoc.org/github.com/vova616/screenshot&#xA;&#xA;package screenshot&#xA;import (&#xA;    &amp;quot;image&amp;quot;&#xA;    &amp;quot;github.com/BurntSushi/xgb&amp;quot;&#xA;    &amp;quot;github.com/BurntSushi/xgb/xproto&amp;quot;&#xA;)&#xA;func ScreenRect() (image.Rectangle, error) {&#xA;    c, err := xgb.NewConn()&#xA;    if err != nil {&#xA;    return image.Rectangle{}, err&#xA;    }&#xA;    defer c.Close()&#xA;    screen := xproto.Setup(c).DefaultScreen(c)&#xA;    x := screen.WidthInPixels&#xA;    y := screen.HeightInPixels&#xA;    return image.Rect(0, 0, int(x), int(y)), nil&#xA;}&#xA;func CaptureScreen() (*image.RGBA, error) {&#xA;    r, e := ScreenRect()&#xA;    if e != nil {&#xA;    return nil, e&#xA;    }&#xA;    return CaptureRect(r)&#xA;}&#xA;func CaptureRect(rect image.Rectangle) (*image.RGBA, error) {&#xA;    c, err := xgb.NewConn()&#xA;    if err != nil {&#xA;    return nil, err&#xA;    }&#xA;    defer c.Close()&#xA;    screen := xproto.Setup(c).DefaultScreen(c)&#xA;    x, y := rect.Dx(), rect.Dy()&#xA;    xImg, err := xproto.GetImage(c, xproto.ImageFormatZPixmap, xproto.Drawable(screen.Root), int16(rect.Min.X), int16(rect.Min.Y), uint16(x), uint16(y), 0xffffffff).Reply()&#xA;    if err != nil {&#xA;    return nil, err&#xA;    }&#xA;    data := xImg.Data&#xA;    for i := 0; i &amp;lt; len(data); i += 4 {&#xA;    data[i], data[i+2], data[i+3] = data[i+2], data[i], 255&#xA;    }&#xA;    img := &amp;amp;image.RGBA{data, 4 * x, image.Rect(0, 0, x, y)}&#xA;    return img, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Golang Go语言断点续传</title>
      <link>http://www.nljb.net/default/Golang-Go%E8%AF%AD%E8%A8%80%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;http&amp;quot;&#xA;    &amp;quot;os&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;    UA = &amp;quot;Golang Downloader from Kejibo.com&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    f, err := os.OpenFile(&amp;quot;./file.exe&amp;quot;, os.O_RDWR, 0666)  //其实这里的 O_RDWR应该是 O_RDWR|O_CREATE，也就是文件不存在的情况下就建一个空文件，但是因为windows下还有BUG，如果使用这个O_CREATE，就会直接清空文件，所以这里就不用了这个标志，你自己事先建立好文件。&#xA;    if err != nil { panic(err) }&#xA;    stat, err := f.Stat()   //获取文件状态&#xA;    if err != nil { panic(err) }&#xA;    f.Seek(stat.Size, 0)    //把文件指针指到文件末，当然你说为何不直接用 O_APPEND 模式打开，没错是可以。我这里只是试验。&#xA;    url := &amp;quot;http://dl.google.com/chrome/install/696.57/chrome_installer.exe&amp;quot;&#xA;    var req http.Request&#xA;    req.Method = &amp;quot;GET&amp;quot;&#xA;    req.UserAgent = UA&#xA;    req.Close = true&#xA;    req.URL, err = http.ParseURL(url)&#xA;    if err != nil { panic(err) }&#xA;    header := http.Header{}&#xA;    header.Set(&amp;quot;Range&amp;quot;, &amp;quot;bytes=&amp;quot; + strconv.Itoa64(stat.Size) + &amp;quot;-&amp;quot;)&#xA;    req.Header = header&#xA;    resp, err := http.DefaultClient.Do(&amp;amp;req)&#xA;    if err != nil { panic(err) }&#xA;    written, err := io.Copy(f, resp.Body)&#xA;    if err != nil { panic(err) }&#xA;    println(&amp;quot;written: &amp;quot;, written)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go-Ping</title>
      <link>http://www.nljb.net/default/Go-Ping/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package conn&#xA;&#xA;import (&#xA;&amp;quot;bytes&amp;quot;&#xA;&amp;quot;net&amp;quot;&#xA;&amp;quot;os&amp;quot;&#xA;&amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;ICMP_ECHO_REQUEST = 8&#xA;ICMP_ECHO_REPLY   = 0&#xA;)&#xA;&#xA;// Ping Request&#xA;func makePingRequest(id, seq, pktlen int, filler []byte) []byte {&#xA;p := make([]byte, pktlen)&#xA;copy(p[8:], bytes.Repeat(filler, (pktlen-8)/len(filler)+1))&#xA;&#xA;p[0] = ICMP_ECHO_REQUEST // type&#xA;p[1] = 0                 // code&#xA;p[2] = 0                 // cksum&#xA;p[3] = 0                 // cksum&#xA;p[4] = uint8(id &amp;gt;&amp;gt; 8)    // id&#xA;p[5] = uint8(id &amp;amp; 0xff)  // id&#xA;p[6] = uint8(seq &amp;gt;&amp;gt; 8)   // sequence&#xA;p[7] = uint8(seq &amp;amp; 0xff) // sequence&#xA;&#xA;// calculate icmp checksum&#xA;cklen := len(p)&#xA;s := uint32(0)&#xA;for i := 0; i &amp;lt; (cklen - 1); i += 2 {&#xA;s += uint32(p[i+1])&amp;lt;&amp;lt;8 | uint32(p[i])&#xA;}&#xA;if cklen&amp;amp;1 == 1 {&#xA;s += uint32(p[cklen-1])&#xA;}&#xA;s = (s &amp;gt;&amp;gt; 16) + (s &amp;amp; 0xffff)&#xA;s = s + (s &amp;gt;&amp;gt; 16)&#xA;&#xA;// place checksum back in header; using ^= avoids the&#xA;// assumption the checksum bytes are zero&#xA;p[2] ^= uint8(^s &amp;amp; 0xff)&#xA;p[3] ^= uint8(^s &amp;gt;&amp;gt; 8)&#xA;&#xA;return p&#xA;}&#xA;&#xA;func parsePingReply(p []byte) (id, seq int) {&#xA;id = int(p[4])&amp;lt;&amp;lt;8 | int(p[5])&#xA;seq = int(p[6])&amp;lt;&amp;lt;8 | int(p[7])&#xA;return&#xA;}&#xA;&#xA;// Ping&#xA;func Ping(addr string, i int) bool {&#xA;&#xA;// *IPAddr&#xA;raddr, e := net.ResolveIPAddr(&amp;quot;ip4&amp;quot;, addr)&#xA;if e != nil {&#xA;return false&#xA;}&#xA;&#xA;// *IPConn&#xA;ipconn, ee := net.DialIP(&amp;quot;ip4:icmp&amp;quot;, nil, raddr)&#xA;if ee != nil {&#xA;return false&#xA;}&#xA;&#xA;// 保证连接正常关闭&#xA;defer ipconn.Close()&#xA;&#xA;// PID&#xA;sendid := os.Getpid() &amp;amp; 0xffff&#xA;sendseq := 1&#xA;pingpktlen := 64&#xA;&#xA;for {&#xA;&#xA;sendpkt := makePingRequest(sendid, sendseq, pingpktlen, []byte(&amp;quot;Go Ping&amp;quot;))&#xA;&#xA;// 发送请求&#xA;n, err := ipconn.WriteToIP(sendpkt, raddr)&#xA;if err != nil || n != pingpktlen {&#xA;break&#xA;}&#xA;&#xA;// 超时&#xA;ipconn.SetDeadline(time.Now().Add(5 * time.Second))&#xA;&#xA;// 返回数据&#xA;resp := make([]byte, 1024)&#xA;for {&#xA;&#xA;// 读取返回&#xA;_, _, err := ipconn.ReadFrom(resp)&#xA;if err != nil {&#xA;break&#xA;}&#xA;&#xA;// 判断状态&#xA;if resp[0] != ICMP_ECHO_REPLY {&#xA;continue&#xA;}&#xA;&#xA;// 判断状态&#xA;rcvid, rcvseq := parsePingReply(resp)&#xA;if rcvid != sendid || rcvseq != sendseq {&#xA;break&#xA;}&#xA;&#xA;// 成功返回&#xA;return true&#xA;&#xA;}&#xA;&#xA;// 执行次数内未成功返回&#xA;if i == sendseq {&#xA;break&#xA;}&#xA;&#xA;// 计数器&#xA;sendseq++&#xA;&#xA;}&#xA;&#xA;// 失败返回&#xA;return false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之静态方法跟实例方法</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8B%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%B7%9F%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;静态是类的，实例是对象的．&#xA;oo的观点就是静态成员就是类所有对象所具备的特点，而实例成员是每个对象自有的实现，是不一样的．&#xA;比如说每个人都有头发，眼睛，耳朵，名字，性别，年龄，身高等等．&#xA;这些都是静态的，但是每个人的这些属性是不一样的，这些不同的属性就是实例化．&#xA;所以可以说静态方法不需要依赖类当中的属性，静态方法本身就可以封闭的完成一个功能，而实例的方法更多会用到类中的属性．&#xA;静态方法在它一启动的时候就实例化了，因而静态内存是连续的，而且静态内存是有限制的；&#xA;而实例方法是在程序运行中生成内存的，实例申请的是离散的空间．静态方法大多用的数据连接上．&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之通过SDL输出一张图片</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8B%E9%80%9A%E8%BF%87SDL%E8%BE%93%E5%87%BA%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这篇教程讲述SDL风格的Hello World。&#xA;假设你已经安装好了SDL库，下面我们制作一个简陋的图片（640*480像素的图片，并命名为hello.bmp），应用SDL把它加载并显示到屏幕上。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//文件名：hello.c，以下内容可以全部复制到源文件中。&#xA;//包含SDL函数和数据类型&#xA;#include &amp;quot;SDL/SDL.h&amp;quot;&#xA;&#xA;/*&#xA;在源文件的开头，包含SDL的头文件，这样，我们就可以使用SDL的函数和数据类型。&#xA;如果有人（比如说使用Visual Studio的）打算这样包含SDL的头文件：#include &amp;quot;SDL.h&amp;quot;。&#xA;如果编译器向你报错说找不到“SDL/SDL.h”的头文件，那么是因为你包含的头文件路径错了，或者说，你没有把SDL.h放到正确的路径下。&#xA;    */&#xA;&#xA;int main( int argc, char* args[] )&#xA;{&#xA;    //The images&#xA;    SDL_Surface* hello = NULL;&#xA;    SDL_Surface* screen = NULL;&#xA;&#xA;/*&#xA;在main()函数的前部，声明两个SDL_Surface的指针。一个SDL_Surface就是一个图片，在这个程序中，我们打算处理两个图片。&#xA;画面指针 “hello”是我们准备加载和显示的图片，“screen”是屏幕上显示出来的范围。&#xA;不论你打算用指针去做什么，始终要记得初始化指针。&#xA;当然，使用SDL的时候，你必须像上面那样声明main函数，不能用void main()或者其他类似的声明。&#xA;    */&#xA;&#xA;    //启动SDL&#xA;    SDL_Init( SDL_INIT_EVERYTHING );&#xA;&#xA;    //建立屏幕&#xA;    screen = SDL_SetVideoMode( 640, 480, 32, SDL_SWSURFACE );&#xA;&#xA;    //加载图片&#xA;    hello = SDL_LoadBMP( &amp;quot;hello.bmp&amp;quot; );&#xA;&#xA;/*&#xA;mian()函数里调用的第一个函数是SDL_Init()，目的是调用SDL_Init()来初始化所有的SDL子系统，这样我们才能开始使用SDL的图形函数。&#xA;下一个函数是SDL_SetVideoMode()，调用它来设置一个640像素宽，480像素高的窗口，每个像素32位。&#xA;最后一个参数(SDL_SWSURFACE)用来在软件存储中建立一个画面。&#xA;当执行完SDL_SetVideoMode()以后，会返回一个我们能够使用的指针，指向窗口画面， 窗口建立以后，我们调用SDL_LoadBMP()来载入图片。&#xA;SDL_LoadBMP()函数接受一个位图文件的路径作为参数，并返回一个指针，该指针指向已经载入的画面。当载入图片发生错误时，该函数返回一个空指针&#xA;*/&#xA;&#xA;    //把图片放置到屏幕上&#xA;    SDL_BlitSurface( hello, NULL, screen, NULL );&#xA;&#xA;    //刷新屏幕&#xA;    SDL_Flip( screen );&#xA;&#xA;    //暂停，等待&#xA;    SDL_Delay( 2000 );&#xA;&#xA;/*&#xA;现在，我们已经建立了一个窗口，并加载了图片，我们准备把加载的图片放置到屏幕上面。这个是通过SDL_BlitSurface()函数实现的。&#xA;SDL_BlitSurface()的第一个参数是源画面的指针（源画面位置），第三个参数是目的画面的指针（目的画面的位置）。&#xA;SDL_BlitSurface()函数把源画面粘贴到目的画面上。这样，就能够把加载的图片放置到屏幕上显示出来。稍后的教程里会介绍其他参数的作用。&#xA;现在我们的图片已经放置到屏幕上了，我们需要用SDL_Flip()函数来刷新屏幕，这样我们才能看到它。&#xA;如果你没有调用SDL_Flip()函数，那你只能看到一个还没有刷新的黑黑的屏幕。&#xA;到这里，图片已经放置到屏幕上，并显示出来了，我们必须让显示出来的窗口能够停留，不会一闪而过，消失不见。&#xA;调用SDL_Delay()函数，让窗口保持稳定。这里，我们让窗口延时2000毫秒（2秒）。&#xA;在接下来的教程的第四课里，你会学到更好的办法，来让窗口停留在一个地方。&#xA;*/&#xA;&#xA;    //释放掉内存中加载的图片&#xA;    SDL_FreeSurface( hello );&#xA;&#xA;    //退出 SDL&#xA;    SDL_Quit();&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;/*&#xA;接下来，我们在程序里将不再使用加载的图片，我们需要把它从内存中释放掉。&#xA;你不能够简单的使用delete释放内存，而是需要调用SDL_FreeSurface()函数把它从内存中释放掉。&#xA;在程序结束时，我们调用SDL_Quit()来关闭SDL程序。你也许或疑惑，为什么我们从来没有释放屏幕画面的内存？别担心，SDL_Quit()会为你释放掉它。&#xA;祝贺你！成功的运行你第一个图形程序。&#xA;*/&#xA;&#xA;/*&#xA;使用wxDev-C++编译的连接器命令为：-lmingw32 -lSDLmain  -lSDL&#xA;测试编译运行OK！在解释的文字两端加了注视符号，所以这些内容可以全部复制到源程序里。&#xA;*/&#xA;&#xA;SDL程序编译出错的解决办法&#xA;&#xA;如果你的编译器向你报错没有找到&#39;SDL/SDL.h&#39;，意味着你忘记了设置头文件。你的编译器或者是IDE应该能都找到SDL的头文件，所以要确认SDL的头文件正确的配置到include文件夹内。如果你使用Visual Studio而编译器报错：&#39;SDL/SDL.h&#39;: No such file or directory，查看源文件顶端的代码，确认是使用的#include &amp;quot;SDL.h&amp;quot;.&#xA;&#xA;如果你的程序能够编译，但是连接器会报错找不到库文件，那么确认你的编译器或者IDE能够找到SDL的库文件。如果你的编译器报错没有定义引用一大堆SDL的函数，请确认你在连接器里连接了SDL。&#xA;&#xA;    如果你的连接器报错是关于指针入口的，那么确认mian函数的声明方式是否正确，在你的源码里，只能有一个main函数。&#xA;&#xA;    如果程序编译、链接、生成都正常，但是当你运行的时候报错，没有找到SDL.dll，确认一下是否将SDL.dll放置到了和编译执行相同的目录下。使用Visual Studio，需要把dll文件放置到与vcproj文件相同的目录下。如果使用Windows系统，可以把dll文件放到system32目录下。&#xA;&#xA;如果你的程序可以运行，但是没有显示图片，或者窗口一闪而过，你可以看到stderr.txt文件的内容为：&#xA;Fatal signal: Segmentation Fault (SDL Parachute Deployed)&#xA;&#xA;这是因为程序试图访问不允许访问的内存。可能是当调用SDL_BlitSurface()时，试图访问NULL。这意味着你需要确认位图文件和程序在同一个目录内。使用Visual Studio需要把位图文件和vcproj文件放在同一个目录内。&#xA;&#xA;也有可能在你使用Visual Studio时显示这样的错误：&amp;quot;The application failed to start because the application configuration is incorrect. Reinstalling the application may fix this problem.&amp;quot;（程序无法启动，重新安装来解决此问题）&#xA;&#xA;这是因为没有安装升级服务包。不要忘记采用最新版本的编译器或者IDE时，安装编译器或IDE的服务升级包，否则Visual Studio编译的程序不会运行。一些Linux的用户运行后可能会显示黑屏，尝试在命令行运行一下程序。&#xA;&#xA;如果你必须建立一个工程来编译SDL程序，记得你需要给你建立的每一个SDL程序建立一个工程。或者，更进一步，你可以重新使用你第一次建立的工程。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之socket.cpp监听解码</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8Bsocket.cpp%E7%9B%91%E5%90%AC%E8%A7%A3%E7%A0%81/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;sys/socket.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;netinet/in.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &amp;lt;json/json.h&amp;gt;&#xA;&#xA;using namespace std;&#xA;&#xA;// 常量&#xA;#define SERVPORT 4444&#xA;#define BACKLOG 10&#xA;#define MAXSIZE 1024&#xA;&#xA;int main() {&#xA;&#xA;    // 声明&#xA;    int sockfd, client_fd;&#xA;    struct sockaddr_in my_addr;&#xA;    struct sockaddr_in remote_addr;&#xA;&#xA;    // 创建&#xA;    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {&#xA;    perror(&amp;quot;socket create failed!&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 绑定端口地址&#xA;    my_addr.sin_family = AF_INET;&#xA;    my_addr.sin_port = htons(SERVPORT);&#xA;    my_addr.sin_addr.s_addr = INADDR_ANY;&#xA;    bzero(&amp;amp;(my_addr.sin_zero), 8);&#xA;&#xA;    // 捆绑&#xA;    if (bind(sockfd, (struct sockaddr*) &amp;amp;my_addr, sizeof(struct sockaddr))&#xA;        == -1) {&#xA;    perror(&amp;quot;bind error!&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 监听端口&#xA;    if (listen(sockfd, BACKLOG) == -1) {&#xA;    perror(&amp;quot;listen error&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 接受连接&#xA;    int sin_size = sizeof(struct sockaddr_in);&#xA;    if ((client_fd = accept(sockfd, (struct sockaddr *) &amp;amp;remote_addr,&#xA;        (socklen_t *) &amp;amp;sin_size)) == -1) {&#xA;    perror(&amp;quot;accept error!&amp;quot;);&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 变量&#xA;    string json_str;&#xA;    char buf[MAXSIZE];&#xA;&#xA;    // 处理&#xA;    while (1) {&#xA;&#xA;    // 归零&#xA;    bzero(buf, MAXSIZE);&#xA;&#xA;    // 接受client发送的请示信息&#xA;    if (recv(client_fd, buf, MAXSIZE, 0) == 0)&#xA;        continue;&#xA;&#xA;    buf[strlen(buf) - 1] = &#39; &#39;;&#xA;    buf[strlen(buf) - 2] = &#39;\0&#39;;&#xA;&#xA;    if (strcmp(buf, &amp;quot;QUIT&amp;quot;) == 0) {&#xA;        printf(&amp;quot;%s\n&amp;quot;, &amp;quot;bye!&amp;quot;);&#xA;        close(sockfd);&#xA;        exit(0);&#xA;    }&#xA;&#xA;    // (Char[]-&amp;gt;String)&#xA;    json_str.insert(0, buf);&#xA;&#xA;    // 解析(Json-&amp;gt;Value)&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(json_str, root, false)) {&#xA;        cout &amp;lt;&amp;lt; &amp;quot;parse error&amp;quot; &amp;lt;&amp;lt; endl;&#xA;        exit(1);&#xA;    }&#xA;&#xA;    // 获取&#xA;    cout &amp;lt;&amp;lt; &amp;quot;Name:&amp;quot; &amp;lt;&amp;lt; root[&amp;quot;name&amp;quot;].asString() &amp;lt;&amp;lt; endl;&#xA;&#xA;    // 写入(Value-&amp;gt;Json)&#xA;    Json::FastWriter writer;&#xA;    json_str = writer.write(root);&#xA;    cout &amp;lt;&amp;lt; json_str &amp;lt;&amp;lt; endl;&#xA;&#xA;    }&#xA;&#xA;    // 返回&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>C++之Jsoncpp的使用</title>
      <link>http://www.nljb.net/default/C%2B%2B%E4%B9%8BJsoncpp%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>2014-07-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;*. 下载jsoncpp源码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;C++要使用JSON来解析数据，一般采用jsoncpp. &#xA;网站：http://sourceforge.net/projects/jsoncpp/&#xA;我下载的时候最新版本是 jsoncpp-src-0.5.0.tar.gz&#xA;这里有一个拷贝（http://dl.iteye.com/topics/download/4cb5ff91-e210-3e0b-9496-fd31a787a6c7）&#xA;解压到一个目录，然后编译成对应机器可用的lib。然后引入它的json.h头文件就可以使用了。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 下载编译jsoncpp的python编译工具并配置环境变量到临时console&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;关键是这个lib怎么编译出来，下面说一下步骤：&#xA;编译jsconcpp要使用scons，scons又是一个牛叉的工具，功能和GNU make一样，又比make简单多了。scons是python工具，需要先安装好python。&#xA;下载 scons，解压就可以使用了。&#xA;scons下载地址：http://sourceforge.net/projects/scons/files/scons/2.3.0/ 本文附件中也有一个拷贝&#xA;在要编译jsoncpp的console中导出scons的环境变量临时用一下即可。不必配置到开机启动的环境变量中。&#xA;$export MYSCONS=your_extract_path&#xA;$export MYSCONS_LIB_DIR=$MYSCONS/engine&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 编译jsoncpp lib&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cd jsoncpp-src-0.5.0&#xA;$ python $MYSCONS/script/scons platform=linux-gcc&#xA;一切正常的话，可以在 jsoncpp-src-0.5.0/libs/linux-gcc-x.x 下看到一个动态文件库（so）和一个静态文件库（a）。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 将jsoncpp库拷贝到系统库下方便使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ cd jsoncpp-src-0.5.0/libs/linux-gcc-4.7&#xA;$ mv libjson_linux-gcc-4.7_libmt.so libjson.so&#xA;$sudo cp libjson.so /usr/lib&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*. 代码演示&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;cassert&amp;gt;&#xA;#include &amp;quot;json/json.h&amp;quot;&#xA;using namespace std;&#xA;&#xA;int main()&#xA;{&#xA;    string json_str = &amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;zzg\&amp;quot;,\&amp;quot;age\&amp;quot;:100}&amp;quot;;&#xA;&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(json_str, root, false))&#xA;    {&#xA;    cout&amp;lt;&amp;lt;&amp;quot;parse error&amp;quot;&amp;lt;&amp;lt;endl;&#xA;    return -1;&#xA;    }&#xA;&#xA;    cout &amp;lt;&amp;lt; &amp;quot;test read:&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    std::string name = root[&amp;quot;name&amp;quot;].asString();&#xA;    int age = root[&amp;quot;age&amp;quot;].asInt();&#xA;&#xA;    std::cout&amp;lt;&amp;lt;name&amp;lt;&amp;lt;std::endl;&#xA;    std::cout&amp;lt;&amp;lt;age&amp;lt;&amp;lt;std::endl;&#xA;&#xA;&#xA;    cout&amp;lt;&amp;lt;&amp;quot;test write:&amp;quot;&amp;lt;&amp;lt;endl;&#xA;    Json::FastWriter writer;&#xA;    json_str = writer.write(root);&#xA;    cout&amp;lt;&amp;lt;json_str&amp;lt;&amp;lt;endl;&#xA;    return 0;&#xA;}&#xA;&#xA;&#xA;&#xA;#include &amp;lt;fstream&amp;gt;&#xA;#include &amp;lt;cassert&amp;gt;&#xA;#include &amp;quot;json/json.h&amp;quot;&#xA;using namespace std;&#xA;&#xA;int main()&#xA;{&#xA;    ifstream ifs;&#xA;    ifs.open(&amp;quot;testjson.json&amp;quot;);&#xA;    assert(ifs.is_open());&#xA;&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(ifs, root, false))&#xA;    {&#xA;    return -1;&#xA;    }&#xA;&#xA;    std::string name = root[&amp;quot;name&amp;quot;].asString();&#xA;    int age = root[&amp;quot;age&amp;quot;].asInt();&#xA;&#xA;    std::cout&amp;lt;&amp;lt;name&amp;lt;&amp;lt;std::endl;&#xA;    std::cout&amp;lt;&amp;lt;age&amp;lt;&amp;lt;std::endl;&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;    // 原始&#xA;    string json_str = &amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;home\&amp;quot;}&amp;quot;;&#xA;&#xA;    // 解析(Json-&amp;gt;Value)&#xA;    Json::Reader reader;&#xA;    Json::Value root;&#xA;    if (!reader.parse(json_str, root, false)) {&#xA;    exit(1);&#xA;    }&#xA;&#xA;    // 读取&#xA;    string name = root[&amp;quot;name&amp;quot;].asString();&#xA;    cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;&#xA;&#xA;    // 写入(Value-&amp;gt;Json)&#xA;    Json::FastWriter writer;&#xA;    json_str = writer.write(root);&#xA;    cout &amp;lt;&amp;lt; json_str &amp;lt;&amp;lt; endl;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>